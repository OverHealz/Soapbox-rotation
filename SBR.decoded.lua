local AResponse = "all"
local RotationsDirectory = "C:/WorldofWarcraft/Interface/AddOns/SBR/"
local Unlocker = (EWT ~= nil and "EWT") or "Other"
local RD, IHE, SHR, RF, WF, OE, OF, OP, TL, UBR, UCR, CAP, CPS, IAP, GOWG, GUNPC, GUNPBI
function RD()
    return RotationsDirectory
end
IHE = IsHackEnabled
SHR = SendHTTPRequest
RF = ReadFile
WF = WriteFile
OE = ObjectExists
OF = ObjectFacing
OP = ObjectPosition
TL = TraceLine
UBR = UnitBoundingRadius
UCR = UnitCombatReach
CAP = ClickPosition
CPS = CancelPendingSpell
IAP = IsAoEPending
GOWG = GetObjectWithGUID
GUNPC = GetObjectCount
GUNPBI = GetObjectWithIndex
local GOOT = GetObjectsOfType
local ObjectTypes = ObjectTypes
local function Randomize(Length, LettersOnly)
    local Length = Length or math.random(10, 24)
    local RandomValues, StringValue =     {
        [1] = { "a", "A" },
        [2] = { "b", "B" },
        [3] = { "c", "C" },
        [4] = { "d", "D" },
        [5] = { "e", "E" },
        [6] = { "f", "F" },
        [7] = { "g", "G" },
        [8] = { "h", "H" },
        [9] = { "i", "I" },
        [10] = { "j", "J" },
        [11] = { "k", "K" },
        [12] = { "l", "L" },
        [13] = { "m", "M" },
        [14] = { "n", "N" },
        [15] = { "o", "O" },
        [16] = { "p", "P" },
        [17] = { "q", "Q" },
        [18] = { "r", "R" },
        [19] = { "s", "S" },
        [20] = { "t", "T" },
        [21] = { "u", "U" },
        [22] = { "v", "V" },
        [23] = { "w", "W" },
        [24] = { "x", "X" },
        [25] = { "y", "Y" },
        [26] = { "z", "Z" },
        [27] = { "1", "2" },
        [28] = { "3", "4" },
        [29] = { "5", "6" },
        [30] = { "7", "8" },
        [31] = { "9", "0" }
    },
    ""
    if LettersOnly then
        for i = 1, Length do
            StringValue = StringValue .. RandomValues[math.random(1, 26)][math.random(1, 2)]
        end
    else
        for i = 1, Length do
            StringValue = StringValue .. RandomValues[math.random(1, 31)][math.random(1, 2)]
        end
    end
    return StringValue
end
local DisplayName = "Soapbox 2.0"
local PROFILESPATH = RD() .. "/../../../"
local RotationFileVersion = "9-9-2017v1"
local _G = _G
local Core = {}
local bit = bit
local error = error
local getmetatable = getmetatable
local ipairs = ipairs
local math = math
local pairs = pairs
local pcall = pcall
local print = print
local require = require
local rawset = rawset
local select = select
local setmetatable = setmetatable
local string = string
local table = table
local tonumber = tonumber
local tostring = tostring
local type = type
local unpack = unpack
local strsplit = strsplit
local xpcall = xpcall
local CastSpellByName = CastSpellByName
local CastSpellByID = CastSpellByID
local RunMacroText = RunMacroText
local SpellIsTargeting = SpellIsTargeting
local TargetUnit = TargetUnit
local CreateFrame = CreateFrame
local GameTooltip = GameTooltip
local CreateMacro = CreateMacro
local message = message
setfenv(1, Core)
CancelShapeshiftForm = _G["CancelShapeshiftForm"]
GetHaste = _G["GetHaste"]
GetInstanceInfo = _G["GetInstanceInfo"]
GetPVPDesired = _G["GetPVPDesired"]
GetSpecialization = _G["GetSpecialization"]
GetSpecializationInfo = _G["GetSpecializationInfo"]
GetUnitMaxHealthModifier = _G["GetUnitMaxHealthModifier"]
HasFullControl = _G["HasFullControl"]
IsAutoRepeatSpell = _G["IsAutoRepeatSpell"]
IsCurrentSpell = _G["IsCurrentSpell"]
IsFalling = _G["IsFalling"]
IsFlying = _G["IsFlying"]
IsInInstance = _G["IsInInstance"]
IsInRaid = _G["IsInRaid"]
IsMounted = _G["IsMounted"]
IsPetActive = _G["IsPetActive"]
UnitAttackSpeed = _G["UnitAttackSpeed"]
UnitOnTaxi = _G["UnitOnTaxi"]
DisableSpellAutocast = _G["DisableSpellAutocast"]
EnableSpellAutocast = _G["EnableSpellAutocast"]
GetPetActionInfo = _G["GetPetActionInfo"]
IsPetAttackActive = _G["IsPetAttackActive"]
PetAssistMode = _G["PetAssistMode"]
PetPassiveMode = _G["PetPassiveMode"]
UnitBuff = _G["UnitBuff"]
UnitDebuff = _G["UnitDebuff"]
UnitAura = _G["UnitAura"]
UnitExists = _G["UnitExists"]
UnitIsPVP = _G["UnitIsPVP"]
GetNumGroupMembers = _G["GetNumGroupMembers"]
UnitGroupRolesAssigned = _G["UnitGroupRolesAssigned"]
IsInGroup = _G["IsInGroup"]
GetNumLootItems = _G["GetNumLootItems"]
GetRaidRosterInfo = _G["GetRaidRosterInfo"]
GetRaidTargetIndex = _G["GetRaidTargetIndex"]
GetUnitSpeed = _G["GetUnitSpeed"]
TargetUnit = _G["TargetUnit"]
UnitAffectingCombat = _G["UnitAffectingCombat"]
UnitCanAttack = _G["UnitCanAttack"]
UnitCastingInfo = _G["UnitCastingInfo"]
UnitChannelInfo = _G["UnitChannelInfo"]
UnitClass = _G["UnitClass"]
UnitCreatureType = _G["UnitCreatureType"]
UnitGUID = _G["UnitGUID"]
UnitHealth = _G["UnitHealth"]
UnitHealthMax = _G["UnitHealthMax"]
UnitInVehicle = _G["UnitInVehicle"]
UnitInRaid = _G["UnitInRaid"]
UnitInParty = _G["UnitInParty"]
UnitIsDead = _G["UnitIsDead"]
UnitIsDeadOrGhost = _G["UnitIsDeadOrGhost"]
UnitIsPlayer = _G["UnitIsPlayer"]
UnitIsAFK = _G["UnitIsAFK"]
UnitIsUnit = _G["UnitIsUnit"]
UnitIsVisible = _G["UnitIsVisible"]
UnitLevel = _G["UnitLevel"]
UnitName = _G["UnitName"]
UnitGetIncomingHeals = _G["UnitGetIncomingHeals"]
UnitGetTotalHealAbsorbs = _G["UnitGetTotalHealAbsorbs"]
UnitThreatSituation = _G["UnitThreatSituation"]
UnitDetailedThreatSituation = _G["UnitDetailedThreatSituation"]
GetPowerRegen = _G["GetPowerRegen"]
GetRuneCooldown = _G["GetRuneCooldown"]
UnitPower = _G["UnitPower"]
UnitPowerMax = _G["UnitPowerMax"]
SPELL_POWER_ALTERNATE_POWER = _G["SPELL_POWER_ALTERNATE_POWER"]
SPELL_POWER_ARCANE_CHARGES = _G["SPELL_POWER_ARCANE_CHARGES"]
SPELL_POWER_CHI = _G["SPELL_POWER_CHI"]
SPELL_POWER_COMBO_POINTS = _G["SPELL_POWER_COMBO_POINTS"]
SPELL_POWER_ENERGY = _G["SPELL_POWER_ENERGY"]
SPELL_POWER_FOCUS = _G["SPELL_POWER_FOCUS"]
SPELL_POWER_FURY = _G["SPELL_POWER_FURY"]
SPELL_POWER_HOLY_POWER = _G["SPELL_POWER_HOLY_POWER"]
SPELL_POWER_INSANITY = _G["SPELL_POWER_INSANITY"]
SPELL_POWER_LUNAR_POWER = _G["SPELL_POWER_LUNAR_POWER"]
SPELL_POWER_MAELSTROM = _G["SPELL_POWER_MAELSTROM"]
SPELL_POWER_MANA = _G["SPELL_POWER_MANA"]
SPELL_POWER_PAIN = _G["SPELL_POWER_PAIN"]
SPELL_POWER_RAGE = _G["SPELL_POWER_RAGE"]
SPELL_POWER_RUNIC_POWER = _G["SPELL_POWER_RUNIC_POWER"]
SPELL_POWER_SOUL_SHARDS = _G["SPELL_POWER_SOUL_SHARDS"]
GetSpellCharges = _G["GetSpellCharges"]
GetSpellCooldown = _G["GetSpellCooldown"]
GetSpellCount = _G["GetSpellCount"]
GetSpellInfo = _G["GetSpellInfo"]
GetTotemInfo = _G["GetTotemInfo"]
GetTotemTimeLeft = _G["GetTotemTimeLeft"]
IsUsableSpell = _G["IsUsableSpell"]
IsPlayerSpell = _G["IsPlayerSpell"]
IsSpellInRange = _G["IsSpellInRange"]
IsSpellKnown = _G["IsSpellKnown"]
SpellStopCasting = _G["SpellStopCasting"]
GetInventoryItemCooldown = _G["GetInventoryItemCooldown"]
GetItemInfo = _G["GetItemInfo"]
GetInventoryItemID = _G["GetInventoryItemID"]
GetItemCooldown = _G["GetItemCooldown"]
GetItemCount = _G["GetItemCount"]
IsUsableInventory = _G["IsUsableInventory"]
UseInventoryItem = _G["UseInventoryItem"]
UseItemByName = _G["UseItemByName"]
UIParent = _G["UIParent"]
HasArtifactEquipped = _G["HasArtifactEquipped"]
SocketInventoryItem = _G["SocketInventoryItem"]
ArtifactFrame = _G["ArtifactFrame"]
C_ArtifactUI = _G["C_ArtifactUI"]
INVSLOT_MAINHAND = _G["INVSLOT_MAINHAND"]
CR_VERSATILITY_DAMAGE_DONE = _G["CR_VERSATILITY_DAMAGE_DONE"]
GetCombatRating = _G["GetCombatRating"]
GetCombatRatingBonus = _G["GetCombatRatingBonus"]
GetVersatilityBonus = _G["GetVersatilityBonus"]
GetMasteryEffect = _G["GetMasteryEffect"]
GetCritChance = _G["GetCritChance"]
GetHaste = _G["GetHaste"]
UnitAttackPower = _G["UnitAttackPower"]
UnitDamage = _G["UnitDamage"]
UnitSpellHaste = _G["UnitSpellHaste"]
IsMouselooking = _G["IsMouselooking"]
IsShiftKeyDown = _G["IsShiftKeyDown"]
MouselookStart = _G["MouselookStart"]
C_Timer = _G["C_Timer"]
Enum = _G["Enum"]
GetBuildInfo = _G["GetBuildInfo"]
GetLocale = _G["GetLocale"]
GetRealTime = _G["GetTime"]
GetNetStats = _G["GetNetStats"]
UnitIsWildBattlePet = _G["UnitIsWildBattlePet"]
CameraOrSelectOrMoveStart = _G["CameraOrSelectOrMoveStart"]
CameraOrSelectOrMoveStop = _G["CameraOrSelectOrMoveStop"]
SpellStopTargeting = _G["SpellStopTargeting"]
GetCVar = _G["GetCVar"]
UIErrorsFrame = _G["UIErrorsFrame"]
ContainerIDToInventoryID = _G["ContainerIDToInventoryID"]
EquipCursorItem = _G["EquipCursorItem"]
GetContainerFreeSlots = _G["GetContainerFreeSlots"]
NUM_BAG_SLOTS = _G["NUM_BAG_SLOTS"]
PickupContainerItem = _G["PickupContainerItem"]
PickupInventoryItem = _G["PickupInventoryItem"]
PutItemInBackpack = _G["PutItemInBackpack"]
PutItemInBag = _G["PutItemInBag"]
LearnTalent = _G["LearnTalent"]
RemoveTalent = _G["RemoveTalent"]
Locale = "en"
ChineseSelection = RF(PROFILESPATH .. "Chinese.json")
ChineseFont = "Fonts\\ARKai_T.ttf"
FontFrame = CreateFrame("Frame")
FontFrame.Text = FontFrame:CreateFontString()
ValidChineseFont = FontFrame.Text:SetFont(ChineseFont, 11, "OUTLINE")
_G["StaticPopupDialogs"]["LanguageWarning"] = {
    text = "We could not translate to Chinese because the required font file could not be found. Please add the required font file to your World of Warcraft/Fonts folder and then reload the game completely.\n\n我们无法翻译成中文，因为无法找到所需的字体文件。 请将所需的字体文件添加到World of Warcraft/Fonts文件夹中，然后重新加载游戏。",
    button1 = "OK / 好",
    hasEditBox = false,
    timeout = 0,
    whileDead = true,
    hideOnEscape = true,
    preferredIndex = 3
}
if (ChineseSelection == nil and string.sub(GetLocale(), 1, 2) == "zh") or ChineseSelection == "1" then
    if ValidChineseFont then
        Locale = "zh"
    else
        _G["StaticPopup_Show"]("LanguageWarning")
    end
end
C = {
    ClientMaxLevel = 110,
    INTERRUPT_DEFAULT1 = 40,
    INTERRUPT_DEFAULT2 = 60,
    INTERRUPT_MIN = ManagerVersion == "Local" and 1 or 20,
    INTERRUPT_MAX = 100,
    INTERRUPT_STEP = 5,
    INTERRUPT_GAP = ManagerVersion == "Local" and 0 or 20,
    TOOLTIP_DESCRIPTION = Locale == "zh" and "|cFF1784d1描述|cFFFFFFFF\n" or "|cFF1784d1功能说明|cFFFFFFFF\n",
    TOOLTIP_VALUE = Locale == "zh" and "\n\n|cFF1784d1值|cFFFFFFFF\n" or "\n\n|cFF1784d1参数|cFFFFFFFF\n",
    TOOLTIP_VALUE_1 = Locale == "zh" and "\n\n|cFF1784d1一值|cFFFFFFFF\n" or "\n\n|cFF1784d1参数 1|cFFFFFFFF\n",
    TOOLTIP_VALUE_2 = Locale == "zh" and "\n\n|cFF1784d1二值|cFFFFFFFF\n" or "\n\n|cFF1784d1参数 2|cFFFFFFFF\n",
    TOOLTIP_DEFAULT_STATE = Locale == "zh" and "\n\n|cFFFFD800检查默认值:|cFFFFFFFF " or "\n\n|cFFFFD800默认开关:|cFFFFFFFF ",
    TOOLTIP_DEFAULT_VALUE = Locale == "zh" and "\n|cFFFFD800默认值:|cFFFFFFFF " or "\n|cFFFFD800默认参数:|cFFFFFFFF ",
    TOOLTIP_DEFAULT_VALUE_1 = Locale == "zh" and "\n|cFFFFD800默认第一选项:|cFFFFFFFF " or "\n|cFFFFD800默认一选项:|cFFFFFFFF ",
    TOOLTIP_DEFAULT_VALUE_2 = Locale == "zh" and "\n|cFFFFD800默认第二选项:|cFFFFFFFF " or "\n|cFFFFD800默认二选项:|cFFFFFFFF ",
    TOOLTIP_SUBVALUE = function(Text, NoLineReturn)
        return NoLineReturn and "|cFF1784d1" .. Text .. ":|cFFFFFFFF " or "\n|cFF1784d1" .. Text .. ":|cFFFFFFFF "
    end,
    TOOLTIP_HINT = function(Text)
        return "\n\n|cFF26BAFF" .. Text .. "|r"
    end,
    MAXIMUM_BUFFS = 40,
    PLAYERGUID = UnitGUID("player"),
    CLASS = ({ UnitClass("player") })[1],
    CLASSNAME = ({ UnitClass("player") })[2],
    CLASSINDEX = ({ UnitClass("player") })[3],
    PROFILESPATH = PROFILESPATH,
    INFORMATIONSPATH = PROFILESPATH .. "/../../"
}
ColorsTable = {
    Blue = { R = 23 / 255, G = 132 / 255, B = 209 / 255, Hex = "|cff1784d1" },
    Black = { R = 5 / 255, G = 5 / 255, B = 5 / 255, Hex = "|cff050505" },
    DarkGray = { R = 0.0588233, G = 0.0588233, B = 0.0588233, Hex = "|cff191919" },
    Gray = { R = 55 / 255, G = 55 / 255, B = 55 / 255, Hex = "|cff373737" },
    Green = { R = 10 / 255, G = 235 / 255, B = 10 / 255, Hex = "|cff0AEB0A" },
    LightGray = { R = 95 / 255, G = 95 / 255, B = 95 / 255, Hex = "|cff4B4B4B" },
    Red = { R = 159 / 255, G = 4 / 255, B = 8 / 255, Hex = "|cff9F0408" },
    Yellow = { R = 255 / 255, G = 215 / 255, B = 0 / 255, Hex = "|cffFFD700" }
}
MemorizedGetTime = GetRealTime()
function GetTime()
    return MemorizedGetTime
end
function TableContains(Table, ValueOrKey, ValueIfKey)
    local ValueOrKey, ValueIfKey = ValueOrKey, ValueIfKey
    local Table = Table or {}
    if ValueIfKey then
        for Key, Value in pairs(Table) do
            if Value[ValueOrKey] == ValueIfKey then
                return true
            end
        end
    else
        for Key, Value in pairs(Table) do
            if Value == ValueOrKey then
                return true
            end
        end
    end
    return false
end
function TableContainsValue(Table, Value)
    local Table = Table or {}
    for i = 1, #Table do
        if GetSpellInfo(Table[i]) == Value then
            return true
        end
    end
    return false
end
local always_try_using_lpeg = true
local register_global_module_table = false
local global_module_name = "json"
local floor, huge = math.floor, math.huge
local strrep, gsub, strsub, strbyte, strchar, strfind, strlen, strformat = string.rep,
string.gsub,
string.sub,
string.byte,
string.char,
string.find,
string.len,
string.format
local strmatch = string.match
local concat = table.concat
json = { version = "dkjson 2.5" }
if register_global_module_table then
    _G[global_module_name] = json
end
local _ENV = nil
pcall(
function()
    local debmeta = require "debug".getmetatable
    if debmeta then
        getmetatable = debmeta
    end
end
)
json.null = setmetatable(
{},
{ __tojson = function()
    return "null"
end }
)
local function isarray(tbl)
    local max, n, arraylen = 0, 0, 0
    for k, v in pairs(tbl) do
        if k == "n" and type(v) == "number" then
            arraylen = v
            if v > max then
                max = v
            end
        else
            if type(k) ~= "number" or k < 1 or floor(k) ~= k then
                return false
            end
            if k > max then
                max = k
            end
            n = n + 1
        end
    end
    if max > 10 and max > arraylen and max > n * 2 then
        return false
    end
    return true, max
end
local escapecodes = {
    ['"'] = '\\"',
    ["\\"] = "\\\\",
    ["\b"] = "\\b",
    ["\f"] = "\\f",
    ["\n"] = "\\n",
    ["\r"] = "\\r",
    ["	"] = "\\t"
}
local function escapeutf8(uchar)
    local value = escapecodes[uchar]
    if value then
        return value
    end
    local a, b, c, d = strbyte(uchar, 1, 4)
    a, b, c, d = a or 0, b or 0, c or 0, d or 0
    if a <= 127 then
        value = a
    elseif 192 <= a and a <= 223 and b >= 128 then
        value = (a - 192) * 64 + b - 128
    elseif 224 <= a and a <= 239 and b >= 128 and c >= 128 then
        value = ((a - 224) * 64 + b - 128) * 64 + c - 128
    elseif 240 <= a and a <= 247 and b >= 128 and c >= 128 and d >= 128 then
        value = (((a - 240) * 64 + b - 128) * 64 + c - 128) * 64 + d - 128
    else
        return ""
    end
    if value <= 65535 then
        return strformat("\\u%.4x", value)
    elseif value <= 1114111 then
        value = value - 65536
        local highsur, lowsur = 55296 + floor(value / 1024), 56320 + (value % 1024)
        return strformat("\\u%.4x\\u%.4x", highsur, lowsur)
    else
        return ""
    end
end
local function fsub(str, pattern, repl)
    if strfind(str, pattern) then
        return gsub(str, pattern, repl)
    else
        return str
    end
end
local function quotestring(value)
    value = fsub(value, "\91\37\122\1\45\31\34\92\127\93", escapeutf8)
    if strfind(value, "\91\194\216\220\225\226\239\93") then value = fsub(value, "\194\91\128\45\159\173\93", escapeutf8)
        value = fsub(value, "\216\91\128\45\132\93", escapeutf8)
        value = fsub(value, "\220\143", escapeutf8)
        value = fsub(value, "\225\158\91\180\181\93", escapeutf8)
        value = fsub(value, "\226\128\91\140\45\143\168\45\175\93", escapeutf8)
        value = fsub(value, "\226\129\91\160\45\175\93", escapeutf8)
        value = fsub(value, "\239\187\191", escapeutf8)
        value = fsub(value, "\239\191\91\176\45\191\93", escapeutf8)
    end
    return '"' .. value .. '"'
end
json.quotestring = quotestring
local function replace(str, o, n)
    local i, j = strfind(str, o, 1, true)
    if i then
        return strsub(str, 1, i - 1) .. n .. strsub(str, j + 1, -1)
    else
        return str
    end
end
local decpoint, numfilter
local function updatedecpoint()
    decpoint = strmatch(tostring(0.5), "([^05+])")
    numfilter = "[^0-9%-%+eE" .. gsub(decpoint, "[%^%$%(%)%%%.%[%]%*%+%-%?]", "%%%0") .. "]+"
end
updatedecpoint()
local function num2str(num)
    return replace(fsub(tostring(num), numfilter, ""), decpoint, ".")
end
local function str2num(str)
    local num = tonumber(replace(str, ".", decpoint))
    if not num then
        updatedecpoint()
        num = tonumber(replace(str, ".", decpoint))
    end
    return num
end
local function addnewline2(level, buffer, buflen)
    buffer[buflen + 1] = "\n"
    buffer[buflen + 2] = strrep("  ", level)
    buflen = buflen + 2
    return buflen
end
function json.addnewline(state)
    if state.indent then
        state.bufferlen = addnewline2(state.level or 0, state.buffer, state.bufferlen or #(state.buffer))
    end
end
local encode2
local function addpair(key, value, prev, indent, level, buffer, buflen, tables, globalorder, state)
    local kt = type(key)
    if kt ~= "string" and kt ~= "number" then
        return nil, "type '" .. kt .. "' is not supported as a key by JSON."
    end
    if prev then
        buflen = buflen + 1
        buffer[buflen] = ","
    end
    if indent then
        buflen = addnewline2(level, buffer, buflen)
    end
    buffer[buflen + 1] = quotestring(key)
    buffer[buflen + 2] = ":"
    return encode2(value, indent, level, buffer, buflen + 2, tables, globalorder, state)
end
local function appendcustom(res, buffer, state)
    local buflen = state.bufferlen
    if type(res) == "string" then
        buflen = buflen + 1
        buffer[buflen] = res
    end
    return buflen
end
local function exception(reason, value, state, buffer, buflen, defaultmessage)
    defaultmessage = defaultmessage or reason
    local handler = state.exception
    if not handler then
        return nil, defaultmessage
    else
        state.bufferlen = buflen
        local ret, msg = handler(reason, value, state, defaultmessage)
        if not ret then
            return nil, msg or defaultmessage
        end
        return appendcustom(ret, buffer, state)
    end
end
function json.encodeexception(reason, value, state, defaultmessage)
    return quotestring("<" .. defaultmessage .. ">")
end
encode2 = function(value, indent, level, buffer, buflen, tables, globalorder, state)
    local valtype = type(value)
    local valmeta = getmetatable(value)
    valmeta = type(valmeta) == "table" and valmeta
    local valtojson = valmeta and valmeta.__tojson
    if valtojson then
        if tables[value] then
            return exception("reference cycle", value, state, buffer, buflen)
        end
        tables[value] = true
        state.bufferlen = buflen
        local ret, msg = valtojson(value, state)
        if not ret then
            return exception("custom encoder failed", value, state, buffer, buflen, msg)
        end
        tables[value] = nil
        buflen = appendcustom(ret, buffer, state)
    elseif value == nil then
        buflen = buflen + 1
        buffer[buflen] = "null"
    elseif valtype == "number" then
        local s
        if value ~= value or value >= huge or -value >= huge then
            s = "null"
        else
            s = num2str(value)
        end
        buflen = buflen + 1
        buffer[buflen] = s
    elseif valtype == "boolean" then
        buflen = buflen + 1
        buffer[buflen] = value and "true" or "false"
    elseif valtype == "string" then
        buflen = buflen + 1
        buffer[buflen] = quotestring(value)
    elseif valtype == "table" then
        if tables[value] then
            return exception("reference cycle", value, state, buffer, buflen)
        end
        tables[value] = true
        level = level + 1
        local isa, n = isarray(value)
        if n == 0 and valmeta and valmeta.__jsontype == "object" then
            isa = false
        end
        local msg
        if isa then
            buflen = buflen + 1
            buffer[buflen] = "["
            for i = 1, n do
                buflen, msg = encode2(value[i], indent, level, buffer, buflen, tables, globalorder, state)
                if not buflen then
                    return nil, msg
                end
                if i < n then
                    buflen = buflen + 1
                    buffer[buflen] = ","
                end
            end
            buflen = buflen + 1
            buffer[buflen] = "]"
        else
            local prev = false
            buflen = buflen + 1
            buffer[buflen] = "{"
            local order = valmeta and valmeta.__jsonorder or globalorder
            if order then
                local used = {}
                n = #order
                for i = 1, n do
                    local k = order[i]
                    local v = value[k]
                    if v then
                        used[k] = true
                        buflen, msg = addpair(k, v, prev, indent, level, buffer, buflen, tables, globalorder, state)
                        prev = true
                    end
                end
                for k, v in pairs(value) do
                    if not used[k] then
                        buflen, msg = addpair(k, v, prev, indent, level, buffer, buflen, tables, globalorder, state)
                        if not buflen then
                            return nil, msg
                        end
                        prev = true
                    end
                end
            else
                for k, v in pairs(value) do
                    buflen, msg = addpair(k, v, prev, indent, level, buffer, buflen, tables, globalorder, state)
                    if not buflen then
                        return nil, msg
                    end
                    prev = true
                end
            end
            if indent then
                buflen = addnewline2(level - 1, buffer, buflen)
            end
            buflen = buflen + 1
            buffer[buflen] = "}"
        end
        tables[value] = nil
    else
        return exception(
        "unsupported type",
        value,
        state,
        buffer,
        buflen,
        "type '" .. valtype .. "' is not supported by JSON."
        )
    end
    return buflen
end
function Travelight(value, state)
    state = state or {}
    local oldbuffer = state.buffer
    local buffer = oldbuffer or {}
    state.buffer = buffer
    updatedecpoint()
    local ret, msg =     encode2(
    value,
    state.indent,
    state.level or 0,
    buffer,
    state.bufferlen or 0,
    state.tables or {},
    state.keyorder,
    state
    )
    if not ret then
        error(msg, 2)
    elseif oldbuffer == buffer then
        state.bufferlen = ret
        return true
    else
        state.bufferlen = nil
        state.buffer = nil
        return concat(buffer)
    end
end
function json.encode(value, state)
    state = state or {}
    local oldbuffer = state.buffer
    local buffer = oldbuffer or {}
    state.buffer = buffer
    updatedecpoint()
    local ret, msg =     encode2(
    value,
    state.indent,
    state.level or 0,
    buffer,
    state.bufferlen or 0,
    state.tables or {},
    state.keyorder,
    state
    )
    if not ret then
        error(msg, 2)
    elseif oldbuffer == buffer then
        state.bufferlen = ret
        return true
    else
        state.bufferlen = nil
        state.buffer = nil
        return concat(buffer)
    end
end
local function loc(str, where)
    local line, pos, linepos = 1, 1, 0
    while true do
        pos = strfind(str, "\n", pos, true)
        if pos and pos < where then
            line = line + 1
            linepos = pos
            pos = pos + 1
        else
            break
        end
    end
    return "line " .. line .. ", column " .. (where - linepos)
end
local function unterminated(str, what, where)
    return nil, strlen(str) + 1, "unterminated " .. what .. " at " .. loc(str, where)
end
local function scanwhite(str, pos)
    while true do
        pos = strfind(str, "%S", pos)
        if not pos then
            return nil
        end
        local sub2 = strsub(str, pos, pos + 1)
        if sub2 == "\239\187" and strsub(str, pos + 2, pos + 2) == "\191" then
            pos = pos + 3
        elseif sub2 == "//" then
            pos = strfind(str, "[\n\r]", pos + 2)
            if not pos then
                return nil
            end
        elseif sub2 == "/*" then
            pos = strfind(str, "*/", pos + 2)
            if not pos then
                return nil
            end
            pos = pos + 2
        else
            return pos
        end
    end
end
local escapechars = {
    ['"'] = '"',
    ["\\"] = "\\",
    ["/"] = "/",
    ["b"] = "\b",
    ["f"] = "\f",
    ["n"] = "\n",
    ["r"] = "\r",
    ["t"] = "	"
}
local function unichar(value)
    if value < 0 then
        return nil
    elseif value <= 127 then
        return strchar(value)
    elseif value <= 2047 then
        return strchar(192 + floor(value / 64), 128 + (floor(value) % 64))
    elseif value <= 65535 then
        return strchar(224 + floor(value / 4096), 128 + (floor(value / 64) % 64), 128 + (floor(value) % 64))
    elseif value <= 1114111 then
        return strchar(
        240 + floor(value / 262144),
        128 + (floor(value / 4096) % 64),
        128 + (floor(value / 64) % 64),
        128 + (floor(value) % 64)
        )
    else
        return nil
    end
end
local function scanstring(str, pos)
    local lastpos = pos + 1
    local buffer, n = {}, 0
    while true do
        local nextpos = strfind(str, '["\\]', lastpos)
        if not nextpos then
            return unterminated(str, "string", pos)
        end
        if nextpos > lastpos then
            n = n + 1
            buffer[n] = strsub(str, lastpos, nextpos - 1)
        end
        if strsub(str, nextpos, nextpos) == '"' then
            lastpos = nextpos + 1
            break
        else
            local escchar = strsub(str, nextpos + 1, nextpos + 1)
            local value
            if escchar == "u" then
                value = tonumber(strsub(str, nextpos + 2, nextpos + 5), 16)
                if value then
                    local value2
                    if 55296 <= value and value <= 56319 then
                        if strsub(str, nextpos + 6, nextpos + 7) == "\\u" then
                            value2 = tonumber(strsub(str, nextpos + 8, nextpos + 11), 16)
                            if value2 and 56320 <= value2 and value2 <= 57343 then
                                value = (value - 55296) * 1024 + (value2 - 56320) + 65536
                            else
                                value2 = nil
                            end
                        end
                    end
                    value = value and unichar(value)
                    if value then
                        if value2 then
                            lastpos = nextpos + 12
                        else
                            lastpos = nextpos + 6
                        end
                    end
                end
            end
            if not value then
                value = escapechars[escchar] or escchar
                lastpos = nextpos + 2
            end
            n = n + 1
            buffer[n] = value
        end
    end
    if n == 1 then
        return buffer[1], lastpos
    elseif n > 1 then
        return concat(buffer), lastpos
    else
        return "", lastpos
    end
end
local scanvalue
local function scantable(what, closechar, str, startpos, nullval, objectmeta, arraymeta)
    local len = strlen(str)
    local tbl, n = {}, 0
    local pos = startpos + 1
    if what == "object" then
        setmetatable(tbl, objectmeta)
    else
        setmetatable(tbl, arraymeta)
    end
    while true do
        pos = scanwhite(str, pos)
        if not pos then
            return unterminated(str, what, startpos)
        end
        local char = strsub(str, pos, pos)
        if char == closechar then
            return tbl, pos + 1
        end
        local val1, err
        val1, pos, err = scanvalue(str, pos, nullval, objectmeta, arraymeta)
        if err then
            return nil, pos, err
        end
        pos = scanwhite(str, pos)
        if not pos then
            return unterminated(str, what, startpos)
        end
        char = strsub(str, pos, pos)
        if char == ":" then
            if val1 == nil then
                return nil, pos, "cannot use nil as table index (at " .. loc(str, pos) .. ")"
            end
            pos = scanwhite(str, pos + 1)
            if not pos then
                return unterminated(str, what, startpos)
            end
            local val2
            val2, pos, err = scanvalue(str, pos, nullval, objectmeta, arraymeta)
            if err then
                return nil, pos, err
            end
            tbl[val1] = val2
            pos = scanwhite(str, pos)
            if not pos then
                return unterminated(str, what, startpos)
            end
            char = strsub(str, pos, pos)
        else
            n = n + 1
            tbl[n] = val1
        end
        if char == "," then
            pos = pos + 1
        end
    end
end
scanvalue = function(str, pos, nullval, objectmeta, arraymeta)
    pos = pos or 1
    pos = scanwhite(str, pos)
    if not pos then
        return nil, strlen(str) + 1, "no valid JSON value (reached the end)"
    end
    local char = strsub(str, pos, pos)
    if char == "{" then
        return scantable("object", "}", str, pos, nullval, objectmeta, arraymeta)
    elseif char == "[" then
        return scantable("array", "]", str, pos, nullval, objectmeta, arraymeta)
    elseif char == '"' then
        return scanstring(str, pos)
    else
        local pstart, pend = strfind(str, "^%-?[%d%.]+[eE]?[%+%-]?%d*", pos)
        if pstart then
            local number = str2num(strsub(str, pstart, pend))
            if number then
                return number, pend + 1
            end
        end
        pstart, pend = strfind(str, "^%a%w*", pos)
        if pstart then
            local name = strsub(str, pstart, pend)
            if name == "true" then
                return true, pend + 1
            elseif name == "false" then
                return false, pend + 1
            elseif name == "null" then
                return nullval, pend + 1
            end
        end
        return nil, pos, "no valid JSON value at " .. loc(str, pos)
    end
end
local function optionalmetatables(...)
    if select("#", ...) > 0 then
        return ...
    else
        return { __jsontype = "object" }, { __jsontype = "array" }
    end
end
function json.decode(str, pos, nullval, ...)
    local objectmeta, arraymeta = optionalmetatables(...)
    return scanvalue(str, pos, nullval, objectmeta, arraymeta)
end
function json.use_lpeg()
    local g = require("lpeg")
    if g.version() == "0.11" then
        error "due to a bug in LPeg 0.11, it cannot be used for JSON matching"
    end
    local pegmatch = g.match
    local P, S, R = g.P, g.S, g.R
    local function ErrorCall(str, pos, msg, state)
        if not state.msg then
            state.msg = msg .. " at " .. loc(str, pos)
            state.pos = pos
        end
        return false
    end
    local function Err(msg)
        return g.Cmt(g.Cc(msg) * g.Carg(2), ErrorCall)
    end
    local SingleLineComment = P "//" * (1 - S "\n\r") ^ 0
    local MultiLineComment = P "/*" * (1 - P "*/") ^ 0 * P "*/"
    local Space = (S "\32\10\13\9" + P "\239\187\191" + SingleLineComment + MultiLineComment) ^ 0
    local PlainChar = 1 - S '"\\\n\r'
    local EscapeSequence = (P "\\" * g.C(S '"\\/bfnrt' + Err "unsupported escape sequence")) / escapechars
    local HexDigit = R("09", "af", "AF")
    local function UTF16Surrogate(match, pos, high, low)
        high, low = tonumber(high, 16), tonumber(low, 16)
        if 55296 <= high and high <= 56319 and 56320 <= low and low <= 57343 then
            return true, unichar((high - 55296) * 1024 + (low - 56320) + 65536)
        else
            return false
        end
    end
    local function UTF16BMP(hex)
        return unichar(tonumber(hex, 16))
    end
    local U16Sequence = (P "\\u" * g.C(HexDigit * HexDigit * HexDigit * HexDigit))
    local UnicodeEscape = g.Cmt(U16Sequence * U16Sequence, UTF16Surrogate) + U16Sequence / UTF16BMP
    local Char = UnicodeEscape + EscapeSequence + PlainChar
    local String = P '"' * g.Cs(Char ^ 0) * (P '"' + Err "unterminated string")
    local Integer = P "-" ^ (-1) * (P "0" + (R "19" * R "09" ^ 0))
    local Fractal = P "." * R "09" ^ 0
    local Exponent = (S "eE") * (S "+-") ^ (-1) * R "09" ^ 1
    local Number = (Integer * Fractal ^ (-1) * Exponent ^ (-1)) / str2num
    local Constant = P "true" * g.Cc(true) + P "false" * g.Cc(false) + P "null" * g.Carg(1)
    local SimpleValue = Number + String + Constant
    local ArrayContent, ObjectContent
    local function parsearray(str, pos, nullval, state)
        local obj, cont
        local npos
        local t, nt = {}, 0
        repeat
            obj, cont, npos = pegmatch(ArrayContent, str, pos, nullval, state)
            if not npos then
                break
            end
            pos = npos
            nt = nt + 1
            t[nt] = obj
        until cont == "last"
        return pos, setmetatable(t, state.arraymeta)
    end
    local function parseobject(str, pos, nullval, state)
        local obj, key, cont
        local npos
        local t = {}
        repeat
            key, obj, cont, npos = pegmatch(ObjectContent, str, pos, nullval, state)
            if not npos then
                break
            end
            pos = npos
            t[key] = obj
        until cont == "last"
        return pos, setmetatable(t, state.objectmeta)
    end
    local Array = P "[" * g.Cmt(g.Carg(1) * g.Carg(2), parsearray) * Space * (P "]" + Err "']' expected")
    local Object = P "{" * g.Cmt(g.Carg(1) * g.Carg(2), parseobject) * Space * (P "}" + Err "'}' expected")
    local Value = Space * (Array + Object + SimpleValue)
    local ExpectedValue = Value + Space * Err "value expected"
    ArrayContent = Value * Space * (P "," * g.Cc "cont" + g.Cc "last") * g.Cp()
    local Pair = g.Cg(Space * String * Space * (P ":" + Err "colon expected") * ExpectedValue)
    ObjectContent = Pair * Space * (P "," * g.Cc "cont" + g.Cc "last") * g.Cp()
    local DecodeValue = ExpectedValue * g.Cp()
    function json.decode(str, pos, nullval, ...)
        local state = {}
        state.objectmeta, state.arraymeta = optionalmetatables(...)
        local obj, retpos = pegmatch(DecodeValue, str, pos, nullval, state)
        if state.msg then
            return nil, state.pos, state.msg
        else
            return obj, retpos
        end
    end
    json.use_lpeg = function()
        return json
    end
    json.using_lpeg = true
    return json
end
if always_try_using_lpeg then
    pcall(json.use_lpeg)
end
BaseSixtyFour = {}
local b = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
function BaseSixtyFour.Encode(data)
    return ((data:gsub(
    ".",
    function(x)
        local r, b = "", x:byte()
        for i = 8, 1, -1 do
            r = r .. (b % 2 ^ i - b % 2 ^ (i - 1) > 0 and "1" or "0")
        end
        return r
    end
    ) .. "0000"):gsub(
    "%d%d%d?%d?%d?%d?",
    function(x)
        if (#x < 6) then
            return ""
        end
        local c = 0
        for i = 1, 6 do
            c = c + (x:sub(i, i) == "1" and 2 ^ (6 - i) or 0)
        end
        return b:sub(c + 1, c + 1)
    end
    ) .. ({ "", "==", "=" })[#data % 3 + 1])
end
function BaseSixtyFour.Decode(data)
    data = string.gsub(data, "[^" .. b .. "=]", "")
    return (data:gsub(
    ".",
    function(x)
        if (x == "=") then
            return ""
        end
        local r, f = "", (b:find(x) - 1)
        for i = 6, 1, -1 do
            r = r .. (f % 2 ^ i - f % 2 ^ (i - 1) > 0 and "1" or "0")
        end
        return r
    end
    ):gsub(
    "%d%d%d?%d?%d?%d?%d?%d?",
    function(x)
        if (#x ~= 8) then
            return ""
        end
        local c = 0
        for i = 1, 8 do
            c = c + (x:sub(i, i) == "1" and 2 ^ (8 - i) or 0)
        end
        return string.char(c)
    end
    ))
end
Sha256 = {}
Sha256.MOD = 2 ^ 32
Sha256.MODM = Sha256.MOD - 1
function Sha256.Memoize(f)
    local mt = {}
    local t = setmetatable({}, mt)
    function mt:__index(k)
        local v = f(k)
        t[k] = v
        return v
    end
    return t
end
function Sha256.MakeBitopUncached(t, m)
    local function bitop(a, b)
        local res, p = 0, 1
        while a ~= 0 and b ~= 0 do
            local am, bm = a % m, b % m
            res = res + t[am][bm] * p
            a = (a - am) / m
            b = (b - bm) / m
            p = p * m
        end
        res = res + (a + b) * p
        return res
    end
    return bitop
end
function Sha256.MakeBitop(t)
    local op1 = Sha256.MakeBitopUncached(t, 2 ^ 1)
    local op2 =     Sha256.Memoize(
    function(a)
        return Sha256.Memoize(
        function(b)
            return op1(a, b)
        end
        )
    end
    )
    return Sha256.MakeBitopUncached(op2, 2 ^ (t.n or 1))
end
Sha256.Bxor1 = Sha256.MakeBitop({[0] = {[0] = 0, [1] = 1 }, [1] = {[0] = 1, [1] = 0 }, n = 4 })
function Sha256.Bxor(a, b, c, ...)
    local z = nil
    if b then
        a = a % Sha256.MOD
        b = b % Sha256.MOD
        z = Sha256.Bxor1(a, b)
        if c then
            z = Sha256.Bxor(z, c, ...)
        end
        return z
    elseif a then
        return a % Sha256.MOD
    else
        return 0
    end
end
function Sha256.Band(a, b, c, ...)
    local z
    if b then
        a = a % Sha256.MOD
        b = b % Sha256.MOD
        z = ((a + b) - Sha256.Bxor1(a, b)) / 2
        if c then
            z = bit32_band(z, c, ...)
        end
        return z
    elseif a then
        return a % Sha256.MOD
    else
        return Sha256.MODM
    end
end
function Sha256.Bnot(x)
    return (-1 - x) % Sha256.MOD
end
function Sha256.Rshift1(a, disp)
    if disp < 0 then
        return Sha256.Lshift(a, -disp)
    end
    return math.floor(a % 2 ^ 32 / 2 ^ disp)
end
function Sha256.Rshift(x, disp)
    if disp > 31 or disp < -31 then
        return 0
    end
    return Sha256.Rshift1(x % Sha256.MOD, disp)
end
function Sha256.Lshift(a, disp)
    if disp < 0 then
        return Sha256.Rshift(a, -disp)
    end
    return (a * 2 ^ disp) % 2 ^ 32
end
function Sha256.Rrotate(x, disp)
    x = x % Sha256.MOD
    disp = disp % 32
    local low = Sha256.Band(x, 2 ^ disp - 1)
    return Sha256.Rshift(x, disp) + Sha256.Lshift(low, 32 - disp)
end
local k = {
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
}
function Sha256.Str2hexa(s)
    return (string.gsub(
    s,
    ".",
    function(c)
        return string.format("%02x", string.byte(c))
    end
    ))
end
function Sha256.Num2s(l, n)
    local s = ""
    for i = 1, n do
        local rem = l % 256
        s = string.char(rem) .. s
        l = (l - rem) / 256
    end
    return s
end
function Sha256.S232num(s, i)
    local n = 0
    for i = i, i + 3 do
        n = n * 256 + string.byte(s, i)
    end
    return n
end
function Sha256.Preproc(msg, len)
    local extra = 64 - ((len + 9) % 64)
    len = Sha256.Num2s(8 * len, 8)
    msg = msg .. "\128" .. string.rep("\0", extra) .. len
    _G.assert(#msg % 64 == 0)
    return msg
end
function Sha256.InitH256(H)
    H[1] = 1779033703
    H[2] = 3144134277
    H[3] = 1013904242
    H[4] = 2773480762
    H[5] = 1359893119
    H[6] = 2600822924
    H[7] = 528734635
    H[8] = 1541459225
    return H
end
function Sha256.DigestBlock(msg, i, H)
    local w = {}
    for j = 1, 16 do
        w[j] = Sha256.S232num(msg, i + (j - 1) * 4)
    end
    for j = 17, 64 do
        local v = w[j - 15]
        local s0 = Sha256.Bxor(Sha256.Rrotate(v, 7), Sha256.Rrotate(v, 18), Sha256.Rshift(v, 3))
        v = w[j - 2]
        w[j] =         w[j - 16] + s0 + w[j - 7] + Sha256.Bxor(Sha256.Rrotate(v, 17), Sha256.Rrotate(v, 19), Sha256.Rshift(v, 10))
    end
    local a, b, c, d, e, f, g, h = H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8]
    for i = 1, 64 do
        local s0 = Sha256.Bxor(Sha256.Rrotate(a, 2), Sha256.Rrotate(a, 13), Sha256.Rrotate(a, 22))
        local maj = Sha256.Bxor(Sha256.Band(a, b), Sha256.Band(a, c), Sha256.Band(b, c))
        local t2 = s0 + maj
        local s1 = Sha256.Bxor(Sha256.Rrotate(e, 6), Sha256.Rrotate(e, 11), Sha256.Rrotate(e, 25))
        local ch = Sha256.Bxor(Sha256.Band(e, f), Sha256.Band(Sha256.Bnot(e), g))
        local t1 = h + s1 + ch + k[i] + w[i]
        h, g, f, e, d, c, b, a = g, f, e, d + t1, c, b, a, t1 + t2
    end
    H[1] = Sha256.Band(H[1] + a)
    H[2] = Sha256.Band(H[2] + b)
    H[3] = Sha256.Band(H[3] + c)
    H[4] = Sha256.Band(H[4] + d)
    H[5] = Sha256.Band(H[5] + e)
    H[6] = Sha256.Band(H[6] + f)
    H[7] = Sha256.Band(H[7] + g)
    H[8] = Sha256.Band(H[8] + h)
end
function Sha256.Encode(msg)
    msg = Sha256.Preproc(msg, #msg)
    local H = Sha256.InitH256({})
    for i = 1, #msg, 64 do
        Sha256.DigestBlock(msg, i, H)
    end
    return Sha256.Str2hexa(
    Sha256.Num2s(H[1], 4) ..
    Sha256.Num2s(H[2], 4) ..
    Sha256.Num2s(H[3], 4) ..
    Sha256.Num2s(H[4], 4) ..
    Sha256.Num2s(H[5], 4) .. Sha256.Num2s(H[6], 4) .. Sha256.Num2s(H[7], 4) .. Sha256.Num2s(H[8], 4)
    )
end
Settings = CreateFrame("Frame", Randomize())
local ProfileKey, ProfileName, ProfilePath_All, ProfilePath_Spec
Settings.TriggerLoad = GetTime() + 0.5
function Settings:TriggerInit()
    if GetRealTime() > Settings.TriggerLoad then
        Settings.Initialized = true
        InitSettings()
        EngineRunning = GetSetting("Running")
        AOEEnabled = GetSetting("AOE")
        AllowCooldowns = GetSetting("cds")
        DebugEnabled = GetSetting("调试")
        DebugFrameEnabled = GetSetting("调试窗口")
        ActionLogEnabled = GetSetting("ActionLog")
        InitCommand()
        InitArguments()
        DebugInit()
        UIInit()
        ActionLogInit()
        CustomSettingsInit()
        Toolbox.Init()
        C.PLAYERGUID = UnitGUID("player")
        print("[|cFFFF0000" .. DisplayName .. "|r] " .. (Locale == "zh" and "加载" or "加载"))
        print("[|cFFFF0000" .. DisplayName .. "|r] " .. (Locale == "zh" and "解锁： " or "解锁器: ") .. Unlocker)
        print(
        "[|cFFFF0000" .. DisplayName .. "|r] " .. (Locale == "zh" and "文件版本： " or "SBR版本: ") .. RotationFileVersion
        )
        print(
        "[|cFFFF0000" ..
        DisplayName ..
        "|r] " ..
        (Locale == "zh" and "有关命令列表的类型： " or "相关命令列表请输入:") ..
        " |cFF0080FF/" .. CommandName .. " commands"
        )
    end
end
local Spec
Settings.UpdateInterval = GetTime() + 1
function Settings.Update()
    Spec = select(2, GetSpecializationInfo(GetSpecialization()))
    if not Settings.Initialized then
        Settings:TriggerInit()
    end
    if (GetTime() > Settings.UpdateInterval and SettingsNeedAnUpdate) or SettingsForceUpdate then
        WF(ProfilePath_All, json.encode(Settings.All))
        WF(ProfilePath_Spec, json.encode(Settings.Spec))
        Settings.UpdateInterval = GetTime() + 1
        SettingsForceUpdate = false
        SettingsNeedAnUpdate = false
    end
end
Settings:SetScript("OnUpdate", Settings.Update)
Settings_AllClass = {
    "Welcome Message",
    "聊天栏信息",
    "聊天栏信息_Checked",
    "聊天栏上层信息",
    "聊天栏上层信息_Checked",
    "AFK时暂停循环",
    "AFK时暂停循环_Checked",
    "TPS: Unit %| Rotation",
    "视线判断",
    "视线判断_Value1",
    "延迟容限",
    "Latency Tolerance_Value1",
    "Latency Tolerance_Value2",
    "目标优先级",
    "Target Priority_Value1",
    "宏命令",
    "宏命令_Value1",
    "Custom Blacklist Table",
    "Custom Interrupts Table",
    "UI_AnchorPoint",
    "UI_X",
    "UI_Y",
    "UI_Visible",
    "Running",
    "cds",
    "AOE",
    "ToolboxAnchorPoint",
    "ToolboxX",
    "ToolboxY",
    "ToolboxRows",
    "ToolboxVisible",
    "StatusVisible",
    "DebugFrameAnchorPoint",
    "DebugFrameX",
    "DebugFrameY",
    "调试窗口",
    "调试",
    "CL_AnchorPoint",
    "CL_X",
    "CL_Y",
    "Custom Frame",
    "自动切换配置",
    "自动切换配置_Checked",
    "自动切换配置_Value1",
    "AL_AnchorPoint",
    "AL_X",
    "AL_Y",
    "ActionLog",
    "Cooldowns On Bosses",
    "Cooldowns On Bosses_Checked",
    "LuaErrorReport",
    "LegionStats",
    "中文",
    "中文_Checked"
}
Settings_RequireUpdate = { "宏命令_Value1" }
function GetSetting(Name)
    if not Settings or not Settings.All then
        return false
    end
    for i = 1, #Settings_AllClass do
        if Name == Settings_AllClass[i] then
            return Settings.All[Name]
        end
    end
    return Settings.Spec[Name]
end
function SetSetting(Name, Value)
    local SettingsTable
    SettingsTable = Settings.Spec
    if not Settings or not Settings.Spec then
        return false
    end
    for i = 1, #Settings_AllClass do
        if Name == Settings_AllClass[i] then
            SettingsTable = Settings.All
            break
        end
    end
    for i = 1, #Settings_RequireUpdate do
        if Name == Settings_RequireUpdate[i] then
            SettingsForceUpdate = true
            break
        end
    end
    SettingsTable[Name] = Value
    SettingsNeedAnUpdate = true
    if Name == "中文_Checked" then
        Settings.ChineseTranslations()
    end
end
function Settings.ChineseTranslations()
    if GetSetting("中文_Checked") then
        WF(C.PROFILESPATH .. "Chinese.json", 1)
    else
        WF(C.PROFILESPATH .. "Chinese.json", 0)
    end
    if
    (not GetSetting("中文_Checked") and Locale == "zh") or
    (GetSetting("中文_Checked") and ValidChineseFont and Locale ~= "zh")
    then
        SettingsForceUpdate = true
        Settings.Update()
        _G["StaticPopupDialogs"]["LanguageReload"] = {
            text = (GetSetting("中文_Checked") and "您现在应该重新加载用户界面，以使这些更改生效。 单击接受以重新加载或取消以在以后手动重新加载。" or
            "你现在应该重新加载插件为更改而生效.点击接受重载插件或点击取消手动重载插件"),
            button1 = (GetSetting("中文_Checked") and "接受" or "接受"),
            button2 = (GetSetting("中文_Checked") and "取消" or "取消"),
            OnShow = function(self, data)
                self.editBox:SetText("")
            end,
            OnAccept = function(self, data, data2)
                RunMacroText("/console reloadui")
            end,
            hasEditBox = false,
            timeout = 0,
            whileDead = true,
            hideOnEscape = true,
            preferredIndex = 3
        }
        _G["StaticPopup_Show"]("LanguageReload")
    elseif GetSetting("中文_Checked") and not ValidChineseFont then
        SetSetting("中文_Checked", false)
        WF(C.PROFILESPATH .. "Chinese.json", 0)
        UpdateOptions()
        _G["StaticPopup_Show"]("LanguageWarning")
    end
end
function IsOptionEnabled(Name)
    return GetSetting(Name .. "_Checked")
end
function GetOptionValue(Name)
    return GetSetting(Name .. "_Value1")
end
function GetSecondOptionValue(Name)
    return GetSetting(Name .. "_Value2")
end
function SelectProfile(Name)
    ProfileName = Name
    ProfilePath_Spec = C.PROFILESPATH .. "" .. ProfileName .. ".json"
    Settings.Spec = json.decode(RF(ProfilePath_Spec) or "") or {}
    ProfileManager((Locale == "zh" and "加载简介：" or "加载配置: " .. "|cFFEEEB16") .. Name)
end
function GetProfile()
    return ProfileName
end
function InitSettings()
    local CurrentSpec = GetSpecialization()
    local CurrentSpecName = CurrentSpec and select(2, GetSpecializationInfo(CurrentSpec)) or C.CLASS
    ProfileKey = C.CLASS .. "" .. CurrentSpecName
    ProfileName = SavedProfile()
    if SwitcherDropDown ~= nil then
        SwitcherDropDown.TitleBarText:SetText(ProfileName)
    end
    ProfilePath_All = C.PROFILESPATH .. "All Class.json"
    ProfilePath_Spec = C.PROFILESPATH .. "" .. ProfileName .. ".json"
    Settings.All = json.decode(RF(ProfilePath_All) or "") or {}
    Settings.Spec = json.decode(RF(ProfilePath_Spec) or "") or {}
    if type(GetSetting("宏命令_Value1")) == "string" then
        local CurrentMacro = GetSetting("宏命令_Value1")
        local TextToWrite =         "你的宏命令是: " ..
        CurrentMacro ..
        ".\n要查看可用命令列表，您应该使用此宏:\n/" ..
        CurrentMacro ..
        " commands " ..
        "你可以通过更改主界面的“高级设置”面板中的宏命令选项来更改此关键字. 如果在使用时看不到命令 /" ..
        CurrentMacro .. "命令,这可能是因为您在UI的“高级”面板中禁用了“聊天栏信息”选项."
        WF(C.PROFILESPATH .. "Macro.txt", TextToWrite)
    end
end
ProfilesTable = {
    "默认",
    "做任务",
    "下副本",
    "史诗五人本",
    "打团本",
    "尼珊德拉",
    "伊格诺斯",
    "艾乐瑞瑟",
    "乌索克",
    "梦魇之龙",
    "塞纳留斯",
    "萨维斯",
    "奥丁",
    "高姆",
    "海拉",
    "斯考匹隆",
    "时空畸体",
    "崔利艾克斯",
    "奥鲁瑞尔",
    "艾塔乌斯",
    "特尔安",
    "克洛苏斯",
    "提克迪奥斯",
    "艾利桑德",
    "古尔丹",
    "格罗斯",
    "恶魔审判庭",
    "哈亚坦",
    "主母萨丝琳",
    "月之姐妹",
    "绝望的聚合体",
    "戒卫侍女",
    "堕落的化身",
    "基尔加丹",
    "战场",
    "阿什兰",
    "世界PVP"
}
local CurrentSavedProfileID
function SaveProfile(ID)
    CurrentSavedProfileID = ID
    local CurrentSpec = GetSpecialization()
    local CurrentSpecName = CurrentSpec and select(2, GetSpecializationInfo(CurrentSpec)) or C.CLASS
    ProfileKey = C.CLASS .. "" .. CurrentSpecName
    WF(C.PROFILESPATH .. "Profile.json", tostring(ID))
end
function SavedProfile()
    local CurrentSpec = GetSpecialization()
    local CurrentSpecName = CurrentSpec and select(2, GetSpecializationInfo(CurrentSpec)) or C.CLASS
    local ProfileKey = C.CLASS .. "" .. CurrentSpecName
    CurrentSavedProfileID = RF(C.PROFILESPATH .. "Profile.json")
    if CurrentSavedProfileID == nil or CurrentSavedProfileID == "" then
        SaveProfile(1)
    else
        CurrentSavedProfileID = tonumber(RF(C.PROFILESPATH .. "Profile.json"))
    end
    local CurrentSavedProfile = ProfilesTable[tonumber(CurrentSavedProfileID)]
    return CurrentSavedProfile
end
function LoadProfile(ID, AllowSaving)
    if AllowSaving then
        SaveProfile(ID)
    end
    if SwitcherDropDown.TitleBarText:GetText() ~= ProfilesTable[ID] then
        SwitcherDropDown.TitleBarText:SetText(ProfilesTable[ID])
    end
    if SwitcherDropDown ~= nil and SelectedProfile ~= ProfilesTable[ID] then
        SelectedProfile = ProfilesTable[ID]
        local ProfileGenerated = false
        if not RF(C.PROFILESPATH .. "" .. SelectedProfile .. ".json") then
            if ID > 4 and ID < #ProfilesTable - 2 then
                if RF(C.PROFILESPATH .. " - Raiding.json") ~= nil then
                    Settings.Spec = json.decode(RF(C.PROFILESPATH .. " - Raiding.json"))
                    WF(C.PROFILESPATH .. "" .. SelectedProfile .. ".json", json.encode(Settings.Spec))
                    ProfileManager(SelectedProfile .. " profile does not exist. Generating profile.")
                    ProfileGenerated = true
                elseif RF(C.PROFILESPATH .. " - Default.json") ~= nil then
                    Settings.Spec = json.decode(RF(C.PROFILESPATH .. " - Default.json"))
                    WF(C.PROFILESPATH .. "" .. SelectedProfile .. ".json", json.encode(Settings.Spec))
                    ProfileManager(SelectedProfile .. " profile does not exist. Generating profile.")
                    ProfileGenerated = true
                end
            elseif ID >= #ProfilesTable - 2 then
                if RF(C.PROFILESPATH .. " - Battlegrounds.json") ~= nil then
                    Settings.Spec = json.decode(RF(C.PROFILESPATH .. " - Battlegrounds.json"))
                    ProfileGenerated = true
                elseif RF(C.PROFILESPATH .. " - Arena.json") ~= nil then
                    Settings.Spec = json.decode(RF(C.PROFILESPATH .. " - Arena.json"))
                    ProfileGenerated = true
                elseif RF(C.PROFILESPATH .. " - World PVP.json") ~= nil then
                    Settings.Spec = json.decode(RF(C.PROFILESPATH .. " - World PVP.json"))
                    ProfileGenerated = true
                elseif RF(C.PROFILESPATH .. " - Raiding.json") ~= nil then
                    Settings.Spec = json.decode(RF(C.PROFILESPATH .. " - Raiding.json"))
                    ProfileGenerated = true
                elseif RF(C.PROFILESPATH .. " - Default.json") ~= nil then
                    Settings.Spec = json.decode(RF(C.PROFILESPATH .. " - Default.json"))
                    ProfileGenerated = true
                end
                WF(C.PROFILESPATH .. "" .. SelectedProfile .. ".json", json.encode(Settings.Spec))
                ProfileManager(SelectedProfile .. " profile does not exist. Generating profile.")
            elseif RF(C.PROFILESPATH .. " - Default.json") ~= nil then
                Settings.Spec = json.decode(RF(C.PROFILESPATH .. " - Default.json"))
                WF(C.PROFILESPATH .. "" .. SelectedProfile .. ".json", json.encode(Settings.Spec))
                ProfileManager(SelectedProfile .. " profile does not exist. Generating profile.")
                ProfileGenerated = true
            end
        end
        SelectProfile(SelectedProfile)
        ClearOptions()
        GetActiveRotation():Initialize()
        CreateUI()
        UpdateOptions()
    end
end
function DisableProfilesSwitcher()
    SetSetting("自动切换配置_Checked", false)
    AutoProfilesChanging = false
end
function EnableProfilesSwitcher()
    AutoProfilesChanging = true
end
AutoProfilesChanging = true
function AutoProfilesChanger()
    if AutoProfilesChanging or IsOptionEnabled("自动切换配置") then
        if IsOptionEnabled("自动切换配置") then
            if SwitcherDropDownBackGround.Color ~= "Red" then
                SwitcherDropDownBackGround.Color = "Red"
                SwitcherDropDownBackGround:SetBackdropColor(ColorsTable.Red.R, ColorsTable.Red.G, ColorsTable.Red.B, 1)
            end
            if EncounterID == 1853 and GetOptionValue("自动切换配置") == "按图切换" then
                LoadProfile(6)
            elseif EncounterID == 1873 and GetOptionValue("自动切换配置") == "按图切换" then
                LoadProfile(7)
            elseif EncounterID == 1876 and GetOptionValue("自动切换配置") == "按图切换" then
                LoadProfile(8)
            elseif EncounterID == 1841 and GetOptionValue("自动切换配置") == "按图切换" then
                LoadProfile(9)
            elseif EncounterID == 1854 and GetOptionValue("自动切换配置") == "按图切换" then
                LoadProfile(10)
            elseif EncounterID == 1877 and GetOptionValue("自动切换配置") == "按图切换" then
                LoadProfile(11)
            elseif EncounterID == 1864 and GetOptionValue("自动切换配置") == "按图切换" then
                LoadProfile(12)
            elseif EncounterID == 1958 and GetOptionValue("自动切换配置") == "按图切换" then
                LoadProfile(13)
            elseif EncounterID == 1962 and GetOptionValue("自动切换配置") == "按图切换" then
                LoadProfile(14)
            elseif EncounterID == 2008 and GetOptionValue("自动切换配置") == "按图切换" then
                LoadProfile(15)
            elseif EncounterID == 1849 and GetOptionValue("自动切换配置") == "按图切换" then
                LoadProfile(16)
            elseif EncounterID == 1865 and GetOptionValue("自动切换配置") == "按图切换" then
                LoadProfile(17)
            elseif EncounterID == 1867 and GetOptionValue("自动切换配置") == "按图切换" then
                LoadProfile(18)
            elseif EncounterID == 1871 and GetOptionValue("自动切换配置") == "按图切换" then
                LoadProfile(19)
            elseif EncounterID == 1863 and GetOptionValue("自动切换配置") == "按图切换" then
                LoadProfile(20)
            elseif EncounterID == 1886 and GetOptionValue("自动切换配置") == "按图切换" then
                LoadProfile(21)
            elseif EncounterID == 1842 and GetOptionValue("自动切换配置") == "按图切换" then
                LoadProfile(22)
            elseif EncounterID == 1862 and GetOptionValue("自动切换配置") == "按图切换" then
                LoadProfile(23)
            elseif EncounterID == 1872 and GetOptionValue("自动切换配置") == "按图切换" then
                LoadProfile(24)
            elseif EncounterID == 1866 and GetOptionValue("自动切换配置") == "按图切换" then
                LoadProfile(25)
            elseif EncounterID == 2032 and GetOptionValue("自动切换配置") == "按图切换" then
                LoadProfile(26)
            elseif EncounterID == 2048 and GetOptionValue("自动切换配置") == "按图切换" then
                LoadProfile(27)
            elseif EncounterID == 2036 and GetOptionValue("自动切换配置") == "按图切换" then
                LoadProfile(28)
            elseif EncounterID == 2037 and GetOptionValue("自动切换配置") == "按图切换" then
                LoadProfile(29)
            elseif EncounterID == 2050 and GetOptionValue("自动切换配置") == "按图切换" then
                LoadProfile(30)
            elseif EncounterID == 2054 and GetOptionValue("自动切换配置") == "按图切换" then
                LoadProfile(31)
            elseif EncounterID == 2052 and GetOptionValue("自动切换配置") == "按图切换" then
                LoadProfile(32)
            elseif EncounterID == 2038 and GetOptionValue("自动切换配置") == "按图切换" then
                LoadProfile(33)
            elseif EncounterID == 2051 and GetOptionValue("自动切换配置") == "按图切换" then
                LoadProfile(34)
            elseif select(2, IsInInstance()) == "pvp" then
                LoadProfile(#ProfilesTable - 2)
            elseif select(2, IsInInstance()) == "arena" then
                LoadProfile(#ProfilesTable - 1)
            elseif (Target:Exists() and Target:IsPlayer() and Player:CanAttack(Target)) or Target:CreatureID() == 114840 then
                LoadProfile(#ProfilesTable)
            elseif select(2, IsInInstance()) == "raid" then
                LoadProfile(5)
            elseif select(2, IsInInstance()) == "party" then
                LoadProfile(3)
            else
                LoadProfile(2)
            end
        else
            LoadProfile(CurrentSavedProfileID)
            if SwitcherDropDownBackGround.Color ~= "Gray" then
                SwitcherDropDownBackGround.Color = "Gray"
                SwitcherDropDownBackGround:SetBackdropColor(
                ColorsTable.LightGray.R,
                ColorsTable.LightGray.G,
                ColorsTable.LightGray.B,
                1
                )
            end
        end
    else
        SelectedProfile = "自定义"
        if SwitcherDropDownBackGround.Color ~= "Gray" then
            SwitcherDropDownBackGround.Color = "Gray"
            SwitcherDropDownBackGround:SetBackdropColor(
            ColorsTable.LightGray.R,
            ColorsTable.LightGray.G,
            ColorsTable.LightGray.B,
            1
            )
        end
        if SwitcherDropDown.TitleBarText:GetText() ~= ProfileName then
            SwitcherDropDown.TitleBarText:SetText(ProfileName)
        end
    end
end
function Authorized()
    local UserAuthorized = false
    if UnitLevel("Player") < 10 then
        UserAuthorized = true
    end
    if string.find(AResponse, "all") ~= nil then
        UserAuthorized = true
    end
    local SpecID = GetSpecialization()
    if not UserAuthorized then
        local SpecInfo = select(1, GetSpecializationInfo(SpecID))
        if SpecID and SpecInfo and string.find(AResponse, SpecInfo) ~= nil then
            UserAuthorized = true
        end
    end
    local SpecName = select(2, GetSpecializationInfo(SpecID))
    if UserAuthorized then
        if UnitLevel("player") < 10 then
            Toolbox.TitleBarText:SetText(
            Toolbox.ClassColor .. select(1, UnitClass("player")) .. (Locale == "zh" and " |cff00FF00拥有的" or "")
            )
        else
            if SpecID == nil or SpecName == nil then
                Toolbox.TitleBarText:SetText(
                Toolbox.ClassColor ..
                select(1, UnitClass("player")) .. (Locale == "zh" and " |cffFF0000没有规格" or " |cffFF0000No Spec")
                )
                TbCmd(true)
            else
                Toolbox.TitleBarText:SetText(
                Toolbox.ClassColor .. SpecName .. (Locale == "zh" and " |cff00FF00拥有的" or "")
                )
            end
        end
    else
        Toolbox.TitleBarText:SetText(
        Toolbox.ClassColor .. SpecName .. (Locale == "zh" and " |cffFF0000不拥有" or " |cffFF0000Not Owned")
        )
        TbCmd(true)
    end
    return UserAuthorized
end
PetBattlesAuthorized = string.find(AResponse, "all") ~= nil or string.find(AResponse, "PetBattles") ~= nil or false
if PetBattlesAuthorized then
    PetBattles = CreateFrame("Frame")
    PetBattles:Show()
    PetBattles.ActivePet = {}
    PetBattles.Pet = {}
    PetBattles.Journal = {}
    PetBattles.Abilities = {}
    PetBattles[1] = {}
    PetBattles[2] = {}
    PetBattles[1].Active = {}
    PetBattles[2].Active = {}
    C_PetJournal = _G["C_PetJournal"]
    C_PetBattles = _G["C_PetBattles"]
    CanInterract = DisplayName == "Soapbox 2.0 - OSX" and false or true
    PetBattles.DoNotEngage = {
        [68558] = true,
        [68559] = true,
        [68560] = true,
        [68561] = true,
        [68562] = true,
        [68563] = true,
        [68564] = true,
        [68566] = true,
        [68565] = true
    }
    function PetBattles.FetchPets()
        local PetsTable = {}
        local ThisUnit
        local X, Y, Z = OP("player")
        for Index = 1, GUNPC(X, Y, Z, GetOptionValue("自动抓野生宠物")) do
            ThisUnit = Unit(GUNPBI(Index))
            if
            ThisUnit:Exists() and _G["UnitIsWildBattlePet"](ThisUnit.UnitID) and
            not PetBattles.DoNotEngage[ThisUnit:CreatureID()]
            then
                table.insert(PetsTable, ThisUnit)
            end
        end
        return PetsTable
    end
    function PetBattles.EngageClosestPet()
        local PetsTable = PetBattles.FetchPets()
        local ClosestPet = nil
        for i = 1, #PetsTable do
            local ThisPet = PetsTable[i]
            local ThisPetDistance = Player:DistanceTo(ThisPet)
            if ThisPetDistance < GetOptionValue("自动抓野生宠物") then
                if ClosestPet == nil or ClosestPetDistance > ThisPetDistance then
                    ClosestPet = ThisPet
                    ClosestPetDistance = ThisPetDistance
                end
            end
        end
        if ClosestPet ~= nil then
            _G["InteractUnit"](ClosestPet.UnitID)
        end
    end
    PetBattles.Abilities = {
        [97] = { Type = "stun", Name = "Stun Shot" },
        [110] = { Type = "attack", Name = "Bite", Prio = 2 },
        [111] = { Type = "attack", Name = "Punch", Prio = 2 },
        [112] = { Type = "attack", Name = "Peck", Prio = 2 },
        [113] = { Type = "attack", Name = "Burn", Prio = 2 },
        [114] = { Type = "attack", Name = "Beam", Prio = 2 },
        [115] = { Type = "attack", Name = "Breath", Prio = 2 },
        [116] = { Type = "attack", Name = "Zap", Prio = 2 },
        [117] = { Type = "attack", Name = "Infected Claw", Prio = 2 },
        [118] = { Type = "attack", Name = "水流喷射", Prio = 2 },
        [119] = { Type = "attack", Name = "Scratch", Prio = 2 },
        [120] = { Type = "highdmg", Name = "凛风冲击" },
        [121] = { Type = "leech", Name = "Death Coil" },
        [122] = { Type = "attack", Name = "Tail Sweep", Prio = 2 },
        [123] = { Type = "heal", Name = "治疗波" },
        [124] = { Type = "3turnhighdmg", Name = "Rampage" },
        [151] = { Type = "debuff", Name = "Poisoned" },
        [152] = { Type = "debuff", Name = "Poison Fang", Debuff = 379 },
        [153] = { Type = "dmgdebuff", Name = "Attack Reduction" },
        [154] = { Type = "speedreduced", Name = "Speed Reduction" },
        [155] = { Type = "speeddebuff", Name = "Hiss" },
        [156] = { Type = "attack", Name = "Vicious Fang", Prio = 1 },
        [157] = { Type = "debuff", Name = "Jacob's" },
        [158] = { Type = "highdmg", Name = "Counterstrike" },
        [159] = { Type = "2turn", Name = "Burrow" },
        [160] = { Type = "leech", Name = "Consume" },
        [161] = { Type = "speedbuff", Name = "Adrenaline" },
        [162] = { Type = "speedbuff", Name = "冲动" },
        [163] = { Type = "3turn", Name = "群兽奔腾" },
        [164] = { Type = "dmgdebuff", Name = "Crouch" },
        [165] = { Type = "shield", Name = "Crouch" },
        [166] = { Type = "teamdebuff", Name = "Nut Barrage", Prio = 3 },
        [167] = { Type = "teamdebuff", Name = "Nut Barrage", Prio = 3 },
        [168] = { Type = "heal", Name = "Healing Flame" },
        [169] = { Type = "attack", Name = "Deep Breath", Prio = 1 },
        [170] = { Type = "highdmg", Name = "Lift-Off" },
        [171] = { Type = "teamdebuff", Name = "Scorched Earth" },
        [172] = { Type = "highdmg", Name = "Scorched Earth" },
        [173] = { Type = "heal", Name = "Cautherize" },
        [174] = { Type = "stun", Name = "Stunned" },
        [175] = { Type = "debuff", Name = "Volcano" },
        [176] = { Type = "debuff", Name = "Volcano" },
        [177] = { Type = "debuff", Name = "Immolate" },
        [178] = { Type = "debuff", Name = "Immolate" },
        [179] = { Type = "debuff", Name = "Conflagrate" },
        [184] = { Type = "quick", Name = "Quills", Prio = 2 },
        [185] = { Type = "dmgdebuff", Name = "Reckless Strike" },
        [186] = { Type = "highdmg", Name = "Reckless Strike" },
        [187] = { Type = "dmgbuff", Name = "Accuracy" },
        [188] = { Type = "dmgbuff", Name = "Accuracy" },
        [189] = { Type = "teamdebuff", Name = "Cyclone" },
        [190] = { Type = "teamdebuff", Name = "Cyclone" },
        [193] = { Type = "attack", Name = "Flank", Prio = 2 },
        [194] = { Type = "speedbuff", Name = "Metabolic Boost" },
        [195] = { Type = "speedbuff", Name = "Metabolic Boost" },
        [196] = { Type = "dmgbuff", Name = "Adrenal Glands" },
        [197] = { Type = "dmgbuff", Name = "Adrenal Glands" },
        [198] = { Type = "3turn", Name = "Zergling Rush" },
        [202] = { Type = "quick", Name = "Trash", Prio = 2 },
        [203] = { Type = "wheater", Name = "Lightning Storm", Desc = "Add lightning damage to all pets attacks" },
        [204] = { Type = "highdmg", Name = "Call Lightning" },
        [205] = { Type = "wheater", Name = "暴风雪", Desc = "All pets are chilled" },
        [206] = { Type = "debuff", Name = "Call Blizzard" },
        [207] = { Type = "dmgbuff", Name = "Supercharged" },
        [208] = { Type = "dmgbuff", Name = "Supercharge" },
        [209] = { Type = "highdmg", Name = "Ion Cannon" },
        [210] = { Type = "attack", Name = "Shadow Slash", Prio = 2 },
        [211] = { Type = "debuff", Name = "Siphon Life" },
        [212] = { Type = "debuff", Name = "Siphon Life" },
        [213] = { Type = "teamdebuff", Name = "Death and Decay" },
        [214] = { Type = "teamdebuff", Name = "Death and Decay" },
        [215] = { Type = "dmgbuff", Name = "Inner Vision" },
        [216] = { Type = "dmgbuff", Name = "Inner Vision" },
        [217] = { Type = "3turnhighdmg", Name = "Curse of Doom" },
        [218] = { Type = "3turnhighdmg", Name = "Curse of Doom" },
        [219] = { Type = "attack", Name = "Jab", Prio = 2 },
        [220] = { Type = "healbuff", Name = "Jacob's" },
        [221] = { Type = "ifbuffed", Name = "Takedown(Stunned)", Debuffs = { 174, 927 } },
        [222] = { Type = "dmgbuff", Name = "Focus Chi" },
        [223] = { Type = "dmgbuff", Name = "Focus Chi" },
        [224] = { Type = "shield", Name = "Staggered Steps" },
        [225] = { Type = "shield", Name = "Staggered Steps" },
        [226] = { Type = "highdmg", Name = "Fury of 1,000 Fists" },
        [227] = { Type = "stun", Name = "幻灭踢" },
        [228] = { Type = "quick", Name = "Tongue Lash" },
        [229] = { Type = "weather", Name = "Cleansing Rain", Desc = "Reduced damage over time by 1 round" },
        [230] = { Type = "highdmg", Name = "Cleansing Waters" },
        [231] = { Type = "teamdebuff", Name = "Swarm of Flies" },
        [232] = { Type = "teamdebuff", Name = "Swarm of Flies" },
        [233] = { Type = "sleep", Name = "Frog Kiss", Prio = 1 },
        [234] = { Type = "healbuff", Name = "Jacob's 2" },
        [235] = { Type = "hastebuff", Name = "Jacob's 3" },
        [236] = { Type = "passive", Name = "Critter" },
        [237] = { Type = "passive", Name = "Beast" },
        [238] = { Type = "passive", Name = "Humanoid" },
        [239] = { Type = "passive", Name = "Flying" },
        [240] = { Type = "passive", Name = "Aquatic" },
        [241] = { Type = "passive", Name = "Elemental" },
        [242] = { Type = "passive", Name = "Undead" },
        [243] = { Type = "passive", Name = "Magic" },
        [244] = { Type = "passive", Name = "Mechanical" },
        [245] = { Type = "passive", Name = "Dragonkin" },
        [246] = { Type = "delayedheal", Name = "Hibernate" },
        [247] = { Type = "delayedheal", Name = "Hibernate" },
        [248] = { Type = "root", Name = "Rooted" },
        [249] = { Type = "rootattack", Debuff = 248, Name = "Rooted" },
        [250] = { Type = "ifbuffed", Name = "Spiderling Swarm(Webbed)", Debuffs = { 338 } },
        [251] = { Type = "dmgbuff", Name = "Uncanny Luck" },
        [252] = { Type = "dmgbuff", Name = "Uncanny Luck" },
        [253] = { Type = "comeback", Name = "Comeback" },
        [254] = { Type = "hotteam", Name = "宁静" },
        [255] = { Type = "hotteam", Name = "宁静" },
        [256] = { Type = "highdmg", Name = "Call Darkness" },
        [257] = { Type = "highdmg", Name = "Call Darkness" },
        [258] = { Type = "highdmg", Name = "星辰坠落" },
        [259] = { Type = "buff", Name = "隐形术" },
        [260] = { Type = "buff", Name = "Fading" },
        [261] = { Type = "buff", Name = "Invisible" },
        [262] = { Type = "dmgbuff", Name = "Crystal Overload" },
        [263] = { Type = "dmgbuff", Name = "Crystal Overload" },
        [264] = { Type = "debuff", Name = "Grounded" },
        [265] = { Type = "debuff", Name = "Boulder Toss" },
        [267] = { Type = "hotbuff", Name = "Phytosynthesis" },
        [268] = { Type = "hotbuff", Name = "Phytosynthesis" },
        [270] = { Type = "debuff", Debuff = 271, Name = "Glowing Toxin" },
        [271] = { Type = "debuff", Name = "Glowing Toxin" },
        [273] = { Type = "delayedheal", Name = "Wish" },
        [274] = { Type = "delayedheal", Name = "Wish" },
        [275] = { Type = "comeback", Name = "Nerfbat" },
        [276] = { Type = "attack", Name = "Swallow You Whole", Prio = 2 },
        [277] = { Type = "lifeswap", Name = "Life Exchange" },
        [278] = { Type = "delayedheal", Name = "Repair", Min = 40 },
        [279] = { Type = "dmgbuff", Name = "Heartbroken" },
        [280] = { Type = "dmgdebuff", Name = "Overload" },
        [281] = { Type = "dmgbuff", Name = "Hearthbreak" },
        [282] = { Type = "kamikaze", Name = "Explode" },
        [283] = { Type = "cantdie", Name = "Survival" },
        [284] = { Type = "cantdie", Name = "Survival" },
        [289] = { Type = "shield", Name = "Stockpile" },
        [290] = { Type = "shield", Name = "Stockpile" },
        [293] = { Type = "attack", Name = "Launch Rocket", Prio = 1 },
        [294] = { Type = "root", Name = "Charging Rocket" },
        [296] = { Type = "todeflect", Name = "Pumped Up" },
        [297] = { Type = "attack", Name = "Pump", Prio = 1 },
        [298] = { Type = "heal", Name = "Inspiring Song" },
        [299] = { Type = "aoe", Name = "魔爆术" },
        [300] = { Type = "todeflect", Name = "Locked" },
        [301] = { Type = "attack", Name = "Lock-On", Prio = 1 },
        [302] = { Type = "root", Name = "Planted" },
        [303] = { Type = "hotbuff", Name = "Plant" },
        [302] = { Type = "hotbuff", Name = "Planted" },
        [305] = { Type = "dmgdebuff", Name = "Exposed Wounds" },
        [307] = { Type = "quick", Name = "Kick", Prio = 3 },
        [310] = { Type = "shield", Name = "Shell Shield" },
        [311] = { Type = "immunity", Name = "Dodge" },
        [312] = { Type = "deflect", Name = "Dodge" },
        [314] = { Type = "dmgdebuff", Name = "Mangle" },
        [315] = { Type = "shield", Name = "Spiked Skin", Buff = 316 },
        [316] = { Type = "shield", Name = "Spiked Skin" },
        [317] = { Type = "buff", Name = "Thorns" },
        [318] = { Type = "buff", Name = "Thorns" },
        [319] = { Type = "aoe", Name = "Magma Wave" },
        [320] = { Type = "dmgdebuff", Name = "Unholy Ascension" },
        [321] = { Type = "kamikaze", Name = "Unholy Ascension" },
        [322] = { Type = "buff", Name = "Levitated" },
        [323] = { Type = "attack", Name = "Gravity", Prio = 1 },
        [324] = { Type = "debuff", Name = "Gravity" },
        [325] = { Type = "shield", Name = "Beaver Dam" },
        [326] = { Type = "shield", Name = "Beaver Dam" },
        [327] = { Type = "delayedheavy", Name = "Hatchlings" },
        [327] = { Type = "todeflect", Name = "Eggs" },
        [329] = { Type = "delayedheavy", Name = "Hatchlings" },
        [330] = { Type = "highdmg", Name = "Sons of the Flame" },
        [331] = { Type = "immunity", Name = "Submerged", Deflect = true },
        [332] = { Type = "debuff", Name = "Sons of the Flame" },
        [333] = { Type = "shield", Name = "Decoy" },
        [334] = { Type = "shield", Name = "Decoy" },
        [338] = { Type = "root", Name = "Webbed" },
        [339] = { Type = "rootattack", Name = "Sticky Web" },
        [340] = { Type = "immunity", Name = "Burrowed", Deflect = true },
        [341] = { Type = "immunity", Name = "Flying", Deflect = true },
        [345] = { Type = "highdmg", Name = "重殴" },
        [347] = { Type = "dmgbuff", Name = "Roar", Prio = 2 },
        [348] = { Type = "stun", Name = "Bash" },
        [349] = { Type = "attack", Name = "Smash", Prio = 2 },
        [350] = { Type = "stun", Name = "Clobber" },
        [351] = { Type = "teamdebuff", Name = "Banana Barrage" },
        [352] = { Type = "teamdebuff", Name = "Banana Barrage" },
        [353] = { Type = "todeflect", Name = "Barrel Ready" },
        [354] = { Type = "attack", Name = "Barrel Toss", Prio = 1 },
        [355] = { Type = "attack", Name = "Triple Snap", Prio = 2 },
        [356] = { Type = "attack", Name = "Snap", Prio = 2 },
        [357] = { Type = "speeddebuff", Name = "Screech - 25%" },
        [358] = { Type = "sleepdebuff", Name = "" },
        [359] = { Type = "debuff", Name = "Sting" },
        [360] = { Type = "quick", Name = "Flurry", Prio = 2 },
        [362] = { Type = "debuff", Debuff = 542, Name = "Howl" },
        [364] = { Type = "buff", Name = "Leap", Buff = 544 },
        [365] = { Type = "teambuff", Name = "Dazzling Dance" },
        [366] = { Type = "teambuff", Name = "Dazzling Dance" },
        [367] = { Type = "attack", Name = "Chomp", Prio = 2 },
        [368] = { Type = "debuffed", Name = "Acidic Goo" },
        [369] = { Type = "debuff", Name = "Acidic Goo", Debuff = 368 },
        [370] = { Type = "root", Name = "Sticky Goo" },
        [371] = { Type = "rootattack", Name = "Sticky Goo" },
        [375] = { Type = "dmgbuff", Name = "Trumpet Strike" },
        [376] = { Type = "highdmg", Name = "Headbutt" },
        [377] = { Type = "attack", Name = "Trample", Prio = 1 },
        [378] = { Type = "attack", Name = "Strike", Prio = 2 },
        [379] = { Type = "debuff", Name = "Poison Spit" },
        [380] = { Type = "debuff", Name = "Poison Spit" },
        [381] = { Type = "debuff", Name = "Brittle Webbing" },
        [382] = { Type = "debuff", Name = "Brittle Webbing" },
        [383] = { Type = "leech", Name = "Leech Life" },
        [384] = { Type = "attack", Name = "Metal Fist", Prio = 2 },
        [385] = { Type = "todeflect", Name = "XE-321 Boombot" },
        [386] = { Type = "delayedheavy", Name = "XE-321 Boombot" },
        [387] = { Type = "aoe", Name = "Tympanic Tantrum" },
        [389] = { Type = "speedbuff", Name = "Overtune" },
        [390] = { Type = "attack", Name = "Demolish", Prio = 2 },
        [391] = { Type = "shield", Name = "Extra Plating" },
        [392] = { Type = "shield", Name = "Extra Plating" },
        [393] = { Type = "attack", Name = "Shadowflame", Prio = 2 },
        [394] = { Type = "quick", Name = "Lash" },
        [395] = { Type = "teambuff", Name = "Soothing Mists" },
        [396] = { Type = "teambuff", Name = "Soothing Mists" },
        [397] = { Type = "debuff", Name = "Poison Lash" },
        [398] = { Type = "debuff", Name = "Poison Lash" },
        [399] = { Type = "todeflect", Name = "Entangling Roots" },
        [400] = { Type = "delayedheavy", Name = "Entangling Roots" },
        [401] = { Type = "todeflect", Name = "Stun Seed" },
        [402] = { Type = "delayedheavy", Name = "Stun Seed" },
        [403] = { Type = "weather", Name = "Sunny Day" },
        [404] = { Type = "aoe", Name = "Sunlight" },
        [405] = { Type = "comeback", Name = "Early Advantage" },
        [406] = { Type = "attack", Name = "Crush", Prio = 2 },
        [407] = { Type = "2turn", Name = "Meteor Strike" },
        [408] = { Type = "buff", Name = "Immolation" },
        [409] = { Type = "buff", Name = "Immolation" },
        [410] = { Type = "debuff", Name = "Woodchipper" },
        [411] = { Type = "debuff", Name = "Woodchipper", Prio = 1 },
        [412] = { Type = "quick", Name = "Gnaw" },
        [413] = { Type = "attack", Name = "Ice Lance", Prio = 1 },
        [414] = { Type = "highdmg", Name = "Frost Nova" },
        [415] = { Type = "speeddebuff", Name = "Frost Shock - 25%" },
        [416] = { Type = "speeddebuff", Name = "Frost Shock - 25%" },
        [417] = { Type = "todeflect", Name = "Geyser" },
        [418] = { Type = "delayedheavy", Name = "Geyser" },
        [419] = { Type = "aoe", Name = "Tidal Wave" },
        [420] = { Type = "attack", Name = "Slicing Wind", Prio = 2 },
        [421] = { Type = "attack", Name = "Arcane Blast", Prio = 2 },
        [422] = { Type = "attack", Name = "Shadow Shock", Prio = 2 },
        [423] = { Type = "ifbuffed", Name = "Blood in the Water if Bleeding.", Debuffs = { 491 } },
        [424] = { Type = "attack", Name = "Tail Slap", Prio = 2 },
        [425] = { Type = "focus", Name = "Focused", Buff = 426 },
        [426] = { Type = "focus", Name = "焦点" },
        [429] = { Type = "attack", Name = "Claw", Prio = 2 },
        [430] = { Type = "shield", Name = "Jadeskin" },
        [431] = { Type = "shield", Name = "Jadeskin" },
        [432] = { Type = "attack", Name = "Jade Claw", Prio = 2 },
        [433] = { Type = "attack", Name = "Jade Claw", Prio = 2 },
        [434] = { Type = "shield", Name = "Jade Barrier" },
        [435] = { Type = "shield", Name = "Stoneskin" },
        [436] = { Type = "shield", Name = "Stoneskin" },
        [437] = { Type = "attack", Name = "Onyx Bite", Prio = 1 },
        [438] = { Type = "deflect", Name = "Onyx Wall" },
        [439] = { Type = "deflect", Name = "Onyx Wall" },
        [440] = { Type = "deflect", Name = "Evanescence" },
        [441] = { Type = "quick", Name = "Rend" },
        [442] = { Type = "highdmg", Name = "Spectral Strike" },
        [443] = { Type = "deflect", Name = "棱光屏障" },
        [444] = { Type = "buff", Name = "棱光屏障" },
        [445] = { Type = "attack", Name = "Ooze Touch", Prio = 2 },
        [446] = { Type = "debuff", Name = "Corrosion" },
        [447] = { Type = "debuff", Name = "Corrosion" },
        [448] = { Type = "debuff", Debuff = 781, Name = "Creeping Ooze" },
        [449] = { Type = "leech", Name = "Absorb" },
        [450] = { Type = "highdmg", Name = "Expunge" },
        [451] = { Type = "highdmg", Name = "Split" },
        [452] = { Type = "attack", Name = "Broom", Prio = 2 },
        [453] = { Type = "highdmg", Name = "SandStorm", Prio = 1 },
        [454] = { Type = "shield", Name = "SandStorm" },
        [455] = { Type = "quick", Name = "Batter", Prio = 2 },
        [456] = { Type = "highdmg", Name = "Clean-Up" },
        [457] = { Type = "highdmg", Name = "Sweep" },
        [458] = { Type = "dmgbuff", Name = "Wind-Up" },
        [459] = { Type = "attack", Name = "Wind-Up", Prio = 1 },
        [460] = { Type = "highdmg", Name = "Illuminate" },
        [461] = { Type = "ifbuffed", Name = "Light(Blinded)", Debuffs = { 462, 954 } },
        [462] = { Type = "blind", Name = "Blinded" },
        [463] = { Type = "debuff", Name = "Flash" },
        [464] = { Type = "shield", Name = "Illusionary Barrier" },
        [465] = { Type = "shield", Name = "Illusionary Barrier" },
        [466] = { Type = "highdmg", Name = "Nether Gate" },
        [467] = { Type = "attack", Name = "Magical Clone", Prio = 1 },
        [468] = { Type = "debuff", Debuff = 469, Name = "Agony" },
        [469] = { Type = "debuff", Name = "Agony" },
        [470] = { Type = "dmgdebuff", Name = "Weakness" },
        [471] = { Type = "attack", Name = "Weakness", Prio = 1 },
        [472] = { Type = "attack", Name = "Blast of Hatred", Prio = 2 },
        [473] = { Type = "attack", Name = "Focused Beams", Prio = 2 },
        [474] = { Type = "quick", Name = "Interupting Gaze", Prio = 2 },
        [475] = { Type = "speeddebuff", Name = "Eyeblast" },
        [476] = { Type = "attack", Name = "Dark Simulacrum", Prio = 1 },
        [477] = { Type = "attack", Name = "Snowball", Prio = 2 },
        [478] = { Type = "attack", Name = "Magic Hat", Prio = 2 },
        [479] = { Type = "deflect", Name = "寒冰护体" },
        [480] = { Type = "immunity", Name = "寒冰护体" },
        [481] = { Type = "highdmg", Name = "Deep Freeze" },
        [482] = { Type = "attack", Name = "Laser", Prio = 2 },
        [483] = { Type = "attack", Name = "Psychic Blast", Prio = 2 },
        [484] = { Type = "attack", Name = "Feedback", Prio = 2 },
        [485] = { Type = "dmgbuff", Name = "Attack Boost", Prio = 2 },
        [486] = { Type = "dmgdebuff", Debuff = 153, Name = "Drain Power" },
        [487] = { Type = "dmgbuff", Name = "Amplify Magic", Prio = 2 },
        [488] = { Type = "dmgbuff", Name = "Amplify Magic" },
        [489] = { Type = "3turnhighdmg", Name = "Mana Surge" },
        [490] = { Type = "deflect", Name = "Deflection" },
        [491] = { Type = "debuff", Name = "Bleeding" },
        [492] = { Type = "attack", Name = "Rake", Prio = 2 },
        [493] = { Type = "highdmg", Name = "Hoof" },
        [494] = { Type = "dmgdebuff", Name = "Attack Reduction" },
        [496] = { Type = "sleep", Name = "Drowsy" },
        [497] = { Type = "debuff", Name = "Soothe" },
        [498] = { Type = "sleepdebuff", Name = "Asleep" },
        [499] = { Type = "attack", Name = "Diseased Bite", Prio = 2 },
        [500] = { Type = "debuff", Name = "Flame Breath" },
        [501] = { Type = "debuff", Name = "Flame Breath", Prio = 3 },
        [502] = { Type = "teamdebuff", Name = "Flamethrower" },
        [503] = { Type = "teamdebuff", Name = "Flamethrower" },
        [504] = { Type = "quick", Name = "Alpha Strike" },
        [505] = { Type = "immunity", Name = "Cocoon Strike" },
        [506] = { Type = "highdmg", Name = "Cocoon Strike" },
        [507] = { Type = "attack", Name = "Moth Balls", Prio = 1 },
        [508] = { Type = "highdmg", Name = "Mosth Dust" },
        [509] = { Type = "attack", Name = "Surge", Prio = 1 },
        [510] = { Type = "hotteam", Name = "Renewing Mists" },
        [511] = { Type = "hotteam", Name = "Renewing Mists", Buff = 510 },
        [512] = { Type = "todeflect", Name = "Whirlpool" },
        [513] = { Type = "delayedheavy", Name = "Whirlpool" },
        [514] = { Type = "attack", Name = "Wild Winds", Prio = 2 },
        [515] = { Type = "debuff", Name = "Flyby" },
        [516] = { Type = "debuff", Name = "Weakened Defenses" },
        [517] = { Type = "highdmg", Name = "Nocturnal Strike" },
        [518] = { Type = "highdmg", Name = "Predatory Strike" },
        [519] = { Type = "apocalypse", Name = "天启" },
        [520] = { Type = "dmgbuff", Name = "Hawk Eye" },
        [521] = { Type = "dmgbuff", Name = "Hawk Eye" },
        [522] = { Type = "dmgdebuff", Debuff = 738, Name = "Nevermore" },
        [524] = { Type = "debuff", Name = "Squawk" },
        [525] = { Type = "attack", Name = "Emerald Bite", Prio = 2 },
        [526] = { Type = "dmgdebuff", Name = "Stench" },
        [527] = { Type = "dmgdebuff", Name = "Stench" },
        [528] = { Type = "attack", Name = "Frost Spit", Prio = 2 },
        [529] = { Type = "attack", Name = "Belly Slide", Prio = 1 },
        [532] = { Type = "highdmg", Name = "Body Slam" },
        [533] = { Type = "delayedheal", Name = "Rebuild" },
        [535] = { Type = "quick", Name = "Pounce" },
        [536] = { Type = "dmgbuff", Name = "Prowl" },
        [537] = { Type = "dmgdebuff", Name = "Attack Reduction" },
        [538] = { Type = "execute", Name = "Devour" },
        [539] = { Type = "delayedheal", Name = "Bleat" },
        [540] = { Type = "todeflect", Name = "Chew" },
        [541] = { Type = "highdmg", Name = "Chew" },
        [542] = { Type = "dmgdebuff", Name = "Shattered Defenses" },
        [543] = { Type = "dmgbuff", Name = "Prowl" },
        [544] = { Type = "speedbuff", Name = "Speed Boost" },
        [546] = { Type = "root", Name = "Frost Nova" },
        [563] = { Type = "attack", Name = "Quick Attack", Prio = 1 },
        [564] = { Type = "2turn", Name = "Dive" },
        [565] = { Type = "todeflect", Name = "Underground" },
        [566] = { Type = "attack", Name = "Powerball", Prio = 1 },
        [567] = { Type = "buff", Name = "Rush", Buff = 544 },
        [568] = { Type = "cantdie", Name = "Feign Death" },
        [569] = { Type = "stun", Name = "Crystal Prison" },
        [570] = { Type = "attack", Name = "Broom Strike" },
        [571] = { Type = "quick", Name = "Horn Attack" },
        [572] = { Type = "highdmg", Name = "MudSlide" },
        [573] = { Type = "heal", Name = "Nature's Touch" },
        [574] = { Type = "hotbuff", Name = "Nature's Ward" },
        [575] = { Type = "teamdebuff", Name = "Slippery Ice" },
        [576] = { Type = "cantdie", Name = "Perk Up" },
        [577] = { Type = "buff", Name = "Healthy" },
        [578] = { Type = "delayedheal", Name = "Buried Treasure" },
        [579] = { Type = "buff", Name = "Gobble Strike", Buff = 735 },
        [580] = { Type = "sleep", Debuff = 498, Name = "Food Coma" },
        [581] = { Type = "3turn", Name = "Flock" },
        [583] = { Type = "dmgbuff", Name = "Intensity" },
        [584] = { Type = "attack", Name = "Winter Spirit" },
        [585] = { Type = "attack", Name = "Holiday Cheer" },
        [586] = { Type = "highdmg", Name = "Gift of Winter's Veil" },
        [588] = { Type = "highdmg", Name = "Devastate" },
        [589] = { Type = "dmgbuff", Name = "Arcane Storm" },
        [590] = { Type = "weather", Name = "Arcane Winds" },
        [591] = { Type = "dmgdebuff", Name = "Wild Magic" },
        [592] = { Type = "debuff", Name = "Wild Magic" },
        [593] = { Type = "highdmg", Name = "Surge of Power" },
        [594] = { Type = "attack", Name = "Sleeping Gas", Prio = 1 },
        [595] = { Type = "highdmg", Name = "月火术" },
        [596] = { Type = "buff", Name = "Moonlight" },
        [597] = { Type = "buff", Name = "Emerald Presence", Buff = 823 },
        [598] = { Type = "delayedheal", Name = "Emerald Dream" },
        [599] = { Type = "delayedheal", Name = "Emerald Dream" },
        [600] = { Type = "stun", Name = "Time Stop" },
        [601] = { Type = "highdmg", Name = "Time Bomb" },
        [602] = { Type = "highdmg", Name = "Time Bomb" },
        [603] = { Type = "teambuff", Name = "Temporal Lapse" },
        [604] = { Type = "teambuff", Name = "Extreme Power" },
        [605] = { Type = "todeflect", Name = "Elementium Bolt" },
        [606] = { Type = "delayedheavy", Name = "Elementium Bolt" },
        [607] = { Type = "highdmg", Name = "大灾变" },
        [608] = { Type = "attack", Name = "Nether Blast", Prio = 2 },
        [609] = { Type = "highdmg", Name = "Instability" },
        [610] = { Type = "buff", Name = "Ancient Blessing" },
        [611] = { Type = "heal", Name = "Ancient Blessing" },
        [612] = { Type = "highdmg", Name = "Proto-Strike" },
        [613] = { Type = "dmgbuff", Name = "Competitive Spirit" },
        [614] = { Type = "dmgbuff", Name = "Competitive Spirit" },
        [615] = { Type = "teambuff", Name = "Wrath of Tarecgosa" },
        [616] = { Type = "attack", Name = "Blinkstrike", Prio = 1 },
        [617] = { Type = "quick", Name = "Spark", Prio = 2 },
        [621] = { Type = "highdmg", Name = "Stone Rush" },
        [623] = { Type = "todeflect", Name = "Ice Tomb" },
        [624] = { Type = "delayedheavy", Name = "Ice Tomb" },
        [625] = { Type = "attack", Name = "Ice Spike" },
        [626] = { Type = "attack", Name = "Skitter", Prio = 2 },
        [627] = { Type = "teamdebuff", Name = "Rock Barrage" },
        [628] = { Type = "teamdebuff", Name = "Rock Barrage" },
        [630] = { Type = "debuff", Name = "Poisoned Branch", Prio = 2 },
        [631] = { Type = "debuff", Name = "Super Sticky Goo" },
        [632] = { Type = "debuff", Debuff = 633, Name = "Confusing Sting" },
        [633] = { Type = "debuff", Name = "Confusing Sting" },
        [634] = { Type = "teamdebuff", Name = "Minefield" },
        [635] = { Type = "teamdebuff", Name = "Minefield" },
        [636] = { Type = "delayedheavy", Name = "Sticky Grenade" },
        [637] = { Type = "todeflect", Name = "Sticky Grenade" },
        [639] = { Type = "teamdebuff", Name = "Toxic Smoke" },
        [640] = { Type = "teamdebuff", Name = "Toxic Smoke" },
        [641] = { Type = "teamdebuff", Name = "Egg Barrage" },
        [642] = { Type = "teamdebuff", Name = "Egg Barrage" },
        [644] = { Type = "teamdebuff", Name = "Quake" },
        [645] = { Type = "2turn", Name = "Launch" },
        [646] = { Type = "highdmg", Name = "Shock and Awe" },
        [647] = { Type = "3turn", Name = "Bombing Run" },
        [648] = { Type = "attack", Name = "Bone Bite", Prio = 2 },
        [649] = { Type = "aoe", Name = "BONESTORM" },
        [650] = { Type = "rootattack", Name = "Bone Prison" },
        [652] = { Type = "kamikaze", Name = "Haunt" },
        [653] = { Type = "debuff", Name = "Haunt" },
        [654] = { Type = "stun", Name = "Ghostly Bite" },
        [655] = { Type = "attack", Name = "Creepy Chomp", Prio = 1 },
        [657] = { Type = "debuff", Debuff = 658, Name = "Plagued Blood" },
        [658] = { Type = "debuff", Name = "Plagued Blood" },
        [660] = { Type = "debuff", Name = "Spreading Infection" },
        [661] = { Type = "debuff", Name = "Spreading Infection" },
        [662] = { Type = "debuff", Name = "Spreading Infection" },
        [663] = { Type = "kamikaze", Name = "Corpse Explosion" },
        [664] = { Type = "debuff", Name = "Corpse Explosion" },
        [665] = { Type = "consume", Name = "Consume Corpse" },
        [666] = { Type = "3turn", Name = "Rabid Bite" },
        [667] = { Type = "cleanse", Name = "Aged Yolk" },
        [668] = { Type = "3turn", Name = "Dreadful Breath" },
        [669] = { Type = "highdmg", Name = "Backflip" },
        [670] = { Type = "debuff", Name = "Snap Trap" },
        [671] = { Type = "debuff", Name = "Snap Trap" },
        [677] = { Type = "dmgdebuff", Name = "Wild Winds" },
        [682] = { Type = "15turn", Name = "天启" },
        [683] = { Type = "15turn", Name = "天启" },
        [706] = { Type = "3turn", Name = "Swarm" },
        [710] = { Type = "turret", Name = "Build Turret" },
        [711] = { Type = "teambuff", Name = "Turret" },
        [712] = { Type = "attack", Name = "Railgun", Prio = 2 },
        [713] = { Type = "quick", Name = "Blitz", Prio = 2 },
        [717] = { Type = "stunned", Name = "Banished" },
        [718] = { Type = "weather", Name = "Mudslide" },
        [720] = { Type = "teambuff", Name = "Clone" },
        [721] = { Type = "weather", Name = "Slippery Ice" },
        [723] = { Type = "passive", Name = "Mechanical" },
        [724] = { Type = "passive", Name = "Undead" },
        [726] = { Type = "passive", Name = "Humanoid" },
        [734] = { Type = "stunned", Name = "Crystal Prison" },
        [735] = { Type = "speedbuff", Name = "Speed Boost" },
        [737] = { Type = "todeflect", Name = "流星" },
        [738] = { Type = "highdmg", Name = "Nevermore" },
        [739] = { Type = "dmgbuff", Name = "Frenzyheart Brew" },
        [740] = { Type = "dmgbuff", Name = "Frenzyheart Brew" },
        [741] = { Type = "aoe", Name = "Whirlwind" },
        [742] = { Type = "teamdebuff", Name = "Creeping Fungus" },
        [743] = { Type = "debuff", Name = "Creeping Fungus" },
        [744] = { Type = "heal", Name = "Leech Seed" },
        [745] = { Type = "heal", Name = "Leech Seed" },
        [746] = { Type = "highdmg", Name = "Spore Shrooms" },
        [747] = { Type = "highdmg", Name = "Spore Shrooms" },
        [748] = { Type = "debuff", Name = "Spore Burst" },
        [750] = { Type = "shield", Name = "Soul Ward" },
        [751] = { Type = "shield", Name = "Soul Ward" },
        [752] = { Type = "highdmg", Name = "Soulrush" },
        [753] = { Type = "highdmg", Name = "Solar Beam" },
        [754] = { Type = "attack", Name = "Screeching Gears", Prio = 1 },
        [755] = { Type = "debuff", Name = "Acid Touch" },
        [756] = { Type = "debuff", Name = "Acid Touch" },
        [757] = { Type = "buff", Name = "Lucky Dance" },
        [758] = { Type = "teambuff", Name = "Mrrrgglllrggghl" },
        [759] = { Type = "immunity", Name = "Block" },
        [760] = { Type = "shield", Name = "Shield Block" },
        [761] = { Type = "highdmg", Name = "Heroic Leap" },
        [762] = { Type = "highdmg", Name = "Haymaker" },
        [763] = { Type = "cleanse", Name = "Sear Magic" },
        [764] = { Type = "deflect", Name = "Phase Shift" },
        [765] = { Type = "attack", Name = "Holy Sword", Prio = 1 },
        [766] = { Type = "stun", Name = "Holy Justice" },
        [767] = { Type = "highdmg", Name = "Holy Charge" },
        [768] = { Type = "aoe", Name = "Omnislash" },
        [769] = { Type = "highdmg", Name = "Surge of Light" },
        [770] = { Type = "heal", Name = "Restoration" },
        [771] = { Type = "attack", Name = "Bow Shot", Prio = 2 },
        [772] = { Type = "stun", Name = "LoveStruck" },
        [773] = { Type = "highdmg", Name = "Shot Through The Heart" },
        [774] = { Type = "aoe", Name = "Rapid Fire" },
        [775] = { Type = "attack", Name = "Perfumed Arrow", Prio = 1 },
        [776] = { Type = "heal", Name = "Love Potion" },
        [777] = { Type = "highdmg", Name = "Missile" },
        [778] = { Type = "attack", Name = "Charge", Prio = 1 },
        [779] = { Type = "highdmg", Name = "Thunderbolt" },
        [780] = { Type = "stun", Name = "Death Grip" },
        [781] = { Type = "debuff", Name = "Creeping Ooze" },
        [782] = { Type = "attack", Name = "Frost Breath", Prio = 2 },
        [784] = { Type = "dmgdebuff", Debuff = 494, Name = "Shriek" },
        [785] = { Type = "teamdebuff", Name = "Blistering Cold" },
        [786] = { Type = "teamdebuff", Name = "Blistering Cold" },
        [787] = { Type = "debuff", Name = "Frostbite" },
        [788] = { Type = "highdmg", Name = "Gauss Rifle" },
        [789] = { Type = "quick", Name = "U-238 Rounds", Prio = 2 },
        [790] = { Type = "dmgbuff", Name = "Stimpack" },
        [791] = { Type = "dmgbuff", Name = "Stimpack" },
        [792] = { Type = "highdmg", Name = "Darkflame" },
        [793] = { Type = "healdebuff", Name = "Healing Reduction" },
        [794] = { Type = "cantdie", Name = "Dark Rebirth" },
        [795] = { Type = "cantdie", Name = "Dark Rebirth" },
        [798] = { Type = "buff", Name = "Dark Simulacrum" },
        [799] = { Type = "teambuff", Name = "Mrrrgglllrggghl" },
        [800] = { Type = "attack", Name = "Impale", Prio = 2 },
        [801] = { Type = "attack", Name = "Stone Shot", Prio = 2 },
        [802] = { Type = "execute", Name = "Ravage" },
        [803] = { Type = "debuff", Name = "割裂" },
        [804] = { Type = "immunity", Name = "Feign Death" },
        [807] = { Type = "dmgdebuff", Name = "Rabies" },
        [809] = { Type = "dmgbuff", Name = "Roll" },
        [810] = { Type = "teamdebuff", Name = "Magma Trap" },
        [811] = { Type = "teamdebuff", Name = "Magma Trap" },
        [812] = { Type = "highdmg", Name = "Sulfuras Smash" },
        [813] = { Type = "highdmg", Name = "Wrath of Tarecgosa" },
        [814] = { Type = "highdmg", Name = "Rupture" },
        [819] = { Type = "todeflect", Name = "Bomb" },
        [820] = { Type = "hotbuff", Name = "Nature's Ward" },
        [822] = { Type = "sleepdebuff", Name = "Frog Kiss" },
        [823] = { Type = "shielded", Name = "Emerald Presence" },
        [826] = { Type = "attack", Name = "Weakening Blow", Prio = 2 },
        [827] = { Type = "immunity", Name = "Sons of the Root" },
        [828] = { Type = "highdmg", Name = "Sons of the Root" },
        [829] = { Type = "immunity", Name = "Submerge", Deflect = true },
        [830] = { Type = "immunity", Name = "Underwater", Deflect = true },
        [831] = { Type = "speedbuff", Name = "Speed Boost" },
        [835] = { Type = "cleanse", Name = "Eggnog" },
        [836] = { Type = "kamikaze", Name = "Baneling Burst" },
        [838] = { Type = "speedbuff", Name = "Centrifugal Hooks" },
        [839] = { Type = "immunity", Name = "Leaping", Deflect = true },
        [841] = { Type = "dmgbuff", Name = "Adrenal Glands" },
        [848] = { Type = "root", Name = "Frost Nova" },
        [849] = { Type = "attack", Name = "Huge, Sharp Teeth!", Prio = 1 },
        [850] = { Type = "speedbuff", Name = "Vicious Streak" },
        [851] = { Type = "buff", Name = "Vicious Streak", Buff = 544 },
        [852] = { Type = "immunity", Name = "Flying(Launch)" },
        [860] = { Type = "teamdebuff", Name = "Flamethrower" },
        [869] = { Type = "dmgdebuff", Debuff = 153, Name = "Darkmoon Curse" },
        [870] = { Type = "3turn", Name = "Murder" },
        [900] = { Type = "debuff", Name = "Fel Immolate" },
        [901] = { Type = "debuff", Name = "Fel Immolate" },
        [904] = { Type = "immunity", Name = "Deflection" },
        [905] = { Type = "buff", Name = "Cute Face" },
        [906] = { Type = "buff", Name = "闪电之盾" },
        [907] = { Type = "buff", Name = "闪电之盾" },
        [908] = { Type = "highdmg", Name = "Jolt" },
        [909] = { Type = "debuff", Name = "Paralyzing Shock" },
        [910] = { Type = "attack", Name = "Sand Bolt", Prio = 2 },
        [911] = { Type = "speeddebuff", Name = "QuickSand" },
        [912] = { Type = "highdmg", Name = "QuickSand" },
        [913] = { Type = "highdmg", Name = "Spectral Spine" },
        [914] = { Type = "buff", Name = "Spirit Spikes" },
        [915] = { Type = "buff", Name = "Spirit Spikes" },
        [916] = { Type = "highdmg", Name = "Haywire" },
        [917] = { Type = "3turnhighdmg", Name = "Bloodfang" },
        [918] = { Type = "dmgdebuff", Name = "Black Claw" },
        [919] = { Type = "dmgdebuff", Name = "Black Claw" },
        [920] = { Type = "teamdebuff", Name = "Primal Cry" },
        [921] = { Type = "attack", Name = "Hunting Party", Prio = 1 },
        [922] = { Type = "delayedheal", Name = "Healing Stream" },
        [923] = { Type = "aoe", Name = "Flux" },
        [924] = { Type = "passive", Name = "Critter" },
        [926] = { Type = "sleepdebuff", Name = "Soothe" },
        [927] = { Type = "sleepdebuff", Name = "Stunned" },
        [928] = { Type = "speeddebuff", Name = "Slither" },
        [929] = { Type = "speeddebuff", Name = "Slither" },
        [930] = { Type = "attack", Name = "Huge Fang", Prio = 1 },
        [931] = { Type = "dmgdebuff", Name = "Croak" },
        [932] = { Type = "dmgdebuff", Name = "Croak" },
        [933] = { Type = "immunity", Name = "Bubble" },
        [934] = { Type = "deflect", Name = "Bubble" },
        [935] = { Type = "dmgbuff", Name = "Caw" },
        [936] = { Type = "dmgbuff", Name = "Caw" },
        [937] = { Type = "leech", Name = "Siphon Anima" },
        [938] = { Type = "quick", Name = "Interrupting Jolt" },
        [939] = { Type = "debuff", Name = "Touch of the Animus" },
        [940] = { Type = "debuff", Debuff = 939, Name = "Touch of the Animus" },
        [941] = { Type = "cleanse", Name = "High Fiber" },
        [942] = { Type = "highdmg", Name = "Frying Pan" },
        [943] = { Type = "attack", Name = "Chop", Prio = 1 },
        [944] = { Type = "buff", Name = "Heat Up" },
        [945] = { Type = "buff", Name = "Heat Up" },
        [954] = { Type = "blind", Name = "Blinded" },
        [955] = { Type = "blind", Name = "Blinded" },
        [956] = { Type = "elite", Name = "Elite" },
        [957] = { Type = "buff", Name = "Evolution", Buff = 485 },
        [958] = { Type = "attack", Name = "Trihorn Charge", Prio = 1 },
        [959] = { Type = "shield", Name = "Trihorn Shield" },
        [960] = { Type = "shield", Name = "Trihorn Shield" },
        [961] = { Type = "shield", Name = "铁木树皮" },
        [962] = { Type = "shield", Name = "铁木树皮" },
        [963] = { Type = "debuff", Name = "Autumn Breeze" },
        [964] = { Type = "debuff", Name = "Autumn Breeze" },
        [983] = { Type = "quick", Name = "SMCKTHAT.EXE" },
        [985] = { Type = "teamdebuff", Name = "Make it Rain", Buff = 986 },
        [986] = { Type = "teamdebuff", Name = "Make it Rain" },
        [989] = { Type = "heal", Name = "Bligntron Gift Package" },
        [996] = { Type = "stunned", Name = "Lullaby" },
        [997] = { Type = "vengeance", Name = "Vengeance" },
        [998] = { Type = "deflect", Name = "Ethereal" },
        [999] = { Type = "immunity", Name = "Ethereal" },
        [1000] = { Type = "highdmg", Name = "Call of Celestials" },
        [1001] = { Type = "highdmg", Name = "Call of Celestials" },
        [1002] = { Type = "3turn", Name = "Inflation" },
        [1003] = { Type = "highdmg", Name = "Gold Rush" },
        [1004] = { Type = "attack", Name = "Gilded Fist", Prio = 1 },
        [1005] = { Type = "shield", Name = "Goldskin" },
        [1006] = { Type = "shield", Name = "Goldskin" },
        [1007] = { Type = "2turn", Name = "Locust Swarm" },
        [1008] = { Type = "highdmg", Name = "Brew Bolt" },
        [1009] = { Type = "dmgdebuff", Name = "Inebriate" },
        [1010] = { Type = "dmgdebuff", Name = "Inebriate" },
        [1011] = { Type = "todeflect", Name = "Locust Swarm" },
        [1012] = { Type = "dmgbuff", Name = "Giant's Blood" },
        [1013] = { Type = "highdmg", Name = "Call of Winter" },
        [1014] = { Type = "blind", Name = "Blinded" },
        [1015] = { Type = "blind", Name = "Blinding Powder" },
        [1016] = { Type = "leech", Name = "Feed" },
        [1019] = { Type = "2turn", Name = "Niuzao's Charge" },
        [1020] = { Type = "blind", Name = "Lens Flare" },
        [1021] = { Type = "attack", Name = "Phaser" },
        [1022] = { Type = "attack", Name = "Plot Twist" },
        [1023] = { Type = "delayedheal", Name = "Rebooting" },
        [1024] = { Type = "delayedheal", Name = "Rebooting" },
        [1025] = { Type = "kamikaze", Name = "Armageddon" },
        [1026] = { Type = "stun", Name = "Amber Prison" },
        [1027] = { Type = "quick", Name = "Fire Quills" },
        [1028] = { Type = "dmgbuff", Name = "Dominance" },
        [1029] = { Type = "dmgbuff", Name = "Dominance" },
        [1030] = { Type = "stunned", Name = "Stunned" },
        [1031] = { Type = "attack", Name = "Jadefire Lightning" },
        [1032] = { Type = "teambuff", Name = "Celestial Blessing" },
        [1033] = { Type = "teambuff", Name = "Sanctified Ground" },
        [1034] = { Type = "dmgreduced", Name = "Celestial Blessing" },
        [1035] = { Type = "aoe", Name = "Spitfire Beam" },
        [1036] = { Type = "forcehigh", Name = "Frill Blast" },
        [1039] = { Type = "teambuff", Name = "Nimbus" },
        [1040] = { Type = "teambuff", Name = "Nimbus" },
        [1041] = { Type = "teamdebuff", Name = "Flame Jet" },
        [1042] = { Type = "teamdebuff", Name = "Flame Jet" },
        [1043] = { Type = "heal", Name = "Drain Blood" },
        [1044] = { Type = "shield", Name = "树皮术" },
        [1045] = { Type = "shield", Name = "树皮术" },
        [1046] = { Type = "dmgreduced", Name = "Frolicking" },
        [1047] = { Type = "dmgreduced", Name = "Frolicking" },
        [1048] = { Type = "blind", Name = "Blinding Poison" },
        [1049] = { Type = "blind", Name = "Blinding Poison" },
        [1050] = { Type = "ifbuffed", Name = "Puncture Wound", Debuffs = { 1049, 1050 } },
        [1051] = { Type = "highdmg", Name = "Acid Rain" },
        [1052] = { Type = "highdmg", Name = "Tornado Punch" },
        [1053] = { Type = "dmgbuff", Name = "Bonkers!" },
        [1054] = { Type = "dmgbuff", Name = "Going Bonkers!" },
        [1055] = { Type = "highdmg", Name = "Breath of Sorrow" },
        [1056] = { Type = "attack", Name = "Seethe" },
        [1057] = { Type = "teambuff", Name = "Birth Evil" },
        [1058] = { Type = "teambuff", Name = "Globule" },
        [1059] = { Type = "healdebuff", Name = "Healing Reduction" },
        [1060] = { Type = "attack", Name = "Steam Vent" },
        [1061] = { Type = "dmgbuff", Name = "Rain Dance" },
        [1062] = { Type = "dmgbuff", Name = "Rain Dance" },
        [1063] = { Type = "teamdebuff", Name = "Pheromones" },
        [1064] = { Type = "teamdebuff", Name = "Pheromones" },
        [1065] = { Type = "consume", Name = "Digest Brains" },
        [1066] = { Type = "attack", Name = "Spiritfire Bolt" },
        [1067] = { Type = "dmgdebuff", Name = "Forboding Curse" },
        [1068] = { Type = "dmgdebuff", Name = "Forboding Curse" },
        [1069] = { Type = "root", Name = "Skunky Brew" },
        [1070] = { Type = "root", Name = "Skunky Brew" },
        [1071] = { Type = "todeflect", Name = "Explosive Brew" },
        [1072] = { Type = "delayedheavy", Name = "Explosive Brew" },
        [1073] = { Type = "shield", Name = "Spiny Carapace" },
        [1074] = { Type = "shield", Name = "Spiny Carapace" },
        [1075] = { Type = "shield", Name = "Spiny Carapace" },
        [1076] = { Type = "highdmg", Name = "Greench's Gift" },
        [1077] = { Type = "quick", Name = "Spin Kick" },
        [1078] = { Type = "hotbuff", Name = "Bandage" },
        [1079] = { Type = "attack", Name = "Club" },
        [1080] = { Type = "teamdebuff", Name = "Booby-Trapped Presents" },
        [1081] = { Type = "teamdebuff", Name = "Booby-Trapped Presents" },
        [1082] = { Type = "attack", Name = "Jade Breath" },
        [1083] = { Type = "immunity", Name = "渐隐术" },
        [1084] = { Type = "deflect", Name = "渐隐术" },
        [1085] = { Type = "attack", Name = "Magic Sword" },
        [1086] = { Type = "debuff", Name = "Toxic Skin" },
        [1087] = { Type = "debuff", Name = "Toxic Skin" },
        [1088] = { Type = "attack", Name = "Nairn!" },
        [1089] = { Type = "elite", Name = "Boss" },
        [1091] = { Type = "teamdebuff", Name = "Bone Barrage" },
        [1092] = { Type = "teamdebuff", Name = "Bone Barrage" },
        [1093] = { Type = "3turn", Name = "Dead Man's Party" },
        [1094] = { Type = "attack", Name = "Macabre Maraca" },
        [1095] = { Type = "attack", Name = "Horn Gore" },
        [1099] = { Type = "attack", Name = "Punish" },
        [1100] = { Type = "attack", Name = "祝福之锤" },
        [1101] = { Type = "teambuff", Name = "Shieldstorm" },
        [1103] = { Type = "highdmg", Name = "Righteous Inspiration" },
        [1104] = { Type = "dmgreduced", Name = "Reflective Shield" },
        [1105] = { Type = "dmgreduced", Name = "Reflective Shield" },
        [1106] = { Type = "dmgreduced", Name = "Reflective Shield" },
        [1107] = { Type = "highdmg", Name = "Falling Murloc" },
        [1108] = { Type = "dmgdebuff", Name = "Bark" },
        [1109] = { Type = "teambuff", Name = "The Good Stuff" },
        [1110] = { Type = "aoe", Name = "Avalanche" },
        [1111] = { Type = "dmgreduced", Name = "Tough n' Cuddly" },
        [1112] = { Type = "dmgreduced", Name = "Tough n' Cuddly" },
        [1116] = { Type = "highdmg", Name = "Call the Pack" },
        [1119] = { Type = "dmgbuff", Name = "Righteous Inspiration" },
        [1120] = { Type = "dmgdebuff", Name = "Attack Reduction" },
        [1121] = { Type = "3turn", Name = "Coin Toss" },
        [1122] = { Type = "debuff", Name = "Greedy" },
        [1123] = { Type = "cleanse", Name = "Disruption" },
        [1124] = { Type = "immunity", Name = "Portal" },
        [1125] = { Type = "deflect", Name = "Portal" },
        [1128] = { Type = "dmgbuff", Name = "Critical Bonus" },
        [1223] = { Type = "attack", Name = "Slice" },
        [1231] = { Type = "cleanse", Name = "Consume Magic" },
        [1232] = { Type = "dmgbuff", Name = "Anzu's Blessing" },
        [1233] = { Type = "attack", Name = "Dark Talon" },
        [1238] = { Type = "attack", Name = "Shadow Talon" },
        [1273] = { Type = "aoe", Name = "顺劈斩" },
        [1287] = { Type = "aoe", Name = "Carpnado" },
        [1301] = { Type = "leech", Name = "Pig Out" },
        [1302] = { Type = "dmgbuff", Name = "Critical Bonus" },
        [1303] = { Type = "dmgbuff", Name = "Critical Bonus" },
        [1304] = { Type = "dmgbuff", Name = "Critical Bonus" },
        [1305] = { Type = "dmgbuff", Name = "Critical Bonus" },
        [1334] = { Type = "attack", Name = "Plushie Rush" },
        [1335] = { Type = "attack", Name = "Rawr!" },
        [1336] = { Type = "attack", Name = "Who's The Best Elekk In The Whole World?" },
        [1337] = { Type = "heal", Name = "Itchin' for a Stitchin'" },
        [1338] = { Type = "kamikaze", Name = "Cute As A Button" },
        [1343] = { Type = "highdmg", Name = "Fist of the Forest" },
        [1344] = { Type = "immunity", Name = "Refuge" },
        [1345] = { Type = "heal", Name = "Nap Time" },
        [1346] = { Type = "shield", Name = "Cute As A Button" },
        [1347] = { Type = "shield", Name = "Cute As A Button" },
        [1348] = { Type = "sleepdebuff", Name = "Asleep" },
        [1353] = { Type = "quick", Name = "Arcane Slash" },
        [1354] = { Type = "highdmg", Name = "Puppies of the Flame" },
        [1355] = { Type = "immunity", Name = "Puppies of the Flame" },
        [1356] = { Type = "forcehigh", Name = "Inferno Herding" },
        [1357] = { Type = "highdmg", Name = "Superbark" },
        [1358] = { Type = "immunity", Name = "Unattackable" },
        [1359] = { Type = "dmgdebuff", Name = "Bark" },
        [1360] = { Type = "2turn", Name = "Bull Charge" },
        [1369] = { Type = "debuff", Name = "Barbed Stinger" },
        [1370] = { Type = "attack", Name = "Savage Talon" },
        [1371] = { Type = "ifbuffed", Name = "Sneak Attack", Debuffs = { 1049, 1050 } },
        [1372] = { Type = "attack", Name = "Deep Bite" },
        [1377] = { Type = "teambuff", Name = "Hearty Meal" },
        [1378] = { Type = "highdmg", Name = "Righteous Inspiration" },
        [1379] = { Type = "shield", Name = "Shell Armor" },
        [1380] = { Type = "shield", Name = "Shell Armor" },
        [1381] = { Type = "2turn", Name = "Death Bleat" },
        [1382] = { Type = "leech", Name = "Unnatural Appetite" },
        [1387] = { Type = "teambuff", Name = "Birds of a Feather" },
        [1388] = { Type = "teambuff", Name = "Birds of a Feather" },
        [1389] = { Type = "teambuff", Name = "Roboflauge" },
        [1390] = { Type = "shield", Name = "Iron Thread" },
        [1391] = { Type = "dmgbuff", Name = "Enraged" },
        [1392] = { Type = "dmgbuff", Name = "Enraged" },
        [1397] = { Type = "healteam", Name = "Haunting Song" },
        [1398] = { Type = "dmgbuff", Name = "Feathered Frenzy" },
        [1399] = { Type = "dmgbuff", Name = "Feathered Frenzy" },
        [1400] = { Type = "highdmg", Name = "Udder Destruction" },
        [1401] = { Type = "deflect", Name = "Where's the Beef?" },
        [1402] = { Type = "healteam", Name = "Mother's Milk" },
        [1407] = { Type = "attack", Name = "Deep Burn" },
        [1408] = { Type = "delayedheal", Name = "Reforge" },
        [1409] = { Type = "delayedheal", Name = "Reforging" },
        [1410] = { Type = "heal", Name = "Gift of the Naaru" },
        [1411] = { Type = "aoe", Name = "Grave Destruction" },
        [1412] = { Type = "highdmg", Name = "When Elekks Fly" },
        [1417] = { Type = "buff", Name = "Elemental Mark" },
        [1418] = { Type = "buff", Name = "Rot" },
        [1419] = { Type = "buff", Name = "Critter Mark" },
        [1420] = { Type = "buff", Name = "Flying Mark" },
        [1438] = { Type = "highdmg", Name = "Mighty Charge" },
        [1443] = { Type = "smgbuff", Name = "Call the Pack" },
        [1465] = { Type = "attack", Name = "Gargoyle Strike" },
        [1466] = { Type = "delayedheal", Name = "Stone Form" },
        [1483] = { Type = "attack", Name = "Skull Toss" },
        [1516] = { Type = "dmgbuff", Name = "Fel Corruption" },
        [1517] = { Type = "dmgbuff", Name = "Fel Corruption" },
        [1518] = { Type = "attack", Name = "Claw" },
        [1531] = { Type = "aoe", Name = "Psionic Shockwave" },
        [1532] = { Type = "highdmg", Name = "Psionic Storm" },
        [1533] = { Type = "3turn", Name = "眼棱" },
        [1534] = { Type = "dmgbuff", Name = "Murkmorphosis" },
        [1535] = { Type = "dmgbuff", Name = "Murkmorphosis" },
        [1536] = { Type = "highdmg", Name = "Arcane Dash" }
    }
    function PetBattles.UI()
        AddPage("宠物对战")
        AddSection("宠物对战", { "离开战斗", "脱离战斗" }, "Yellow")
        AddNewOption(
        "宠物对战",
        { "自动宠物对战", "宠物战" },
        210,
        false,
        nil,
        nil,
        { "Enable Pet Battles (In and Out of Battle)", "启动宠物战斗（进出战斗）" }
        )
        if CanInterract then
            AddNewOption(
            "宠物对战",
            { "自动抓野生宠物", "参与野生宠物" },
            220,
            false,
            { 20, 1, 40, 1 },
            nil,
            {
                "Automatically engage battle against Wild Pets in a 20 yards radius around the player",
                "自动与野生宠物战斗，围绕玩家二十码半径"
            }
            )
        end
        AddNewOption(
        "宠物对战",
        { "复活战斗宠物", "复活战宠物" },
        220,
        false,
        { 70, 0, 100, 5 },
        nil,
        {
            "Use Revive Battle Pets when one of your pets health is under this threshold if the spell is not available, pets under threshold will be changed for ones with more health.",
            "当您的宠物健康状况不到这个阈值时，使用复活战斗宠物，如果不能使用咒语，那么具有更高健康状况的宠物将被更改。"
        }
        )
        AddNewOption(
        "宠物对战",
        { "更换练级宠物的品质设定", "改变和级别宠物" },
        220,
        false,
        { 4, 1, 4, 1 },
        nil,
        {
            "Change pets in your journal while out of battle to level these, define leveling pet quality threshold (1-Poor/2-Common/3-Uncommon/4-Rare).",
            "改变宠物在你的杂志，而不在战斗，以平衡这些，定义调整宠物质量阈值（1差/ 2普通/ 3罕见/ 4稀有）。"
        }
        )
        AddNewOption(
        "宠物对战",
        { "优先练野生宠物", "野生宠物" },
        210,
        false,
        nil,
        nil,
        { "Enable to level all pets, Disable to level only pets that can be caged.", "启用对所有宠物进行调整，禁用只能对可笼养的宠物进行分级。" }
        )
        AddNewOption(
        "宠物对战",
        { "优先练高级的宠物", "最高级宠物" },
        210,
        false,
        nil,
        nil,
        {
            "Enable this to level highest level pets first, Disable to level lowest level pets first.",
            "启用此功能以首先对最高级别的宠物进行分级，首先禁用最低级别的宠物。"
        }
        )
        AddNewOption(
        "宠物对战",
        { "最小等级", "最低等级" },
        120,
        false,
        { 6, 1, 24, 1 },
        nil,
        { "Minimum level to bring a pet to slot 1 to level it.", "将宠物带到插槽1的最小级别使其平整。" }
        )
        AddNewOption(
        "宠物对战",
        { "最高等级", "最高等级" },
        120,
        false,
        { 24, 1, 24, 1 },
        nil,
        { "Maximum level to bring a pet to slot 1 to level it.", "将宠物带到插槽1的最大级别使其平整。" }
        )
        AddNewOption(
        "宠物对战",
        { "精英队伍", "硕士团队" },
        220,
        false,
        { 4, 1, 4, 1 },
        nil,
        {
            "Change pets in your journal while out of battle, use Favorite pets first, will use Min and Max from the two options above, set quality threshold (1-Poor/2-Common/3-Uncommon/4-Rare).",
            "改变宠物在你的日记中，而不在战斗，首先使用收藏的宠物，将使用上述两个选项的最小和最大，设置质量阈值（1差/ 2普通/ 3罕见/ 4稀有）。"
        }
        )
        AddSection("宠物对战", { "战斗状态", "在战斗中" }, "Yellow")
        AddNewOption(
        "宠物对战",
        { "捕捉宠物", "捕捉宠物" },
        220,
        false,
        { 4, 1, 4, 1 },
        nil,
        { "Capture Pets (1-Poor/2-Common/3-Uncommon/4-Rare).", "捕捉宠物（1差/ 2普通/ 3罕见/ 4稀有）。" }
        )
        AddNewOption(
        "宠物对战",
        { "收集数量", "收取金额" },
        220,
        false,
        { 3, 1, 3, 1 },
        nil,
        { "Number of pets to keep of each species.", "每个物种的宠物数量。" }
        )
        AddNewOption(
        "宠物对战",
        { "根据HP切换宠物", "互换健康" },
        220,
        false,
        { 25, 0, 100, 5 },
        nil,
        {
            "Change pet when active pet health falls under threshold, will not swap out for non-wild battles.",
            "当宠物的健康状况低于阈值时，可以改变宠物，不会换出非野生动物。"
        }
        )
        AddNewOption(
        "宠物对战",
        { "练一号位置宠物", "水平宠物1" },
        210,
        false,
        nil,
        nil,
        { "Change pet when active pet health falls under threshold.", "当宠物的健康状况低于阈值时，更改宠物。" }
        )
        AddNewOption(
        "宠物对战",
        { "立即治疗", "直接治疗" },
        220,
        false,
        { 40, 0, 100, 5 },
        nil,
        { "Cast Heal when active pet health falls under threshold.", "当宠物健康状况低于阈值时，进行治疗。" }
        )
        AddNewOption(
        "宠物对战",
        { "延迟治疗", "延迟治疗" },
        220,
        false,
        { 70, 0, 100, 5 },
        nil,
        { "Cast Delayed Heal when active pet health falls under threshold.", "宠物健康状况低于阈值时，延迟愈合。" }
        )
        AddNewOption(
        "宠物对战",
        { "持续治疗", "随着时间的过去愈合" },
        220,
        false,
        { 85, 0, 100, 5 },
        nil,
        { "Cast Heal Over Time when active pet health falls under threshold.", "随着时间的推移，当宠物的健康状况下降到阈值以下时，可以愈合" }
        )
    end
    function PetBattles.Rotation()
        if IsOptionEnabled ~= nil and IsOptionEnabled("自动宠物对战") then
            if PetBattles.InBattle() == "pve" and TurnReady then
                PetBattles.Consumed = PetBattles.Consumed or 0
                PetBattles.RefreshActivePet(1)
                PetBattles.RefreshPets(1)
                PetBattles.RefreshActivePet(2)
                PetBattles.RefreshPets(2)
                IsWildBattle = C_PetBattles.IsInBattle() and C_PetBattles.IsWildBattle()
                PetBattles.CapturePet()
                if IsWildBattle and PetBattles.ShouldCapture then
                    if PetBattles[2].Active.Percent > 35 then
                        PetBattles.Pass()
                        PetBattles.Swapper(true)
                        PetBattles.Healing()
                        PetBattles.HealingDelayed()
                        PetBattles.HealTeamOverTime()
                        PetBattles.HealOverTime()
                        PetBattles.Leech()
                        PetBattles.Quick()
                        PetBattles.Attack()
                    end
                else
                    PetBattles.Pass()
                    if
                    IsWildBattle and not PetBattles.IsRooted() and IsOptionEnabled("练一号位置宠物") and
                    PetBattles[1].Active.Slot == 1 and
                    PetBattles[1].Active.Level <= GetOptionValue("最高等级") and
                    PetBattles[2].Active.Percent == 100 and
                    PetBattles[1].Pet[2].Percent > 0 and
                    PetBattles[1].Pet[3].Percent > 0
                    then
                        PetBattles.Leech()
                        PetBattles.Quick()
                        PetBattles.Attack()
                        PetBattles.Filler()
                    elseif C_PetBattles.IsInBattle() and not C_PetBattles.IsWildBattle() then
                        if PetBattles.CantDie() then
                            PetBattles.Swapper(false)
                            PetBattles.CastBuff("shield")
                            PetBattles.Turrets()
                            PetBattles.Healing()
                            PetBattles.HealingDelayed()
                            PetBattles.HealTeamOverTime()
                            PetBattles.HealOverTime()
                            PetBattles.CastBuff("buff")
                            PetBattles.CastBuff("focus")
                            PetBattles.DamageBuff()
                            PetBattles.Leech()
                            PetBattles.ThreeTurnHeavy()
                            PetBattles.DelayedHeavy()
                            PetBattles.TwoTurns()
                            PetBattles.TeamDebuff()
                            PetBattles.Quick("normal")
                            PetBattles.AoEPunch("normal")
                            PetBattles.Attack()
                            PetBattles.ThreeTurnSoft()
                            PetBattles.Quick("filler")
                            PetBattles.AoEPunch("filler")
                            PetBattles.Filler()
                        end
                        PetBattles.Swapper(false)
                        PetBattles.LifeSwap()
                        PetBattles.Kamikaze()
                        PetBattles.Deflect()
                        PetBattles.Apocalypse()
                        PetBattles.CastBuff("shield")
                        PetBattles.Turrets()
                        PetBattles.Consume()
                        PetBattles.Healing()
                        PetBattles.HealingDelayed()
                        PetBattles.HealTeam()
                        PetBattles.HealTeamOverTime()
                        PetBattles.HealOverTime()
                        PetBattles.CastBuff("buff")
                        PetBattles.CastBuff("focus")
                        PetBattles.IfBuffed()
                        PetBattles.DmgDebuff()
                        PetBattles.CastBuff("focus")
                        PetBattles.DamageBuff()
                        PetBattles.Sleep()
                        PetBattles.HeavyAttack()
                        PetBattles.Leech()
                        PetBattles.ThreeTurnHeavy()
                        PetBattles.DelayedHeavy()
                        PetBattles.TwoTurns()
                        PetBattles.TeamDebuff()
                        PetBattles.Debuff()
                        PetBattles.SpeedDebuff()
                        PetBattles.Quick("normal")
                        PetBattles.AoEPunch("normal")
                        PetBattles.Attack()
                        PetBattles.ThreeTurnSoft()
                        PetBattles.Quick("filler")
                        PetBattles.AoEPunch("filler")
                        PetBattles.Roots()
                        PetBattles.Filler()
                    else
                        if PetBattles.CantDie() then
                            PetBattles.Swapper(true)
                            PetBattles.CastBuff("shield")
                            PetBattles.Turrets()
                            PetBattles.Healing()
                            PetBattles.HealingDelayed()
                            PetBattles.HealTeamOverTime()
                            PetBattles.HealOverTime()
                            PetBattles.CastBuff("buff")
                            PetBattles.CastBuff("focus")
                            PetBattles.DamageBuff()
                            PetBattles.Leech()
                            PetBattles.ThreeTurnHeavy()
                            PetBattles.DelayedHeavy()
                            PetBattles.TwoTurns()
                            PetBattles.TeamDebuff()
                            PetBattles.Quick("normal")
                            PetBattles.AoEPunch("normal")
                            PetBattles.Attack()
                            PetBattles.ThreeTurnSoft()
                            PetBattles.Quick("filler")
                            PetBattles.AoEPunch("filler")
                            PetBattles.Filler()
                        end
                        PetBattles.Swapper(true)
                        PetBattles.LifeSwap()
                        PetBattles.Kamikaze()
                        PetBattles.Deflect()
                        PetBattles.Apocalypse()
                        PetBattles.CastBuff("shield")
                        PetBattles.Turrets()
                        PetBattles.Consume()
                        PetBattles.Healing()
                        PetBattles.HealingDelayed()
                        PetBattles.HealTeam()
                        PetBattles.HealTeamOverTime()
                        PetBattles.HealOverTime()
                        PetBattles.CastBuff("buff")
                        PetBattles.CastBuff("focus")
                        PetBattles.IfBuffed()
                        PetBattles.DmgDebuff()
                        PetBattles.CastBuff("focus")
                        PetBattles.DamageBuff()
                        PetBattles.Sleep()
                        PetBattles.HeavyAttack()
                        PetBattles.Leech()
                        PetBattles.ThreeTurnHeavy()
                        PetBattles.DelayedHeavy()
                        PetBattles.TwoTurns()
                        PetBattles.TeamDebuff()
                        PetBattles.Debuff()
                        PetBattles.SpeedDebuff()
                        PetBattles.Quick("normal")
                        PetBattles.AoEPunch("normal")
                        PetBattles.Attack()
                        PetBattles.ThreeTurnSoft()
                        PetBattles.Quick("filler")
                        PetBattles.AoEPunch("filler")
                        PetBattles.Roots()
                        PetBattles.Filler()
                    end
                end
            end
            if PetBattles.InBattle() == "no" then
                PetBattles.Consumed = 0
                if not PetBattles.HealPets() then
                    PetBattles.PetSwapper()
                end
                if IsOptionEnabled("自动抓野生宠物") and CanInterract then
                    if ThrottleEngage == nil or ThrottleEngage < GetTime() then
                        ThrottleEngage = GetTime() + 1.5
                        PetBattles.EngageClosestPet()
                    end
                end
            end
        end
    end
    function PetBattles.CapturePet()
        if
        select(11, C_PetJournal.GetPetInfoBySpeciesID(C_PetBattles.GetPetSpeciesID(2, PetBattles[2].Active.Slot))) ==
        true and
        IsOptionEnabled("捕捉宠物") and
        C_PetBattles.GetBreedQuality(2, PetBattles[2].Active.Slot) >= GetOptionValue("捕捉宠物") and
        C_PetJournal.GetNumCollectedInfo(C_PetBattles.GetPetSpeciesID(2, PetBattles[2].Active.Slot)) <
        GetOptionValue("收集数量")
        then
            if PetBattles[2].Active.Percent < 35 and C_PetBattles.IsTrapAvailable() then
                C_PetBattles.UseTrap()
                PetBattles.Status("Trapping Pet")
                TurnReady = false
                return
            end
        end
    end
    PetBattles.RarityColorsTable = {
        { Type = "Poor", Color = "999999" },
        { Type = "常规", Color = "FFFFFF" },
        { Type = "Uncommon", Color = "33FF33" },
        { Type = "Rare", Color = "00AAFF" }
    }
    PetBattles.TypeWeaknessTable = {
        { Num = 1, Type = "Humanoid", Weak = 8, Strong = 2, Resist = 5, Color = "00AAFF" },
        { Num = 2, Type = "Dragonkin", Weak = 4, Strong = 6, Resist = 3, Color = "33FF33" },
        { Num = 3, Type = "Flying", Weak = 2, Strong = 9, Resist = 8, Color = "FFFF66" },
        { Num = 4, Type = "Undead", Weak = 9, Strong = 1, Resist = 2, Color = "663366" },
        { Num = 5, Type = "Critter", Weak = 1, Strong = 4, Resist = 7, Color = "AA7744" },
        { Num = 6, Type = "Magic", Weak = 10, Strong = 3, Resist = 9, Color = "CC44DD" },
        { Num = 7, Type = "Elemental", Weak = 5, Strong = 10, Resist = 10, Color = "FF9933" },
        { Num = 8, Type = "Beast", Weak = 3, Strong = 5, Resist = 1, Color = "DD2200" },
        { Num = 9, Type = "Aquatic", Weak = 6, Strong = 7, Resist = 4, Color = "33CCFF" },
        { Num = 10, Type = "Mechanical", Weak = 7, Strong = 8, Resist = 6, Color = "999999" }
    }
    function PetBattles.InBattle()
        if C_PetBattles.IsInBattle() then
            return "pve"
        elseif C_PetBattles.IsWildBattle() then
            return "wild"
        elseif C_PetBattles.IsInBattle() and C_PetBattles.GetTurnTimeInfo() ~= nil then
            return "pvp"
        else
            return "no"
        end
    end
    function PetBattles.NumberOfAbilities()
        local level = C_PetBattles.GetLevel(1, C_PetBattles.GetActivePet(1))
        if level >= 4 then
            return 3
        elseif level >= 2 then
            return 2
        else
            return 1
        end
    end
    function PetBattles.RefreshActivePet(thisOwner)
        local active = C_PetBattles.GetActivePet(thisOwner)
        PetBattles[thisOwner].Active = {
            Abilities = {
                [0] = PetBattles.NumberOfAbilities(),
                [1] = {
                    ID = C_PetBattles.GetAbilityInfo(thisOwner, active, 1),
                    Name = select(2, C_PetBattles.GetAbilityInfo(thisOwner, active, 1)),
                    Ready = C_PetBattles.GetAbilityState(thisOwner, active, 1)
                },
                [2] = {
                    ID = C_PetBattles.GetAbilityInfo(thisOwner, active, 2),
                    Name = select(2, C_PetBattles.GetAbilityInfo(thisOwner, active, 2)),
                    Ready = C_PetBattles.GetAbilityState(thisOwner, active, 2)
                },
                [3] = {
                    ID = C_PetBattles.GetAbilityInfo(thisOwner, active, 3),
                    Name = select(2, C_PetBattles.GetAbilityInfo(thisOwner, active, 3)),
                    Ready = C_PetBattles.GetAbilityState(thisOwner, active, 3)
                }
            },
            AllAuras = {},
            Auras = C_PetBattles.GetNumAuras(thisOwner, active),
            CanSwap = C_PetBattles.CanActivePetSwapOut(),
            Health = C_PetBattles.GetHealth(thisOwner, active),
            Level = C_PetBattles.GetLevel(thisOwner, active),
            MaxHealth = C_PetBattles.GetMaxHealth(thisOwner, active),
            Percent = math.floor(
            C_PetBattles.GetHealth(thisOwner, active) / C_PetBattles.GetMaxHealth(thisOwner, active) * 100
            ),
            Quality = C_PetBattles.GetBreedQuality(thisOwner, active),
            Slot = active,
            Speed = C_PetBattles.GetSpeed(thisOwner, active),
            Type = C_PetBattles.GetPetType(thisOwner, active)
        }
        for i = 1, PetBattles[thisOwner].Active.Auras do
            PetBattles[thisOwner].Active.AllAuras[i] =             C_PetBattles.GetAuraInfo(thisOwner, PetBattles[thisOwner].Active.Slot, i)
        end
        PetBattles[thisOwner].TeamAuras = C_PetBattles.GetNumAuras(thisOwner, 0)
        PetBattles[thisOwner].AllTeamAuras = {}
        for i = 1, PetBattles[thisOwner].TeamAuras do
            PetBattles[thisOwner].AllTeamAuras[i] = C_PetBattles.GetAuraInfo(thisOwner, 0, i)
        end
        for i = 1, PetBattles[thisOwner].Active.Auras do
            PetBattles[thisOwner].Active.AllAuras[i] =             C_PetBattles.GetAuraInfo(thisOwner, PetBattles[thisOwner].Active.Slot, i)
        end
        if PetBattles.Abilities[PetBattles[1].Active.Abilities[1].ID] == nil then
            thisColor = "|cffFF0011"
        else
            thisColor = "|cff00AAFF"
        end
    end
    function PetBattles.RefreshPets(thisOwner)
        local average = 0
        PetBattles[thisOwner].Pet = {}
        for i = 1, 3 do
            PetBattles[thisOwner].Pet[i] = {
                Health = C_PetBattles.GetHealth(thisOwner, i),
                ID = C_PetBattles.GetDisplayID(thisOwner, i),
                Level = C_PetBattles.GetLevel(thisOwner, active),
                MaxHealth = C_PetBattles.GetMaxHealth(thisOwner, i),
                Percent = math.floor(
                C_PetBattles.GetHealth(thisOwner, i) / C_PetBattles.GetMaxHealth(thisOwner, i) * 100
                ),
                Quality = C_PetBattles.GetBreedQuality(thisOwner, i),
                Quality = C_PetBattles.GetBreedQuality(thisOwner, i),
                Type = C_PetBattles.GetPetType(thisOwner, i)
            }
            average = average + PetBattles[thisOwner].Pet[i].Percent
        end
        PetBattles[thisOwner].AverageHealth = math.floor(average / 3)
    end
    function PetBattles.CanTrap()
        return C_PetBattles.IsTrapAvailable()
    end
    function PetBattles.Weather()
        return C_PetBattles.GetAuraInfo(0, 0, 1)
    end
    function PetBattles.AbilityStrenght(thisAbility)
        if TypeWeaknessTable[select(7, C_PetBattles.GetAbilityInfoByID(thisAbility))].Strong == NmePetType then
            return 3
        end
        if TypeWeaknessTable[select(7, C_PetBattles.GetAbilityInfoByID(thisAbility))].Weak == NmePetType then
            return 1
        end
        return 2
    end
    function PetBattles.IsImmune(thisOwner)
        for i = 1, #PetBattles[thisOwner].Active.AllAuras do
            if PetBattles.Abilities[PetBattles[thisOwner].Active.AllAuras[i]] == "immunity" then
                return true
            end
        end
        return false
    end
    function PetBattles.PouplatePetTable(MinLevel, MaxLevel, ThisQuality)
        PetBattles.Journal.PetTable = {}
        for i = 1, select(2, C_PetJournal.GetNumPets()) do
            petID, _, _, _, level, favorite, _, name, _, _, _, _, _, isWild, canBattle, _, _, _ =             C_PetJournal.GetPetInfoByIndex(i)
            if petID ~= nil then
                if isWild then
                    WildConvert = 1
                else
                    WildConvert = 0
                end
                if favorite then
                    FavoriteConvert = 1
                else
                    FavoriteConvert = 0
                end
                if
                canBattle and level >= MinLevel and level <= MaxLevel and PetBattles.Journal.HealthGUID(petID) >= 70 and
                select(5, C_PetJournal.GetPetStats(select(1, C_PetJournal.GetPetInfoByIndex(i)))) >= ThisQuality
                then
                    table.insert(
                    PetBattles.Journal.PetTable,
                    { ID = petID, Level = level, Favorite = FavoriteConvert, Name = name, Wild = WildConvert }
                    )
                end
            end
        end
    end
    function PetBattles.PetSwapper()
        if
        IsOptionEnabled("精英队伍") and not C_PetBattles.IsInBattle() and
        (PetBattles.Journal.PetLevel(1) ~= 25 or PetBattles.Journal.PetLevel(2) ~= 25 or
        PetBattles.Journal.PetLevel(3) ~= 25)
        then
            PetBattles.PouplatePetTable(1, 25, GetOptionValue("精英队伍"))
            for i = 1, #PetBattles.Journal.PetTable do
                for j = 2, #PetBattles.Journal.PetTable do
                    if i ~= j then
                        if PetBattles.Journal.PetTable[j].Level > PetBattles.Journal.PetTable[j - 1].Level then
                            local TempPet = PetBattles.Journal.PetTable[j]
                            PetBattles.Journal.PetTable[j] = PetBattles.Journal.PetTable[j - 1]
                            PetBattles.Journal.PetTable[j - 1] = TempPet
                        end
                    end
                end
            end
            for i = 1, #PetBattles.Journal.PetTable do
                for j = 2, #PetBattles.Journal.PetTable do
                    if PetBattles.Journal.PetTable[j].Favorite > PetBattles.Journal.PetTable[j - 1].Favorite then
                        local TempPet = PetBattles.Journal.PetTable[j]
                        PetBattles.Journal.PetTable[j] = PetBattles.Journal.PetTable[j - 1]
                        PetBattles.Journal.PetTable[j - 1] = TempPet
                    end
                end
            end
            if
            #PetBattles.Journal.PetTable > 0 and
            (PetBattles.Journal.Health(1) <= 70 or PetBattles.Journal.PetLevel(1) ~= 25)
            then
                C_PetJournal.SetPetLoadOutInfo(1, PetBattles.Journal.PetTable[1].ID)
            end
            if
            #PetBattles.Journal.PetTable > 1 and
            (PetBattles.Journal.Health(2) <= 70 or PetBattles.Journal.PetLevel(2) ~= 25)
            then
                C_PetJournal.SetPetLoadOutInfo(2, PetBattles.Journal.PetTable[2].ID)
            end
            if
            #PetBattles.Journal.PetTable > 2 and
            (PetBattles.Journal.Health(3) <= 70 or PetBattles.Journal.PetLevel(3) ~= 25)
            then
                C_PetJournal.SetPetLoadOutInfo(3, PetBattles.Journal.PetTable[3].ID)
            end
        end
        if not IsOptionEnabled("精英队伍") and IsOptionEnabled("更换练级宠物的品质设定") and not C_PetBattles.IsInBattle() then
            if
            PetBattles.Journal.PetLevel(1) ~= nil and
            (PetBattles.Journal.PetLevel(1) >= 25 or PetBattles.Journal.Health(1) < GetOptionValue("复活战斗宠物") or
            PetBattles.Journal.PetLevel(2) ~= 25 or
            PetBattles.Journal.PetLevel(3) ~= 25 or
            PetBattles.Journal.Health(2) < 40 or
            PetBattles.Journal.Health(3) < 40)
            then
                PetBattles.PouplatePetTable(
                GetOptionValue("最小等级"),
                GetOptionValue("最高等级"),
                GetOptionValue("更换练级宠物的品质设定")
                )
                for i = 1, #PetBattles.Journal.PetTable do
                    for j = 2, #PetBattles.Journal.PetTable do
                        if i ~= j then
                            if
                            (not IsOptionEnabled("优先练高级的宠物") and
                            PetBattles.Journal.PetTable[j].Level < PetBattles.Journal.PetTable[j - 1].Level) or
                            (IsOptionEnabled("优先练高级的宠物") and
                            PetBattles.Journal.PetTable[j].Level > PetBattles.Journal.PetTable[j - 1].Level)
                            then
                                local TempPet = PetBattles.Journal.PetTable[j]
                                PetBattles.Journal.PetTable[j] = PetBattles.Journal.PetTable[j - 1]
                                PetBattles.Journal.PetTable[j - 1] = TempPet
                            end
                        end
                    end
                end
                for i = 1, #PetBattles.Journal.PetTable do
                    for j = 2, #PetBattles.Journal.PetTable do
                        if i ~= j then
                            if
                            (not IsOptionEnabled("优先练野生宠物") and
                            PetBattles.Journal.PetTable[j].Wild < PetBattles.Journal.PetTable[j - 1].Wild) or
                            (IsOptionEnabled("优先练野生宠物") and
                            PetBattles.Journal.PetTable[j].Wild > PetBattles.Journal.PetTable[j - 1].Wild)
                            then
                                local TempPet = PetBattles.Journal.PetTable[j]
                                PetBattles.Journal.PetTable[j] = PetBattles.Journal.PetTable[j - 1]
                                PetBattles.Journal.PetTable[j - 1] = TempPet
                            end
                        end
                    end
                end
                for i = 1, #PetBattles.Journal.PetTable do
                    for j = 2, #PetBattles.Journal.PetTable do
                        if PetBattles.Journal.PetTable[j].Favorite > PetBattles.Journal.PetTable[j - 1].Favorite then
                            local TempPet = PetBattles.Journal.PetTable[j]
                            PetBattles.Journal.PetTable[j] = PetBattles.Journal.PetTable[j - 1]
                            PetBattles.Journal.PetTable[j - 1] = TempPet
                        end
                    end
                end
                if #PetBattles.Journal.PetTable > 0 then
                    C_PetJournal.SetPetLoadOutInfo(1, PetBattles.Journal.PetTable[1].ID)
                end
                for i = 2, 3 do
                    if (PetBattles.Journal.Health(i) <= 70 or PetBattles.Journal.PetLevel(i) ~= 25) then
                        PetBattles.Journal.RingnersTable = {}
                        for j = 1, select(2, C_PetJournal.GetNumPets()) do
                            petID, _, _, _, level, favorite, _, _, _, _, _, _, _, isWild, canBattle, _, _, _ =                             C_PetJournal.GetPetInfoByIndex(j)
                            if petID ~= nil then
                                if isWild then
                                    WildConvert = 1
                                else
                                    WildConvert = 0
                                end
                                if favorite then
                                    FavoriteConvert = 1
                                else
                                    FavoriteConvert = 0
                                end
                                if
                                canBattle and PetBattles.Journal.HealthGUID(petID) > 70 and level >= 25 and
                                petID ~= C_PetJournal.GetPetLoadOutInfo(1) and
                                petID ~= C_PetJournal.GetPetLoadOutInfo(2) and
                                petID ~= C_PetJournal.GetPetLoadOutInfo(3) and
                                select(
                                5,
                                C_PetJournal.GetPetStats(select(1, C_PetJournal.GetPetInfoByIndex(j)))
                                ) >= GetOptionValue("更换练级宠物的品质设定")
                                then
                                    table.insert(
                                    PetBattles.Journal.RingnersTable,
                                    { ID = petID, Level = level, Favorite = FavoriteConvert, Wild = WildConvert }
                                    )
                                end
                            end
                        end
                        for i = 1, #PetBattles.Journal.RingnersTable do
                            for j = 2, #PetBattles.Journal.PetTable do
                                if i ~= j then
                                    if PetBattles.Journal.PetTable[j].Level > PetBattles.Journal.PetTable[j - 1].Level then
                                        local TempPet = PetBattles.Journal.PetTable[j]
                                        PetBattles.Journal.PetTable[j] = PetBattles.Journal.PetTable[j - 1]
                                        PetBattles.Journal.PetTable[j - 1] = TempPet
                                    end
                                end
                            end
                        end
                        for i = 1, #PetBattles.Journal.RingnersTable do
                            for j = 2, #PetBattles.Journal.PetTable do
                                if PetBattles.Journal.PetTable[j].Favorite > PetBattles.Journal.PetTable[j - 1].Favorite then
                                    local TempPet = PetBattles.Journal.PetTable[j]
                                    PetBattles.Journal.PetTable[j] = PetBattles.Journal.PetTable[j - 1]
                                    PetBattles.Journal.PetTable[j - 1] = TempPet
                                end
                            end
                        end
                        if #PetBattles.Journal.RingnersTable > 0 then
                            C_PetJournal.SetPetLoadOutInfo(i, PetBattles.Journal.RingnersTable[1].ID)
                        end
                    end
                end
            end
        end
    end
    function PetBattles.Cast(thisType)
        if TurnReady then
            local BestAbility = 0
            local BestPrio = 4
            for i = 1, 3 do
                if
                PetBattles.Abilities[PetBattles[1].Active.Abilities[i].ID] and
                PetBattles.Abilities[PetBattles[1].Active.Abilities[i].ID].Type == thisType
                then
                    local ThisPrio = PetBattles.Abilities[PetBattles[1].Active.Abilities[i].ID].Prio or 4
                    if PetBattles[1].Active.Abilities[i].Ready and (BestPrio == 4 or (ThisPrio < BestPrio)) then
                        BestAbility = i
                        BestPrio = ThisPrio
                    end
                end
            end
            if BestAbility ~= 0 then
                C_PetBattles.UseAbility(BestAbility)
                PetBattles.LastAbility = thisType
                PetBattles.Status("Casting Ability #" .. BestAbility .. " (" .. thisType .. ")")
                TurnReady = false
                return
            end
        end
    end
    function PetBattles.CastBuff(thisType)
        if TurnReady then
            for i = 1, 3 do
                local ThisAbility = PetBattles.Abilities[PetBattles[1].Active.Abilities[i].ID]
                if ThisAbility and ThisAbility.Type == thisType then
                    if PetBattles[1].Active.Abilities[i].Ready then
                        local ThisBuff
                        if PetBattles.Abilities[PetBattles[1].Active.Abilities[i].ID].Buff == nil then
                            ThisBuff = PetBattles[1].Active.Abilities[i].ID - 1
                        else
                            ThisBuff = PetBattles.Abilities[PetBattles[1].Active.Abilities[i].ID].Buff
                        end
                        if not PetBattles.IsBuffed(1, ThisBuff) then
                            C_PetBattles.UseAbility(i)
                            PetBattles.Status("Casting Ability #" .. i .. " to apply Buff (" .. thisType .. ")")
                            TurnReady = false
                            return
                        end
                    end
                end
            end
        end
    end
    function PetBattles.CastDebuff(thisType)
        if TurnReady then
            for i = 1, 3 do
                if
                PetBattles.Abilities[PetBattles[1].Active.Abilities[i].ID] and
                PetBattles.Abilities[PetBattles[1].Active.Abilities[i].ID].Type == thisType
                then
                    if PetBattles[1].Active.Abilities[i].Ready then
                        local thisDebuff
                        if PetBattles.Abilities[PetBattles[1].Active.Abilities[i].ID].Debuff == nil then
                            thisDebuff = PetBattles[1].Active.Abilities[i].ID - 1
                        else
                            thisDebuff = PetBattles.Abilities[PetBattles[1].Active.Abilities[i].ID].Debuff
                        end
                        if not PetBattles.IsBuffed(2, thisDebuff) then
                            C_PetBattles.UseAbility(i)
                            PetBattles.Status("Casting Ability #" .. i .. " to apply Debuff (" .. thisType .. ")")
                            TurnReady = false
                            return
                        end
                    end
                end
            end
        end
    end
    function PetBattles.Filler()
        if TurnReady then
            for i = 1, 3 do
                if PetBattles[1].Active.Abilities[i].Ready then
                    C_PetBattles.UseAbility(i)
                    PetBattles.Status("Using ability #" .. i .. " without conditions as nothing known was found")
                    TurnReady = false
                    return
                end
            end
            if
            not PetBattles[1].Active.Abilities[1].Ready and not PetBattles[1].Active.Abilities[2].Ready and
            not PetBattles[1].Active.Abilities[3].Ready
            then
                C_PetBattles.SkipTurn()
                if
                PetBattles[2].Active.Percent ~= 0 and PetBattles[2].Active.Percent ~= 100 and
                PetBattles.LastAbility ~= "3turnhighdmg"
                then
                    PetBattles.Status("Casted Pass as nothing could be casted")
                end
                TurnReady = false
                return
            end
        end
    end
    function PetBattles.HealPets()
        if
        IsOptionEnabled("复活战斗宠物") and
        (PetBattles.Journal.Health(1) <= GetOptionValue("复活战斗宠物") or
        PetBattles.Journal.Health(2) <= GetOptionValue("复活战斗宠物") or
        PetBattles.Journal.Health(3) <= GetOptionValue("复活战斗宠物")) and
        PetBattles:SpellCooldown(125439) == 0
        then
            CastSpellByID(125439, "player")
            return true
        else
            return false
        end
    end
    function PetBattles.IsBuffed(thisOwner, ThisBuff)
        for i = 1, #PetBattles[thisOwner].Active.AllAuras do
            if PetBattles[thisOwner].Active.AllAuras[i] == ThisBuff then
                return true
            end
        end
        return false
    end
    function PetBattles.IsRooted()
        for i = 1, 1536 do
            if PetBattles.Abilities[i] then
                if PetBattles.Abilities[i].Type == "root" and PetBattles.IsBuffed(1, i) then
                    return true
                end
            end
        end
        return false
    end
    function PetBattles.IsTeamBuffed(thisOwner, ThisBuff)
        for i = 1, #PetBattles[thisOwner].AllTeamAuras do
            if PetBattles[thisOwner].AllTeamAuras[i] == ThisBuff then
                return true
            end
        end
        return false
    end
    function PetBattles.Pass()
        if TurnReady then
            for i = 1, #PetBattles[1].Active.AllAuras do
                if
                PetBattles.Abilities[PetBattles[1].Active.AllAuras[i]] and
                PetBattles.Abilities[PetBattles[1].Active.AllAuras[i]].Type == "sleepdebuff"
                then
                    C_PetBattles.SkipTurn()
                    TurnReady = false
                    return
                end
            end
        end
    end
    function PetBattles.Swap(thisPet, thisMessage)
        if TurnReady then
            C_PetBattles.ChangePet(thisPet)
            PetBattles.Status("Changing pet to pet #" .. thisPet .. " as " .. thisMessage)
            TurnReady = false
            return
        end
    end
    function PetBattles.Swapper(AllowSwap)
        if not PetBattles.IsRooted() and (AllowSwap or PetBattles[1].Active.Percent == 0) then
            if PetBattles[1].Active.Slot == 1 and PetBattles[1].Active.Level < 25 and IsOptionEnabled("练一号位置宠物") then
                if PetBattles[2].Active.Percent < 100 then
                    if PetBattles[1].Pet[2].Percent > 0 then
                        PetBattles.Swap(2, "pet 1 is leveling")
                    elseif PetBattles[1].Pet[3].Percent > 0 then
                        PetBattles.Swap(3, "pet 1 is leveling")
                    end
                end
            end
            if
            PetBattles[1].Active.Percent == 0 or
            (IsOptionEnabled("根据HP切换宠物") and PetBattles[1].Active.Percent <= GetOptionValue("根据HP切换宠物"))
            then
                if PetBattles[1].Active.Slot == 1 and PetBattles[1].Pet[2].Percent > 0 then
                    PetBattles.Swap(2, "pet 1 is dieing")
                end
            end
            if
            PetBattles[1].Active.Percent == 0 or
            (IsOptionEnabled("根据HP切换宠物") and PetBattles[1].Active.Percent <= GetOptionValue("根据HP切换宠物"))
            then
                if PetBattles[1].Active.Slot == 2 then
                    if PetBattles[1].Pet[3].Percent > GetOptionValue("根据HP切换宠物") then
                        PetBattles.Swap(3, "pet 2 is dieing")
                    elseif PetBattles[1].Pet[2].Percent == 0 and PetBattles[1].Pet[1].Percent > 0 then
                        PetBattles.Swap(1, "pet 2 and pet 3 are dead")
                    end
                end
                if PetBattles[1].Active.Slot == 3 then
                    if PetBattles[1].Pet[2].Percent > GetOptionValue("根据HP切换宠物") then
                        PetBattles.Swap(2, "pet 3 is dieing")
                    elseif PetBattles[1].Pet[3].Percent == 0 and PetBattles[1].Pet[1].Percent > 0 then
                        PetBattles.Swap(1, "pet 2 and pet 3 are dead")
                    end
                end
            end
        end
    end
    function PetBattles:SpellCooldown(SpellID)
        if GetSpellCooldown(SpellID) == 0 then
            return 0
        else
            local Start, CD = GetSpellCooldown(SpellID)
            local MyCD = Start + CD - GetTime()
            return MyCD
        end
    end
    function PetBattles.Journal.Health(thisPet)
        return C_PetJournal.GetPetLoadOutInfo(thisPet) and
        100 *
        (select(1, C_PetJournal.GetPetStats(C_PetJournal.GetPetLoadOutInfo(thisPet))) /
        select(2, C_PetJournal.GetPetStats(C_PetJournal.GetPetLoadOutInfo(thisPet)))) or
        0
    end
    function PetBattles.Journal.HealthGUID(PetGUID)
        return 100 * (select(1, C_PetJournal.GetPetStats(PetGUID)) / select(2, C_PetJournal.GetPetStats(PetGUID))) or 0
    end
    function PetBattles.Journal.PetLevel(thisPet)
        return C_PetJournal.GetPetLoadOutInfo(thisPet) and
        select(3, C_PetJournal.GetPetInfoByPetID(C_PetJournal.GetPetLoadOutInfo(thisPet)))
    end
    function PetBattles.Status(thisStatus)
        if PetBattles.CurrentStatus ~= thisStatus then
            PetBattles.CurrentStatus = thisStatus
            Bug(thisStatus)
        end
    end
    function PetBattles.AoEPunch(isFiller)
        if PetBattles[2].Active.Slot == 1 or isFiller == "filler" then
            PetBattles.Cast("aoe")
        end
    end
    function PetBattles.Apocalypse()
        if
        PetBattles[2].Active.MaxHealth > 2000 or
        (PetBattles[2].Pet[1].Health > 50 and PetBattles[2].Pet[2].Health > 80 and
        PetBattles[2].Pet[2].Health > 80)
        then
            PetBattles.Cast("apocalypse")
        end
    end
    function PetBattles.Attack()
        PetBattles.Cast("attack")
    end
    function PetBattles.CantDie()
        for i = 1, 1536 do
            if
            PetBattles.Abilities[i] and PetBattles.Abilities[i].Type == "cantdie" and
            PetBattles.IsBuffed(2, PetBattles.Abilities[i])
            then
                return true
            end
        end
        return false
    end
    function PetBattles.Comeback()
        if PetBattles[1].Active.Percent < PetBattles[2].Active.Percent and not PetBattles.IsImmune(2) then
            PetBattles.Cast("comeback")
        end
    end
    function PetBattles.DamageBuff()
        if not PetBattles.IsBuffed(1, 485) then
            PetBattles.Cast("dmgbuff")
        end
    end
    function PetBattles.FocusBuff()
        if not PetBattles.IsBuffed(1, 425) then
            PetBattles.Cast("focusbuff")
        end
    end
    function PetBattles.Buff()
        PetBattles.CastBuff("buff")
    end
    function PetBattles.Consume()
        if IsOptionEnabled("立即治疗") then
            local DeadCorpses = 0
            for i = 1, 3 do
                if PetBattles[1].Pet[i].Percent == 0 then
                    DeadCorpses = DeadCorpses + 1
                end
            end
            if PetBattles.Consumed < DeadCorpses then
                if PetBattles[1].Active.Percent < GetOptionValue("立即治疗") then
                    PetBattles.Consumed = PetBattles.Consumed + 1
                    PetBattles.Cast("consume")
                end
            end
        end
    end
    function PetBattles.Deflect()
        for i = 1, 1536 do
            if
            PetBattles.Abilities[i] ~= nil and
            ((PetBattles.Abilities[i].Type == "todeflect" and PetBattles.IsBuffed(2, PetBattles.Abilities[i])) or
            (PetBattles.Abilities[i].Type == "immunity" and PetBattles.IsBuffed(2, PetBattles.Abilities[i]) and
            PetBattles.Abilities[i].Deflect == true))
            then
                PetBattles.Cast("deflect")
            end
        end
    end
    function PetBattles.DelayedHeavy()
        PetBattles.Cast("delayedheavy")
    end
    function PetBattles.Debuff()
        PetBattles.CastDebuff("debuff")
    end
    function PetBattles.DmgDebuff()
        PetBattles.CastDebuff("dmgdebuff")
    end
    function PetBattles.HealingDelayed()
        if IsOptionEnabled("延迟治疗") then
            if PetBattles[1].Active.Percent < GetOptionValue("延迟治疗") then
                for i = 1, 3 do
                    if
                    PetBattles.Abilities[PetBattles[1].Active.Abilities[i].ID] and
                    PetBattles.Abilities[PetBattles[1].Active.Abilities[i].ID].Type == "delayedheal"
                    then
                        if PetBattles[1].Active.Abilities[i].Ready and PetBattles[1].Active.Percent > 40 then
                            C_PetBattles.UseAbility(i)
                            TurnReady = false
                            return
                        end
                    end
                end
            end
        end
    end
    function PetBattles.HealOverTime()
        if TurnReady then
            if IsOptionEnabled("持续治疗") and PetBattles[1].Active.Percent < GetOptionValue("持续治疗") then
                for i = 1, 3 do
                    if
                    PetBattles.Abilities[PetBattles[1].Active.Abilities[i].ID] and
                    PetBattles.Abilities[PetBattles[1].Active.Abilities[i].ID].Type == "hotbuff"
                    then
                        if
                        PetBattles[1].Active.Abilities[i].Ready and
                        not PetBattles.IsBuffed(1, PetBattles[1].Active.Abilities[i].ID) and
                        not (PetBattles[1].Active.Abilities[i].Buff and
                        PetBattles.IsBuffed(1, PetBattles[1].Active.Abilities[i].Buff))
                        then
                            C_PetBattles.UseAbility(i)
                            TurnReady = false
                            return
                        end
                    end
                end
            end
        end
    end
    function PetBattles.HealTeamOverTime()
        if TurnReady then
            if IsOptionEnabled("持续治疗") and PetBattles[1].Active.Percent < GetOptionValue("持续治疗") then
                for i = 1, 3 do
                    if
                    PetBattles.Abilities[PetBattles[1].Active.Abilities[i].ID] and
                    PetBattles.Abilities[PetBattles[1].Active.Abilities[i].ID].Type == "hotteam"
                    then
                        if
                        PetBattles[1].Active.Abilities[i].Ready and
                        not PetBattles.IsTeamBuffed(1, PetBattles[1].Active.Abilities[i].ID) and
                        not (PetBattles.Abilities[PetBattles[1].Active.Abilities[i].ID].Buff and
                        PetBattles.IsTeamBuffed(
                        1,
                        PetBattles.Abilities[PetBattles[1].Active.Abilities[i].ID].Buff
                        ))
                        then
                            C_PetBattles.UseAbility(i)
                            TurnReady = false
                            return
                        end
                    end
                end
            end
        end
    end
    function PetBattles.Healing()
        if IsOptionEnabled("立即治疗") then
            if PetBattles[1].Active.Percent < GetOptionValue("立即治疗") then
                PetBattles.Cast("heal")
            end
        end
    end
    function PetBattles.HealTeam()
        if IsOptionEnabled("立即治疗") then
            local LifeDeficit = 0
            for i = 1, 3 do
                LifeDeficit = LifeDeficit + (100 - PetBattles[1].Pet[i].Percent)
            end
            if PetBattles[1].Active.Percent < GetOptionValue("立即治疗") and LifeDeficit > 50 then
                PetBattles.Cast("healteam")
            end
        end
    end
    function PetBattles.HeavyAttack()
        PetBattles.Cast("highdmg")
    end
    function PetBattles.IfBuffed()
        if TurnReady then
            for i = 1, 3 do
                local ThisAbility = PetBattles.Abilities[PetBattles[1].Active.Abilities[i].ID]
                if ThisAbility and ThisAbility.Type == "ifbuffed" and PetBattles[1].Active.Abilities[i].Ready then
                    for j = 1, #ThisAbility.Debuffs do
                        if PetBattles.IsBuffed(2, ThisAbility.Debuffs[j]) then
                            C_PetBattles.UseAbility(i)
                            PetBattles.Status("Casting Ability #" .. i .. " (ifbuffed)")
                            TurnReady = false
                            return
                        end
                    end
                end
            end
        end
    end
    function PetBattles.Kamikaze()
        if PetBattles[1].Active.Percent < 35 then
            PetBattles.Cast("kamikaze")
        end
    end
    function PetBattles.Leech()
        PetBattles.Cast("leech")
    end
    function PetBattles.LifeSwap()
        if TurnReady then
            for i = 1, 3 do
                local ThisAbility = PetBattles.Abilities[PetBattles[1].Active.Abilities[i].ID]
                if ThisAbility and ThisAbility.Type == "lifeswap" and PetBattles[1].Active.Abilities[i].Ready then
                    if PetBattles[1].Active.Percent < PetBattles[2].Active.Percent - 50 then
                        C_PetBattles.UseAbility(i)
                        PetBattles.Status("Casting Ability #" .. i .. " (lifeswap)")
                        TurnReady = false
                        return
                    end
                end
            end
        end
    end
    function PetBattles.Roots()
        PetBattles.Cast("rootattack")
    end
    function PetBattles.Sleep()
        if not PetBattles.IsBuffed(2, 236) then
            local Sleeping = false
            for i = 1, 1536 do
                local ThisAbility = PetBattles.Abilities[i]
                if ThisAbility and ThisAbility.Type == "sleepdebuff" and PetBattles.IsBuffed(2, ThisAbility) then
                    Sleeping = true
                    break
                end
            end
            if not Sleeping then
                PetBattles.Cast("sleep")
            end
        end
    end
    function PetBattles.SpeedBuff()
        if
        PetBattles[2].Active.Percent >= 45 and PetBattles[1].Active.Speed < PetBattles[2].Active.Speed and
        PetBattles[1].Active.Speed > (3 * PetBattles[2].Active.Speed / 4)
        then
            PetBattles.CastBuff("speedbuff")
        end
    end
    function PetBattles.SpeedDebuff()
        if
        PetBattles[2].Active.Percent >= 45 and PetBattles[1].Active.Speed < PetBattles[2].Active.Speed and
        PetBattles[1].Active.Speed > (3 * PetBattles[2].Active.Speed / 4)
        then
            PetBattles.CastDebuff("speeddebuff")
        end
    end
    function PetBattles.TeamDebuff()
        if TurnReady then
            for i = 1, 3 do
                if
                PetBattles.Abilities[PetBattles[1].Active.Abilities[i].ID] and
                PetBattles.Abilities[PetBattles[1].Active.Abilities[i].ID].Type == "teamdebuff"
                then
                    if
                    PetBattles[1].Active.Abilities[i].Ready and
                    not PetBattles.IsTeamBuffed(2, PetBattles[1].Active.Abilities[i].ID) and
                    not (PetBattles.Abilities[PetBattles[1].Active.Abilities[i].ID].Buff and
                    PetBattles.IsTeamBuffed(
                    2,
                    PetBattles.Abilities[PetBattles[1].Active.Abilities[i].ID].Buff
                    ))
                    then
                        C_PetBattles.UseAbility(i)
                        TurnReady = false
                        return
                    end
                end
            end
        end
    end
    function PetBattles.Turrets()
        if PetBattles.Weather() ~= 454 and not (PetBattles[2].Active.Slot == 3 and PetBattles[2].Active.Percent <= 55) then
            PetBattles.Cast("turret")
        end
    end
    function PetBattles.ThreeTurnSoft()
        PetBattles.Cast("3turn")
    end
    function PetBattles.ThreeTurnHeavy()
        PetBattles.Cast("3turnhighdmg")
    end
    function PetBattles.TwoTurns()
        PetBattles.Cast("2turn")
    end
    function PetBattles.Quick(isFiller)
        if
        (PetBattles[1].Active.Speed > PetBattles[2].Active.Speed or isFiller == "filler") and
        not PetBattles.IsImmune(2)
        then
            PetBattles.Cast("quick")
        end
    end
    function PetBattles.DeBuff()
        if PetBattles[2].Active.Percent >= 45 and not PetBattles.IsImmune() then
            local abilityList = PetBattles.Abilities.DeBuffList
            for i = 1, #abilityList do
                if not PetBattles.IsBuffed(abilityList[i], 2) then
                    PetBattles.Cast(abilityList[i])
                end
            end
            local abilityList = PetBattles.Abilities.SpecialDebuffsList
            for i = 1, #abilityList do
                if not PetBattles.IsBuffed(nil, 2, abilityList[i].Debuff) then
                    PetBattles.Cast(abilityList[i].Ability)
                end
            end
        end
    end
    function PetBattles.HighDamageIfBuffed()
        if not PetBattles.IsImmune() then
            local abilityList = PetBattles.Abilities.HighDamageIfBuffedList
            for i = 1, #abilityList do
                if PetBattles.IsBuffed(nil, 2, abilityList[i]) then
                    PetBattles.Cast(abilityList[i])
                end
            end
        end
    end
    local Frame = CreateFrame("FRAME")
    Frame:RegisterEvent("PET_BATTLE_PET_ROUND_PLAYBACK_COMPLETE")
    Frame:RegisterEvent("PET_BATTLE_OPENING_START")
    local function AddonsLoaded(timeStamp, event, addonName)
        if event == "PET_BATTLE_PET_ROUND_PLAYBACK_COMPLETE" or event == "PET_BATTLE_OPENING_START" then
            TurnReady = true
        end
    end
    Frame:SetScript("OnEvent", AddonsLoaded)
end
function InstanceCallOperator(self, ...)
    return self:Call(...)
end
function ToStringOperator(self, ...)
    return self:ToString(...)
end
function UnaryMinusOperator(self, ...)
    return self:UnaryMinus(...)
end
function AddOperator(self, ...)
    return self:Add(...)
end
function SubtractOperator(self, ...)
    return self:Subtract(...)
end
function MultiplyOperator(self, ...)
    return self:Multiply(...)
end
function DivideOperator(self, ...)
    return self:Divide(...)
end
function ModuloOperator(self, ...)
    return self:Modulo(...)
end
function PowerOperator(self, ...)
    return self:Power(...)
end
function ConcatenateOperator(self, ...)
    return self:Concatenate(...)
end
function EqualsOperator(self, ...)
    return self:Equals(...)
end
function LessThanOperator(self, ...)
    return self:LessThan(...)
end
function LessThanOrEqualToOperator(self, ...)
    return self:LessThanOrEqualTo(...)
end
function ClassCallOperator(self, ...)
    local Object = {}
    setmetatable(Object, self)
    if Object.Constructor then
        Object:Constructor(...)
    end
    return Object
end
function Class()
    local Table = {}
    Table.__index = Table
    Table.__call = InstanceCallOperator
    Table.__tostring = ToStringOperator
    Table.__unm = UnaryMinusOperator
    Table.__add = AddOperator
    Table.__sub = SubtractOperator
    Table.__mul = MultiplyOperator
    Table.__div = DivideOperator
    Table.__mod = ModuloOperator
    Table.__pow = PowerOperator
    Table.__concat = ConcatenateOperator
    Table.__eq = EqualsOperator
    Table.__lt = LessThanOperator
    Table.__le = LessThanOrEqualToOperator
    local MetaTable = {}
    MetaTable.__call = ClassCallOperator
    setmetatable(Table, MetaTable)
    return Table
end
Unit = Class()
function Unit:Constructor(UnitID)
    self.UnitID = UnitID
    if Unlocker ~= "FireHack" and Unlocker ~= "EWT" then
        self.X, self.Y, self.Z = OP(UnitID)
    else
        if OE(UnitID) then
            self.X, self.Y, self.Z = OP(UnitID)
        end
    end
end
Unit.Player = Unit("player")
Unit.PlayerPet, Unit.PlayerPetTarget = Unit("pet"), Unit("pettarget")
Unit.Target, Unit.TargetTarget = Unit("target"), Unit("targettarget")
Unit.Mouseover, Unit.MouseoverTarget = Unit("mouseover"), Unit("mouseovertarget")
Unit.Focus, Unit.FocusTarget = Unit("focus"), Unit("focustarget")
Unit.Boss1, Unit.Boss1Target = Unit("boss1"), Unit("boss1target")
Unit.Boss2, Unit.Boss2Target = Unit("boss2"), Unit("boss2target")
Unit.Boss3, Unit.Boss3Target = Unit("boss3"), Unit("boss3target")
Unit.Boss4, Unit.Boss4Target = Unit("boss4"), Unit("boss4target")
Player = Unit.Player
Target = Unit.Target
TargetTarget = Unit.TargetTarget
Focus = Unit.Focus
FocusTarget = Unit.FocusTarget
Mouseover = Unit.Mouseover
MouseoverTarget = Unit.MouseoverTarget
PlayerPet = Unit.PlayerPet
PlayerPetTarget = Unit.PlayerPetTarget
Boss1, Boss1Target = Unit.Boss1, Unit.Boss1Target
Boss2, Boss2Target = Unit.Boss2, Unit.Boss2Target
Boss3, Boss3Target = Unit.Boss3, Unit.Boss3Target
Boss4, Boss4Target = Unit.Boss4, Unit.Boss4Target
Item = Class()
function Item:Constructor(Identifier, ItemSlotID)
    if not Identifier then
        return
    end
    if ItemSlotID and type(ItemSlotID) ~= "table" then
        return
    end
    self.Identifier = Identifier
    self.ItemSlotID = ItemSlotID or { 0 }
    self.LastUseTime = 0
end
Spell = Class()
Spells = {}
function Spell:Constructor(Identifier, FacingRequired, Hostile, Instant, Resurrect)
    if not Identifier then
        return
    end
    self.Identifier = Identifier
    self.FacingRequired = FacingRequired and FacingRequired or false
    self.Hostile = Hostile and Hostile or false
    self.Instant = Instant and Instant or false
    self.Resurrect = Resurrect and Resurrect or false
    self.LastCastTime = 0
    self.DoNotCast = false
    Spells[Identifier] = self
end
Vector3 = Class()
function Vector3:Constructor(X, Y, Z)
    self.X = X
    self.Y = Y
    self.Z = Z
end
Rotations = {}
function SetRotation(SpecID, Rotation)
    Rotations[SpecID] = Rotation
    Rotation.Identifier = SpecID
    Rotation.SpamPrevention = 0
    Rotation.TablesRefreshed = 0
end
function GetActiveRotation()
    if not RunOnceMessage then
        RunOnceMessage = true
    end
    local SpecID = UnitClass("Player")
    local SpecInfo = select(2, UnitClass("Player"))
    if GetSpecialization() and UnitLevel("Player") >= 10 then
        SpecID = GetSpecialization()
        SpecInfo = select(1, GetSpecializationInfo(SpecID))
    else
        SpecID = UnitClass("Player")
        SpecInfo = select(2, UnitClass("Player"))
    end
    return SpecID and Rotations[SpecInfo]
end
function Rotations:Init(Rotation)
    if Rotations.CurrentUI ~= Rotation.Identifier then
        Rotations.CurrentUI = Rotation.Identifier
        ClearOptions()
        ClearOutputs()
        AddCommonMeleeStatus()
        Rotation:Initialize()
        CreateUI()
        if not Rotations.EventsLoaded then
            Rotation:Events()
            Rotation.EventsLoaded = true
        end
    end
end
function Rotations:RefreshUnitTables(Identifier)
    if UnitsEngine.Updated then
        UnitsEngine.Updated = false
        ResfreshStoredTables = true
        Rotations[Identifier]:UnitTables()
    end
end
function IsRunning()
    return EngineRunning
end
function SetRunning(Running)
    EngineRunning = Running
    SetSetting("Running", Running)
    if Locale == "zh" then
        StatusUpdate(Running and "|cFF40FF00战斗启用。" or "|cFFFF0000战斗禁用。")
        Overlay(Running and "|cFF40FF00战斗启用" or "|cFFFF0000战斗禁用")
    else
        StatusUpdate(Running and "|cFF40FF00开始." or "|cFFFF0000停止.")
        Overlay(Running and "|cFF40FF00开" or "|cFFFF0000关")
    end
end
function ToggleRunning(Parts)
    local Parts = Parts ~= nil and string.lower(Parts) or nil
    if Parts == "off" and IsRunning() then
        SetRunning(false)
    elseif Parts == "on" and not IsRunning() then
        SetRunning(true)
    elseif Parts ~= "off" and Parts ~= "on" then
        local Running = not IsRunning()
        SetRunning(Running)
    end
end
function UseCooldowns()
    return AllowCooldowns
end
local Burst = "禁用"
local PrepStarted = 0
local PrepDuration = 5
function PVPBurstHandler(forceBurst)
    if forceBurst and Burst ~= "Bursting" then
        Burst = "Bursting"
        BurstStarted = GetTime()
    elseif Burst == "禁用" and UseCooldowns() then
        if IsOptionEnabled("Pre-Burst") then
            if UseCooldowns() then
                SetCooldowns(false, true)
            end
            Burst = "Prepped"
            PrepStarted = GetTime()
        else
            Burst = "Bursting"
        end
    elseif Burst == "Prepped" and UseCooldowns() then
        Burst = "Bursting"
    end
end
function PrepTimeLeft()
    local timeLeft = GetOptionValue("Pre-Burst") - (GetTime() - PrepStarted)
    return timeLeft
end
function DisableBurst()
    if PVPEnabled then
        Bug("|cffFF0000Burst Reset.")
    end
    Burst = "禁用"
end
function SetCooldowns(Cooldowns)
    AllowCooldowns = Cooldowns
    SetSetting("cds", Cooldowns)
end
function ToggleCDs()
    local Cooldowns = not UseCooldowns()
    SetCooldowns(Cooldowns)
    if Locale == "zh" then
        StatusUpdate(Cooldowns and "冷却时间|cFF40FF00启用。" or "冷却时间|cFFFF0000禁用。")
        Overlay(Cooldowns and "冷却时间|cFF40FF00启用" or "冷却时间|cFFFF0000禁用")
    else
        StatusUpdate(Cooldowns and "大技能 |cFF40FF00启用." or "大技能 |cFFFF0000禁用.")
        Overlay(Cooldowns and "大技能 |cFF40FF00启用" or "大技能 |cFFFF0000禁用")
    end
end
SpeedSlow = Spell(207011)
function CooldownsAllowed()
    return UseCooldowns() and (not IsOptionEnabled("Cooldowns On Bosses") or Unit.Target:IsBoss()) and
    (not IsOptionEnabled("【速度:慢】效果下禁用大技能") or not Player:Debuff(SpeedSlow)) and
    (EncounterID ~= 2037 or not IsOptionEnabled("在昏暗隐匿中停止输出(主母绿水)") or
    not Player:DebuffAny(DontCastDebuff["Concealing Murk"]))
end
function UseAOE()
    return AOEEnabled
end
function SetAOE(AOE)
    AOEEnabled = AOE
    SetSetting("AOE", AOE)
end
function ToggleAoE()
    local AOE = not UseAOE()
    SetAOE(AOE)
    if Locale == "zh" then
        StatusUpdate(AOE and "自动区域效果|cFF40FF00启用。" or "自动区域效果|cFFFF0000禁用。")
        Overlay(AOE and "自动区域效果|cFF40FF00启用" or "自动区域效果|cFFFF0000禁用")
    else
        StatusUpdate(AOE and "自动AOE |cFF40FF00启用." or "自动AOE |cFFFF0000禁用.")
        Overlay(AOE and "自动 AOE |cFF40FF00启用" or "自动 AOE |cFFFF0000禁用")
    end
end
function UseDebug()
    return DebugEnabled
end
function SetDebug(Debug)
    DebugEnabled = Debug
    SetSetting("调试", Debug)
end
function ToggleDebug()
    local Debug = not UseDebug()
    SetDebug(Debug)
    if Locale == "zh" then
        StatusUpdate(Debug and "调试文字|cFF40FF00启用。" or "调试文字|cFFFF0000禁用。")
        Overlay(Debug and "调试文字|cFF40FF00启用" or "调试文字|cFFFF0000禁用")
    else
        StatusUpdate(Debug and "调试文本 |cFF40FF00启用." or "调试文本 |cFFFF0000禁用.")
        Overlay(Debug and "调试文本 |cFF40FF00启用" or "调试文本 |cFFFF0000禁用")
    end
end
function UseDebugFrame()
    return DebugFrameEnabled
end
function SetDebugFrame(State)
    DebugFrameEnabled = State
    SetSetting("调试窗口", DebugFrameEnabled)
end
function ToggleDebugFrame()
    local State = not UseDebugFrame()
    SetDebugFrame(State)
    if Locale == "zh" then
        StatusUpdate(State and "调试窗口|cFF40FF00显示。" or "调试窗口|cFFFF0000隐。")
        Overlay(State and "调试窗口|cFF40FF00显示" or "调试窗口|cFFFF0000隐")
    else
        StatusUpdate(State and "调试窗口 |cFF40FF00显示." or "调试窗口 |cFFFF0000隐藏.")
        Overlay(State and "调试窗口 |cFF40FF00显示" or "调试窗口 |cFFFF0000隐藏")
    end
end
function UseActionLog()
    return ActionLogEnabled
end
function SetActionLog(State)
    ActionLogEnabled = State
    SetSetting("ActionLog", ActionLogEnabled)
end
function ToggleActionLog()
    local State = not UseActionLog()
    SetActionLog(State)
    if Locale == "zh" then
        StatusUpdate(State and "行动日志|cFF40FF00显示。" or "行动日志|cFFFF0000隐。")
        Overlay(State and "行动日志|cFF40FF00显示" or "行动日志|cFFFF0000隐")
    else
        StatusUpdate(State and "动作记录窗口 |cFF00FF00显示." or "动作记录窗口 |cFFFF0000隐藏.")
        Overlay(State and "动作记录 |cFF00FF00显示" or "动作记录 |cFFFF0000隐藏")
    end
end
function Print(...)
    if GetSetting("聊天栏信息_Checked") then
        print("[|cFF26BAFF" .. DisplayName .. "|r]", ...)
    end
end
function Command(...)
    print("[|cFF26BAFF" .. DisplayName .. " Macros|r]", ...)
end
function QueueSystem(...)
    if GetSetting("聊天栏信息_Checked") then
        print("[|cFF26BAFF" .. DisplayName .. "|r]", ...)
    end
end
function StatusUpdate(...)
    if GetSetting("聊天栏信息_Checked") then
        print("[|cFF26BAFF" .. DisplayName .. "|r]", ...)
    end
end
function ProfileManager(...)
    if GetSetting("聊天栏信息_Checked") then
        print("[|cFF26BAFF" .. DisplayName .. "|r]", ...)
    end
end
function Error(...)
    if GetSetting("聊天栏信息_Checked") then
        print("[|cFF26BAFF" .. DisplayName .. " ERROR|r]", ...)
    end
end
function Bug(...)
    if GetSetting("聊天栏信息_Checked") and UseDebug() then
        print("[|cFF26BAFFDebug|r]", ...)
    end
end
if not Event then
    Event = Class()
    function Event:Constructor()
        self.Handlers = {}
    end
    function Event:AddHandler(Handler)
        table.insert(self.Handlers, Handler)
    end
    function Event:RemoveHandler(Handler)
        for Key, Value in pairs(self.Handlers) do
            if Value == Handler then
                table.remove(self.Handlers, Key)
                return
            end
        end
        error("The handler was not found.")
    end
    function Event:Call(...)
        for Key, Handler in pairs(self.Handlers) do
            Handler(...)
        end
    end
end
Events = {}
EventFrame = CreateFrame("Frame")
CombatEvents = {}
SelfCombatEvents = {}
function EventFrame:RegisterForEvent(Handler, ...)
    local EventsTable = { ... }
    local Event
    for i = 1, #EventsTable do
        Event = EventsTable[i]
        if not Events[Event] then
            Events[Event] = { Handler }
            EventFrame:RegisterEvent(Event)
        else
            table.insert(Events[Event], Handler)
        end
    end
end
function EventFrame:RegisterForCombatEvent(Handler, ...)
    local EventsTable = { ... }
    local Event
    for i = 1, #EventsTable do
        Event = EventsTable[i]
        if not CombatEvents[Event] then
            CombatEvents[Event] = { Handler }
        else
            table.insert(CombatEvents[Event], Handler)
        end
    end
end
function EventFrame:RegisterForSelfCombatEvent(Handler, ...)
    local EventsTable = { ... }
    local Event
    for i = 1, #EventsTable do
        Event = EventsTable[i]
        if not SelfCombatEvents[Event] then
            SelfCombatEvents[Event] = { Handler }
        else
            table.insert(SelfCombatEvents[Event], Handler)
        end
    end
end
function EventFrame:UnregisterForEvent(Handler, Event)
    if Events[Event] then
        for Index, Function in pairs(Events[Event]) do
            if Function == Handler then
                table.remove(Events[Event], Index)
                if #Events[Event] == 0 then
                    EventFrame:UnregisterEvent(Event)
                end
                return
            end
        end
    end
end
function EventFrame:UnregisterForCombatEvent(Handler, Event)
    if CombatEvents[Event] then
        for Index, Function in pairs(CombatEvents[Event]) do
            if Function == Handler then
                table.remove(CombatEvents[Event], Index)
                return
            end
        end
    end
end
function EventFrame:UnregisterForSelfCombatEvent(Handler, Event)
    if SelfCombatEvents[Event] then
        for Index, Function in pairs(SelfCombatEvents[Event]) do
            if Function == Handler then
                table.remove(SelfCombatEvents[Event], Index)
                return
            end
        end
    end
end
EventFrame:SetScript(
"OnEvent",
function(self, Event, ...)
    for Index, Handler in pairs(Events[Event]) do
        Handler(...)
    end
end
)
EventFrame:RegisterForEvent(
function(TimeStamp, Event, ...)
    if CombatEvents[Event] then
        for Index, Handler in pairs(CombatEvents[Event]) do
            Handler(TimeStamp, Event, ...)
        end
    end
    C.PLAYERGUID = C.PLAYERGUID or UnitGUID("player")
    if SelfCombatEvents[Event] then
        if select(2, ...) == C.PLAYERGUID then
            for Index, Handler in pairs(SelfCombatEvents[Event]) do
                Handler(TimeStamp, Event, ...)
            end
        end
    end
end,
"COMBAT_LOG_EVENT_UNFILTERED"
)
EventFrame:RegisterForEvent(
function()
    local CurrentSpec = GetSpecialization()
    local CurrentSpecName = CurrentSpec and select(2, GetSpecializationInfo(CurrentSpec)) or C.CLASS
    local ProfileKey = C.CLASS .. "" .. CurrentSpecName
    ProfileName = SavedProfile()
    ShouldUpdate, ShouldUpdateTime = true, GetTime() + 0.25
end,
"ACTIVE_TALENT_GROUP_CHANGED"
)
UpdateFrame = CreateFrame("Frame")
function UpdateFrame.UpdateOptions()
    if SwitcherDropDown ~= nil and ShouldUpdate and ShouldUpdateTime < GetTime() then
        SelectedProfile = nil
        InitSettings()
        CurrentSavedProfileID = tonumber(RF(C.PROFILESPATH .. "Profile.json"))
        if CurrentSavedProfileID == nil then
            ProfileManager("Profile ID Not Found in file")
            CurrentSavedProfileID = 1
        end
        LoadProfile(CurrentSavedProfileID)
        ShouldUpdate, ShouldUpdateTime = false, 0
    end
end
UpdateFrame:SetScript("OnUpdate", UpdateFrame.UpdateOptions)
UpdateFrame:Show()
local NoPathTime, NoPathCleared = 0, true
EventFrame:RegisterForEvent(
function(...)
    local MessageID = select(1, ...)
    if MessageID == 50 then
        SpellStopTargeting()
        NoPathCleared = false
        NoPathTime = GetTime() + 1
    end
end,
"UI_ERROR_MESSAGE"
)
InLoadingScreen = 0
EventFrame:RegisterForEvent(
function(...)
    InLoadingScreen = GetTime() + 5
end,
"LOADING_SCREEN_ENABLED"
)
EventFrame:RegisterForEvent(
function(...)
    InLoadingScreen = GetTime() + 3
end,
"LOADING_SCREEN_DISABLED"
)
isMovingStartTime = 0
isStandingStartTime = GetTime()
EventFrame:RegisterForEvent(
function()
    isStandingStartTime = 0
    isMovingStartTime = GetTime()
end,
"PLAYER_STARTED_MOVING"
)
EventFrame:RegisterForEvent(
function()
    isMovingStartTime = 0
    isStandingStartTime = GetTime()
end,
"PLAYER_STOPPED_MOVING"
)
local AttackStarted
local function StartAttack(...)
    if
    IsRunning() and
    (GetSecondOptionValue("目标 | 攻击") == "启用" or
    (GetSecondOptionValue("目标 | 攻击") == "仅战斗状态时" and Player:IsInCombat())) and
    (IsOptionEnabled("自动进入战斗") or Player:IsInCombat()) and
    Target:Exists() and
    not Target:IsDeadOrGhost() and
    Player:CanAttack(Target) and
    not Player:IsMounted() and
    not Player:IsStealthed(true, true) and
    not UnitIsWildBattlePet("target")
    then
        RunMacroText("/StartAttack")
        AttackStarted = true
    end
    if AttackStarted and Player:IsStealthed(true, true) then
        RunMacroText("/StopAttack")
        AttackStarted = false
    end
end
EventFrame:RegisterForEvent(
function()
    UnitsEngine.Fetch()
    StartAttack()
end,
"PLAYER_TARGET_CHANGED"
)
EncounterID = 0
EventFrame:RegisterForEvent(
function(ID)
    EncounterDifficulty = select(3, GetInstanceInfo())
    EncounterID = ID
end,
"ENCOUNTER_START"
)
EventFrame:RegisterForEvent(
function()
    EncounterID = 0
end,
"ENCOUNTER_END"
)
if
C.CLASSINDEX == 1 or C.CLASSINDEX == 2 or C.CLASSINDEX == 6 or C.CLASSINDEX == 10 or C.CLASSINDEX == 11 or
C.CLASSINDEX == 12
then
    DamageTakenTable = {}
    local TotalAmount, LastCleanup, ThisKey = 0, GetTime() + 10, 1
    local function CleanupDamageTakenTable()
        if LastCleanup < GetTime() then
            local CleanedUpDamageTakenTable = {}
            for Key, Value in pairs(DamageTakenTable) do
                if GetTime() - DamageTakenTable[Key][1] < 15 then
                    CleanedUpDamageTakenTable[#CleanedUpDamageTakenTable + 1] = DamageTakenTable[Key]
                else
                end
            end
            DamageTakenTable = CleanedUpDamageTakenTable
            LastCleanup = GetTime() + 10
        end
    end
    EventFrame:RegisterForCombatEvent(
    function(...)
        if select(8, ...) == C.PLAYERGUID then
            CleanupDamageTakenTable()
            Amount, _, SpellSchool, Resisted, Blocked, Absorbed = select(12, ...)
            CurrentTime = GetTime()
            Resisted, Blocked, Absorbed = Resisted or 0, Blocked or 0, Absorbed or 0
            TotalAmount = Amount
            DamageTakenTable[#DamageTakenTable + 1] =             SpellSchool == 1 and { CurrentTime, TotalAmount, "Physical" } or { CurrentTime, TotalAmount, "Spell" }
        end
    end,
    "SWING_DAMAGE"
    )
    EventFrame:RegisterForCombatEvent(
    function(...)
        if select(8, ...) == C.PLAYERGUID then
            CleanupDamageTakenTable()
            Amount, _, SpellSchool, Resisted, Blocked, Absorbed = select(15, ...)
            CurrentTime = GetTime()
            Resisted, Blocked, Absorbed = Resisted or 0, Blocked or 0, Absorbed or 0
            TotalAmount = Amount
            DamageTakenTable[#DamageTakenTable + 1] =             SpellSchool == 1 and { CurrentTime, TotalAmount, "Physical" } or { CurrentTime, TotalAmount, "Spell" }
        end
    end,
    "RANGE_DAMAGE"
    )
    EventFrame:RegisterForCombatEvent(
    function(...)
        if select(8, ...) == C.PLAYERGUID and select(12, ...) ~= 124255 then
            CleanupDamageTakenTable()
            Amount, _, SpellSchool, Resisted, Blocked, Absorbed = select(15, ...)
            CurrentTime = GetTime()
            Resisted, Blocked, Absorbed = Resisted or 0, Blocked or 0, Absorbed or 0
            TotalAmount = Amount
            DamageTakenTable[#DamageTakenTable + 1] =             SpellSchool == 1 and { CurrentTime, TotalAmount, "Physical" } or { CurrentTime, TotalAmount, "Spell" }
        end
    end,
    "SPELL_DAMAGE",
    "SPELL_PERIODIC_DAMAGE",
    "SPELL_BUILDING_DAMAGE"
    )
end
EventFrame:RegisterForEvent(
function(prefixe, message)
    if prefixe == "D4" then
        local DBMPrefix, DBMTimer = strsplit("	", message)
        if DBMPrefix == "PT" then
            Bug("DBM - Pulltimer encountered: " .. message)
            BossModTime = tonumber(DBMTimer)
            BossModEndTime = GetTime() + BossModTime
        end
    elseif prefixe == "BigWigs" then
        local BigWigsPrefix, BigWigsMessage, BigWigsExtra = strsplit("^", message)
        if BigWigsPrefix == "P" and BigWigsMessage == "Pull" then
            Bug("BW - Pulltimer encountered: " .. message)
            BossModTime = tonumber(BigWigsExtra)
            BossModEndTime = GetTime() + BossModTime
        end
    end
end,
"CHAT_MSG_ADDON"
)
function BMPullTime()
    if not BossModTime or BossModTime == 0 or BossModEndTime - GetTime() < 0 then
        return 60
    else
        return BossModEndTime - GetTime()
    end
end
CombatStarted, CombatEnded, PotionUsed, PreventPotion = 0, 1, false, 0
EventFrame:RegisterForEvent(
function()
    CombatStarted = GetTime()
    CombatEnded = 0
    Bug("|cffFF0000Entering Combat")
    DisableBurst()
end,
"PLAYER_REGEN_DISABLED"
)
EventFrame:RegisterForEvent(
function()
    if PotionUsed == true then
        PreventPotion = GetTime() + 61
        PotionUsed = false
    end
    CombatStarted = 0
    CombatEnded = GetTime()
    OpenerStep, OpenerEnded = 1, false
    Bug("|cff00FF00Leaving Combat")
    PulseControl:DisableControl("Leaving Combat")
    PulseControl:QueueControl(1)
end,
"PLAYER_REGEN_ENABLED"
)
function CombatTime()
    if CombatStarted ~= 0 then
        CombatEntered = true
    end
    return CombatStarted ~= 0 and GetTime() - CombatStarted or 0
end
function OutOfCombatTime()
    return CombatEnded ~= 0 and GetTime() - CombatEnded or 0
end
function StartAttack(...)
    if
    EngineRunning and
    (GetSecondOptionValue("目标 | 攻击") == "启用" or
    (GetSecondOptionValue("目标 | 攻击") == "仅战斗状态时" and Player:IsInCombat())) and
    (IsOptionEnabled("自动进入战斗") or Player:IsInCombat()) and
    Target:Exists() and
    not Target:IsDeadOrGhost() and
    Player:CanAttack(Target) and
    not Player:IsMounted() and
    not Player:IsStealthed(true, true) and
    not UnitIsWildBattlePet("target")
    then
        RunMacroText("/StartAttack")
        AttackStarted = true
    end
    if AttackStarted and Player:IsStealthed(true, true) then
        RunMacroText("/StopAttack")
        AttackStarted = false
    end
end
EventFrame:RegisterForEvent(StartAttack, "PLAYER_TARGET_CHANGED")
EventFrame:RegisterForSelfCombatEvent(
function(...)
    if ISCL and ISCL[select(12, ...)] then
        StartedSpell = select(12, ...)
        SpellStartCastingTime = GetTime()
        if not PauseRotation then
            Bug("Spell Cast Started: |cFFFFFF00Rotation Paused")
        end
        PauseRotation = true
    end
end,
"SPELL_CAST_START"
)
EventFrame:RegisterForSelfCombatEvent(
function(...)
    if ISCL and ISCL[select(12, ...)] then
        if PauseRotation then
            Bug("Spell Cast Failed: |cFFFF0000Rotation Resumed")
        end
        PauseRotation = false
    end
end,
"SPELL_CAST_FAILED"
)
LastCastedSpells = {}
EventFrame:RegisterForSelfCombatEvent(
function(...)
    DestGUID, DestName, DestFlags, DestRaidFlags, SpellID = select(8, ...)
    LastCastedSpells[SpellID] = { Time = GetTime(), Unit = DestGUID }
    if ISCL and ISCL[select(12, ...)] then
        if PauseRotation then
            Bug("Spell Casted Successfully: |cFF00FF00Rotation Resumed")
        end
        PauseRotation = GetTime() + 0.05
    end
end,
"SPELL_CAST_SUCCESS"
)
TemporaryBlackList = {}
EventFrame:RegisterForEvent(
function(...)
    if GroundCastTarget then
        TemporaryBlackList[GroundCastTarget] = GetTime() + 0.5
    end
end,
"UNIT_SPELLCAST_FAILED_QUIET"
)
EventFrame:RegisterForEvent(
function(...)
    if ... == "Blizzard_TalentUI" then
        local TomeOfTheTranquilMind, CodexOfTheTranquilMind = Spell(227041), Spell(226234)
        for i = 1, 7 do
            for j = 1, 3 do
                _G["PlayerTalentFrameTalentsTalentRow" .. i .. "Talent" .. j]:SetScript(
                "OnClick",
                function(self)
                    if IsOptionEnabled("强制学习天赋") then
                        if
                        _G.IsResting() or Player:BuffAny(TomeOfTheTranquilMind) or
                        Player:BuffAny(CodexOfTheTranquilMind)
                        then
                            LearnTalent(self:GetID())
                            return
                        end
                        for i = 1, 3 do
                            RemoveTalent(self:GetParent().talents[i]:GetID())
                            RemoveTalent(self:GetParent().talents[i]:GetID())
                        end
                        UIErrorsFrame:Clear()
                        C_Timer.After(
                        0.5,
                        function()
                            LearnTalent(self:GetID())
                        end
                        )
                    else
                        LearnTalent(self:GetID())
                    end
                end
                )
            end
        end
    end
end,
"ADDON_LOADED"
)
PauseModiferChatNotifications = false
EventFrame:RegisterForEvent(
function(...)
    if not IsOptionEnabled("开关状态切换按键") then
        return
    end
    local Key, KeyState = ...
    if Key == GetOptionValue("开关状态切换按键") and KeyState == 1 then
        if IsOptionEnabled("聊天栏信息") then
            PauseModiferChatNotifications = true
            SetSetting("聊天栏信息_Checked", false)
        end
        ToggleRunning()
    end
    if Key == GetOptionValue("开关状态切换按键") and KeyState == 0 then
        ToggleRunning()
        if PauseModiferChatNotifications then
            SetSetting("聊天栏信息_Checked", true)
            PauseModiferChatNotifications = false
        end
    end
end,
"MODIFIER_STATE_CHANGED"
)
EventFrame:RegisterForEvent(
function(...)
    if not IsOptionEnabled("自动进副本") then
        return
    end
    C_Timer.After(
    math.random(GetOptionValue("自动进副本"), 12),
    function()
        _G.AcceptProposal()
    end
    )
end,
"LFG_PROPOSAL_SHOW"
)
function ActionLogInit()
    local Font = Locale == "zh" and ChineseFont or "Fonts\\ARKai_T.ttf"
    if not GetSetting("AL_AnchorPoint") then
        SetSetting("AL_AnchorPoint", "TOP")
    end
    if not GetSetting("AL_X") then
        SetSetting("AL_X", 0)
    end
    if not GetSetting("AL_Y") then
        SetSetting("AL_Y", -90)
    end
    stringLen = string.len
    log_height = 15
    log_items = 10
    abs_height = log_height * log_items + log_height + 5
    delta = 0
    ActionLog = CreateFrame("Frame", Randomize(24), UIParent)
    ActionLog.show = false
    ActionLog:SetWidth(250)
    ActionLog:SetHeight(abs_height)
    ActionLog:SetPoint(GetSetting("AL_AnchorPoint"), GetSetting("AL_X"), GetSetting("AL_Y"))
    ActionLog:SetFrameStrata("LOW")
    ActionLog:SetFrameLevel(90)
    ActionLog:SetMovable(true)
    ActionLog:EnableMouse(true)
    ActionLog:EnableMouseWheel(true)
    ActionLog:SetClampedToScreen(true)
    ActionLog:SetScale(1.3)
    Backdrop = { bgFile = "Interface\\ChatFrame\\ChatFrameBackground" }
    ActionLog:SetBackdrop(Backdrop)
    ActionLog:SetBackdropColor(ColorsTable.DarkGray.R, ColorsTable.DarkGray.R, ColorsTable.DarkGray.R, 0.8)
    ActionLog_texture = ActionLog:CreateTexture(nil, "BACKGROUND")
    ActionLog_texture:SetTexture(0, 0, 0, 0.9)
    ActionLog_texture:SetAllPoints(ActionLog)
    ActionLog.texture = ActionLogHeader_texture
    ActionLog:SetScript(
    "OnMouseDown",
    function(self, button)
        if not self.isMoving then
            self:StartMoving()
            self.isMoving = true
        end
    end
    )
    ActionLog:SetScript(
    "OnMouseUp",
    function(self, button)
        if self.isMoving then
            self:StopMovingOrSizing()
            self.isMoving = false
            local Point, RelativeTo, RelativePoint, X, Y = ActionLog:GetPoint()
            SetSetting("AL_AnchorPoint", Point)
            SetSetting("AL_X", X)
            SetSetting("AL_Y", Y)
        end
    end
    )
    ActionLog:SetScript(
    "OnHide",
    function(self)
        if self.isMoving then
            self:StopMovingOrSizing()
            self.isMoving = false
        end
    end
    )
    ActionLog:SetScript(
    "OnMouseWheel",
    function(self, mouse)
        local top = #actionLog.log - log_items
        if IsShiftKeyDown() then
            if mouse == 1 then
                delta = top
            elseif mouse == -1 then
                delta = 0
            end
        else
            if mouse == 1 then
                if delta < top then
                    delta = delta + mouse
                end
            elseif mouse == -1 then
                if delta > 0 then
                    delta = delta + mouse
                end
            end
        end
        actionLog.update()
    end
    )
    ActionLogDivA = CreateFrame("Frame", Randomize(24), ActionLog)
    ActionLogDivA:SetFrameLevel(99)
    ActionLogDivA:SetWidth(1)
    ActionLogDivA:SetHeight(abs_height)
    ActionLogDivA:SetPoint("LEFT", ActionLog, 125, 0)
    ActionLogDivA:SetMovable(true)
    ActionLogDivA_texture = ActionLogDivA:CreateTexture(nil, "BACKGROUND")
    ActionLogDivA_texture:SetTexture(0, 0, 0, 0.5)
    ActionLogDivA_texture:SetAllPoints(ActionLogDivA)
    ActionLogDivA.texture = ActionLogDivA_texture
    ActionLogDivB = CreateFrame("Frame", Randomize(24), ActionLog)
    ActionLogDivB:SetFrameLevel(99)
    ActionLogDivB:SetWidth(1)
    ActionLogDivB:SetHeight(abs_height)
    ActionLogDivB:SetPoint("LEFT", ActionLog, 375, 0)
    ActionLogDivB:SetMovable(true)
    ActionLogDivB_texture = ActionLogDivB:CreateTexture(nil, "BACKGROUND")
    ActionLogDivB_texture:SetTexture(0, 0, 0, 0.5)
    ActionLogDivB_texture:SetAllPoints(ActionLogDivB)
    ActionLogDivB.texture = ActionLogDivB_texture
    ActionLog:Hide()
    ActionLogHeader = CreateFrame("Frame", Randomize(24), ActionLog)
    ActionLogHeader:SetFrameLevel(92)
    ActionLogHeader:SetHeight(20)
    ActionLogHeader:SetPoint("TOPLEFT", ActionLog, "TOPLEFT", 1, -1)
    ActionLogHeader:SetPoint("TOPRIGHT", ActionLog, "TOPRIGHT", -1, -1)
    ActionLogHeader:SetBackdrop(Backdrop)
    ActionLogHeader:EnableMouse(true)
    ActionLogHeader:SetBackdropColor(0.184, 0.184, 0.184, 1)
    ActionLogHeader_texture = ActionLogHeader:CreateTexture(nil, "BACKGROUND")
    ActionLogHeader_texture:SetTexture(0.15, 0.15, 0.15, 1)
    ActionLogHeader_texture:SetGradient("VERTICAL", 0.8, 0.8, 0.8, 0, 0, 0)
    ActionLogHeader_texture:SetAllPoints(ActionLogHeader)
    ActionLogHeader.texture = ActionLogHeader_texture
    ActionLogHeader.statusTextA = ActionLogHeader:CreateFontString(DisplayName .. "_ActionLogHeaderText")
    ActionLogHeader.statusTextA:SetFont(Font, 9, 12)
    ActionLogHeader.statusTextA:SetPoint("LEFT", ActionLogHeader, 5, -1)
    ActionLogHeader.statusTextA:SetText((Locale == "zh" and "行动" or "动作"))
    ActionLogHeader.statusTextB = ActionLogHeader:CreateFontString(DisplayName .. "_ActionLogHeaderText")
    ActionLogHeader.statusTextB:SetFont(Font, 9, 12)
    ActionLogHeader.statusTextB:SetPoint("LEFT", ActionLogHeader, 80, -1)
    ActionLogHeader.statusTextB:SetText((Locale == "zh" and "描述" or "描述"))
    ActionLogHeader.statusTextC = ActionLogHeader:CreateFontString(DisplayName .. "_ActionLogHeaderText")
    ActionLogHeader.statusTextC:SetFont(Font, 9, 12)
    ActionLogHeader.statusTextC:SetPoint("RIGHT", ActionLogHeader, -4, -1)
    ActionLogHeader.statusTextC:SetText((Locale == "zh" and "战斗时间" or "战斗时间"))
    ActionLogHeader:SetScript(
    "OnMouseDown",
    function(self, button)
        if not ActionLog.isMoving then
            ActionLog:StartMoving()
            ActionLog.isMoving = true
        end
    end
    )
    ActionLogHeader:SetScript(
    "OnMouseUp",
    function(self, button)
        if ActionLog.isMoving then
            ActionLog:StopMovingOrSizing()
            ActionLog.isMoving = false
            local Point, RelativeTo, RelativePoint, X, Y = ActionLog:GetPoint()
            SetSetting("AL_AnchorPoint", Point)
            SetSetting("AL_X", X)
            SetSetting("AL_Y", Y)
        end
    end
    )
    ActionLogItem = {}
    for i = 1, (log_items) do
        ActionLogItem[i] = CreateFrame("Frame", Randomize(24), ActionLog)
        ActionLogItem[i]:SetFrameLevel(94)
        local texture = ActionLogItem[i]:CreateTexture(nil, "BACKGROUND")
        texture:SetAllPoints(ActionLogItem[i])
        if (i % 2) == 1 then
            texture:SetTexture(0.15, 0.15, 0.15, 1)
        else
            texture:SetTexture(0.1, 0.1, 0.1, 1)
        end
        ActionLogItem[i].texture = texture
        ActionLogItem[i]:SetHeight(log_height)
        ActionLogItem[i]:SetPoint("LEFT", ActionLog, "LEFT")
        ActionLogItem[i]:SetPoint("RIGHT", ActionLog, "RIGHT")
        ActionLogItem[i].itemA = ActionLogItem[i]:CreateFontString("itemA")
        ActionLogItem[i].itemA:SetFont(Font, 9)
        ActionLogItem[i].itemA:SetShadowColor(0, 0, 0, 0.8)
        ActionLogItem[i].itemA:SetShadowOffset(-1, -1)
        ActionLogItem[i].itemA:SetPoint("LEFT", ActionLogItem[i], 5, 0)
        ActionLogItem[i].itemB = ActionLogItem[i]:CreateFontString("itemA")
        ActionLogItem[i].itemB:SetFont(Font, 9)
        ActionLogItem[i].itemB:SetShadowColor(0, 0, 0, 0.8)
        ActionLogItem[i].itemB:SetShadowOffset(-1, -1)
        ActionLogItem[i].itemB:SetPoint("LEFT", ActionLogItem[i], 80, 0)
        ActionLogItem[i].itemC = ActionLogItem[i]:CreateFontString("itemA")
        ActionLogItem[i].itemC:SetFont(Font, 9)
        ActionLogItem[i].itemC:SetShadowColor(0, 0, 0, 0.8)
        ActionLogItem[i].itemC:SetShadowOffset(-1, -1)
        ActionLogItem[i].itemC:SetPoint("RIGHT", ActionLogItem[i], -3, 0)
        local position = ((i * log_height) * -1) - 4
        ActionLogItem[i]:SetPoint("TOPLEFT", ActionLog, "TOPLEFT", 0, position)
    end
    actionLog = { log = {} }
    actionLog.insert = function(type, spell, spellIcon, target)
        if spellIcon then
            if
            actionLog.log[1] and actionLog.log[1]["event"] == type and actionLog.log[1]["description"] == spell and
            actionLog.log[1]["target"] == target
            then
                actionLog.log[1]["count"] = actionLog.log[1]["count"] + 1
            else
                local Time = tostring(math.floor(CombatTime() * 1000) / 1000)
                local StringLenght = string.len(Time)
                if string.sub(Time, StringLenght - 2, StringLenght - 2) == "." then
                    Time = Time .. "0"
                elseif string.sub(Time, StringLenght - 1, StringLenght - 1) == "." then
                    Time = Time .. "00"
                end
                table.insert(
                actionLog.log,
                1,
                { event = type, target = target or "", icon = spellIcon, description = spell, count = 1, time = Time }
                )
                if delta > 0 and delta < #actionLog.log - log_items then
                    delta = delta + 1
                end
            end
        end
    end
    actionLog.updateRow = function(row, a, b, c)
        ActionLogItem[row].itemA:SetText(a)
        ActionLogItem[row].itemB:SetText(b)
        ActionLogItem[row].itemC:SetText(c)
    end
    actionLog.update = function()
        if UseActionLog() then
            if not ActionLog:IsShown() then
                ActionLog:Show()
            end
        else
            if ActionLog:IsShown() then
                ActionLog:Hide()
            end
        end
        local offset = 0
        for i = log_items, 1, -1 do
            offset = offset + 1
            local item = actionLog.log[offset + delta]
            if not item then
                actionLog.updateRow(i, "", "", "")
            else
                local target = stringLen(item.target) > 0 and " @ (" .. item.target .. ")" or ""
                actionLog.updateRow(
                i,
                item.event,
                "x" .. item.count .. " " .. "|T" .. item.icon .. ":-1:-1:0:0|t" .. item.description .. target,
                item.time
                )
            end
        end
    end
    function ActionLogUpdate()
        actionLog.update()
    end
    EventFrame:RegisterForSelfCombatEvent(
    function(...)
        DestGUID, _, _, _, SpellID = select(8, ...)
        SpellInfoName, _, SpellInfoIcon = GetSpellInfo(SpellID)
        actionLog.insert(Locale == "zh" and "铸造成功" or "Cast Success", SpellInfoName, SpellInfoIcon)
    end,
    "SPELL_CAST_SUCCESS"
    )
    EventFrame:RegisterForSelfCombatEvent(
    function(...)
        DestGUID, _, _, _, SpellID = select(8, ...)
        SpellInfoName, _, SpellInfoIcon = GetSpellInfo(SpellID)
        actionLog.insert(Locale == "zh" and "开始了" or "Cast Started", SpellInfoName, SpellInfoIcon)
    end,
    "SPELL_CAST_START"
    )
end
Commands = {}
CmdArgument = {}
ArgumentsInitialized = false
function RegisterCommand(Command, Function)
    Commands[Command:lower()] = Function
end
SlashRegisteredCommand = {}
function FindSlash()
    if not SlashRegisteredCommand[1] then
        local Global = _G
        local Index = 1
        for Key, Value in pairs(Global) do
            if type(Key) == "String" and string.sub(Key, 1, 6) == "SLASH_" and string.sub(Value, 1, 1) == "/" then
                SlashRegisteredCommand[Index] = string.sub(Value, 2)
                Index = Index + 1
            end
        end
    end
end
function CmdFunc(Message, EditBox)
    local Command = Message:sub(1, Message:find(" ") and Message:find(" ") - 1 or nil):lower()
    local Rest = Message:find(" ") and Message:sub(Message:find(" ") + 1) or ""
    if not Command then
        Print(Locale == "zh" and "未知的命令。" or "Unknown command.")
    else
        local Handler = Commands[Command]
        if Handler then
            Handler(Rest)
        else
            Print(Locale == "zh" and "未知的命令。" or "Unknown command.", Command)
        end
    end
end
function InitCommand()
    FindSlash()
    local CurrentCommand, CommandValidate = GetSetting("宏命令_Value1"), true
    if CurrentCommand ~= nil then
        for i = 1, #SlashRegisteredCommand do
            if SlashRegisteredCommand[i] == CurrentCommand then
                CommandValidate = false
                break
            end
        end
        if GetSetting("宏命令_Value1") == "" then
            CommandValidate = false
        end
    else
        CommandValidate = false
    end
    if CommandValidate then
        CommandName = GetSetting("宏命令_Value1")
    else
        CommandName = string.lower(Randomize(4, true))
        SetSetting("宏命令_Value1", CommandName)
        _G["StaticPopupDialogs"]["MacroReload"] = {
            text = (Locale == "zh" and "您现在应该重新加载用户界面，以使这些更改生效。 单击接受以重新加载或取消以在以后手动重新加载。" or
            "你现在应该重新加载插件为更改而生效.点击接受重载插件或点击取消手动重载插件"),
            button1 = (Locale == "zh" and "接受" or "接受"),
            button2 = (Locale == "zh" and "取消" or "取消"),
            OnShow = function(self, data)
                self.editBox:SetText("")
            end,
            OnAccept = function(self, data, data2)
                RunMacroText("/console reloadui")
            end,
            hasEditBox = false,
            timeout = 0,
            whileDead = true,
            hideOnEscape = true,
            preferredIndex = 3
        }
        _G["StaticPopupDialogs"]["MacroPopup"] = {
            text = (Locale == "zh" and
            "|cFFFF7D0A宏命令自定义|r\n\n\n您 |cFFFF0044需要键入替换|r 为您的宏命令。 您 |cFFFF0044不能|r 使用任何内置命令 (喜欢 '|cFF0066FFcast|r') 如 |cFFFF0044宏命令|r 字首.\n\n|cFF0066FF您将看到此窗口，直到您将其更改为其他。 |r\n\n你可以稍后更改 '|cFF66FF00高级|r' 标签 |cFF66FF00用户界面|r." or
            "|cFFFF7D0A自定义宏命令|r\n\n\n你|cFFFF0044需要输入|r你的宏命令. 你|cFFFF0044不能|r使用任何内置命令(比如'|cFF0066FFcast|r')作为|cFFFF0044宏命令|r前缀.\n\n|cFF0066FF你将看到此窗口,直到你将宏命令更改为其他. |r\n\n你可以更改它,到设置界面'|cFF66FF00高级设置|r'里面宏命令那里去更改它|r."),
            button1 = (Locale == "zh" and "接受" or "接受"),
            button2 = (Locale == "zh" and "取消" or "取消"),
            OnShow = function(self, data)
                self.editBox:SetText("")
            end,
            OnAccept = function(self, data, data2)
                local Text = self.editBox:GetText()
                SetSetting("宏命令_Value1", Text)
                _G["StaticPopup_Show"]("MacroReload")
            end,
            hasEditBox = true,
            timeout = 0,
            whileDead = true,
            hideOnEscape = true,
            preferredIndex = 3
        }
        _G["StaticPopup_Show"]("MacroPopup")
    end
    _G["SLASH_" .. string.upper(DisplayName) .. "1"] = "/" .. string.lower(DisplayName)
    _G["SlashCmdList"][string.upper(DisplayName)] = CmdFunc
    _G["SLASH_" .. string.upper(CommandName) .. "1"] = "/" .. string.lower(CommandName)
    _G["SlashCmdList"][string.upper(CommandName)] = CmdFunc
end
function InitArguments()
    if not ArgumentsInitialized then
        RegisterCommand(
        "toggle",
        function(Parts)
            ToggleRunning(Parts)
        end
        )
        RegisterCommand(
        "cds",
        function(Parts)
            ToggleCDs()
        end
        )
        RegisterCommand(
        "aoe",
        function(Parts)
            ToggleAoE()
        end
        )
        RegisterCommand(
        "cast",
        function(Spell)
            Queue.CastCmd(Spell)
        end
        )
        RegisterCommand(
        "castmouse",
        function(Spell)
            Queue.CastCmd(Spell, true)
        end
        )
        RegisterCommand(
        "castmouseover",
        function(Spell)
            Queue.CastCmd(Spell, false, true)
        end
        )
        RegisterCommand(
        "cancel",
        function(self)
            Queue.CancelCmd()
        end
        )
        RegisterCommand(
        "debug",
        function(Parts)
            ToggleDebug()
        end
        )
        RegisterCommand(
        "loadui",
        function(Name)
            DisableProfilesSwitcher()
            if not RF(C.PROFILESPATH .. "" .. Name .. ".json") then
                ProfileManager(Name .. (Locale == "zh" and " 个人资料不存在。" or " profile does not exist."))
                Overlay(Name .. (Locale == "zh" and " 个人资料不存在。" or " profile does not exist."))
                return
            end
            ProfileManager(
            (Locale == "zh" and "加载配置 " .. Name .. "。" or "Loading configuration |cFFEEEB16" .. Name .. ".")
            )
            Overlay((Locale == "zh" and "轮廓 " .. Name .. " 加载" or "Profile " .. Name .. " Loaded"))
            SelectProfile(Name)
            ClearOptions()
            GetActiveRotation():Initialize()
            CreateUI()
            EngineRunning = GetSetting("Running")
            AOEEnabled = GetSetting("AOE")
            AllowCooldowns = GetSetting("cds")
            DebugEnabled = GetSetting("调试")
            DebugFrameEnabled = GetSetting("调试窗口")
            ActionLogEnabled = GetSetting("ActionLog")
            StatusHidden = GetSetting("StatusVisible")
        end
        )
        RegisterCommand(
        "saveui",
        function(Name)
            DisableProfilesSwitcher()
            if Name == "" then
                WF(C.PROFILESPATH .. "All Class.json", json.encode(Settings.All))
                WF(C.PROFILESPATH .. "" .. ProfileName .. ".json", json.encode(Settings.Spec))
                ProfileManager(
                (Locale == "zh" and "保存当前配置 |cFFEEEB16" .. ProfileName .. "|r。" or
                "Saved the current configuration to |cFFEEEB16" .. ProfileName .. "|r.")
                )
                Overlay((Locale == "zh" and "轮廓 " .. Name .. " 保存" or "Profile " .. Name .. " Saved"))
            else
                WF(C.PROFILESPATH .. "All Class.json", json.encode(Settings.All))
                WF(C.PROFILESPATH .. "" .. Name .. ".json", json.encode(Settings.Spec))
                ProfileManager(
                (Locale == "zh" and "保存当前配置 |cFFEEEB16" .. Name .. "|r。" or
                "Saved the current configuration to |cFFEEEB16" .. Name .. "|r.")
                )
                Overlay((Locale == "zh" and "轮廓 " .. Name .. " 保存" or "Profile " .. Name .. " Saved"))
                if ProfileName ~= Name then
                    ProfileName = Name
                    SelectProfile(Name)
                    ClearOptions()
                    GetActiveRotation():Initialize()
                    CreateUI()
                end
            end
        end
        )
        RegisterCommand(
        "currentui",
        function()
            ProfileManager(
            (Locale == "zh" and "当前的配置文件是: |cFFEEEB16" .. GetProfile() or
            "The current profile is: |cFFEEEB16" .. GetProfile())
            )
        end
        )
        RegisterCommand(
        "defaultui",
        function()
            DisableProfilesSwitcher()
            if not RF(C.PROFILESPATH .. "" .. "默认" .. ".json") then
                ProfileManager((Locale == "zh" and "该配置文件不存在。" or "The profile does not exist."))
                return
            end
            SelectProfile("默认")
            ClearOptions()
            GetActiveRotation():Initialize()
            CreateUI()
            EngineRunning = GetSetting("Running")
            AOEEnabled = GetSetting("AOE")
            AllowCooldowns = GetSetting("cds")
            DebugEnabled = GetSetting("调试")
            DebugFrameEnabled = GetSetting("调试窗口")
            ActionLogEnabled = GetSetting("ActionLog")
            StatusHidden = GetSetting("StatusVisible")
        end
        )
        RegisterCommand(
        "ui",
        function(Parts)
            UICmd()
        end
        )
        RegisterCommand(
        "toggleoption",
        function(Name)
            if IsOptionEnabled(Name) == nil then
                Error((Locale == "zh" and "选项无效" or "Invalid Option"))
            elseif IsOptionEnabled(Name) == true then
                SetSetting(Name .. "_Checked", false)
                StatusUpdate((Locale == "zh" and Name .. " |cFFDF0101残" or Name .. " |cFFDF0101Disabled"))
                Overlay((Locale == "zh" and Name .. " |cFFDF0101残" or Name .. " |cFFDF0101Disabled"))
            elseif IsOptionEnabled(Name) == false then
                SetSetting(Name .. "_Checked", true)
                StatusUpdate((Locale == "zh" and Name .. " |cFF04B431启用" or Name .. " |cFF04B431Enabled"))
                Overlay((Locale == "zh" and Name .. " |cFF04B431启用" or Name .. " |cFF04B431Enabled"))
            end
            UpdateOptions()
        end
        )
        RegisterCommand(
        "changevalue",
        function(Arg)
            local function Split(Str, Pat)
                local t = {}
                local fpat = "(.-)" .. Pat
                local last_end = 1
                local s, e, cap = Str:find(fpat, 1)
                while s do
                    if s ~= 1 or cap ~= "" then
                        table.insert(t, cap)
                    end
                    last_end = e + 1
                    s, e, cap = Str:find(fpat, last_end)
                end
                if last_end <= #Str then
                    cap = Str:sub(last_end)
                    table.insert(t, cap)
                end
                return t
            end
            local Arguments = Split(Arg, ",")
            if Arguments[1] ~= nil and Arguments[2] ~= nil and Arguments[3] ~= nil then
                if GetOptionValue(Arguments[1]) == nil then
                    Error("Invalid Option")
                else
                    if Arguments[2] == "1" then
                        if type(GetSetting(Arguments[1] .. "_Value1")) == "number" then
                            local NewValue = tonumber(Arguments[3])
                            if NewValue and type(NewValue == "number") then
                                SetSetting(Arguments[1] .. "_Value1", NewValue)
                                StatusUpdate(Arguments[1] .. "'s first value changed to " .. Arguments[3])
                                Overlay(Arguments[1] .. " (1) - " .. Arguments[3])
                                UpdateOptions()
                            else
                                StatusUpdate(
                                Arguments[1] ..
                                "'s first Value could not be changed as it will only accept numbers."
                                )
                                Overlay(Arguments[1] .. " (1) - failed.")
                            end
                        else
                            SetSetting(Arguments[1] .. "_Value1", Arguments[3])
                            StatusUpdate(Arguments[1] .. "'s first value changed to " .. Arguments[3])
                            Overlay(Arguments[1] .. " (1) - " .. Arguments[3])
                            UpdateOptions()
                        end
                    elseif Arguments[2] == "2" then
                        if type(GetSetting(Arguments[1] .. "_Value2")) == "number" then
                            local NewValue = tonumber(Arguments[3])
                            if NewValue and type(NewValue == "number") then
                                SetSetting(Arguments[1] .. "_Value2", NewValue)
                                StatusUpdate(Arguments[1] .. "'s second value changed to " .. Arguments[3])
                                Overlay(Arguments[1] .. " (2) - " .. Arguments[3])
                                UpdateOptions()
                            else
                                StatusUpdate(
                                Arguments[1] ..
                                "'s second Value could not be changed as it will only accept numbers."
                                )
                                Overlay(Arguments[1] .. " (2) - failed.")
                            end
                        else
                            SetSetting(Arguments[1] .. "_Value2", Arguments[3])
                            StatusUpdate(Arguments[1] .. "'s second value changed to " .. Arguments[3])
                            Overlay(Arguments[1] .. " (2) - " .. Arguments[3])
                            UpdateOptions()
                        end
                    end
                end
            end
        end
        )
        RegisterCommand(
        "toggleon",
        function(Name)
            if IsOptionEnabled(Name) == nil then
                Error("Invalid Option")
            else
                SetSetting(Name .. "_Checked", true)
                StatusUpdate(Name .. " |cFF04B431Enabled")
                Overlay(Name .. " |cFF04B431Enabled")
            end
            UpdateOptions()
        end
        )
        RegisterCommand(
        "toggleoff",
        function(Name)
            if IsOptionEnabled(Name) == nil then
                Error("Invalid Option")
            else
                SetSetting(Name .. "_Checked", false)
                StatusUpdate(Name .. " |cFFDF0101Disabled")
                Overlay(Name .. " |cFFDF0101Disabled")
            end
            UpdateOptions()
        end
        )
        RegisterCommand(
        "tb",
        function(Parts)
            TbCmd()
        end
        )
        RegisterCommand(
        "custom",
        function(Parts)
            CustomFrame.Toggle()
        end
        )
        RegisterCommand(
        "status",
        function(Parts)
            StatusCmd()
        end
        )
        local function DisplayCommands()
            local MacroCommand = GetSetting("宏命令_Value1")
            if Locale == "zh" then
                Command(
                "启用/禁用旋转类型: |cFF26BAFF/" ..
                MacroCommand .. " toggle|r 你可以添加参数 |cFF26BAFFon (上)|r 要么 |cFF26BAFFoff (离)|r 在单独的宏中使用它。"
                )
                Command("启用/禁用用户界面选项: |cFF26BAFF/" .. MacroCommand .. " toggleoption OPTION_NAME")
                Command("启用用户界面选项: |cFF26BAFF/" .. MacroCommand .. " toggleon OPTION_NAME")
                Command("禁用用户界面选项: |cFF26BAFF/" .. MacroCommand .. " toggleoff OPTION_NAME")
                Command(
                "更改用户界面值的选项: |cFF26BAFF/" ..
                MacroCommand ..
                " changevalue OPTION_NAME,OPTION_POSITION,NEW_VALUE |cffFFFFFFOPTION_NAME: 选项的名称. OPTION_POSITION: 选项的位置（左= 1，右= 2，只有1 = 1）. NEW_VALUE: 必须是有效值. 参数必须用逗号（，）分隔，并且必须在前后没有空格。 例: |cFF26BAFF/" ..
                MacroCommand .. " changevalue 目标 | 攻击,1,血量最多"
                )
                Command("显示/隐藏用户界面类型: |cFF26BAFF/" .. MacroCommand .. " ui")
                Command("显示/隐藏工具箱类型: |cFF26BAFF/" .. MacroCommand .. " tb")
                Command("显示/隐藏自定义帧类型: |cFF26BAFF/" .. MacroCommand .. " custom")
                Command("重置用户界面框架位置: |cFF26BAFF/" .. MacroCommand .. " resetui")
                Command("保存用户界面设置: |cFF26BAFF/" .. MacroCommand .. " saveui NAME |cFFFFFFFFNAME: 配置文件的名称应该保存到")
                Command("加载以前保存的用户界面: |cFF26BAFF/" .. MacroCommand .. " loadui NAME |cFFFFFFFFNAME: 要加载的配置文件的名称")
                Command("要加载默认的用户界面: |cFF26BAFF/" .. MacroCommand .. " defaultui")
                Command("启用/禁用自动区域效果处理: |cFF26BAFF/" .. MacroCommand .. " aoe")
                Command("冷却时间切换: |cFF26BAFF/" .. MacroCommand .. " cds")
                Command("排队法术: |cFF26BAFF/" .. MacroCommand .. " cast SPELL_NAME")
                Command(
                "要使用小饰品进行排队，请选择要使用的合适的饰品插槽，trinket1 要么 trinket2: |cFF26BAFF/" ..
                MacroCommand .. " cast TRINKET_SLOT |cFFFFFFFFTRINKET_SLOT: trinekt1 要么 trinket2"
                )
                Command(
                "排队法术将其投射到鼠标光标上: |cFF26BAFF/" ..
                MacroCommand .. " castmouse SPELL_NAME |cFFFFFFFFSPELL_NAME: 您客户的语言中的法术名称"
                )
                Command(
                "排队法术将其投射到鼠标光标下的单位上: |cFF26BAFF/" ..
                MacroCommand .. " castmouseover SPELL_NAME |cFFFFFFFFSPELL_NAME: 您客户的语言中的法术名称"
                )
                Command("取消所有队列: |cFF26BAFF/" .. MacroCommand .. " cancel")
                Command("保存自定义中断文件， Default 将会选择名字 LIST_NAME 被省略: |cFF26BAFF/" .. MacroCommand .. " savecil LIST_NAME")
                Command("从文件加载自定义中断，Default 将会选择名字 LIST_NAME 被省略: |cFF26BAFF/" .. MacroCommand .. " loadcil LIST_NAME")
            else
                Command("切换开关:|cFF26BAFF/" .. MacroCommand .. " toggle")
                Command("启用/禁用GUI选项:|cFF26BAFF/" .. MacroCommand .. " toggleoption OPTION_NAME")
                Command("启用GUI选项:|cFF26BAFF/" .. MacroCommand .. " toggleon OPTION_NAME")
                Command("禁用GUI选项:|cFF26BAFF/" .. MacroCommand .. " toggleoff OPTION_NAME")
                Command(
                "更改GUI选项的值:|cFF26BAFF/" ..
                MacroCommand ..
                " changevalue OPTION_NAME,OPTION_POSITION,NEW_VALUE |cffFFFFFFOption Name: 选项的名称.Option Position: 选项位置(左 = 1, 右 = 2, 只有一个选项 = 1). New Value:必须是有效的选项. 参数必须用逗号(,)分隔,并且在coma之前和之后都不得有空格. 例如:|cFF26BAFF/" ..
                MacroCommand .. " changevalue 目标 | 攻击,1,血量最多"
                )
                Command("显示/隐藏设置界面:|cFF26BAFF/" .. MacroCommand .. " ui")
                Command("显示/隐藏SBR主界面:|cFF26BAFF/" .. MacroCommand .. " tb")
                Command("显示/隐自定义界面:|cFF26BAFF/" .. MacroCommand .. " custom")
                Command("重置用户界面框架位置:|cFF26BAFF/" .. MacroCommand .. " resetui")
                Command("保存UI设置:|cFF26BAFF/" .. MacroCommand .. " saveui 名字")
                Command("加载以前保存的UI:|cFF26BAFF/" .. MacroCommand .. " loadui 名字")
                Command("加载默认,自动保存UI:|cFF26BAFF/" .. MacroCommand .. " defaultui")
                Command("启用/禁用AOE:|cFF26BAFF/" .. MacroCommand .. " aoe")
                Command("大技能切换:|cFF26BAFF/" .. MacroCommand .. " cds")
                Command("法术列队:|cFF26BAFF/" .. MacroCommand .. " cast SPELL_NAME")
                Command("饰品列队:|cFF26BAFF/" .. MacroCommand .. " cast TRINKET_SLOT")
                Command("鼠标位置上的技能排队:|cFF26BAFF/" .. MacroCommand .. " castmouse SPELL_NAME")
                Command("在鼠标位置单位技能排队:|cFF26BAFF/" .. MacroCommand .. " castmouseover SPELL_NAME")
                Command("取消所有列队: |cFF26BAFF/" .. MacroCommand .. " cancel")
                Command("将自定义打断保存到C盘:|cFF26BAFF/" .. MacroCommand .. " savecil LIST_NAME")
                Command("从C盘加载自定义打断文件:|cFF26BAFF/" .. MacroCommand .. " loadcil LIST_NAME")
            end
        end
        RegisterCommand(
        "commands",
        function(self)
            DisplayCommands()
        end
        )
        RegisterCommand(
        "help",
        function(self)
            DisplayCommands()
        end
        )
        RegisterCommand(
        "loadcil",
        function(Name)
            if Name == "" then
                Name = "默认"
            end
            CustomFrame.LoadCILCmd(Name)
        end
        )
        RegisterCommand(
        "savecil",
        function(Name)
            if Name == "" then
                Name = "默认"
            end
            CustomFrame.SaveCILCmd(Name)
        end
        )
        RegisterCommand(
        "resetui",
        function(self)
            SetSetting("UI_AnchorPoint", "CENTER")
            SetSetting("UI_X", 250)
            SetSetting("UI_Y", 30)
            SetSetting("ToolboxAnchorPoint", "CENTER")
            SetSetting("ToolboxX", 0)
            SetSetting("ToolboxY", -140)
            SetSetting("ToolboxRows", 3)
            SetSetting("DebugFrameAnchorPoint", "CENTER")
            SetSetting("DebugFrameX", -250)
            SetSetting("DebugFrameY", 30)
            SetSetting("AL_AnchorPoint", "TOP")
            SetSetting("AL_X", 0)
            SetSetting("AL_Y", -90)
            SetSetting("CL_AnchorPoint", "CENTER")
            SetSetting("CL_X", 0)
            SetSetting("CL_Y", 21)
            SettingsForceUpdate = true
            Settings.Update()
            RunMacroText("/console reloadui")
        end
        )
    end
end
function CustomSettingsInit()
    local Font = Locale == "zh" and ChineseFont or "Fonts\\ARKai_T.ttf"
    if not GetSetting("CL_AnchorPoint") then
        SetSetting("CL_AnchorPoint", "CENTER")
    end
    if not GetSetting("CL_X") then
        SetSetting("CL_X", 0)
    end
    if not GetSetting("CL_Y") then
        SetSetting("CL_Y", 21)
    end
    ItemHeight, MaxItems, TotalHeight = 15, 10, 185
    CustomFrame = CreateFrame("Frame", Randomize(24), UIParent)
    CustomFrame:SetWidth(120)
    CustomFrame:SetHeight(TotalHeight)
    CustomFrame:SetPoint(GetSetting("CL_AnchorPoint"), GetSetting("CL_X"), GetSetting("CL_Y"))
    CustomFrame:SetFrameStrata("LOW")
    CustomFrame:SetFrameLevel(75)
    CustomFrame:SetMovable(true)
    CustomFrame:EnableMouse(true)
    CustomFrame:EnableMouseWheel(true)
    CustomFrame:SetClampedToScreen(true)
    CustomFrame:SetScale(1.4)
    CustomFrame:Hide()
    local Backdrop = { bgFile = "Interface\\ChatFrame\\ChatFrameBackground" }
    CustomFrame:SetBackdrop(Backdrop)
    CustomFrame:SetBackdropColor(ColorsTable.DarkGray.R, ColorsTable.DarkGray.R, ColorsTable.DarkGray.R, 0.8)
    CustomFrame.Texture = CustomFrame:CreateTexture(nil, "BACKGROUND")
    CustomFrame.Texture:SetTexture(0, 0, 0, 0.9)
    CustomFrame.Texture:SetAllPoints(CustomFrame)
    CustomFrame:SetScript(
    "OnMouseDown",
    function(self, button)
        if not self.isMoving then
            self:StartMoving()
            self.isMoving = true
        end
    end
    )
    CustomFrame:SetScript(
    "OnMouseUp",
    function(self, button)
        if self.isMoving then
            self:StopMovingOrSizing()
            self.isMoving = false
            self:StorePositions()
        end
    end
    )
    CustomFrame:SetScript(
    "OnHide",
    function(self)
        if self.isMoving then
            self:StopMovingOrSizing()
            self.isMoving = false
        end
    end
    )
    CustomFrame:SetScript(
    "OnMouseWheel",
    function(self, Mouse)
        if Mouse == -1 then
            if CustomFrame.Position < #CustomFrame.Lists[CustomFrame.CurrentList] - 10 then
                CustomFrame.Position = CustomFrame.Position + 1
            end
        elseif Mouse == 1 then
            if CustomFrame.Position > 0 then
                CustomFrame.Position = CustomFrame.Position - 1
            end
        end
        CustomFrame.UpdateOutputs()
    end
    )
    function CustomFrame:StorePositions()
        local Point, RelativeTo, RelativePoint, X, Y = self:GetPoint()
        SetSetting("CL_AnchorPoint", Point)
        SetSetting("CL_X", X)
        SetSetting("CL_Y", Y)
    end
    CustomFrame.StoredLists = { { "打断施法", "中断" }, { "黑名单", "黑名单" } }
    CustomFrame.CurrentList = 1
    function CustomFrame:CycleList(Next)
        if Next and CustomFrame.CurrentList < #CustomFrame.StoredLists then
            CustomFrame.CurrentList = CustomFrame.CurrentList + 1
        elseif not Next and CustomFrame.CurrentList > 1 then
            CustomFrame.CurrentList = CustomFrame.CurrentList - 1
        end
        CustomFrame.Position = 0
    end
    function CustomFrame:AddRemove(ValueToAdd)
        local ValueToAdd, Removed = ValueToAdd or tonumber(CustomFrame.BottomBar.EditField.EditBox:GetText()), false
        local ThisList = CustomFrame.Lists[CustomFrame.CurrentList]
        if
        CustomFrame.CurrentList == 2 and not CustomFrame.BottomBar.EditField.EditBox:HasFocus() and Target:Exists() and
        not Target:IsPlayer()
        then
            ValueToAdd = tonumber(Target:CreatureID())
        end
        if
        CustomFrame.CurrentList == 1 and not CustomFrame.BottomBar.EditField.EditBox:HasFocus() and Target:Exists() and
        Target:IsCasting()
        then
            ValueToAdd = tonumber(select(10, Target:IsCasting()))
        end
        for Key, Value in pairs(ThisList) do
            if Value == ValueToAdd then
                table.remove(ThisList, Key)
                Removed = true
            end
        end
        if not Removed then
            table.insert(ThisList, ValueToAdd)
            table.sort(
            ThisList,
            function(a, b)
                return a < b
            end
            )
        end
        CustomFrame.SaveLists()
        CustomFrame.UpdateOutputs()
        CustomFrame.BottomBar.EditField.EditBox:SetText("")
        CustomFrame.BottomBar.EditField.EditBox:ClearFocus()
    end
    CustomFrame.TitleBar = CreateFrame("Frame", nil, CustomFrame)
    CustomFrame.TitleBar:SetPoint("TOPLEFT", 1, -1)
    CustomFrame.TitleBar:SetPoint("TOPRIGHT", -1, -1)
    CustomFrame.TitleBar:SetFrameLevel(76)
    CustomFrame.TitleBar:SetHeight(15)
    CustomFrame.TitleBar:SetBackdrop(Backdrop)
    CustomFrame.TitleBar:SetBackdropColor(0.184, 0.184, 0.184, 1)
    CustomFrame.TitleBar:EnableMouse(true)
    CustomFrame.TitleBar:SetScript(
    "OnMouseDown",
    function(self)
        CustomFrame:StartMoving()
    end
    )
    CustomFrame.TitleBar:SetScript(
    "OnMouseUp",
    function(self)
        CustomFrame:StopMovingOrSizing()
        CustomFrame:StorePositions()
    end
    )
    CustomFrame.TitleBar.PreviousPageButton = CreateFrame("Button", nil, CustomFrame.TitleBar)
    CustomFrame.TitleBar.PreviousPageButton:SetPoint("TOPLEFT", CustomFrame.TitleBar, "TOPLEFT", 2, -2)
    CustomFrame.TitleBar.PreviousPageButton:SetPoint("BOTTOMRIGHT", CustomFrame.TitleBar, "TOPLEFT", 12, -12)
    CustomFrame.TitleBar.PreviousPageButton:SetFrameLevel(77)
    CustomFrame.TitleBar.PreviousPageButton:SetBackdrop(Backdrop)
    CustomFrame.TitleBar.PreviousPageButton:SetBackdropColor(
    ColorsTable.Gray.R,
    ColorsTable.Gray.G,
    ColorsTable.Gray.B,
    0.75
    )
    CustomFrame.TitleBar.PreviousPageButton:SetScript(
    "PostClick",
    function(self)
        CustomFrame:CycleList(false)
        if CustomFrame.CurrentList < #CustomFrame.StoredLists then
            CustomFrame.TitleBar.NextPageButton:SetBackdropColor(
            ColorsTable.Red.R,
            ColorsTable.Red.G,
            ColorsTable.Red.B,
            0.75
            )
        end
        if CustomFrame.CurrentList == 1 then
            CustomFrame.TitleBar.PreviousPageButton:SetBackdropColor(
            ColorsTable.Gray.R,
            ColorsTable.Gray.G,
            ColorsTable.Gray.B,
            0.75
            )
        end
        CustomFrame.UpdateOutputs()
        if CustomFrame.CurrentList == 1 then
            GameTooltip:Hide()
        end
    end
    )
    CustomFrame.TitleBar.PreviousPageButton:SetScript(
    "OnEnter",
    function(self)
        if CustomFrame.CurrentList ~= 1 then
            GameTooltip:SetOwner(self, "ANCHOR_TOPRIGHT")
            GameTooltip:ClearLines()
            GameTooltip:SetBackdropColor(0, 0, 0, 1)
            GameTooltip:SetText((Locale == "zh" and "|cffFFFFFF循环到上一页。" or "|cffFFFFFF上一页"), nil, nil, nil, 1, true)
        end
    end
    )
    CustomFrame.TitleBar.PreviousPageButton:SetScript(
    "OnLeave",
    function(self)
        GameTooltip:Hide()
    end
    )
    CustomFrame.TitleBar.PageTitle = CustomFrame.TitleBar:CreateFontString()
    CustomFrame.TitleBar.PageTitle:SetPoint("TOPLEFT", CustomFrame.TitleBar, "TOPLEFT", 1, -3)
    CustomFrame.TitleBar.PageTitle:SetPoint("BOTTOMRIGHT", CustomFrame.TitleBar, "TOPRIGHT", -1, -13)
    CustomFrame.TitleBar.PageTitle:SetFont(Font, 10, "OUTLINE")
    CustomFrame.TitleBar.PageTitle:SetJustifyH("CENTER")
    CustomFrame.TitleBar.NextPageButton = CreateFrame("Button", nil, CustomFrame.TitleBar)
    CustomFrame.TitleBar.NextPageButton:SetPoint("TOPRIGHT", CustomFrame.TitleBar, "TOPRIGHT", -2, -2)
    CustomFrame.TitleBar.NextPageButton:SetPoint("BOTTOMLEFT", CustomFrame.TitleBar, "TOPRIGHT", -12, -12)
    CustomFrame.TitleBar.NextPageButton:SetFrameLevel(77)
    CustomFrame.TitleBar.NextPageButton:SetBackdrop(Backdrop)
    CustomFrame.TitleBar.NextPageButton:SetBackdropColor(ColorsTable.Red.R, ColorsTable.Red.G, ColorsTable.Red.B, 0.75)
    CustomFrame.TitleBar.NextPageButton:SetScript(
    "PostClick",
    function(self)
        CustomFrame:CycleList(true)
        if CustomFrame.CurrentList == #CustomFrame.StoredLists then
            CustomFrame.TitleBar.NextPageButton:SetBackdropColor(
            ColorsTable.Gray.R,
            ColorsTable.Gray.G,
            ColorsTable.Gray.B,
            0.75
            )
        end
        if CustomFrame.CurrentList > 1 then
            CustomFrame.TitleBar.PreviousPageButton:SetBackdropColor(
            ColorsTable.Red.R,
            ColorsTable.Red.G,
            ColorsTable.Red.B,
            0.75
            )
        end
        CustomFrame.UpdateOutputs()
        if CustomFrame.CurrentList == #CustomFrame.StoredLists then
            GameTooltip:Hide()
        end
    end
    )
    CustomFrame.TitleBar.NextPageButton:SetScript(
    "OnEnter",
    function(self)
        if CustomFrame.CurrentList < #CustomFrame.StoredLists then
            GameTooltip:SetOwner(self, "ANCHOR_TOPRIGHT")
            GameTooltip:ClearLines()
            GameTooltip:SetBackdropColor(0, 0, 0, 1)
            GameTooltip:SetText((Locale == "zh" and "|cffFFFFFF循环到下一页。" or "|cffFFFFFF下一页"), nil, nil, nil, 1, true)
        end
    end
    )
    CustomFrame.TitleBar.NextPageButton:SetScript(
    "OnLeave",
    function(self)
        GameTooltip:Hide()
    end
    )
    CustomFrame.BottomBar = CreateFrame("Frame", nil, CustomFrame)
    CustomFrame.BottomBar:SetPoint("TOPLEFT", CustomFrame, "BOTTOMLEFT", 0, 18)
    CustomFrame.BottomBar:SetPoint("BOTTOMRIGHT", CustomFrame, "BOTTOMRIGHT", 0, 0)
    CustomFrame.BottomBar:SetFrameLevel(76)
    CustomFrame.BottomBar:SetHeight(18)
    CustomFrame.BottomBar:SetBackdrop(Backdrop)
    CustomFrame.BottomBar:SetBackdropColor(0.15, 0.15, 0.15, 1)
    CustomFrame.BottomBar:EnableMouse(true)
    CustomFrame.BottomBar:SetScript(
    "OnMouseDown",
    function(self)
        CustomFrame:StartMoving()
    end
    )
    CustomFrame.BottomBar:SetScript(
    "OnMouseUp",
    function(self)
        CustomFrame:StopMovingOrSizing()
        CustomFrame:StorePositions()
    end
    )
    CustomFrame.BottomBar.EditField = CreateFrame("Frame", nil, CustomFrame.BottomBar)
    CustomFrame.BottomBar.EditField:SetPoint("TOPLEFT", CustomFrame, "BOTTOMLEFT", 0, 18)
    CustomFrame.BottomBar.EditField:SetPoint("BOTTOMRIGHT", CustomFrame, "BOTTOMRIGHT", -18, 0)
    CustomFrame.BottomBar.EditField:SetFrameLevel(77)
    CustomFrame.BottomBar.EditField:SetBackdrop(Backdrop)
    CustomFrame.BottomBar.EditField:SetBackdropColor(0.35, 0.35, 0.35, 1)
    CustomFrame.BottomBar.EditField:EnableMouse(true)
    CustomFrame.BottomBar.EditField.EditBox = CreateFrame("EditBox", nil, CustomFrame.BottomBar.EditField)
    CustomFrame.BottomBar.EditField.EditBox:SetPoint("TOPLEFT", CustomFrame.BottomBar, "TOPLEFT", 3, -1)
    CustomFrame.BottomBar.EditField.EditBox:SetPoint("BOTTOMRIGHT", CustomFrame.BottomBar, "TOPRIGHT", -15, -18)
    CustomFrame.BottomBar.EditField.EditBox:SetWidth(100)
    CustomFrame.BottomBar.EditField.EditBox:SetHeight(18)
    CustomFrame.BottomBar.EditField.EditBox:SetFont(Font, 10, "OUTLINE")
    CustomFrame.BottomBar.EditField.EditBox:SetAutoFocus(false)
    CustomFrame.BottomBar.EditField.EditBox:SetText((Locale == "zh" and "法术编号" or "技能ID"))
    CustomFrame.BottomBar.EditField.EditBox:SetScript(
    "OnEnterPressed",
    function(self)
        CustomFrame:AddRemove()
    end
    )
    CustomFrame.BottomBar.EditField.EditBox:SetScript(
    "OnEscapePressed",
    function(self)
        self:ClearFocus()
    end
    )
    CustomFrame.BottomBar.EditField.EditBox:SetScript(
    "OnEditFocusGained",
    function(self)
        self:SetMaxLetters(10)
        self:SetNumeric(true)
        self:SetText("")
    end
    )
    CustomFrame.BottomBar.EditField.EditBox:SetScript(
    "OnEditFocusLost",
    function(self)
        self:SetMaxLetters(12)
        self:SetNumeric(false)
        if CustomFrame.CurrentList == 1 then
            self:SetText((Locale == "zh" and "法术编号" or "技能ID"))
        elseif CustomFrame.CurrentList == 2 then
            self:SetText((Locale == "zh" and "生物编号" or "生物ID"))
        end
    end
    )
    CustomFrame.BottomBar.AddRemove = CreateFrame("Button", nil, CustomFrame.BottomBar)
    CustomFrame.BottomBar.AddRemove:SetPoint("TOPRIGHT", CustomFrame.BottomBar, "TOPRIGHT", 0, 0)
    CustomFrame.BottomBar.AddRemove:SetPoint("BOTTOMLEFT", CustomFrame.BottomBar, "TOPRIGHT", -18, -18)
    CustomFrame.BottomBar.AddRemove:SetFrameLevel(77)
    CustomFrame.BottomBar.AddRemove:SetBackdrop(Backdrop)
    CustomFrame.BottomBar.AddRemove:SetBackdropColor(ColorsTable.Red.R, ColorsTable.Red.G, ColorsTable.Red.B, 0.75)
    CustomFrame.BottomBar.AddRemove:SetScript(
    "PostClick",
    function(self)
        CustomFrame:AddRemove()
    end
    )
    CustomFrame.BottomBar.AddRemove:SetScript(
    "OnEnter",
    function(self)
        GameTooltip:SetOwner(self, "ANCHOR_BOTTOMRIGHT")
        GameTooltip:ClearLines()
        GameTooltip:SetBackdropColor(0, 0, 0, 1)
        if CustomFrame.CurrentList == 1 then
            GameTooltip:SetText(
            (Locale == "zh" and
            "|cffFFFFFF单击此按钮可以从自定义中断列表添加或删除拼写号码。\n\n当敌人开始投射时，您也可以点击此按钮直接将该法术添加到列表中。\n\n|cffFF2211直接插入功能仅适用于演员，而不适用于频道，请手动插入拼写号码。" or
            "|cffFFFFFF点击此按钮从自定义打断列表添加或删除法术ID. \n\n当敌人开始施放法术时,你也可以点击此按钮直接将该法术添加到列表中.\n\n|cffFF2211The direct insert feature only works with Casts, not with Channels, for Channels, please insert the Spell ID manually."),
            nil,
            nil,
            nil,
            1,
            true
            )
        elseif CustomFrame.CurrentList == 2 then
            GameTooltip:SetText(
            (Locale == "zh" and
            "|cffFFFFFF单击此按钮可以从自定义黑名单添加或删除生物编号。\n\n当您瞄准敌人直接添加敌人时，您也可以点击此按钮。\n\n|cffFF2211不适用于玩家。" or
            "|cffFFFFFF单击此按钮可以从自定义黑名单添加或删除生物ID. \n\n当你瞄准敌人时,你也可以点击此按钮添加. \n\n|cffFF2211不适用于玩家."),
            nil,
            nil,
            nil,
            1,
            true
            )
        end
        GameTooltip:Show()
    end
    )
    CustomFrame.BottomBar.AddRemove:SetScript(
    "OnLeave",
    function(self)
        GameTooltip:Hide()
    end
    )
    CustomFrame.BottomBar.AddRemove.Text = CustomFrame.BottomBar.AddRemove:CreateFontString()
    CustomFrame.BottomBar.AddRemove.Text:SetPoint("TOPLEFT", CustomFrame.BottomBar.AddRemove, "TOPLEFT", 2, 0)
    CustomFrame.BottomBar.AddRemove.Text:SetPoint("BOTTOMRIGHT", CustomFrame.BottomBar.AddRemove, "TOPRIGHT", 0, -18)
    CustomFrame.BottomBar.AddRemove.Text:SetFont(Font, 7, "OUTLINE")
    CustomFrame.BottomBar.AddRemove.Text:SetJustifyH("CENTER")
    CustomFrame.BottomBar.AddRemove.Text:SetText("+/-")
    CustomFrame.Items = {}
    CustomFrame.Position = 0
    for i = 1, 10 do
        CustomFrame.Items[i] = CreateFrame("Frame", nil, CustomFrame)
        CustomFrame.Items[i]:SetPoint("TOPLEFT", CustomFrame, "TOPLEFT", 2, -(1 + i * 15))
        CustomFrame.Items[i]:SetFrameLevel(75)
        CustomFrame.Items[i]:SetHeight(14)
        CustomFrame.Items[i]:SetWidth(116)
        CustomFrame.Items[i]:SetBackdrop(Backdrop)
        CustomFrame.Items[i]:SetBackdropColor(0.15, 0.15, 0.15, 1)
        CustomFrame.Items[i]:EnableMouse(true)
        CustomFrame.Items[i].BackGround = CreateFrame("Frame", nil, CustomFrame.Items[i])
        CustomFrame.Items[i].BackGround:SetPoint("TOPLEFT", -1, 1)
        CustomFrame.Items[i].BackGround:SetPoint("TOPRIGHT", -1, 1)
        CustomFrame.Items[i].BackGround:SetFrameLevel(74)
        CustomFrame.Items[i].BackGround:SetHeight(15)
        CustomFrame.Items[i].BackGround:SetBackdrop(Backdrop)
        CustomFrame.Items[i].BackGround:SetBackdropColor(
        ColorsTable.LightGray.R,
        ColorsTable.LightGray.G,
        ColorsTable.LightGray.B,
        0.75
        )
        CustomFrame.Items[i].BackGround:Show()
        CustomFrame.Items[i].ID = CustomFrame.Items[i]:CreateFontString()
        CustomFrame.Items[i].ID:SetPoint("TOPLEFT", CustomFrame.Items[i], "TOPLEFT", 3, -3)
        CustomFrame.Items[i].ID:SetPoint("BOTTOMRIGHT", CustomFrame.Items[i], "TOPRIGHT", -1, -13)
        CustomFrame.Items[i].ID:SetFont(Font, 10, "OUTLINE")
        CustomFrame.Items[i].ID:SetJustifyH("LEFT")
        CustomFrame.Items[i].Text = CustomFrame.Items[i]:CreateFontString()
        CustomFrame.Items[i].Text:SetPoint("TOPLEFT", CustomFrame.Items[i], "TOPLEFT", 25, -2)
        CustomFrame.Items[i].Text:SetPoint("BOTTOMRIGHT", CustomFrame.Items[i], "TOPRIGHT", -1, -13)
        CustomFrame.Items[i].Text:SetFont(Font, 10, "OUTLINE")
        CustomFrame.Items[i].Text:SetJustifyH("LEFT")
        CustomFrame.Items[i].Info = CreateFrame("Frame", nil, CustomFrame.Items[i])
        CustomFrame.Items[i].Info:SetPoint("TOPLEFT", CustomFrame.Items[i], "TOPLEFT", 3, -2)
        CustomFrame.Items[i].Info:SetPoint("BOTTOMRIGHT", CustomFrame.Items[i], "TOPRIGHT", -14, -12)
        CustomFrame.Items[i].Info:SetFrameLevel(77)
        CustomFrame.Items[i].Info:SetBackdrop(Backdrop)
        CustomFrame.Items[i].Info:SetBackdropColor(
        ColorsTable.DarkGray.R,
        ColorsTable.DarkGray.G,
        ColorsTable.DarkGray.B,
        0
        )
        CustomFrame.Items[i].Info:SetScript(
        "OnEnter",
        function(self)
            GameTooltip:SetOwner(self, "ANCHOR_TOPLEFT")
            GameTooltip:ClearLines()
            GameTooltip:SetBackdropColor(0, 0, 0, 1)
            if CustomFrame.CurrentList == 1 then
                if
                GetSpellInfo(tonumber(CustomFrame.Items[i].Text:GetText())) ~= nil and
                type(GetSpellInfo(tonumber(CustomFrame.Items[i].Text:GetText()))) == "string"
                then
                    GameTooltip:SetText(
                    "|cffFFFFFF" .. GetSpellInfo(tonumber(CustomFrame.Items[i].Text:GetText())),
                    nil,
                    nil,
                    nil,
                    1,
                    true
                    )
                else
                    GameTooltip:SetText(
                    (Locale == "zh" and "|cffFFFFFF法术号无效。" or "|cffFFFFFFInvalid Spell Number."),
                    nil,
                    nil,
                    nil,
                    1,
                    true
                    )
                end
            end
        end
        )
        CustomFrame.Items[i].Info:SetScript(
        "OnLeave",
        function(self)
            GameTooltip:Hide()
        end
        )
        CustomFrame.Items[i].Info:SetScript(
        "OnMouseDown",
        function(self)
            CustomFrame:StartMoving()
        end
        )
        CustomFrame.Items[i].Info:SetScript(
        "OnMouseUp",
        function(self)
            CustomFrame:StopMovingOrSizing()
            CustomFrame:StorePositions()
        end
        )
        CustomFrame.Items[i].Remove = CreateFrame("Button", nil, CustomFrame.Items[i])
        CustomFrame.Items[i].Remove:SetPoint("TOPRIGHT", CustomFrame.Items[i], "TOPRIGHT", -2, -2)
        CustomFrame.Items[i].Remove:SetPoint("BOTTOMLEFT", CustomFrame.Items[i], "TOPRIGHT", -12, -12)
        CustomFrame.Items[i].Remove:SetFrameLevel(77)
        CustomFrame.Items[i].Remove:SetBackdrop(Backdrop)
        CustomFrame.Items[i].Remove:SetBackdropColor(ColorsTable.Red.R, ColorsTable.Red.G, ColorsTable.Red.B, 0.75)
        CustomFrame.Items[i].Remove:SetScript(
        "PostClick",
        function(self)
            CustomFrame:AddRemove(tonumber(CustomFrame.Items[i].Text:GetText()))
            CustomFrame.UpdateOutputs()
            GameTooltip:Hide()
        end
        )
        CustomFrame.Items[i].Remove:SetScript(
        "OnEnter",
        function(self)
            GameTooltip:SetOwner(self, "ANCHOR_TOPLEFT")
            GameTooltip:ClearLines()
            GameTooltip:SetBackdropColor(0, 0, 0, 1)
            if CustomFrame.CurrentList == 1 then
                if
                GetSpellInfo(tonumber(CustomFrame.Items[i].Text:GetText())) ~= nil and
                type(GetSpellInfo(tonumber(CustomFrame.Items[i].Text:GetText()))) == "string"
                then
                    GameTooltip:SetText(
                    (Locale == "zh" and
                    "|cffFFFFFF去掉 |cffFFDD11" ..
                    CustomFrame.Items[i].Text:GetText() ..
                    " |cffFFFFFF(|cffFFDD11" ..
                    GetSpellInfo(tonumber(CustomFrame.Items[i].Text:GetText())) ..
                    "|cffFFFFFF) 从列表中。" or
                    "|cffFFFFFFRemove |cffFFDD11" ..
                    CustomFrame.Items[i].Text:GetText() ..
                    " |cffFFFFFF(|cffFFDD11" ..
                    GetSpellInfo(tonumber(CustomFrame.Items[i].Text:GetText())) ..
                    "|cffFFFFFF) from the list."),
                    nil,
                    nil,
                    nil,
                    1,
                    true
                    )
                else
                    GameTooltip:SetText(
                    (Locale == "zh" and
                    "|cffFFFFFF去掉 |cffFFDD11" .. CustomFrame.Items[i].Text:GetText() .. " |cffFFFFFF从列表中。" or
                    "|cffFFFFFFRemove |cffFFDD11" ..
                    CustomFrame.Items[i].Text:GetText() .. " |cffFFFFFFfrom the list."),
                    nil,
                    nil,
                    nil,
                    1,
                    true
                    )
                end
            else
                GameTooltip:SetText(
                (Locale == "zh" and
                "|cffFFFFFF去掉 |cffFFDD11" .. CustomFrame.Items[i].Text:GetText() .. " |cffFFFFFF从列表中。" or
                "|cffFFFFFFRemove |cffFFDD11" ..
                CustomFrame.Items[i].Text:GetText() .. " |cffFFFFFFfrom the list."),
                nil,
                nil,
                nil,
                1,
                true
                )
            end
        end
        )
        CustomFrame.Items[i].Remove:SetScript(
        "OnLeave",
        function(self)
            GameTooltip:Hide()
        end
        )
    end
    CustomInterrupts = GetSetting("Custom Interrupts Table") or {}
    CustomBlacklist = GetSetting("Custom Blacklist Table") or {}
    CustomFrame.Lists = {[1] = CustomInterrupts, [2] = CustomBlacklist }
    function CustomFrame.SaveLists()
        SetSetting("Custom Interrupts Table", CustomFrame.Lists[1])
        SetSetting("Custom Blacklist Table", CustomFrame.Lists[2])
    end
    function CustomFrame.UpdateOutputs()
        CustomFrame.BottomBar.EditField.EditBox:ClearFocus()
        if CustomFrame.CurrentList == 1 then
            CustomFrame.BottomBar.EditField.EditBox:SetText((Locale == "zh" and "法术编号" or "技能ID"))
        elseif CustomFrame.CurrentList == 2 then
            CustomFrame.BottomBar.EditField.EditBox:SetText((Locale == "zh" and "生物编号" or "生物ID"))
        end
        CustomFrame.TitleBar.PageTitle:SetText(
        CustomFrame.StoredLists[CustomFrame.CurrentList][(Locale == "zh" and 2 or 1)] ..
        " |cffFFDD11(" .. #CustomFrame.Lists[CustomFrame.CurrentList] .. ")"
        )
        local ThisList, ListPosition = {}, 0
        if CustomFrame.CurrentList == 1 then
            ThisList = CustomFrame.Lists[CustomFrame.CurrentList]
            for i = 1, 10 do
                ListPosition = i + CustomFrame.Position
                if ThisList[ListPosition] ~= nil then
                    CustomFrame.Items[i]:Show()
                    CustomFrame.Items[i].ID:SetText("|cffFFDD11" .. ListPosition)
                    CustomFrame.Items[i].Text:SetText(ThisList[ListPosition])
                    local Tip = GetSpellInfo(ThisList[ListPosition])
                    CustomFrame.Items[i]:SetScript(
                    "OnEnter",
                    function(self)
                        GameTooltip:SetOwner(self, "ANCHOR_BOTTOMRIGHT")
                        GameTooltip:ClearLines()
                        GameTooltip:SetBackdropColor(0, 0, 0, 1)
                        if type(Tip) == "string" then
                            GameTooltip:SetText("|cffFFFFFF" .. Tip, nil, nil, nil, 1, true)
                        else
                            GameTooltip:SetText(
                            (Locale == "zh" and "|cffFFFFFF法术无效。" or "|cffFFFFFFInvalid Spell."),
                            nil,
                            nil,
                            nil,
                            1,
                            true
                            )
                        end
                    end
                    )
                    CustomFrame.Items[i]:SetScript(
                    "OnLeave",
                    function(self)
                        GameTooltip:Hide()
                    end
                    )
                else
                    CustomFrame.Items[i]:Hide()
                end
            end
        elseif CustomFrame.CurrentList == 2 then
            ThisList = CustomFrame.Lists[CustomFrame.CurrentList]
            for i = 1, 10 do
                ListPosition = i + CustomFrame.Position
                if ThisList[ListPosition] ~= nil then
                    CustomFrame.Items[i]:Show()
                    CustomFrame.Items[i].ID:SetText("|cffFFDD11" .. ListPosition)
                    CustomFrame.Items[i].Text:SetText(ThisList[ListPosition])
                    CustomFrame.Items[i]:SetScript(
                    "OnEnter",
                    function(self)
                    end
                    )
                    CustomFrame.Items[i]:SetScript(
                    "OnLeave",
                    function(self)
                    end
                    )
                else
                    CustomFrame.Items[i]:Hide()
                end
            end
        end
    end
    function CustomFrame:Update()
        if GetSetting("Custom Frame_Checked") == true then
            if not CustomFrame:IsShown() then
                CustomFrame:Show()
            end
        else
            if CustomFrame:IsShown() then
                CustomFrame:Hide()
            end
        end
    end
    function CustomFrame.Toggle()
        local State = not GetSetting("Custom Frame_Checked")
        SetSetting("Custom Frame_Checked", State)
        if Locale == "zh" then
            StatusUpdate(State and "自定义框架|cFF40FF00显示。" or "自定义框架|cFFFF0000隐。")
            Overlay(State and "自定义框架|cFF40FF00显示" or "自定义框架|cFFFF0000隐")
        else
            StatusUpdate(State and "自定义窗口 |cFF00FF00显示." or "自定义窗口 |cFFFF0000隐藏.")
            Overlay(State and "自定义窗口 |cFF00FF00显示" or "自定义窗口 |cFFFF0000隐藏")
        end
    end
    CustomFrame.UpdateOutputs()
    function CustomFrame.SaveCILCmd(Arg)
        local FullList = ""
        local AllCustomInterrupts = GetSetting("Custom Interrupts Table")
        local TotalInterrupts = #AllCustomInterrupts
        for i = 1, #AllCustomInterrupts do
            local ThisInterrupt = AllCustomInterrupts[i]
            FullList = FullList .. ThisInterrupt .. "--" .. select(1, GetSpellInfo(ThisInterrupt))
            if i < TotalInterrupts then
                FullList = FullList .. "\n"
            end
        end
        WF(C.PROFILESPATH .. "Interrupts - " .. Arg .. ".txt", FullList)
        Print("|cffa901dbSaved |cFF0099FFInterrupts - " .. Arg .. ".txt|r Custom Interrupt List in profiles folder.")
    end
    local function Split(Str, Pat)
        local t = {}
        local fpat = "(.-)" .. Pat
        local last_end = 1
        local s, e, cap = Str:find(fpat, 1)
        while s do
            if s ~= 1 or cap ~= "" then
                table.insert(t, cap)
            end
            last_end = e + 1
            s, e, cap = Str:find(fpat, last_end)
        end
        if last_end <= #Str then
            cap = Str:sub(last_end)
            table.insert(t, cap)
        end
        return t
    end
    function CustomFrame.LoadCILCmd(Arg)
        local InterruptsFile = RF(C.PROFILESPATH .. "Interrupts - " .. Arg .. ".txt")
        if InterruptsFile then
            local FinalInterruptsArray = {}
            local InterruptsArray = Split(InterruptsFile, "\n")
            for i = 1, #InterruptsArray do
                local ThisInterrupt = Split(InterruptsArray[i], "-")
                if ThisInterrupt[1] ~= nil and type(tonumber(ThisInterrupt[1])) == "number" then
                    local ThisInterruptPosition = #FinalInterruptsArray + 1
                    local SpellID = tonumber(ThisInterrupt[1])
                    if SpellID ~= nil then
                        FinalInterruptsArray[ThisInterruptPosition] = SpellID
                    end
                end
            end
            for i = 1, #FinalInterruptsArray do
                for j = 2, #FinalInterruptsArray do
                    if FinalInterruptsArray[j] < FinalInterruptsArray[j - 1] then
                        local TempSpell = FinalInterruptsArray[j]
                        FinalInterruptsArray[j] = FinalInterruptsArray[j - 1]
                        FinalInterruptsArray[j - 1] = TempSpell
                    end
                end
            end
            SetSetting("Custom Interrupts Table", FinalInterruptsArray)
            CustomFrame.Lists[1] = FinalInterruptsArray
            CustomFrame.UpdateOutputs()
            Print("|cffa901dbLoaded |cFF0099FF" .. Arg .. "|r Custom Interrupt List.")
        else
            Print(
            "|cffa901dbAttempted to load |cFF0099FF" ..
            Arg .. "|r Custom Interrupt List but the file does not exists."
            )
        end
    end
end
function DebugInit()
    if not GetSetting("DebugFrameAnchorPoint") then
        SetSetting("DebugFrameAnchorPoint", "CENTER")
    end
    if not GetSetting("DebugFrameX") then
        SetSetting("DebugFrameX", -250)
    end
    if not GetSetting("DebugFrameY") then
        SetSetting("DebugFrameY", 30)
    end
    DebugFrame = CreateFrame("Frame")
    local Spacing = 14
    local Target = Target
    local Player = Player
    DebugFrame:ClearAllPoints()
    DebugFrame:SetHeight(35)
    DebugFrame:SetWidth(210)
    DebugFrame:SetPoint(
    GetSetting("DebugFrameAnchorPoint") or "CENTER",
    GetSetting("DebugFrameX") or 0,
    GetSetting("DebugFrameY") or 0
    )
    DebugFrame:SetFrameStrata("LOW")
    DebugFrame:SetFrameLevel(25)
    DebugFrame:SetClampedToScreen(true)
    DebugFrame:SetMovable(true)
    DebugFrame:EnableMouse(true)
    DebugFrame:SetScript(
    "OnMouseDown",
    function(self)
        DebugFrame:StartMoving()
    end
    )
    DebugFrame:SetScript(
    "OnMouseUp",
    function(self)
        DebugFrame:StopMovingOrSizing()
        local Point, RelativeTo, RelativePoint, X, Y = DebugFrame:GetPoint()
        SetSetting("DebugFrameAnchorPoint", Point)
        SetSetting("DebugFrameX", X)
        SetSetting("DebugFrameY", Y)
    end
    )
    local Backdrop = { bgFile = "Interface\\ChatFrame\\ChatFrameBackground" }
    DebugFrame:SetBackdrop(Backdrop)
    DebugFrame:SetBackdropColor(ColorsTable.DarkGray.R, ColorsTable.DarkGray.R, ColorsTable.DarkGray.R, 0.8)
    DebugFrame.TitleBar = CreateFrame("Frame", nil, DebugFrame)
    local TitleBar = DebugFrame.TitleBar
    TitleBar:SetPoint("TOPLEFT", 1, -1)
    TitleBar:SetPoint("TOPRIGHT", -1, -1)
    TitleBar:SetHeight(16)
    TitleBar:SetBackdrop(Backdrop)
    TitleBar:SetBackdropColor(0.184, 0.184, 0.184, 1)
    TitleBar:EnableMouse(true)
    TitleBar:SetScript(
    "OnMouseDown",
    function(self)
        DebugFrame:StartMoving()
    end
    )
    TitleBar:SetScript(
    "OnMouseUp",
    function(self)
        DebugFrame:StopMovingOrSizing()
        local Point, RelativeTo, RelativePoint, X, Y = DebugFrame:GetPoint()
        SetSetting("DebugFrameAnchorPoint", Point)
        SetSetting("DebugFrameX", X)
        SetSetting("DebugFrameY", Y)
    end
    )
    DebugFrame.TitleBarText = TitleBar:CreateFontString()
    local TitleBarText = DebugFrame.TitleBarText
    TitleBarText:SetAllPoints(TitleBar)
    TitleBarText:SetFont("Fonts\\ARKai_T.ttf", 11, "OUTLINE")
    TitleBarText:SetText("调试窗口")
    TitleBarText:SetJustifyH("CENTER")
    local Pages = {}
    local PageIndex = 1
    local OutputInfo = {}
    local Outputs = {}
    local PreviousPageButton = CreateFrame("Button", nil, DebugFrame)
    PreviousPageButton:SetPoint("TOPLEFT", TitleBar, "BOTTOMLEFT", 2, -1)
    PreviousPageButton:SetPoint("BOTTOMRIGHT", TitleBar, "BOTTOMLEFT", 12, -11)
    PreviousPageButton:SetBackdrop(Backdrop)
    PreviousPageButton:SetBackdropColor(ColorsTable.Red.R, ColorsTable.Red.G, ColorsTable.Red.B, 0.75)
    PreviousPageButton:SetScript(
    "PostClick",
    function(self)
        PageIndex = PageIndex - 1
        DebugFrame.UpdateOutputs()
    end
    )
    DebugFrame.PageTitle = DebugFrame:CreateFontString()
    local PageTitle = DebugFrame.PageTitle
    PageTitle:SetPoint("TOPLEFT", TitleBar, "BOTTOMLEFT", 2, -2)
    PageTitle:SetPoint("BOTTOMRIGHT", TitleBar, "BOTTOMRIGHT", -2, -16)
    PageTitle:SetFont("Fonts\\ARKai_T.ttf", 11, "OUTLINE")
    PageTitle:SetJustifyH("CENTER")
    local NextPageButton = CreateFrame("Button", nil, DebugFrame)
    NextPageButton:SetPoint("TOPRIGHT", TitleBar, "BOTTOMRIGHT", -2, -1)
    NextPageButton:SetPoint("BOTTOMLEFT", TitleBar, "BOTTOMRIGHT", -12, -11)
    NextPageButton:SetBackdrop(Backdrop)
    NextPageButton:SetBackdropColor(ColorsTable.Red.R, ColorsTable.Red.G, ColorsTable.Red.B, 0.75)
    NextPageButton:SetScript(
    "PostClick",
    function(self)
        PageIndex = PageIndex + 1
        DebugFrame.UpdateOutputs()
    end
    )
    function DebugFrame.UpdateOutputs()
        local PageName = Pages[PageIndex]
        local PageCount = {}
        PageTitle:SetText(PageName)
        local Count = 0
        for Index, Info in pairs(OutputInfo) do
            if PageCount[Info.Page] then
                PageCount[Info.Page] = PageCount[Info.Page] + 1
            else
                PageCount[Info.Page] = 1
            end
            if Info.Page == PageIndex or Info.Page == PageName then
                local Output = Outputs[Count + 1]
                Output[1]:SetText(Info.Name)
                Output[1]:Show()
                Output[2]:SetText("")
                Output[2]:Show()
                Count = Count + 1
            end
        end
        for Index, Output in pairs(Outputs) do
            if Index > Count then
                Output[1]:Hide()
                Output[2]:Hide()
            end
        end
        if PageIndex == 1 then
            PreviousPageButton:Disable()
        else
            PreviousPageButton:Enable()
        end
        if PageIndex == #Pages or #Pages == 0 then
            NextPageButton:Disable()
        else
            NextPageButton:Enable()
        end
        local MaxPage = nil
        local MaxCount = 0
        for Page, Count in pairs(PageCount) do
            if not MaxPage or Count > MaxCount then
                MaxPage = Page
                MaxCount = Count
            end
        end
        DebugFrame:SetHeight(35 + Spacing * MaxCount)
    end
    for Index = 1, 30 do
        local Output = {
            DebugFrame:CreateFontString("Output" .. Index .. "Label"),
            DebugFrame:CreateFontString("Output" .. Index .. "Value")
        }
        Output[1]:SetPoint("TOPLEFT", DebugFrame, "TOPLEFT", 5, -21 + -Spacing * Index)
        Output[1]:SetWidth(195)
        Output[1]:SetFont("Fonts\\ARKai_T.ttf", 11, "OUTLINE")
        Output[1]:SetJustifyH("LEFT")
        Output[2]:SetPoint("TOPLEFT", DebugFrame, "TOPLEFT", 5, -21 + -Spacing * Index)
        Output[2]:SetWidth(195)
        Output[2]:SetFont("Fonts\\ARKai_T.ttf", 11, "OUTLINE")
        Output[2]:SetJustifyH("RIGHT")
        table.insert(Outputs, Output)
    end
    local Visible = GetSetting("Debug Frame")
    if Visible == true then
        DebugFrame:Show()
    else
        DebugFrame:Hide()
    end
    RegisterCommand(
    "dag",
    function(Parts)
        local Visible = DebugFrame:IsVisible()
        if Visible then
            DebugFrame:Hide()
        else
            DebugFrame:Show()
        end
        Print("The Debug frame is now", Visible and "|cFFFF0000hidden.|r" or "|cFF00FF00shown.|r")
    end
    )
    function DebugFrame.ClearOutputs()
        for Index, Output in pairs(Outputs) do
            Output[1]:Hide()
            Output[2]:Hide()
        end
        Pages = {}
        OutputInfo = {}
        DebugFrame.UpdateOutputs()
    end
    function DebugFrame.AddOutputPage(Name)
        table.insert(Pages, Name)
        DebugFrame.UpdateOutputs()
        return #Pages
    end
    function DebugFrame.AddOutput(Page, Name, Tooltip)
        table.insert(OutputInfo, {["Page"] = Page, ["Name"] = Name, ["Tooltip"] = Tooltip })
        DebugFrame.UpdateOutputs()
    end
    function DebugFrame.IsOutputActive(Name)
        for Index, Output in pairs(Outputs) do
            if Output[1]:GetText() == Name then
                return true
            end
        end
        return false
    end
    function DebugFrame.SetOutput(Name, Value)
        for Index, Output in pairs(Outputs) do
            if Output[1]:GetText() == Name then
                local Value = tostring(Value)
                Value = Value:gsub("true", "|cff0A8CD7是|r")
                Value = Value:gsub("false", "|cffB81F1A不是|r")
                Output[2]:SetText(Value)
                return
            end
        end
    end
    function DebugFrame.Initialize()
        DebugFrame.AddOutputPage("常规")
        DebugFrame.AddOutput(1, "FPS:")
        DebugFrame.AddOutput(1, "敌方单位")
        DebugFrame.AddOutput(1, "友方单位")
        DebugFrame.AddOutput(1, "生物ID:")
        DebugFrame.AddOutput(1, "是木桩:")
        DebugFrame.AddOutput(1, "是死或幽灵:")
        DebugFrame.AddOutput(1, "IsHardBlacklisted:")
        DebugFrame.AddOutput(1, "IsBlacklisted:")
        DebugFrame.AddOutput(1, "正在战斗中:")
        DebugFrame.AddOutput(1, "CombatFlagForced:")
        DebugFrame.AddOutput(1, "可以攻击:")
        DebugFrame.AddOutput(1, "IsCrowdControlled:")
        DebugFrame.AddOutput(1, "背后:")
        DebugFrame.AddOutput(1, "面对:")
        DebugFrame.AddOutput(1, "InLineOfSight:")
        DebugFrame.AddOutput(1, "IsMounted:")
        DebugFrame.AddOutput(1, "InVehicle:")
        DebugFrame.AddOutput(1, "InVehicle SBR:")
        DebugFrame.AddOutput(1, "HasFullControl:")
        DebugFrame.AddOutput(1, "RawDistance:")
        DebugFrame.AddOutput(1, "Player Reach:")
        DebugFrame.AddOutput(1, "Target Reach:")
        DebugFrame.AddOutput(1, "近战范围:")
        DebugFrame.AddOutput(1, "FinalDistance:")
        DebugFrame.AddOutput(1, "目标 X:")
        DebugFrame.AddOutput(1, "目标 Y:")
        DebugFrame.AddOutput(1, "目标 Z:")
        DebugFrame.AddOutputPage("TTD")
        DebugFrame.AddOutput(2, "敌人1:")
        DebugFrame.AddOutput(2, "TTD1:")
        DebugFrame.AddOutput(2, "敌人2:")
        DebugFrame.AddOutput(2, "TTD2:")
        DebugFrame.AddOutput(2, "敌人3:")
        DebugFrame.AddOutput(2, "TTD3:")
        DebugFrame.AddOutput(2, "敌人4:")
        DebugFrame.AddOutput(2, "TTD4:")
        DebugFrame.AddOutput(2, "敌人5:")
        DebugFrame.AddOutput(2, "TTD5:")
        DebugFrame.AddOutput(2, "敌人6:")
        DebugFrame.AddOutput(2, "TTD6:")
        DebugFrame.AddOutput(2, "敌人7:")
        DebugFrame.AddOutput(2, "TTD7:")
        DebugFrame.AddOutput(2, "敌人8:")
        DebugFrame.AddOutput(2, "TTD8:")
        DebugFrame.AddOutput(2, "敌人9:")
        DebugFrame.AddOutput(2, "TTD9:")
        DebugFrame.AddOutput(2, "敌人10:")
        DebugFrame.AddOutput(2, "TTD10:")
        DebugFrame.AddOutput(2, "敌人11:")
        DebugFrame.AddOutput(2, "TTD11:")
        DebugFrame.AddOutput(2, "敌人12:")
        DebugFrame.AddOutput(2, "TTD12:")
    end
    function DebugFrame.Refresh()
        if PageIndex == 1 then
            if not UpdateUnitTime or GetTime() > UpdateUnitTime then
                UpdateUnitTime = GetTime() + 0.7
                DebugFrame.SetOutput("FPS:", math.floor(_G["GetFramerate"]()))
                DebugFrame.SetOutput("敌方单位", #UnitsEngine.Units.Hostile)
                DebugFrame.SetOutput("友方单位", #UnitsEngine.Units.Friendly)
            end
            if Target:Exists() then
                if not UpdateUnitTime2 or GetTime() > UpdateUnitTime2 then
                    UpdateUnitTime = GetTime() + 0.4
                    local CanAttack = Player:CanAttack(Target)
                    DebugFrame.SetOutput("生物ID:", Target:CreatureID())
                    DebugFrame.SetOutput("是木桩:", Target:IsDummy())
                    DebugFrame.SetOutput("是死或幽灵:", Target:IsDeadOrGhost())
                    DebugFrame.SetOutput("IsHardBlacklisted:", Target:IsHardBlacklisted())
                    DebugFrame.SetOutput("IsBlacklisted:", Target:IsBlacklisted())
                    DebugFrame.SetOutput("正在战斗中:", Target:IsInCombat())
                    DebugFrame.SetOutput("CombatFlagForced:", Target:WithoutCombatFlags())
                    DebugFrame.SetOutput("可以攻击:", CanAttack)
                    DebugFrame.SetOutput("IsCrowdControlled:", Target:IsCrowdControlled())
                    DebugFrame.SetOutput("面对:", Player:IsFacing(Target))
                    DebugFrame.SetOutput("InLineOfSight:", Player:InLineOfSight(Target))
                    DebugFrame.SetOutput("IsMounted:", IsMounted())
                    DebugFrame.SetOutput("InVehicle:", UnitInVehicle("Player"))
                    DebugFrame.SetOutput("InVehicle SBR:", Player:InVehicle())
                    DebugFrame.SetOutput("HasFullControl:", HasFullControl())
                end
                DebugFrame.SetOutput("背后:", not Target:IsFacing(Player))
                DebugFrame.SetOutput("RawDistance:", Player:DistanceTo(Target, true, true))
                DebugFrame.SetOutput("Player Reach:", Player:CombatReach())
                DebugFrame.SetOutput("Target Reach:", Target:CombatReach())
                DebugFrame.SetOutput("近战范围:", Player:MeleeRange(Target))
                DebugFrame.SetOutput("FinalDistance:", Player:DistanceTo(Target))
                local TX, TY, TZ = Target:Position().X, Target:Position().Y, Target:Position().Z
                DebugFrame.SetOutput("目标 X:", TX)
                DebugFrame.SetOutput("目标 Y:", TY)
                DebugFrame.SetOutput("目标 Z:", TZ)
            else
                DebugFrame.SetOutput("生物ID:", "|CFF939393没有目标")
                DebugFrame.SetOutput("是死或幽灵:", "|CFF939393没有目标")
                DebugFrame.SetOutput("IsHardBlacklisted:", "|CFF939393没有目标")
                DebugFrame.SetOutput("Blacklist:", "|CFF939393没有目标")
                DebugFrame.SetOutput("正在战斗中:", "|CFF939393没有目标")
                DebugFrame.SetOutput("CombatFlagForced:", "|CFF939393没有目标")
                DebugFrame.SetOutput("可以攻击:", "|CFF939393没有目标")
                DebugFrame.SetOutput("IsCrowdControlled:", "|CFF939393没有目标")
                DebugFrame.SetOutput("背后:", "|CFF939393没有目标")
                DebugFrame.SetOutput("面对:", "|CFF939393没有目标")
                DebugFrame.SetOutput("InLineOfSight:", "|CFF939393没有目标")
                DebugFrame.SetOutput("IsMounted:", IsMounted())
                DebugFrame.SetOutput("InVehicle:", UnitInVehicle("Player"))
                DebugFrame.SetOutput("InVehicle SBR:", Player:InVehicle())
                DebugFrame.SetOutput("HasFullControl:", HasFullControl())
                DebugFrame.SetOutput("RawDistance:", "|CFF939393没有目标")
                DebugFrame.SetOutput("Target Reach:", "|CFF939393没有目标")
                DebugFrame.SetOutput("Player Reach:", Player:CombatReach())
                DebugFrame.SetOutput("近战范围:", "|CFF939393没有目标")
                DebugFrame.SetOutput("FinalDistance:", "|CFF939393没有目标")
                DebugFrame.SetOutput("目标 X:", "|CFF939393没有目标")
                DebugFrame.SetOutput("目标 Y:", "|CFF939393没有目标")
                DebugFrame.SetOutput("目标 Z:", "|CFF939393没有目标")
            end
        elseif PageIndex == 2 then
            local Enemies = Player:EnemiesWithinDistance(30, false)
            local NumEnemies = #Enemies
            if not UpdateUnitTime or GetTime() > UpdateUnitTime then
                UpdateUnitTime = GetTime() + 0.4
                for i = 1, NumEnemies do
                    DebugFrame.SetOutput("Enemy" .. i .. ":", Enemies[i]:Name())
                    DebugFrame.SetOutput("TTD" .. i .. ":", Enemies[i]:TimeToDie())
                end
            end
            for i = NumEnemies + 1, 12 - NumEnemies do
                DebugFrame.SetOutput("Enemy" .. i .. ":", "|CFF939393没有单位")
                DebugFrame.SetOutput("TTD" .. i .. ":", "|CFF939393没有单位")
            end
        end
    end
    function DebugFrame:Update()
        if UseDebugFrame() then
            if not DebugFrame:IsShown() then
                DebugFrame:Show()
            end
        else
            if DebugFrame:IsShown() then
                DebugFrame:Hide()
            end
        end
        if DebugFrame:IsVisible() then
            if not DebugFrame.Initialized then
                DebugFrame.Initialize()
                DebugFrame.Initialized = true
            end
            DebugFrame.Refresh()
        end
    end
end
Toolbox = CreateFrame("Frame")
function Toolbox.Init()
    local Font = Locale == "zh" and ChineseFont or "Fonts\\ARKai_T.ttf"
    local FontSize = Locale == "zh" and 12 or 12
    local MaxRowValue = 3
    local function ToolboxInit()
        if not GetSetting("ToolboxAnchorPoint") then
            SetSetting("ToolboxAnchorPoint", "CENTER")
        end
        if not GetSetting("ToolboxX") then
            SetSetting("ToolboxX", 0)
        end
        if not GetSetting("ToolboxY") then
            SetSetting("ToolboxY", -140)
        end
        if not GetSetting("ToolboxRows") then
            SetSetting("ToolboxRows", MaxRowValue)
        end
        if GetSetting("ToolboxRows") > MaxRowValue then
            SetSetting("ToolboxRows", MaxRowValue)
        end
    end
    ToolboxInit()
    local ButtonRowNumber, ButtonInit = GetSetting("ToolboxRows") or MaxRowValue, nil
    local ButtonRowSize = 21 * ButtonRowNumber
    local Height, Width, Spacing, MaxCount = 21 + ButtonRowSize, 210, 14, 0
    StatusHidden = GetSetting("StatusVisible") or false
    Toolbox:ClearAllPoints()
    Toolbox:SetHeight(Height)
    Toolbox:SetWidth(Width)
    Toolbox:SetFrameStrata("LOW")
    Toolbox:SetClampedToScreen(true)
    Toolbox:SetMovable(true)
    Toolbox:EnableMouse(true)
    Toolbox:Show()
    local Backdrop = { bgFile = "Interface\\ChatFrame\\ChatFrameBackground" }
    Toolbox:SetBackdrop(Backdrop)
    Toolbox:SetBackdropColor(ColorsTable.DarkGray.R, ColorsTable.DarkGray.R, ColorsTable.DarkGray.R, 0.8)
    Toolbox:SetScript(
    "OnShow",
    function(self)
        SetSetting("ToolboxVisible", true)
    end
    )
    Toolbox:SetScript(
    "OnHide",
    function(self)
        SetSetting("ToolboxVisible", false)
    end
    )
    Toolbox:SetScript(
    "OnMouseDown",
    function(self)
        Toolbox:StartMoving()
    end
    )
    Toolbox:SetScript(
    "OnMouseUp",
    function(self)
        Toolbox:StopMovingOrSizing()
        local Point, RelativeTo, RelativePoint, X, Y = Toolbox:GetPoint()
        SetSetting("ToolboxAnchorPoint", Point)
        SetSetting("ToolboxX", X)
        SetSetting("ToolboxY", Y)
    end
    )
    Toolbox.TitleBar = CreateFrame("Frame", nil, Toolbox)
    local TitleBar = Toolbox.TitleBar
    TitleBar:SetPoint("TOPLEFT", 1, -1)
    TitleBar:SetPoint("TOPRIGHT", -1, -1)
    TitleBar:SetHeight(15)
    TitleBar:SetBackdrop(Backdrop)
    TitleBar:SetBackdropColor(0.184, 0.184, 0.184, 1)
    TitleBar:EnableMouse(true)
    Toolbox.TitleBarText = TitleBar:CreateFontString()
    local TitleBarText = Toolbox.TitleBarText
    TitleBarText:SetAllPoints(TitleBar)
    TitleBarText:SetFont(Font, 11, "OUTLINE")
    TitleBarText:SetTextColor(ColorsTable.Blue.R, ColorsTable.Blue.G, ColorsTable.Blue.B, 1)
    TitleBarText:SetJustifyH("CENTER")
    Toolbox.ClassColor = "|c" .. _G["RAID_CLASS_COLORS"][select(2, UnitClass("player"))].colorStr
    local Backdrop = { bgFile = "Interface\\ChatFrame\\ChatFrameBackground" }
    local Button = {}
    function AddButton(Texts, SecondTexts, i, j, Command, Status, StatusCommand, Tooltip)
        local Text, SecondText
        if Locale == "zh" then
            Text = Texts[2]
        else
            Text = Texts[1]
        end
        if SecondTexts ~= nil then
            if Locale == "zh" then
                SecondText = SecondTexts[2]
            else
                SecondText = SecondTexts[1]
            end
        end
        Button[i] = Button[i] or {}
        local y = -20 - 20 * (i - 1)
        local x = 4 + 68 * (j - 1)
        Button[i][j] = CreateFrame("Frame", nil, Toolbox)
        Button[i][j].BackGround = CreateFrame("Frame", nil, Toolbox)
        local ThisBackGround = Button[i][j].BackGround
        ThisBackGround:SetPoint("TOPLEFT", Toolbox, "TOPLEFT", x - 1, y + 1)
        ThisBackGround:SetWidth(65)
        ThisBackGround:SetHeight(18)
        ThisBackGround:SetFrameLevel(5)
        ThisBackGround:SetBackdrop(Backdrop)
        ThisBackGround:SetBackdropColor(ColorsTable.LightGray.R, ColorsTable.LightGray.G, ColorsTable.LightGray.B, 0.75)
        local ThisButton = Button[i][j]
        ThisButton:SetPoint("TOPLEFT", Toolbox, "TOPLEFT", x, y)
        ThisButton:SetWidth(63)
        ThisButton:SetHeight(16)
        ThisButton:SetFrameLevel(6)
        ThisButton:SetBackdrop(Backdrop)
        ThisButton:SetBackdropColor(ColorsTable.Black.R, ColorsTable.Black.G, ColorsTable.Black.B, 0.75)
        ThisButton.Text = ThisButton:CreateFontString()
        ThisButton.Text:SetPoint("TOPLEFT", ThisButton, "TOPLEFT", 0, 0)
        ThisButton.Text:SetPoint("BOTTOMRIGHT", ThisButton, "BOTTOMRIGHT", 0, 0)
        ThisButton.Text:SetFont(Font, FontSize, "OUTLINE")
        ThisButton.Text:SetJustifyH("CENTER")
        ThisButton.Text:SetText("|cffFFFFFF" .. Text)
        if Text == "大技能" or Text == "冷却" then
            ThisButton.TimeSinceLastUpdate = 0
            ThisButton.UpdateInterval = 0.25
            ThisButton:SetScript(
            "OnUpdate",
            function(self, elapsed)
                self.TimeSinceLastUpdate = self.TimeSinceLastUpdate + elapsed
                if self.TimeSinceLastUpdate > self.UpdateInterval then
                    if StatusCommand() then
                        if IsOptionEnabled("Cooldowns On Bosses") then
                            ThisButton.Text:SetText("|cffa901db" .. Text)
                        else
                            ThisButton.Text:SetText("|cff00ff00" .. Text)
                        end
                    else
                        ThisButton.Text:SetText("|cffff0000" .. Text)
                    end
                    self.TimeSinceLastUpdate = 0
                end
            end
            )
        elseif Text == "开" or Text == "开" then
            ThisButton.TimeSinceLastUpdate = 0
            ThisButton.UpdateInterval = 0.25
            ThisButton:SetScript(
            "OnUpdate",
            function(self, elapsed)
                self.TimeSinceLastUpdate = self.TimeSinceLastUpdate + elapsed
                if self.TimeSinceLastUpdate > self.UpdateInterval then
                    if StatusCommand() then
                        if IsOptionEnabled("暂停自动技能") and PulseControl.IsInControl ~= "Complete" then
                            ThisButton.Text:SetText("|cfffff569" .. Text)
                        else
                            ThisButton.Text:SetText("|cff00ff00" .. Text)
                        end
                    else
                        ThisButton.Text:SetText("|cffff0000" .. SecondText)
                    end
                    self.TimeSinceLastUpdate = 0
                end
            end
            )
        elseif Status then
            ThisButton.TimeSinceLastUpdate = 0
            ThisButton.UpdateInterval = 0.25
            ThisButton:SetScript(
            "OnUpdate",
            function(self, elapsed)
                self.TimeSinceLastUpdate = self.TimeSinceLastUpdate + elapsed
                if self.TimeSinceLastUpdate > self.UpdateInterval then
                    if StatusCommand() then
                        ThisButton.Text:SetText("|cff00ff00" .. Text)
                    else
                        ThisButton.Text:SetText(SecondText and "|cffff0000" .. SecondText or "|cffff0000" .. Text)
                    end
                    self.TimeSinceLastUpdate = 0
                end
            end
            )
        else
            ThisButton.Text:SetText("|cffd3d3d3" .. Text)
        end
        if Tooltip then
            ThisButton:SetScript(
            "OnEnter",
            function(self)
                self:SetBackdropColor(
                ColorsTable.LightGray.R,
                ColorsTable.LightGray.G,
                ColorsTable.LightGray.B,
                0.75
                )
                GameTooltip:SetOwner(Toolbox, "ANCHOR_TOPLEFT", 0, 0)
                GameTooltip:ClearLines()
                GameTooltip:SetBackdropColor(0, 0, 0, 1)
                GameTooltip:SetText("|cffFFFFFF" .. Tooltip, nil, nil, nil, 1, true)
                GameTooltip:Show()
            end
            )
            ThisButton:SetScript(
            "OnLeave",
            function(self)
                self:SetBackdropColor(ColorsTable.Black.R, ColorsTable.Black.G, ColorsTable.Black.B, 0.75)
                GameTooltip:Hide()
            end
            )
        end
        if Text == "大技能" or Text == "冷却" then
            ThisButton:SetScript(
            "OnMouseDown",
            function(self, button)
                if button == "RightButton" then
                    if not IsOptionEnabled("Cooldowns On Bosses") then
                        SetSetting("Cooldowns On Bosses_Checked", true)
                    else
                        SetSetting("Cooldowns On Bosses_Checked", false)
                    end
                    UpdateOptions()
                else
                    Command()
                end
            end
            )
        else
            ThisButton:SetScript(
            "OnMouseDown",
            function(self)
                Command()
            end
            )
        end
    end
    function ToolboxButtonAdd()
        if not Button[1] then
            AddButton(
            { "开", "开" },
            { "关", "关" },
            1,
            1,
            ToggleRunning,
            true,
            function()
                return IsRunning()
            end,
            Locale == "zh" and "打开/关闭管理器。\n如果启用脉冲控制，则当脉冲被阻止时，文本将以黄色显示。" or "打开/关闭 脚本循环. 如果使用暂停循环控制时,按钮就会变成黄色"
            )
            AddButton(
            { "大技能", "冷却" },
            nil,
            1,
            2,
            ToggleCDs,
            true,
            function()
                return UseCooldowns()
            end,
            Locale == "zh" and "左击：切换开/关冷却。 右键单击：在老板（|cffa901db上 - 紫色|cffFFFFFF）或（|cff00ff00关闭 - 绿色|cffFFFFFF）。" or
            "左键点击:切换开关大技能. 右键点击:只在BOSS使用大技能(|cffa901db开 - 紫色|cffFFFFFF) or (|cff00ff00关 - 绿色|cffFFFFFF)."
            )
            AddButton(
            { "AoE", "AoE" },
            nil,
            1,
            3,
            ToggleAoE,
            true,
            function()
                return UseAOE()
            end,
            Locale == "zh" and "打开/关闭效果区域。" or "打开/关闭 AoE"
            )
            AddButton(
            { "设置", "用户界面" },
            nil,
            2,
            1,
            UICmd,
            true,
            function()
                return UserInterface:IsVisible()
            end,
            Locale == "zh" and "显示用户界面。" or "打开/关闭 用户设置界面"
            )
            AddButton(
            { "状态", "状态" },
            nil,
            2,
            2,
            StatusCmd,
            true,
            function()
                return not StatusHidden
            end,
            Locale == "zh" and "切换工具箱中的状态。" or "打开/关闭 状态栏"
            )
            AddButton(
            { "自定义", "自定义" },
            nil,
            2,
            3,
            CustomFrame.Toggle,
            true,
            function()
                return CustomFrame:IsVisible()
            end,
            Locale == "zh" and "显示自定义设置。" or "打开/关闭 自定义设置界面"
            )
            AddButton(
            { "动作记录", "行动日志" },
            nil,
            3,
            1,
            ToggleActionLog,
            true,
            function()
                return UseActionLog()
            end,
            Locale == "zh" and "显示动作日志框。" or "打开/关闭 动作日志界面"
            )
            AddButton(
            { "调试", "调试" },
            nil,
            3,
            2,
            ToggleDebug,
            true,
            function()
                return UseDebug()
            end,
            Locale == "zh" and "启用调试模式。" or "打开/关闭 调试模式"
            )
            AddButton(
            { "调试窗口", "调试框架" },
            nil,
            3,
            3,
            ToggleDebugFrame,
            true,
            function()
                return UseDebugFrame()
            end,
            Locale == "zh" and "显示调试框。" or "打开/关闭 调试界面"
            )
            UpdateToolbox()
        end
    end
    local OutputInfo = {}
    local Outputs = {}
    function UpdateOutputs()
        local Count = 0
        for Index, Info in pairs(OutputInfo) do
            local Output = Outputs[Count + 1]
            Output[1]:SetText(Info.Name)
            Output[1]:Show()
            Output[2]:SetText("")
            Output[2]:Show()
            Count = Count + 1
        end
        MaxCount = Count
        if StatusHidden then
            for Index, Output in pairs(Outputs) do
                Output[1]:Hide()
                Output[2]:Hide()
            end
            Toolbox:SetHeight(20 + ButtonRowSize)
        else
            for Index, Output in pairs(Outputs) do
                if Index > Count then
                    Output[1]:Hide()
                    Output[2]:Hide()
                end
            end
            Toolbox:SetHeight(20 + ButtonRowSize + Spacing * MaxCount)
        end
    end
    for Index = 1, 20 do
        local Output = {
            Toolbox:CreateFontString("Output" .. Index .. "Label"),
            Toolbox:CreateFontString("Output" .. Index .. "Value")
        }
        Output[1]:SetPoint("TOPLEFT", Toolbox, "TOPLEFT", 5, -(4 + ButtonRowSize + Spacing * Index))
        Output[1]:SetWidth(Width - 10)
        Output[1]:SetFont(Font, 11, "OUTLINE")
        Output[1]:SetJustifyH("LEFT")
        Output[2]:SetPoint("TOPLEFT", Toolbox, "TOPLEFT", 5, -(4 + ButtonRowSize + Spacing * Index))
        Output[2]:SetWidth(Width - 10)
        Output[2]:SetFont(Font, 11, "OUTLINE")
        Output[2]:SetJustifyH("RIGHT")
        table.insert(Outputs, Output)
    end
    function TbCmd(Show)
        local Visible = Toolbox:IsVisible()
        if Show == true then
            Toolbox:Show()
            SetSetting("ToolboxVisible", true)
        else
            if Visible then
                Toolbox:Hide()
            elseif not Visible then
                Toolbox:Show()
            end
            Print(
            (Locale == "zh" and ("工具箱现在" .. (Visible and " |cFFFF0000隐。|r" or " |cFF00FF00所示。|r")) or
            ("The Toolbox is now" .. (Visible and "|cFFFF0000hidden.|r" or "|cFF00FF00shown.|r")))
            )
        end
    end
    function StatusCmd()
        if MaxCount > 0 then
            Toolbox:StartMoving()
            ToolboxPreviousHeight = Toolbox:GetHeight()
            if not StatusHidden then
                StatusHidden = true
                SetSetting("StatusVisible", true)
                for Index, Output in pairs(Outputs) do
                    Output[1]:Hide()
                    Output[2]:Hide()
                end
                Toolbox:SetHeight(20 + ButtonRowSize)
            else
                if not Toolbox:IsVisible() then
                    Toolbox:Show()
                    Print(
                    "|cFFFF0000The Toolbox has been forced to be visible, use '/" ..
                    AddOnName ..
                    " " ..
                    CmdArgument.tb ..
                    "' to toggle the Toolbox instead of '/" ..
                    AddOnName ..
                    " " ..
                    CmdArgument.status ..
                    "'' wich is only to control the Status part of Toolbox.|r"
                    )
                end
                StatusHidden = false
                SetSetting("StatusVisible", false)
                UpdateOutputs()
                Toolbox:SetHeight(20 + ButtonRowSize + Spacing * MaxCount)
                for Index, Output in pairs(Outputs) do
                    local Point, RelativeTo, RelativePoint, X, Y = Output[1]:GetPoint()
                    Output[1]:SetPoint(Point, RelativeTo, RelativePoint, X, -(4 + ButtonRowSize + Spacing * Index))
                    local Point, RelativeTo, RelativePoint, X, Y = Output[2]:GetPoint()
                    Output[2]:SetPoint(Point, RelativeTo, RelativePoint, X, -(4 + ButtonRowSize + Spacing * Index))
                end
            end
            Toolbox:StopMovingOrSizing()
            if Locale == "zh" then
                Print(StatusHidden and "工具箱的状态部分现在|cFFFF0000隐。" or "工具箱的状态部分现在|cFFFF0000显示。")
                Overlay(StatusHidden and "状态|cFF40FF00显示" or "状态|cFFFF0000隐")
            else
                Print(StatusHidden and "状态界面 |cFFFF0000隐藏." or "状态界面 |cFF00FF00显示.|r")
                Overlay(StatusHidden and "状态 |cFF40FF00隐藏" or "状态 |cFFFF0000显示")
            end
        else
            Print("The Status part of Toolbox is |cFFFF0000empty|r for this rotation.")
            StatusHidden = true
            SetSetting("StatusVisible", true)
        end
    end
    function ClearOutputs()
        for Index, Output in pairs(Outputs) do
            Output[1]:Hide()
            Output[2]:Hide()
        end
        OutputInfo = {}
        UpdateOutputs()
    end
    function AddOutput(Name)
        local Found = false
        for i = 1, #OutputInfo do
            if OutputInfo[i]["Name"] == Name then
                Found = true
            end
        end
        if not Found then
            table.insert(OutputInfo, {["Name"] = Name })
        end
        UpdateOutputs()
    end
    function SetOutput(Name, Value)
        for Index, Output in pairs(Outputs) do
            if Output[1]:GetText() == Name then
                local Value = tostring(Value)
                Output[2]:SetText(Value)
                return
            end
        end
    end
    function UpdateToolbox()
        Toolbox:StartMoving()
        StatusHidden = GetSetting("StatusVisible")
        ButtonRowNumber = GetSetting("ToolboxRows")
        ButtonRowSize = 21 * ButtonRowNumber
        for a = 1, MaxRowValue do
            if a < ButtonRowNumber + 1 then
                for b = 1, #Button[a] do
                    Button[a][b]:Show()
                    Button[a][b].BackGround:Show()
                end
            else
                for b = 1, #Button[a] do
                    Button[a][b]:Hide()
                    Button[a][b].BackGround:Hide()
                end
            end
        end
        if not StatusHidden then
            Toolbox:SetHeight(21 + ButtonRowSize + Spacing * MaxCount)
            for Index, Output in pairs(Outputs) do
                local Point, RelativeTo, RelativePoint, X, Y = Output[1]:GetPoint()
                Output[1]:SetPoint(Point, RelativeTo, RelativePoint, X, -(4 + ButtonRowSize + Spacing * Index))
                local Point, RelativeTo, RelativePoint, X, Y = Output[2]:GetPoint()
                Output[2]:SetPoint(Point, RelativeTo, RelativePoint, X, -(4 + ButtonRowSize + Spacing * Index))
            end
        else
            Toolbox:SetHeight(20 + ButtonRowSize)
        end
        Toolbox:StopMovingOrSizing()
    end
    function UpdateToolboxChangeSpec()
        ToolboxInit()
        Toolbox:SetPoint(GetSetting("ToolboxAnchorPoint"), GetSetting("ToolboxX"), GetSetting("ToolboxY"))
        local Visible = GetSetting("ToolboxVisible")
        if Visible == false then
            Toolbox:Hide()
        else
            Toolbox:Show()
        end
        for a = 1, #Button do
            for b = 1, #Button[a] do
                Button[a][b]:Hide()
            end
        end
        UpdateToolbox()
    end
    local UIBackdrop = { bgFile = "Interface\\ChatFrame\\ChatFrameBackground" }
    TitleBar.LuaErrorButton = CreateFrame("Frame", nil, TitleBar)
    local ErrorButton = TitleBar.LuaErrorButton
    ErrorButton:SetPoint("TOPLEFT", 2, -2)
    ErrorButton:SetHeight(10)
    ErrorButton:SetWidth(10)
    ErrorButton:SetBackdrop(UIBackdrop)
    ErrorButton:SetBackdropColor(ColorsTable.Blue.R, ColorsTable.Blue.G, ColorsTable.Blue.B, 1)
    ErrorButton:SetScript(
    "OnEnter",
    function(self)
        local ClassName = select(2, UnitClass("player"))
        local CurrentSpec = GetSpecialization()
        local CurrentSpecName = CurrentSpec and select(2, GetSpecializationInfo(CurrentSpec)) or UnitClass("Player")
        GameTooltip:SetOwner(Toolbox, "ANCHOR_TOPLEFT", 0, 0)
        GameTooltip:ClearLines()
        GameTooltip:SetBackdropColor(0, 0, 0, 1)
        GameTooltip:SetText(
        "When this button is flashing, it means that lua errors occured internally. Please copy the content of Errors/" ..
        ClassName ..
        "" ..
        CurrentSpecName ..
        " - Error.txt and post it to one of our developers on Discord or on our forum.",
        nil,
        nil,
        nil,
        1,
        true
        )
        GameTooltip:Show()
    end
    )
    ErrorButton:SetScript(
    "OnLeave",
    function(self)
        GameTooltip:Hide()
    end
    )
    function Toolbox.TitleBar.LuaErrorButton.Error(Trigger)
        if Trigger ~= true then
            if ErrorButton.Color == "Red" then
                ErrorButton:SetBackdropColor(ColorsTable.Blue.R, ColorsTable.Blue.G, ColorsTable.Blue.B, 1)
                ErrorButton.Color = "Black"
            else
                ErrorButton:SetBackdropColor(ColorsTable.Red.R, ColorsTable.Red.G, ColorsTable.Red.B, 1)
                ErrorButton.Color = "Red"
            end
        else
            if not ErrorButton.TimerStarted then
                ErrorButton.TimerStarted = true
                C_Timer.NewTicker(0.7, TitleBar.LuaErrorButton.Error)
            end
        end
    end
    TitleBar.CloseButton = CreateFrame("Frame", nil, TitleBar)
    local CloseButton = TitleBar.CloseButton
    CloseButton:SetPoint("TOPRIGHT", -2, -2)
    CloseButton:SetHeight(10)
    CloseButton:SetWidth(10)
    CloseButton:SetBackdrop(UIBackdrop)
    CloseButton:SetBackdropColor(ColorsTable.Red.R, ColorsTable.Red.G, ColorsTable.Red.B, 0.75)
    CloseButton:SetScript(
    "OnMouseUp",
    function(self)
        Toolbox:Hide()
    end
    )
    CloseButton:SetScript(
    "OnEnter",
    function(self)
        GameTooltip:SetOwner(Toolbox, "ANCHOR_TOPLEFT", 0, 0)
        GameTooltip:ClearLines()
        GameTooltip:SetBackdropColor(0, 0, 0, 1)
        GameTooltip:SetText("点击关闭该窗口.", nil, nil, nil, 1, true)
        GameTooltip:Show()
    end
    )
    CloseButton:SetScript(
    "OnLeave",
    function(self)
        GameTooltip:Hide()
    end
    )
    TitleBar:SetScript(
    "OnMouseUp",
    function(self, button)
        Toolbox:StopMovingOrSizing()
        local Point, RelativeTo, RelativePoint, X, Y = Toolbox:GetPoint()
        SetSetting("ToolboxAnchorPoint", Point)
        SetSetting("ToolboxX", X)
        SetSetting("ToolboxY", Y)
    end
    )
    local function ToolboxRowResize(Plus)
        if Plus then
            if GetSetting("ToolboxRows") == MaxRowValue then
                SetSetting("ToolboxRows", 0)
            else
                SetSetting("ToolboxRows", GetSetting("ToolboxRows") + 1)
            end
            UpdateToolbox()
        else
            if GetSetting("ToolboxRows") == 0 then
                SetSetting("ToolboxRows", MaxRowValue)
            else
                SetSetting("ToolboxRows", GetSetting("ToolboxRows") - 1)
            end
            UpdateToolbox()
        end
    end
    TitleBar:SetScript(
    "OnMouseDown",
    function(self, button)
        if button == "RightButton" then
            ToolboxRowResize()
        else
            Toolbox:StartMoving()
        end
    end
    )
    TitleBar:SetScript(
    "OnMouseWheel",
    function(self, delta)
        ToolboxRowResize(delta == -1)
    end
    )
    TitleBar:SetScript(
    "OnEnter",
    function(self)
        GameTooltip:SetOwner(Toolbox, "ANCHOR_TOPLEFT", 0, 0)
        GameTooltip:ClearLines()
        GameTooltip:SetBackdropColor(0, 0, 0, 1)
        GameTooltip:SetText("右键单击以显示/隐藏按钮.", nil, nil, nil, 1, true)
        GameTooltip:Show()
    end
    )
    TitleBar:SetScript(
    "OnLeave",
    function(self)
        GameTooltip:Hide()
    end
    )
    ToolboxButtonAdd()
    UpdateToolboxChangeSpec()
    Authorized()
end
function UIInit()
    UserInterface = CreateFrame("Frame", Randomize())
    UI = UserInterface
    local Font = Locale == "zh" and ChineseFont or "Fonts\\ARKai_T.ttf"
    local FontSize = Locale == "zh" and 11 or 10
    local function UI_SettingsInit()
        if not GetSetting("UI_AnchorPoint") then
            SetSetting("UI_AnchorPoint", "CENTER")
        end
        if not GetSetting("UI_X") then
            SetSetting("UI_X", 250)
        end
        if not GetSetting("UI_Y") then
            SetSetting("UI_Y", 30)
        end
    end
    local TitleBar_Height, PageInfo_Height = 18, 12
    local Height_Total = TitleBar_Height + 2 + 2
    local UI_Height, UI_Width = Height_Total, 215
    local Spacing = 15
    local UIBackdrop = { bgFile = "Interface\\ChatFrame\\ChatFrameBackground" }
    StaticInitialized = false
    Pages, PageIndex = {}, 1
    OptionInfo, OptionFrame, Options = {}, {}, {}
    DropDown_Index_Bis = {}
    local function CloseDropDowns()
        for i = 1, #Options do
            for j = 1, #Options[i] do
                for k = 1, #Options[i][j] do
                    if Options[i][j][k].Type == "DropDown" then
                        Options[i][j][k].Items:Hide()
                    elseif Options[i][j][k].Type == "EditBox" then
                        Options[i][j][k]:ClearFocus()
                    end
                end
            end
        end
        SwitcherItems:Hide()
    end
    local function CheckButton(OptionTable, CheckEntry)
        local Option = OptionTable
        Option[CheckEntry]:SetPoint("TOPLEFT", OptionFrame[POIndex], "TOPLEFT", 2, -Spacing * LineIndex)
        Option[CheckEntry]:SetWidth(10)
        Option[CheckEntry]:SetHeight(10)
        Option[CheckEntry]:Hide()
        Option[CheckEntry]:SetScript(
        "OnClick",
        function(self)
            CloseDropDowns()
            if not GetSetting(self.Name .. "_Checked") then
                self:SetBackdropColor(ColorsTable.Blue.R, ColorsTable.Blue.G, ColorsTable.Blue.B, 0.75)
                SetSetting(self.Name .. "_Checked", true)
            else
                self:SetBackdropColor(
                ColorsTable.LightGray.R,
                ColorsTable.LightGray.G,
                ColorsTable.LightGray.B,
                0.75
                )
                SetSetting(self.Name .. "_Checked", false)
            end
        end
        )
        Option[CheckEntry]:SetScript(
        "OnEnter",
        function(self)
            if self.Tooltip then
                CloseDropDowns()
                GameTooltip:SetOwner(self, "ANCHOR_BOTTOMRIGHT")
                GameTooltip:ClearLines()
                GameTooltip:SetBackdropColor(0, 0, 0, 1)
                GameTooltip:SetText(self.Tooltip, nil, nil, nil, 1, true)
                GameTooltip:Show()
            end
        end
        )
        Option[CheckEntry]:SetScript(
        "OnLeave",
        function(self)
            GameTooltip:Hide()
        end
        )
        return Option
    end
    local function Label(OptionTable, TextEntry)
        local Option = OptionTable
        Option[TextEntry]:SetPoint("TOPLEFT", OptionFrame[POIndex], "TOPLEFT", 16, -Spacing * LineIndex)
        Option[TextEntry]:SetWidth(190)
        Option[TextEntry]:SetFont(Font, FontSize)
        Option[TextEntry]:SetJustifyH("LEFT")
        Option[TextEntry]:Hide()
        return Option
    end
    local function SectionLabel(OptionTable, TextEntry)
        local Option = OptionTable
        Option[TextEntry]:SetPoint("TOPLEFT", OptionFrame[POIndex], "TOPLEFT", 3, -Spacing * LineIndex)
        Option[TextEntry]:SetWidth(190)
        Option[TextEntry]:SetFont(Font, FontSize)
        Option[TextEntry]:SetJustifyH("LEFT")
        Option[TextEntry]:Hide()
        return Option
    end
    local function NumericInputBox(OptionTable, SettingValue, SettingName, NumericEntry, x)
        local Option = OptionTable
        local Backdrop = { bgFile = "Interface\\ChatFrame\\ChatFrameBackground" }
        local EditBox = Option[NumericEntry]
        EditBox.Type = "EditBox"
        EditBox:SetPoint("TOPRIGHT", OptionFrame[POIndex], "TOPRIGHT", -x, -Spacing * LineIndex)
        EditBox:SetWidth(36)
        EditBox:SetHeight(11)
        EditBox:SetAutoFocus(false)
        EditBox:SetFontObject(ChatFontNormal)
        EditBox:SetMaxLetters(4)
        EditBox:SetBackdrop(Backdrop)
        EditBox:SetBackdropColor(ColorsTable.DarkGray.R, ColorsTable.DarkGray.G, ColorsTable.DarkGray.B, 1)
        EditBox:SetJustifyH("CENTER")
        EditBox.BackGround = CreateFrame("Frame", "$parent_BackGround", EditBox)
        local ThisBackGround = EditBox.BackGround
        ThisBackGround:SetPoint("TOPRIGHT", OptionFrame[POIndex], "TOPRIGHT", -x + 1, -(Spacing * LineIndex) + 1)
        ThisBackGround:SetWidth(38)
        ThisBackGround:SetHeight(13)
        ThisBackGround:SetFrameLevel(5)
        ThisBackGround:SetBackdrop(Backdrop)
        ThisBackGround:SetBackdropColor(1, 1, 1, 1)
        EditBox:SetFont("Fonts\\ARKai_T.ttf", 10, "OUTLINE")
        EditBox:SetScript(
        "OnEnterPressed",
        function(self)
            local CurrentOptionValue = GetOptionValue(SettingName)
            if self:GetText():gsub("[^0-9%.]", "") ~= "" then
                local NewOptionValue = tonumber(self:GetText())
                if NewOptionValue > EditBox.Maximum then
                    NewOptionValue = EditBox.Maximum
                elseif NewOptionValue < EditBox.Minimum then
                    NewOptionValue = EditBox.Minimum
                end
                SetSetting(SettingName .. SettingValue, NewOptionValue)
                self:SetText(NewOptionValue)
                self:ClearFocus()
            else
                self:SetText(CurrentOptionValue)
                SetSetting(SettingName .. SettingValue, tonumber(CurrentOptionValue))
                self:ClearFocus()
            end
            UpdateOptions()
        end
        )
        EditBox:SetScript(
        "OnEscapePressed",
        function(self)
            self:ClearFocus()
        end
        )
        EditBox:SetScript(
        "OnChar",
        function(self, text)
            if not LastOption then
                LastOption = nil
            end
            local CurrentOption = SettingName
            local CurrentOptionValue = GetOptionValue(SettingName)
            if CurrentOption ~= LastOption then
                LastNumbers = nil
            end
            if text:gsub("[^0-9%.]", "") ~= "" then
                self:SetText(self:GetText():gsub("[^0-9%.]", ""))
                LastNumbers = self:GetText():gsub("[^0-9%.]", "")
                LastOption = SettingName
                LastOptionValue = GetOptionValue(SettingName)
                SetSetting(SettingName .. SettingValue, tonumber(self:GetText()))
            elseif CurrentOption == LastOption and LastNumbers then
                LastOption = SettingName
                LastOptionValue = GetOptionValue(SettingName)
                self:SetText(LastNumbers)
                SetSetting(SettingName .. SettingValue, tonumber(LastNumbers))
                self:ClearFocus()
            elseif CurrentOption == LastOption then
                LastOption = SettingName
                LastOptionValue = GetOptionValue(SettingName)
                self:SetText(LastOptionValue)
                SetSetting(SettingName .. SettingValue, tonumber(LastOptionValue))
                self:ClearFocus()
            else
                self:SetText(CurrentOptionValue)
                SetSetting(SettingName .. SettingValue, tonumber(CurrentOptionValue))
                self:ClearFocus()
            end
        end
        )
        EditBox:SetScript(
        "OnMouseWheel",
        function(self, delta)
            local Value = tonumber(self:GetText())
            if Value then
                Value = Value + (self.Step * delta)
                if Value < self.Minimum then
                    Value = self.Minimum
                elseif Value > self.Maximum then
                    Value = self.Maximum
                end
                self:SetText(Value)
                SetSetting(SettingName .. SettingValue, Value)
                UpdateOptions()
            end
        end
        )
        EditBox:SetScript(
        "OnEnter",
        function(self)
            CloseDropDowns()
            self:SetBackdropColor(55 / 255, 55 / 255, 55 / 255, 1)
            GameTooltip:SetOwner(self, "ANCHOR_BOTTOMLEFT")
            GameTooltip:ClearLines()
            GameTooltip:SetBackdropColor(0, 0, 0, 1)
            GameTooltip:SetText("|CFFFFFFFF" .. Option[2].Tooltip, nil, nil, nil, 1, true)
            GameTooltip:Show()
        end
        )
        EditBox:SetScript(
        "OnLeave",
        function(self)
            self:SetBackdropColor(ColorsTable.DarkGray.R, ColorsTable.DarkGray.G, ColorsTable.DarkGray.B, 1)
            GameTooltip:Hide()
        end
        )
        return Option
    end
    local function DropDown(OptionTable, DDIndex, SettingValue, SettingName, DDEntry, Items, x)
        local Option = OptionTable
        Option[DDEntry]:SetPoint("TOPRIGHT", OptionFrame[POIndex], "TOPRIGHT", -x, -Spacing * LineIndex)
        local Backdrop = { bgFile = "Interface\\ChatFrame\\ChatFrameBackground" }
        local DropDown = Option[DDEntry]
        DropDown.Type = "DropDown"
        DropDown:SetPoint("TOPRIGHT", OptionFrame[POIndex], "TOPRIGHT", -x, -Spacing * LineIndex)
        DropDown:SetFrameStrata("LOW")
        DropDown:SetFrameLevel(50)
        DropDown:SetWidth(36)
        DropDown:SetHeight(11)
        DropDown:SetBackdrop(Backdrop)
        DropDown:SetBackdropColor(ColorsTable.DarkGray.R, ColorsTable.DarkGray.G, ColorsTable.DarkGray.B, 1)
        DropDown.SettingName = SettingName
        DropDown.SettingValue = SettingValue
        DropDown.BackGround = CreateFrame("Frame", "$parent_BackGround", DropDown)
        local ThisBackGround = DropDown.BackGround
        ThisBackGround:SetPoint("TOPRIGHT", OptionFrame[POIndex], "TOPRIGHT", -x + 1, -(Spacing * LineIndex) + 1)
        ThisBackGround:SetWidth(38)
        ThisBackGround:SetHeight(13)
        ThisBackGround:SetFrameLevel(5)
        ThisBackGround:SetBackdrop(Backdrop)
        ThisBackGround:SetBackdropColor(1, 1, 1, 1)
        DropDown:Show()
        DropDown:SetScript(
        "OnEnter",
        function(self)
            self:SetBackdropColor(55 / 255, 55 / 255, 55 / 255, 1)
            GameTooltip:SetOwner(self, "ANCHOR_BOTTOMLEFT")
            GameTooltip:ClearLines()
            GameTooltip:SetBackdropColor(0, 0, 0, 1)
            GameTooltip:SetText("|CFFFFFFFF" .. Option[2].Tooltip, nil, nil, nil, 1, true)
            GameTooltip:Show()
        end
        )
        DropDown:SetScript(
        "OnLeave",
        function(self)
            self:SetBackdropColor(ColorsTable.DarkGray.R, ColorsTable.DarkGray.G, ColorsTable.DarkGray.B, 1)
            GameTooltip:Hide()
        end
        )
        DropDown.Text = DropDown:CreateFontString()
        local DropDownText = DropDown.Text
        DropDownText:SetAllPoints(DropDown)
        DropDownText:SetPoint("TOPLEFT", 1, -1)
        DropDownText:SetPoint("BOTTOMRIGHT", 0, 0)
        DropDownText:SetFont(Font, FontSize - 1, "OUTLINE")
        DropDownText:SetText("默认")
        DropDownText:SetJustifyH("LEFT")
        local SelectedOption
        if type(Items[2]) == "table" and Locale == "zh" then
            local CurrentSelection = GetSetting(SettingName .. SettingValue)
            for i = 2, #Items do
                if CurrentSelection == Items[i][1] then
                    SelectedOption = Items[i][2]
                end
            end
        else
            SelectedOption = GetSetting(SettingName .. SettingValue)
        end
        DropDownText:SetText(SelectedOption)
        DropDown.Items = CreateFrame("Frame", "DropDownItems", DropDown)
        local DropDownItems = DropDown.Items
        DropDownItems:SetPoint("TOPLEFT", -2, -12)
        DropDownItems:SetWidth(90)
        DropDownItems:SetHeight(15 * #Items - 15)
        DropDownItems:SetBackdrop(Backdrop)
        DropDownItems:SetBackdropColor(ColorsTable.LightGray.R, ColorsTable.LightGray.G, ColorsTable.LightGray.B, 1)
        for i = 2, #Items do
            DropDownItems[i] = CreateFrame("Button", "DropDown" .. i, DropDownItems)
            local DropDownItem = DropDownItems[i]
            DropDownItem:SetPoint("TOPLEFT", 1, 14 - ((i - 1) * 15))
            DropDownItem:SetWidth(88)
            DropDownItem:SetHeight(13)
            DropDownItem:SetBackdrop(Backdrop)
            DropDownItem.NormalColor = "DarkGray"
            DropDownItem:SetBackdropColor(
            ColorsTable[DropDownItem.NormalColor].R,
            ColorsTable[DropDownItem.NormalColor].G,
            ColorsTable[DropDownItem.NormalColor].B,
            1
            )
            DropDownItem:Show()
            DropDownItem.ID = i
            DropDownItem:SetScript(
            "OnClick",
            function(self)
                if type(Items[2]) == "table" then
                    if Locale == "zh" then
                        DropDownText:SetText(Items[self.ID][2])
                    else
                        DropDownText:SetText(Items[self.ID][1])
                    end
                    SetSetting(SettingName .. SettingValue, Items[self.ID][1])
                else
                    DropDownText:SetText(Items[self.ID])
                    SetSetting(SettingName .. SettingValue, Items[self.ID])
                end
                SwitcherItems:Hide()
                CloseDropDowns()
            end
            )
            DropDownItem:SetScript(
            "OnEnter",
            function(self)
                self:SetBackdropColor(ColorsTable.Gray.R, ColorsTable.Gray.G, ColorsTable.Gray.B, 1)
            end
            )
            DropDownItem:SetScript(
            "OnLeave",
            function(self)
                self:SetBackdropColor(
                ColorsTable[self.NormalColor].R,
                ColorsTable[self.NormalColor].G,
                ColorsTable[self.NormalColor].B,
                1
                )
            end
            )
            DropDownItem.Text = DropDownItem:CreateFontString()
            local DropDownItemText = DropDownItem.Text
            DropDownItemText:SetAllPoints(DropDownItem)
            DropDownItemText:SetPoint("TOPLEFT", 3, 0)
            DropDownItemText:SetPoint("BOTTOMRIGHT", 0, 0)
            DropDownItemText:SetFont(Font, 8, "OUTLINE")
            if type(Items[2]) == "table" then
                if Locale == "zh" then
                    DropDownItemText:SetText(Items[i][2])
                else
                    DropDownItemText:SetText(Items[i][1])
                end
            else
                DropDownItemText:SetText(Items[i])
            end
            DropDownItemText:SetJustifyH("LEFT")
        end
        DropDownItems:Hide()
        DropDown:SetScript(
        "OnClick",
        function(self)
            if not self.Items:IsShown() then
                CloseDropDowns()
                self.Items:Show()
                local CurrentSetting = GetSetting(SettingName .. SettingValue)
                if type(Items[2]) == "table" then
                    for i = 2, #Items do
                        if CurrentSetting == Items[i][1] then
                            self.Items[i].NormalColor = "LightGray"
                        else
                            self.Items[i].NormalColor = "DarkGray"
                        end
                        self.Items[i]:SetBackdropColor(
                        ColorsTable[self.Items[i].NormalColor].R,
                        ColorsTable[self.Items[i].NormalColor].G,
                        ColorsTable[self.Items[i].NormalColor].B,
                        1
                        )
                    end
                else
                    for i = 2, #Items do
                        if CurrentSetting == Items[i] then
                            self.Items[i].NormalColor = "LightGray"
                        else
                            self.Items[i].NormalColor = "DarkGray"
                        end
                        self.Items[i]:SetBackdropColor(
                        ColorsTable[self.Items[i].NormalColor].R,
                        ColorsTable[self.Items[i].NormalColor].G,
                        ColorsTable[self.Items[i].NormalColor].B,
                        1
                        )
                    end
                end
            else
                CloseDropDowns()
                self.Items:Hide()
            end
        end
        )
        if not DropDown_Index_Bis[DDIndex] then
            DropDown_Index_Bis[DDIndex] = 1
        else
            DropDown_Index_Bis[DDIndex] = DropDown_Index_Bis[DDIndex] + 1
        end
        Option[DDEntry] = DropDown
        return Option
    end
    local function EditBoxButton(OptionTable, SettingValue, SettingName, EditEntry, x)
        local Option = OptionTable
        _G["StaticPopupDialogs"][Option[EditEntry]:GetName() .. " - Popup"] = {
            text = "设置你想要的命令.",
            button1 = "接受",
            button2 = "取消",
            OnShow = function(self, data)
                self.editBox:SetText(GetSetting(SettingName .. SettingValue))
            end,
            OnAccept = function(self, data, data2)
                local Text = self.editBox:GetText()
                SetSetting(SettingName .. SettingValue, Text)
                if string.len(Text) > 4 then
                    Text = string.sub(Text, 1, 4) .. ".."
                end
                Option[EditEntry]:SetFormattedText("|cFF26BAFF%s|r", Text)
            end,
            hasEditBox = true,
            timeout = 0,
            whileDead = true,
            hideOnEscape = true,
            preferredIndex = 3
        }
        Option[EditEntry]:SetPoint("TOPRIGHT", OptionFrame[POIndex], "TOPRIGHT", -x, -Spacing * LineIndex + 1)
        Option[EditEntry]:SetWidth(37)
        Option[EditEntry]:SetHeight(12)
        local Text = GetSetting(SettingName .. SettingValue) or "Clic"
        if string.len(Text) > 4 then
            Text = string.sub(Text, 1, 4) .. ".."
        end
        Option[EditEntry]:SetFormattedText("|cFF26BAFF%s|r", Text)
        Option[EditEntry]:SetScript(
        "OnEnter",
        function(self)
            GameTooltip:SetOwner(Option[EditEntry], "ANCHOR_TOPLEFT", 0, 0)
            GameTooltip:ClearLines()
            GameTooltip:SetBackdropColor(0, 0, 0, 1)
            GameTooltip:SetText(GetSetting(SettingName .. SettingValue), 1, 1, 1, 1, true)
            GameTooltip:Show()
        end
        )
        Option[EditEntry]:SetScript(
        "OnLeave",
        function(self)
            GameTooltip:Hide()
        end
        )
        Option[EditEntry]:SetNormalFontObject("GameFontNormalSmall")
        local ntex = Option[EditEntry]:CreateTexture()
        ntex:SetTexture("Interface/Buttons/UI-Silver-Button-Up")
        ntex:SetTexCoord(0, 0.625, 0, 0.7875)
        ntex:SetAllPoints()
        Option[EditEntry]:SetNormalTexture(ntex)
        local htex = Option[EditEntry]:CreateTexture()
        htex:SetTexture("Interface/Buttons/UI-Silver-Button-Highlight")
        htex:SetTexCoord(0, 0.625, 0, 0.7875)
        htex:SetAllPoints()
        Option[EditEntry]:SetHighlightTexture(htex)
        local ptex = Option[EditEntry]:CreateTexture()
        ptex:SetTexture("Interface/Buttons/UI-Silver-Button-Down")
        ptex:SetTexCoord(0, 0.625, 0, 0.7875)
        ptex:SetAllPoints()
        Option[EditEntry]:SetPushedTexture(ptex)
        Option[EditEntry]:SetScript(
        "OnMouseDown",
        function(self)
            _G["StaticPopup_Show"](Option[EditEntry]:GetName() .. " - Popup")
        end
        )
        return Option
    end
    local function InitFrame()
        UI_SettingsInit()
        UI:ClearAllPoints()
        UI:SetHeight(UI_Height)
        UI:SetWidth(UI_Width)
        UI:SetPoint(GetSetting("UI_AnchorPoint"), GetSetting("UI_X"), GetSetting("UI_Y"))
        UI:SetFrameStrata("LOW")
        UI:SetFrameLevel(45)
        UI:SetMovable(true)
        UI:EnableMouse(true)
        UI:SetBackdrop(UIBackdrop)
        UI:SetClampedToScreen(true)
        UI:SetBackdropColor(ColorsTable.DarkGray.R, ColorsTable.DarkGray.R, ColorsTable.DarkGray.R, 0.8)
        UI:SetScript(
        "OnShow",
        function(self)
            SetSetting("UI_Visible", true)
        end
        )
        UI:SetScript(
        "OnHide",
        function(self)
            SetSetting("UI_Visible", false)
        end
        )
        UI:SetScript(
        "OnMouseDown",
        function(self)
            CloseDropDowns()
            UI:StartMoving()
        end
        )
        UI:SetScript(
        "OnMouseUp",
        function(self)
            UI:StopMovingOrSizing()
            local Point, RelativeTo, RelativePoint, X, Y = UI:GetPoint()
            SetSetting("UI_AnchorPoint", Point)
            SetSetting("UI_X", X)
            SetSetting("UI_Y", Y)
        end
        )
    end
    local function InitStatic()
        TitleBar = CreateFrame("Frame", "$parent_TitleBar", UI)
        TitleBar:SetPoint("TOPLEFT", 1, -1)
        TitleBar:SetPoint("TOPRIGHT", -1, -1)
        TitleBar:SetHeight(TitleBar_Height)
        TitleBar:SetBackdrop(UIBackdrop)
        TitleBar:SetBackdropColor(0.184, 0.184, 0.184, 1)
        TitleBar:EnableMouse(true)
        TitleBar:SetScript(
        "OnMouseDown",
        function(self)
            UI:StartMoving()
        end
        )
        TitleBar:SetScript(
        "OnMouseUp",
        function(self)
            UI:StopMovingOrSizing()
            local Point, RelativeTo, RelativePoint, X, Y = UI:GetPoint()
            SetSetting("UI_AnchorPoint", Point)
            SetSetting("UI_X", X)
            SetSetting("UI_Y", Y)
        end
        )
        TitleBar:SetScript(
        "OnMouseWheel",
        function(self, delta)
            if delta > 0 and PageIndex == #Pages or delta < 0 and PageIndex == 1 then
                return
            end
            OptionFrame[PageIndex]:Hide()
            PageIndex = PageIndex + delta
            OptionFrame[PageIndex]:Show()
            UpdateOptions()
        end
        )
        Header = CreateFrame("Frame", "$parent_Header", UI)
        Header:SetPoint("TOPLEFT", TitleBar, "TOPLEFT", 1, -2)
        Header:SetPoint("TOPRIGHT", TitleBar, "TOPRIGHT", -1, -2)
        Header:SetHeight(12)
        PageInfo = CreateFrame("Frame", "$parent_PageInfo", Header)
        PageInfo:SetPoint("TOPLEFT", 1, -1)
        PageInfo:SetPoint("TOPRIGHT", -1, -1)
        PageInfo:SetHeight(12)
        PreviousPageButton = CreateFrame("Button", "$parent_PreviousButton", PageInfo)
        PreviousPageButton:SetPoint("TOPLEFT", PageInfo, "TOPLEFT", 1, -1)
        PreviousPageButton:SetPoint("BOTTOMRIGHT", PageInfo, "TOPLEFT", 11, -11)
        PreviousPageButton:SetBackdrop(UIBackdrop)
        PreviousPageButton:SetBackdropColor(ColorsTable.Red.R, ColorsTable.Red.G, ColorsTable.Red.B, 0.75)
        PreviousPageButton:SetScript(
        "PostClick",
        function(self)
            CloseDropDowns()
            OptionFrame[PageIndex]:Hide()
            PageIndex = PageIndex - 1
            OptionFrame[PageIndex]:Show()
            UpdateOptions()
        end
        )
        PreviousPageButtonText = PreviousPageButton:CreateFontString("$parent_Text")
        PreviousPageButtonText:SetPoint("TOPLEFT", PreviousPageButton, "TOPLEFT", 1, 0)
        PreviousPageButtonText:SetPoint("BOTTOMRIGHT", PreviousPageButton, "BOTTOMRIGHT", 0, 0)
        PreviousPageButtonText:SetFont("Fonts\\ARKai_T.ttf", 10, "OUTLINE")
        PreviousPageButtonText:SetTextColor(1, 1, 1, 1)
        PreviousPageButtonText:SetJustifyH("CENTER")
        PreviousPageButtonText:SetText("<")
        PageTitle = PageInfo:CreateFontString("$parent_Title")
        PageTitle:SetPoint("TOPLEFT", PageInfo, "TOPLEFT", 132, 0)
        PageTitle:SetFont(Font, 11, "OUTLINE")
        PageTitle:SetTextColor(ColorsTable.Blue.R, ColorsTable.Blue.G, ColorsTable.Blue.B, 1)
        PageTitle:SetJustifyH("CENTER")
        NextPageButton = CreateFrame("Button", "$parent_NextButton", PageInfo)
        NextPageButton:SetPoint("TOPRIGHT", PageInfo, "TOPRIGHT", -1, -1)
        NextPageButton:SetPoint("BOTTOMLEFT", PageInfo, "TOPRIGHT", -11, -11)
        NextPageButton:SetBackdrop(UIBackdrop)
        NextPageButton:SetBackdropColor(ColorsTable.Red.R, ColorsTable.Red.G, ColorsTable.Red.B, 0.75)
        NextPageButton:SetScript(
        "PostClick",
        function(self)
            CloseDropDowns()
            OptionFrame[PageIndex]:Hide()
            PageIndex = PageIndex + 1
            OptionFrame[PageIndex]:Show()
            UpdateOptions()
        end
        )
        NextPageButtonText = NextPageButton:CreateFontString("$parent_Text")
        NextPageButtonText:SetPoint("TOPLEFT", NextPageButton, "TOPLEFT", 2, 0)
        NextPageButtonText:SetPoint("BOTTOMRIGHT", NextPageButton, "BOTTOMRIGHT", 0, 0)
        NextPageButtonText:SetFont("Fonts\\ARKai_T.ttf", 10, "OUTLINE")
        NextPageButtonText:SetTextColor(1, 1, 1, 1)
        NextPageButtonText:SetJustifyH("CENTER")
        NextPageButtonText:SetText(">")
        local SwitcherBackdrop = { bgFile = "Interface\\ChatFrame\\ChatFrameBackground" }
        SwitcherDropDownBackGround = CreateFrame("Frame", "SwitcherDropDownBackGround", Header)
        SwitcherDropDownBackGround:SetPoint("TOPLEFT", 16, 1)
        SwitcherDropDownBackGround:SetFrameStrata("LOW")
        SwitcherDropDownBackGround:SetFrameLevel(49)
        SwitcherDropDownBackGround:SetWidth(112)
        SwitcherDropDownBackGround:SetHeight(16)
        SwitcherDropDownBackGround:SetBackdrop(SwitcherBackdrop)
        if IsOptionEnabled("自动切换配置") then
            SwitcherDropDownBackGround:SetBackdropColor(ColorsTable.Red.R, ColorsTable.Red.G, ColorsTable.Red.B, 1)
            SwitcherDropDownBackGround.Color = "Red"
        else
            SwitcherDropDownBackGround:SetBackdropColor(
            ColorsTable.LightGray.R,
            ColorsTable.LightGray.G,
            ColorsTable.LightGray.B,
            1
            )
            SwitcherDropDownBackGround.Color = "Gray"
        end
        SwitcherDropDownBackGround:Show()
        SwitcherDropDown = CreateFrame("Button", "SwitcherDropDown", Header)
        SwitcherDropDown:SetPoint("TOPLEFT", 17, 0)
        SwitcherDropDown:SetFrameStrata("LOW")
        SwitcherDropDown:SetFrameLevel(50)
        SwitcherDropDown:SetWidth(110)
        SwitcherDropDown:SetHeight(14)
        SwitcherDropDown:SetBackdrop(SwitcherBackdrop)
        SwitcherDropDown:SetBackdropColor(ColorsTable.DarkGray.R, ColorsTable.DarkGray.G, ColorsTable.DarkGray.B, 1)
        SwitcherDropDown:Show()
        SwitcherDropDown:SetScript(
        "OnEnter",
        function(self)
            self:SetBackdropColor(ColorsTable.Gray.R, ColorsTable.Gray.G, ColorsTable.Gray.B, 1)
            GameTooltip:SetOwner(self, "ANCHOR_TOPLEFT", -5)
            GameTooltip:ClearLines()
            GameTooltip:SetBackdropColor(0, 0, 0, 1)
            GameTooltip:SetText(
            "|CFFFFFFFF左键点击选择配置.\n右键点击 " .. (IsOptionEnabled("自动切换配置") and "禁用" or "启用") .. "自动切换配置.",
            nil,
            nil,
            nil,
            1,
            true
            )
            GameTooltip:Show()
        end
        )
        SwitcherDropDown:SetScript(
        "OnLeave",
        function(self)
            self:SetBackdropColor(ColorsTable.DarkGray.R, ColorsTable.DarkGray.G, ColorsTable.DarkGray.B, 1)
            GameTooltip:Hide()
        end
        )
        SwitcherDropDown.TitleBarText = SwitcherDropDown:CreateFontString()
        local SwitcherText = SwitcherDropDown.TitleBarText
        SwitcherText:SetAllPoints(SwitcherDropDown)
        SwitcherText:SetPoint("TOPLEFT", 4, -1)
        SwitcherText:SetPoint("BOTTOMRIGHT", 0, 0)
        SwitcherText:SetFont(Font, 10, "OUTLINE")
        SwitcherText:SetText("默认")
        SwitcherText:SetJustifyH("LEFT")
        SelectedProfile = SavedProfile(ProfilesTable)
        SwitcherText:SetText(SelectedProfile)
        local ProfilesTableParents = { "常规", "翡翠梦魇", "勇气试炼", "暗夜要塞", "萨格拉斯之墓", "PVP" }
        local ProfilesTableWithParents = {
            ["常规"] = { "默认", "做任务", "下副本", "史诗五人本", "打团本" },
            ["翡翠梦魇"] = { "尼珊德拉", "伊格诺斯", "艾乐瑞瑟", "乌索克", "梦魇之龙", "塞纳留斯", "萨维斯" },
            ["勇气试炼"] = { "奥丁", "高姆", "海拉" },
            ["暗夜要塞"] = { "斯考匹隆", "时空畸体", "崔利艾克斯", "奥鲁瑞尔", "艾塔乌斯", "特尔安", "克洛苏斯", "提克迪奥斯", "艾利桑德", "古尔丹" },
            ["萨格拉斯之墓"] = { "格罗斯", "恶魔审判庭", "哈亚坦", "主母萨丝琳", "月之姐妹", "绝望的聚合体", "戒卫侍女", "堕落的化身", "基尔加丹" },
            ["PVP"] = { "战场", "阿什兰", "世界PVP" }
        }
        SwitcherItems = CreateFrame("Frame", "SwitcherItems", SwitcherDropDown)
        SwitcherItems:SetPoint("TOPLEFT", 0, -14)
        SwitcherItems:SetWidth(110)
        SwitcherItems:SetHeight(14 * #ProfilesTableParents + 1)
        SwitcherItems:SetBackdrop(UIBackdrop)
        SwitcherItems:SetBackdropColor(ColorsTable.LightGray.R, ColorsTable.LightGray.G, ColorsTable.LightGray.B, 1)
        for i = 1, #ProfilesTableParents do
            SwitcherItems[i] = CreateFrame("Button", "Switcher" .. i, SwitcherItems)
            local SwitcherItem = SwitcherItems[i]
            SwitcherItem:SetPoint("TOPLEFT", 1, 14 - (i * 14) - 1)
            SwitcherItem:SetWidth(108)
            SwitcherItem:SetHeight(13)
            SwitcherItem:SetBackdrop(SwitcherBackdrop)
            SwitcherItem:SetBackdropColor(ColorsTable.DarkGray.R, ColorsTable.DarkGray.G, ColorsTable.DarkGray.B, 1)
            SwitcherItem:Show()
            SwitcherItem.ID = i
            SwitcherItem:SetScript(
            "OnEnter",
            function(self)
                self:SetBackdropColor(ColorsTable.Gray.R, ColorsTable.Gray.G, ColorsTable.Gray.B, 1)
                SwitcherItem.Childs:Show()
            end
            )
            SwitcherItem:SetScript(
            "OnLeave",
            function(self)
                self:SetBackdropColor(ColorsTable.DarkGray.R, ColorsTable.DarkGray.G, ColorsTable.DarkGray.B, 1)
                SwitcherItem.Childs:Hide()
            end
            )
            SwitcherItem.Text = SwitcherItem:CreateFontString()
            local SwitcherItemText = SwitcherItem.Text
            SwitcherItemText:SetAllPoints(SwitcherItem)
            SwitcherItemText:SetPoint("TOPLEFT", 2, 0)
            SwitcherItemText:SetPoint("BOTTOMRIGHT", 0, 0)
            SwitcherItemText:SetFont(Font, 8, "OUTLINE")
            SwitcherItemText:SetText(ProfilesTableParents[i])
            SwitcherItemText:SetJustifyH("LEFT")
            SwitcherItem.Childs = CreateFrame("Frame", "SwitcherItems" .. i .. "Childs", SwitcherItem)
            SwitcherItem.Childs:SetPoint("TOPLEFT", 108, 1)
            SwitcherItem.Childs:SetWidth(110)
            SwitcherItem.Childs:SetHeight(14 * #ProfilesTableWithParents[ProfilesTableParents[i]] + 1)
            SwitcherItem.Childs:SetBackdrop(UIBackdrop)
            SwitcherItem.Childs:SetBackdropColor(
            ColorsTable.LightGray.R,
            ColorsTable.LightGray.G,
            ColorsTable.LightGray.B,
            1
            )
            SwitcherItem.Childs:SetScript(
            "OnEnter",
            function(self)
                self:Show()
                self:GetParent():SetBackdropColor(ColorsTable.Gray.R, ColorsTable.Gray.G, ColorsTable.Gray.B, 1)
            end
            )
            SwitcherItem.Childs:SetScript(
            "OnLeave",
            function(self)
                self:Hide()
                self:GetParent():SetBackdropColor(
                ColorsTable.DarkGray.R,
                ColorsTable.DarkGray.G,
                ColorsTable.DarkGray.B,
                1
                )
            end
            )
            for j = 1, #ProfilesTableWithParents[ProfilesTableParents[i]] do
                local ChildText = ProfilesTableWithParents[ProfilesTableParents[i]][j]
                SwitcherItem.Childs[j] = CreateFrame("Button", "SwitcherChild" .. j, SwitcherItem.Childs)
                local SwitcherItemChild = SwitcherItem.Childs[j]
                SwitcherItemChild:SetPoint("TOPLEFT", 1, 14 - (j * 14) - 1)
                SwitcherItemChild:SetWidth(108)
                SwitcherItemChild:SetHeight(13)
                SwitcherItemChild:SetBackdrop(SwitcherBackdrop)
                SwitcherItemChild:SetBackdropColor(
                ColorsTable.DarkGray.R,
                ColorsTable.DarkGray.G,
                ColorsTable.DarkGray.B,
                1
                )
                SwitcherItemChild:Show()
                for k = 1, #ProfilesTable do
                    if ChildText == ProfilesTable[k] then
                        SwitcherItemChild.ID = k
                    end
                end
                SwitcherItemChild:SetScript(
                "OnClick",
                function(self)
                    EnableProfilesSwitcher()
                    SwitcherText:SetText(ProfilesTable[self.ID])
                    LoadProfile(self.ID, true)
                    SwitcherItemChild:GetParent():Hide()
                    SwitcherItems:Hide()
                end
                )
                SwitcherItemChild:SetScript(
                "OnEnter",
                function(self)
                    self:SetBackdropColor(ColorsTable.Gray.R, ColorsTable.Gray.G, ColorsTable.Gray.B, 1)
                    self:GetParent():GetParent():SetBackdropColor(
                    ColorsTable.Gray.R,
                    ColorsTable.Gray.G,
                    ColorsTable.Gray.B,
                    1
                    )
                    SwitcherItemChild:GetParent():Show()
                end
                )
                SwitcherItemChild:SetScript(
                "OnLeave",
                function(self)
                    self:SetBackdropColor(ColorsTable.DarkGray.R, ColorsTable.DarkGray.G, ColorsTable.DarkGray.B, 1)
                    self:GetParent():GetParent():SetBackdropColor(
                    ColorsTable.DarkGray.R,
                    ColorsTable.DarkGray.G,
                    ColorsTable.DarkGray.B,
                    1
                    )
                    SwitcherItemChild:GetParent():Hide()
                end
                )
                SwitcherItemChild.Text = SwitcherItemChild:CreateFontString()
                local SwitcherItemChildText = SwitcherItemChild.Text
                SwitcherItemChildText:SetAllPoints(SwitcherItemChild)
                SwitcherItemChildText:SetPoint("TOPLEFT", 2, 0)
                SwitcherItemChildText:SetPoint("BOTTOMRIGHT", 0, 0)
                SwitcherItemChildText:SetFont(Font, 8, "OUTLINE")
                SwitcherItemChildText:SetText(ChildText)
                SwitcherItemChildText:SetJustifyH("LEFT")
            end
            SwitcherItem.Childs:Hide()
        end
        SwitcherItems:Hide()
        SwitcherDropDown:SetScript(
        "OnMouseUp",
        function(self, Button)
            if Button == "LeftButton" then
                if not IsOptionEnabled("自动切换配置") and not SwitcherItems:IsShown() then
                    CloseDropDowns()
                    SwitcherItems:Show()
                else
                    CloseDropDowns()
                end
            elseif Button == "RightButton" then
                EnableProfilesSwitcher()
                CloseDropDowns()
                if IsOptionEnabled("自动切换配置") then
                    SetSetting("自动切换配置_Checked", nil)
                else
                    SetSetting("自动切换配置_Checked", true)
                end
            end
        end
        )
        StaticInitialized = true
    end
    local function InitPages()
        for Index = 1, #Pages do
            local PageName = Pages[Index]
            POIndex = Index
            OptionFrame[POIndex] = CreateFrame("Frame", "$parent_OptionFrame_" .. POIndex, UI)
            OptionFrame[POIndex]:SetPoint("TOPLEFT", TitleBar, "BOTTOMLEFT", 0, -3)
            OptionFrame[POIndex]:SetPoint("BOTTOMRIGHT", UI, "BOTTOMRIGHT", 0, 0)
            Options[POIndex] = {}
            LineIndex = 0
            for Index = 1, #OptionInfo do
                local CurrentLine = OptionInfo[Index]
                local Type = CurrentLine.Type
                if CurrentLine.Page == PageName then
                    local Option = {}
                    if Type.X == 1 and Type.Y == 1 then
                        Option = { Type, OptionFrame[POIndex]:CreateFontString("Option" .. Index .. "Label") }
                        Option = SectionLabel(Option, 2)
                    elseif Type.Y == 2 and Type.Z == 0 then
                        Option = {
                            Type,
                            CreateFrame("Button", "Option" .. Index .. "CheckButton", OptionFrame[POIndex]),
                            OptionFrame[POIndex]:CreateFontString("Option" .. Index .. "Label"),
                            CreateFrame("EditBox", "Option" .. Index .. "EditBox", OptionFrame[POIndex])
                        }
                        Option = CheckButton(Option, 2)
                        Option = Label(Option, 3)
                        Option = NumericInputBox(Option, "_Value1", CurrentLine.Name, 4, 3)
                    elseif Type.X == 2 and Type.Y == 1 then
                        Option = {
                            Type,
                            CreateFrame("Button", "Option" .. Index .. "CheckButton", OptionFrame[POIndex]),
                            OptionFrame[POIndex]:CreateFontString("Option" .. Index .. "Label")
                        }
                        Option = CheckButton(Option, 2)
                        Option = Label(Option, 3)
                    elseif Type.Y == 2 and (Type.Z == 1 or Type.Z == 2) then
                        Option = {
                            Type,
                            CreateFrame("Button", "Option" .. Index .. "CheckButton", OptionFrame[POIndex]),
                            OptionFrame[POIndex]:CreateFontString("Option" .. Index .. "Label"),
                            CreateFrame("EditBox", "Option" .. Index .. "EditBox", OptionFrame[POIndex]),
                            CreateFrame("EditBox", "Option" .. Index .. "EditBox2", OptionFrame[POIndex])
                        }
                        Option = CheckButton(Option, 2)
                        Option = Label(Option, 3)
                        Option = NumericInputBox(Option, "_Value1", CurrentLine.Name, 4, 42)
                        Option = NumericInputBox(Option, "_Value2", CurrentLine.Name, 5, 3)
                    elseif Type.Y == 2 and Type.Z == 3 then
                        local DropDownIndex
                        if not DropDown_Index_Bis[Index] then
                            DropDownIndex = Index
                        else
                            DropDownIndex = Index .. "Bis(" .. DropDown_Index_Bis[Index] .. ")"
                        end
                        Option = {
                            Type,
                            CreateFrame("Button", "Option" .. Index .. "CheckButton", OptionFrame[POIndex]),
                            OptionFrame[POIndex]:CreateFontString("Option" .. Index .. "Label"),
                            CreateFrame("EditBox", "Option" .. Index .. "EditBox", OptionFrame[POIndex]),
                            CreateFrame("Button", "Option" .. DropDownIndex .. "DropDownMenu", OptionFrame[POIndex])
                        }
                        Option = CheckButton(Option, 2)
                        Option = Label(Option, 3)
                        Option = NumericInputBox(Option, "_Value1", CurrentLine.Name, 4, 42)
                        Option = DropDown(Option, Index, "_Value2", CurrentLine.Name, 5, CurrentLine.Value2, 3)
                    elseif Type.Y == 2 and Type.Z == 4 then
                        Option = {
                            Type,
                            CreateFrame("Button", "Option" .. Index .. "CheckButton", OptionFrame[POIndex]),
                            OptionFrame[POIndex]:CreateFontString("Option" .. Index .. "Label"),
                            CreateFrame("EditBox", "Option" .. Index .. "EditBox", OptionFrame[POIndex]),
                            CreateFrame("Button", "Option" .. Index .. "EditBoxButton", OptionFrame[POIndex])
                        }
                        Option = CheckButton(Option, 2)
                        Option = Label(Option, 3)
                        Option = NumericInputBox(Option, "_Value1", CurrentLine.Name, 4, 42)
                        Option = EditBoxButton(Option, "_Value2", CurrentLine.Name, 5, 3)
                    elseif Type.Y == 3 and Type.Z == 0 then
                        local DropDownIndex
                        if not DropDown_Index_Bis[Index] then
                            DropDownIndex = Index
                        else
                            DropDownIndex = Index .. "Bis(" .. DropDown_Index_Bis[Index] .. ")"
                        end
                        Option = {
                            Type,
                            CreateFrame("Button", "Option" .. Index .. "CheckButton", OptionFrame[POIndex]),
                            OptionFrame[POIndex]:CreateFontString("Option" .. Index .. "Label"),
                            CreateFrame("Button", "Option" .. DropDownIndex .. "DropDownMenu", OptionFrame[POIndex])
                        }
                        Option = CheckButton(Option, 2)
                        Option = Label(Option, 3)
                        Option = DropDown(Option, Index, "_Value1", CurrentLine.Name, 4, CurrentLine.Value1, 3)
                    elseif Type.Y == 3 and Type.Z == 2 then
                        local DropDownIndex
                        if not DropDown_Index_Bis[Index] then
                            DropDownIndex = Index
                        else
                            DropDownIndex = Index .. "Bis(" .. DropDown_Index_Bis[Index] .. ")"
                        end
                        Option = {
                            Type,
                            CreateFrame("Button", "Option" .. Index .. "CheckButton", OptionFrame[POIndex]),
                            OptionFrame[POIndex]:CreateFontString("Option" .. Index .. "Label"),
                            CreateFrame("Button", "Option" .. DropDownIndex .. "DropDownMenu", OptionFrame[POIndex]),
                            CreateFrame("EditBox", "Option" .. Index .. "EditBox", OptionFrame[POIndex])
                        }
                        Option = CheckButton(Option, 2)
                        Option = Label(Option, 3)
                        Option = DropDown(Option, Index, "_Value1", CurrentLine.Name, 4, CurrentLine.Value1, 42)
                        Option = NumericInputBox(Option, "_Value2", CurrentLine.Name, 5, 3)
                    elseif Type.Y == 3 and Type.Z == 3 then
                        local DropDownIndex
                        if not DropDown_Index_Bis[Index] then
                            DropDownIndex = Index
                        else
                            DropDownIndex = Index .. "Bis(" .. DropDown_Index_Bis[Index] .. ")"
                        end
                        Option = {
                            Type,
                            CreateFrame("Button", "Option" .. Index .. "CheckButton", OptionFrame[POIndex]),
                            OptionFrame[POIndex]:CreateFontString("Option" .. Index .. "Label"),
                            CreateFrame("Button", "Option" .. DropDownIndex .. "DropDownMenu", OptionFrame[POIndex]),
                            CreateFrame("Button", "Option" .. DropDownIndex .. "DropDownMenu2", OptionFrame[POIndex])
                        }
                        Option = CheckButton(Option, 2)
                        Option = Label(Option, 3)
                        Option = DropDown(Option, Index, "_Value1", CurrentLine.Name, 4, CurrentLine.Value1, 42)
                        Option = DropDown(Option, Index, "_Value2", CurrentLine.Name, 5, CurrentLine.Value2, 3)
                    elseif Type.Y == 3 and Type.Z == 4 then
                        local DropDownIndex
                        if not DropDown_Index_Bis[Index] then
                            DropDownIndex = Index
                        else
                            DropDownIndex = Index .. "Bis(" .. DropDown_Index_Bis[Index] .. ")"
                        end
                        Option = {
                            Type,
                            CreateFrame("Button", "Option" .. Index .. "CheckButton", OptionFrame[POIndex]),
                            OptionFrame[POIndex]:CreateFontString("Option" .. Index .. "Label"),
                            CreateFrame("Button", "Option" .. DropDownIndex .. "DropDownMenu", OptionFrame[POIndex]),
                            CreateFrame("Button", "Option" .. Index .. "EditBoxButton", OptionFrame[POIndex])
                        }
                        Option = CheckButton(Option, 2)
                        Option = Label(Option, 3)
                        Option = DropDown(Option, Index, "_Value1", CurrentLine.Name, 4, CurrentLine.Value1, 42)
                        Option = EditBoxButton(Option, "_Value2", CurrentLine.Name, 5, 3)
                    elseif Type.Y == 4 and Type.Z == 0 then
                        Option = {
                            Type,
                            CreateFrame("Button", "Option" .. Index .. "CheckButton", OptionFrame[POIndex]),
                            OptionFrame[POIndex]:CreateFontString("Option" .. Index .. "Label"),
                            CreateFrame("Button", "Option" .. Index .. "EditBoxButton", OptionFrame[POIndex])
                        }
                        Option = CheckButton(Option, 2)
                        Option = Label(Option, 3)
                        Option = EditBoxButton(Option, "_Value1", CurrentLine.Name, 4, 3)
                    elseif Type.Y == 4 and Type.Z == 2 then
                        Option = {
                            Type,
                            CreateFrame("Button", "Option" .. Index .. "CheckButton", OptionFrame[POIndex]),
                            OptionFrame[POIndex]:CreateFontString("Option" .. Index .. "Label"),
                            CreateFrame("Button", "Option" .. Index .. "EditBoxButton", OptionFrame[POIndex]),
                            CreateFrame("EditBox", "Option" .. Index .. "EditBox", OptionFrame[POIndex])
                        }
                        Option = CheckButton(Option, 2)
                        Option = Label(Option, 3)
                        Option = EditBoxButton(Option, "_Value1", CurrentLine.Name, 4, 42)
                        Option = NumericInputBox(Option, "_Value2", CurrentLine.Name, 5, 3)
                    elseif Type.Y == 4 and Type.Z == 3 then
                        local DropDownIndex
                        if not DropDown_Index_Bis[Index] then
                            DropDownIndex = Index
                        else
                            DropDownIndex = Index .. "Bis(" .. DropDown_Index_Bis[Index] .. ")"
                        end
                        Option = {
                            Type,
                            CreateFrame("Button", "Option" .. Index .. "CheckButton", OptionFrame[POIndex]),
                            OptionFrame[POIndex]:CreateFontString("Option" .. Index .. "Label"),
                            CreateFrame("Button", "Option" .. Index .. "EditBoxButton", OptionFrame[POIndex]),
                            CreateFrame("Button", "Option" .. DropDownIndex .. "DropDownMenu", OptionFrame[POIndex])
                        }
                        Option = CheckButton(Option, 2)
                        Option = Label(Option, 3)
                        Option = EditBoxButton(Option, "_Value1", CurrentLine.Name, 4, 42)
                        Option = DropDown(Option, Index, "_Value2", CurrentLine.Name, 5, CurrentLine.Value2, 3)
                    elseif Type.Y == 4 and Type.Z == 4 then
                        Option = {
                            Type,
                            CreateFrame("Button", "Option" .. Index .. "CheckButton", OptionFrame[POIndex]),
                            OptionFrame[POIndex]:CreateFontString("Option" .. Index .. "Label"),
                            CreateFrame("Button", "Option" .. Index .. "EditBoxButton", OptionFrame[POIndex]),
                            CreateFrame("Button", "Option" .. Index .. "EditBoxButton2", OptionFrame[POIndex])
                        }
                        Option = CheckButton(Option, 2)
                        Option = Label(Option, 3)
                        Option = EditBoxButton(Option, "_Value1", CurrentLine.Name, 4, 42)
                        Option = EditBoxButton(Option, "_Value2", CurrentLine.Name, 5, 3)
                    end
                    LineIndex = LineIndex + 1
                    Options[POIndex][LineIndex] = Option
                end
            end
        end
        for Index = 1, #OptionFrame do
            OptionFrame[Index]:Hide()
        end
        OptionFrame[PageIndex]:Show()
        UpdateOptions()
    end
    function CreateUI()
        InitFrame()
        if not StaticInitialized then
            InitStatic()
        end
        InitPages()
        local Visible = GetSetting("UI_Visible")
        if Visible == false then
            UI:Hide()
        else
            UI:Show()
        end
        UISpec = GetSpecialization()
    end
    local TranslatedPages = {
        ["高级设置"] = "高级",
        ["大技能"] = "冷却时间",
        ["防御"] = "防御性",
        ["附加"] = "额外",
        ["物品"] = "项目",
        ["常规"] = "一般",
        ["治愈"] = "复原",
        ["攻/防"] = "进攻/防守",
        ["宠物对战"] = "宠物战",
        ["进攻"] = "进攻",
        ["亲和"] = "亲和力"
    }
    function UpdateOptions()
        local PageName = Pages[PageIndex]
        local PageCount = {}
        if Locale == "zh" then
            PageTitle:SetText(TranslatedPages[PageName])
        else
            PageTitle:SetText(PageName)
        end
        local Count = 0
        for Index, Info in pairs(OptionInfo) do
            if PageCount[Info.Page] then
                PageCount[Info.Page] = PageCount[Info.Page] + 1
            else
                PageCount[Info.Page] = 1
            end
            if Info.Page == PageIndex or Info.Page == PageName then
                local Option = Options[PageIndex][Count + 1]
                local CheckEntry, TextEntry, NumericEntry1, NumericEntry2, DDEntry1, DDEntry2 = nil, nil, nil, nil, nil
                local Type = Info.Type
                if Type.X == 1 and Type.Y == 1 then
                    TextEntry = 2
                elseif Type.Y == 2 and Type.Z == 0 then
                    CheckEntry = 2
                    TextEntry = 3
                    NumericEntry1 = 4
                elseif Type.X == 2 and Type.Y == 1 then
                    CheckEntry = 2
                    TextEntry = 3
                elseif Type.Y == 2 and (Type.Z == 1 or Type.Z == 2) then
                    CheckEntry = 2
                    TextEntry = 3
                    NumericEntry1 = 4
                    NumericEntry2 = 5
                elseif Type.Y == 2 and Type.Z == 3 then
                    CheckEntry = 2
                    TextEntry = 3
                    NumericEntry1 = 4
                    DDEntry1 = 5
                elseif Type.Y == 2 and Type.Z == 4 then
                    CheckEntry = 2
                    TextEntry = 3
                    NumericEntry1 = 4
                elseif Type.Y == 3 and Type.Z == 0 then
                    CheckEntry = 2
                    TextEntry = 3
                    DDEntry1 = 4
                elseif Type.Y == 3 and Type.Z == 2 then
                    CheckEntry = 2
                    TextEntry = 3
                    DDEntry1 = 4
                    NumericEntry1 = 5
                elseif Type.Y == 3 and Type.Z == 3 then
                    CheckEntry = 2
                    TextEntry = 3
                    DDEntry1 = 4
                    DDEntry2 = 5
                elseif Type.Y == 3 and Type.Z == 4 then
                    CheckEntry = 2
                    TextEntry = 3
                    DDEntry1 = 4
                elseif Type.Y == 4 and Type.Z == 0 then
                    CheckEntry = 2
                    TextEntry = 3
                elseif Type.Y == 4 and Type.Z == 2 then
                    CheckEntry = 2
                    TextEntry = 3
                    NumericEntry1 = 5
                elseif Type.Y == 4 and Type.Z == 3 then
                    CheckEntry = 2
                    TextEntry = 3
                    DDEntry1 = 5
                elseif Type.Y == 4 and Type.Z == 4 then
                    CheckEntry = 2
                    TextEntry = 3
                end
                if Locale == "zh" then
                    Option[TextEntry]:SetText(Info.ChineseName)
                else
                    Option[TextEntry]:SetText(Info.Name)
                end
                if not (Type.X == 1 and Type.Y == 1) then
                    Option[CheckEntry].Tooltip = Info.Tooltip
                    Option[CheckEntry].Name = Info.Name
                    Option[CheckEntry]:SetBackdrop(UIBackdrop)
                    if GetSetting(Info.Name .. "_Checked") then
                        Option[CheckEntry]:SetBackdropColor(
                        ColorsTable.Blue.R,
                        ColorsTable.Blue.G,
                        ColorsTable.Blue.B,
                        0.75
                        )
                    else
                        Option[CheckEntry]:SetBackdropColor(
                        ColorsTable.LightGray.R,
                        ColorsTable.LightGray.G,
                        ColorsTable.LightGray.B,
                        0.75
                        )
                    end
                    Option[CheckEntry]:SetBackdropBorderColor(0, 0, 0, 1)
                    if Type.X == 1 then
                        Option[CheckEntry]:SetAlpha(0)
                    else
                        Option[CheckEntry]:SetAlpha(1)
                    end
                    Option[CheckEntry]:Show()
                    if Type.Y == 2 or Type.Z == 2 then
                        local Value
                        local Minimum, Maximum, Step, Gap
                        if Type.Y ~= 2 and Type.Z == 2 then
                            Value = GetSetting(Info.Name .. "_Value2") or Info.Value2[1] or 0
                            Minimum, Maximum, Step = Info.Value2[2], Info.Value2[3], Info.Value2[4]
                        else
                            Value = GetSetting(Info.Name .. "_Value1") or Info.Value1[1] or 0
                            Minimum, Maximum, Step, Gap = Info.Value1[2], Info.Value1[3], Info.Value1[4], Info.Value1[5]
                        end
                        Option[NumericEntry1]:SetText(Value)
                        Option[NumericEntry1].Step = Step
                        Option[NumericEntry1].Minimum = Minimum
                        Option[NumericEntry1].Maximum = Maximum
                        Option[NumericEntry1]:Show()
                        if Type.Z == 1 or (Type.Y == 2 and Type.Z == 2) then
                            local Value2 = GetSetting(Info.Name .. "_Value2") or Info.Value2[1] or 0
                            if Type.Y == 2 and Type.Z == 2 then
                                Minimum, Maximum, Step = Info.Value2[2], Info.Value2[3], Info.Value2[4]
                                Option[NumericEntry2]:SetText(Value2)
                                Option[NumericEntry2].Step = Step
                                Option[NumericEntry2].Minimum = Minimum
                                Option[NumericEntry2].Maximum = Maximum
                                Option[NumericEntry2]:Show()
                            elseif Type.Z == 1 then
                                Option[NumericEntry1].Maximum = Value2 - Gap
                                Option[NumericEntry2]:SetText(Value2)
                                Option[NumericEntry2].Step = Step
                                Option[NumericEntry2].Minimum = Value + Gap
                                Option[NumericEntry2].Maximum = Maximum
                                Option[NumericEntry2]:Show()
                            end
                        end
                    end
                    local Value, Found, DisplayEntry
                    if Type.Y == 3 then
                        if type(Info.Value1[2]) == "string" then
                            Value = GetSetting(Info.Name .. "_Value1") or Info.Value1[Info.Value1[1] + 1] or ""
                            Found = false
                            for i = 2, #Info.Value1 do
                                if Value == Info.Value1[i] then
                                    Found = true
                                end
                            end
                            if Found then
                                Option[DDEntry1].Text:SetText(Value)
                                Option[DDEntry1]:Show()
                            else
                                local DefaultValue = Info.Value1[Info.Value1[1] + 1]
                                StatusUpdate(
                                Info.Name ..
                                "'s 1st value changed back to " ..
                                DefaultValue .. " as " .. Value .. " is not a valid option."
                                )
                                Overlay(Info.Name .. " value 1 back to " .. DefaultValue)
                                SetSetting(Info.Name .. "_Value1", DefaultValue)
                                Option[DDEntry1].Text:SetText(DefaultValue)
                                Option[DDEntry1]:Show()
                            end
                        else
                            Value = GetSetting(Info.Name .. "_Value1") or Info.Value1[Info.Value1[1] + 1][1] or ""
                            Found = false
                            for i = 2, #Info.Value1 do
                                if Value == Info.Value1[i][1] then
                                    Found = true
                                    DisplayEntry = Locale == "zh" and Info.Value1[i][2] or Info.Value1[i][1]
                                end
                            end
                            if Found then
                                Option[DDEntry1].Text:SetText(DisplayEntry)
                                Option[DDEntry1]:Show()
                            else
                                local DefaultValue = Info.Value1[Info.Value1[1] + 1]
                                StatusUpdate(
                                Info.Name ..
                                "'s 1st value changed back to " ..
                                DefaultValue .. " as " .. Value .. " is not a valid option."
                                )
                                Overlay(Info.Name .. " value 1 back to " .. DefaultValue)
                                SetSetting(Info.Name .. "_Value1", DefaultValue)
                                Option[DDEntry1].Text:SetText(DefaultValue)
                                Option[DDEntry1]:Show()
                            end
                        end
                    end
                    if Type.Z == 3 then
                        if type(Info.Value2[2]) == "string" then
                            local SpecificDDEntry = Type.Y == 3 and DDEntry2 or DDEntry1
                            Value = GetSetting(Info.Name .. "_Value2") or Info.Value2[Info.Value2[1] + 1] or ""
                            Found = false
                            for i = 2, #Info.Value2 do
                                if Value == Info.Value2[i] then
                                    Found = true
                                end
                            end
                            if Found then
                                Option[SpecificDDEntry].Text:SetText(Value)
                                Option[SpecificDDEntry]:Show()
                            else
                                local DefaultValue = Info.Value2[Info.Value2[1] + 1]
                                StatusUpdate(
                                Info.Name ..
                                "'s 2nd value changed back to " ..
                                DefaultValue .. " as " .. Value .. " is not a valid option."
                                )
                                Overlay(Info.Name .. " value 2 back to " .. DefaultValue)
                                SetSetting(Info.Name .. "_Value2", DefaultValue)
                                Option[SpecificDDEntry].Text:SetText(DefaultValue)
                                Option[SpecificDDEntry]:Show()
                            end
                        else
                            local SpecificDDEntry = Type.Y == 3 and DDEntry2 or DDEntry1
                            Value = GetSetting(Info.Name .. "_Value2") or Info.Value2[Info.Value2[1] + 1][1] or ""
                            Found = false
                            for i = 2, #Info.Value2 do
                                if Value == Info.Value2[i][1] then
                                    Found = true
                                    DisplayEntry = Locale == "zh" and Info.Value2[i][2] or Info.Value2[i][1]
                                end
                            end
                            if Found then
                                Option[SpecificDDEntry].Text:SetText(DisplayEntry)
                                Option[SpecificDDEntry]:Show()
                            else
                                local DefaultValue =                                 type(Info.Value2[Info.Value2[1] + 1]) == "string" and
                                Info.Value2[Info.Value2[1] + 1] or
                                Info.Value2[Info.Value2[1] + 1][1]
                                StatusUpdate(
                                Info.Name ..
                                "'s 2nd value changed back to " ..
                                DefaultValue .. " as " .. Value .. " is not a valid option."
                                )
                                Overlay(Info.Name .. " value 2 back to " .. DefaultValue)
                                SetSetting(Info.Name .. "_Value2", DefaultValue)
                                Option[SpecificDDEntry].Text:SetText(DefaultValue)
                                Option[SpecificDDEntry]:Show()
                            end
                        end
                    end
                end
                Option[TextEntry]:Show()
                Count = Count + 1
            end
        end
        if PageIndex == 1 then
            PreviousPageButton:Disable()
        else
            PreviousPageButton:Enable()
        end
        if PageIndex == #Pages or #Pages == 0 then
            NextPageButton:Disable()
        else
            NextPageButton:Enable()
        end
        local MaxPage = nil
        local MaxCount = 0
        for Page, Count in pairs(PageCount) do
            if not MaxPage or Count > MaxCount then
                MaxPage = Page
                MaxCount = Count
            end
        end
        UI:SetHeight(UI_Height + Spacing * MaxCount)
    end
    function ClearOptions()
        Pages = {}
        OptionInfo = {}
        for Index = 1, #OptionFrame do
            OptionFrame[Index]:Hide()
        end
    end
    function AddPage(Name)
        table.insert(Pages, Name)
        return #Pages
    end
    function AddSection(Page, Names, Color, Code)
        local ChineseName, Name
        if type(Names) == "string" then
            Name, ChineseName = Names, Names
        elseif type(Names) ~= nil then
            Name, ChineseName = Names[1], Names[2]
        end
        if Color == "自定义" and Code then
            Name, ChineseName = "|cFF" .. Code .. Name .. "|r", "|cFF" .. Code .. ChineseName .. "|r"
        elseif Color == "Blue" then
            Name, ChineseName = "|cFF0066FF" .. Name .. "|r", "|cFF0066FF" .. ChineseName .. "|r"
        elseif Color == "Red" then
            Name, ChineseName = "|cFFFF0044" .. Name .. "|r", "|cFFFF0044" .. ChineseName .. "|r"
        elseif Color == "Green" then
            Name, ChineseName = "|cFF66FF00" .. Name .. "|r", "|cFF66FF00" .. ChineseName .. "|r"
        elseif Color == "JadeGreen" then
            Name, ChineseName = "|cFF00EE99" .. Name .. "|r", "|cFF00EE99" .. ChineseName .. "|r"
        elseif Color == "Yellow" then
            Name, ChineseName = "|cFFFFD700" .. Name .. "|r", "|cFFFFD700" .. ChineseName .. "|r"
        elseif Color == "Orange" then
            Name, ChineseName = "|cFFFF8000" .. Name .. "|r", "|cFFFF8000" .. ChineseName .. "|r"
        elseif not Color == "None" then
            Name, ChineseName = "|cFFFFFFFF" .. Name .. "|r", "|cFFFFFFFF" .. ChineseName .. "|r"
        end
        AddNewOption(Page, { Name, ChineseName }, 110)
        return
    end
    function AddOption(
    Page,
    Name,
    CheckedIfNotSaved,
    Tooltip,
    NumericInput,
    NumericInputValue,
    NumericInputMinimum,
    NumericInputMaximum,
    NumericInputStep,
    NumericInputSecondValue)
        local Type, CheckedIfNotSaved, Value1, Value2 = 210, CheckedIfNotSaved, nil, nil
        if NumericInput then
            if NumericInputSecondValue then
                Type = 221
            else
                Type = 220
            end
        end
        if CheckedIfNotSaved == "locked" then
            Type = 120
            CheckedIfNotSaved = true
        end
        if NumericInputSecondValue then
            Value1 = { NumericInputSecondValue, NumericInputMinimum, NumericInputMaximum, NumericInputStep, 20 }
            Value2 = { NumericInputValue }
        elseif NumericInputValue then
            Value1 = { NumericInputValue, NumericInputMinimum, NumericInputMaximum, NumericInputStep }
        end
        AddNewOption(Page, Name, Type, CheckedIfNotSaved, Value1, Value2, Tooltip)
    end
    function AddNewOption(Page, Names, Type, CheckedIfNotSaved, Value1, Value2, Tooltips)
        local ChineseName, Name, Tooltip
        if type(Names) == "string" then
            Name, ChineseName = Names, Names
        elseif type(Names) ~= nil then
            Name, ChineseName = Names[1], Names[2]
        end
        if Tooltips ~= nil then
            Tooltip = type(Tooltips) == "string" and Tooltips or Locale == "zh" and Tooltips[2] or Tooltips[1]
        end
        local StringType = tostring(Type)
        local Type = {}
        Type.X = tonumber(string.sub(StringType, 1, 1))
        Type.Y = tonumber(string.sub(StringType, 2, 2))
        Type.Z = tonumber(string.sub(StringType, 3, 3))
        local CheckedIfNotSaved = Type.X == 1 and true or CheckedIfNotSaved
        local CheckedText = Locale == "zh" and "开" or "开"
        local UnCheckedText = Locale == "zh" and "未选中" or "关"
        if Tooltip ~= nil then
            Tooltip = C.TOOLTIP_DESCRIPTION .. Tooltip
            if Type.Y == 1 then
                Tooltip =                 Tooltip ..
                (Type.X == 2 and C.TOOLTIP_DEFAULT_STATE .. (CheckedIfNotSaved and CheckedText or UnCheckedText) or
                "")
            elseif Type.Y == 2 and Type.Z == 0 then
                Tooltip =                 Tooltip ..
                (Type.X == 2 and C.TOOLTIP_DEFAULT_STATE .. (CheckedIfNotSaved and CheckedText or UnCheckedText) or
                "\n") ..
                C.TOOLTIP_DEFAULT_VALUE .. tostring(Value1[1])
            elseif Type.Y == 3 and Type.Z == 0 then
                local Value1Default =                 type(Value1[Value1[1] + 1]) == "string" and Value1[Value1[1] + 1] or
                Locale == "zh" and Value1[Value1[1] + 1][2] or
                Value1[Value1[1] + 1][1]
                Tooltip =                 Tooltip ..
                (Type.X == 2 and C.TOOLTIP_DEFAULT_STATE .. (CheckedIfNotSaved and CheckedText or UnCheckedText) or
                "\n") ..
                C.TOOLTIP_DEFAULT_VALUE .. Value1Default
            elseif Type.Y == 2 and (Type.Z == 1 or Type.Z == 2) then
                Tooltip =                 Tooltip ..
                (Type.X == 2 and C.TOOLTIP_DEFAULT_STATE .. (CheckedIfNotSaved and CheckedText or UnCheckedText) or
                "\n") ..
                C.TOOLTIP_DEFAULT_VALUE_1 ..
                tostring(Value1[1]) .. C.TOOLTIP_DEFAULT_VALUE_2 .. tostring(Value2[1])
            elseif Type.Y == 2 and Type.Z == 3 then
                local Value2Default =                 type(Value2[Value2[1] + 1]) == "string" and Value2[Value2[1] + 1] or
                Locale == "zh" and Value2[Value2[1] + 1][2] or
                Value2[Value2[1] + 1][1]
                Tooltip =                 Tooltip ..
                (Type.X == 2 and C.TOOLTIP_DEFAULT_STATE .. (CheckedIfNotSaved and CheckedText or UnCheckedText) or
                "\n") ..
                C.TOOLTIP_DEFAULT_VALUE_1 .. tostring(Value1[1]) .. C.TOOLTIP_DEFAULT_VALUE_2 .. Value2Default
            elseif Type.Y == 2 and Type.Z == 4 then
                Tooltip =                 Tooltip ..
                (Type.X == 2 and C.TOOLTIP_DEFAULT_STATE .. (CheckedIfNotSaved and CheckedText or UnCheckedText) or
                "\n") ..
                C.TOOLTIP_DEFAULT_VALUE_1 .. tostring(Value1[1]) .. C.TOOLTIP_DEFAULT_VALUE_2 .. Value2
            elseif Type.Y == 3 and Type.Z == 2 then
                local Value1Default =                 type(Value1[Value1[1] + 1]) == "string" and Value1[Value1[1] + 1] or
                Locale == "zh" and Value1[Value1[1] + 1][2] or
                Value1[Value1[1] + 1][1]
                Tooltip =                 Tooltip ..
                (Type.X == 2 and C.TOOLTIP_DEFAULT_STATE .. (CheckedIfNotSaved and CheckedText or UnCheckedText) or
                "\n") ..
                C.TOOLTIP_DEFAULT_VALUE_1 .. Value1Default .. C.TOOLTIP_DEFAULT_VALUE_2 .. tostring(Value2[1])
            elseif Type.Y == 3 and Type.Z == 3 then
                local Value1Default =                 type(Value1[Value1[1] + 1]) == "string" and Value1[Value1[1] + 1] or
                Locale == "zh" and Value1[Value1[1] + 1][2] or
                Value1[Value1[1] + 1][1]
                local Value2Default =                 type(Value2[Value2[1] + 1]) == "string" and Value2[Value2[1] + 1] or
                Locale == "zh" and Value2[Value2[1] + 1][2] or
                Value2[Value2[1] + 1][1]
                Tooltip =                 Tooltip ..
                (Type.X == 2 and C.TOOLTIP_DEFAULT_STATE .. (CheckedIfNotSaved and CheckedText or UnCheckedText) or
                "\n") ..
                C.TOOLTIP_DEFAULT_VALUE_1 .. Value1Default .. C.TOOLTIP_DEFAULT_VALUE_2 .. Value2Default
            elseif Type.Y == 3 and Type.Z == 4 then
                local Value1Default =                 type(Value1[Value1[1] + 1]) == "string" and Value1[Value1[1] + 1] or
                Locale == "zh" and Value1[Value1[1] + 1][2] or
                Value1[Value1[1] + 1][1]
                Tooltip =                 Tooltip ..
                (Type.X == 2 and C.TOOLTIP_DEFAULT_STATE .. (CheckedIfNotSaved and CheckedText or UnCheckedText) or
                "\n") ..
                C.TOOLTIP_DEFAULT_VALUE_1 .. Value1Default .. C.TOOLTIP_DEFAULT_VALUE_2 .. Value2
            elseif Type.Y == 4 and Type.Z == 2 then
                Tooltip =                 Tooltip ..
                (Type.X == 2 and C.TOOLTIP_DEFAULT_STATE .. (CheckedIfNotSaved and CheckedText or UnCheckedText) or
                "\n") ..
                C.TOOLTIP_DEFAULT_VALUE_1 .. Value1 .. C.TOOLTIP_DEFAULT_VALUE_2 .. tostring(Value2[1])
            elseif Type.Y == 4 and Type.Z == 3 then
                local Value2Default =                 type(Value2[Value2[1] + 1]) == "string" and Value2[Value2[1] + 1] or
                Locale == "zh" and Value2[Value2[1] + 1][2] or
                Value2[Value2[1] + 1][1]
                Tooltip =                 Tooltip ..
                (Type.X == 2 and C.TOOLTIP_DEFAULT_STATE .. (CheckedIfNotSaved and CheckedText or UnCheckedText) or
                "\n") ..
                C.TOOLTIP_DEFAULT_VALUE_1 .. Value1 .. C.TOOLTIP_DEFAULT_VALUE_2 .. Value2Default
            elseif Type.Y == 4 and Type.Z == 4 then
                Tooltip =                 Tooltip ..
                (Type.X == 2 and C.TOOLTIP_DEFAULT_STATE .. (CheckedIfNotSaved and CheckedText or UnCheckedText) or
                "\n") ..
                C.TOOLTIP_DEFAULT_VALUE_1 .. Value1 .. C.TOOLTIP_DEFAULT_VALUE_2 .. Value2
            end
        end
        table.insert(
        OptionInfo,
        {
            ["Page"] = Page,
            ["Name"] = Name,
            ["ChineseName"] = ChineseName,
            ["Type"] = Type,
            ["CheckedIfNotSaved"] = CheckedIfNotSaved,
            ["Value1"] = Value1,
            ["Value2"] = Value2,
            ["Tooltip"] = Tooltip
        }
        )
        local SettingChecked = Name .. "_Checked"
        local SettingValue1 = Name .. "_Value1"
        local SettingValue2 = Name .. "_Value2"
        if Type.X == 1 or (Type.X == 2 and GetSetting(SettingChecked) == nil) then
            SetSetting(SettingChecked, CheckedIfNotSaved)
        end
        if Value1 and Type.Y == 2 then
            if not GetSetting(SettingValue1) or type(GetSetting(SettingValue1)) ~= "number" then
                SetSetting(SettingValue1, Value1[1])
            end
            if GetSetting(SettingValue1) < Value1[2] then
                SetSetting(SettingValue1, Value1[2])
            end
            if GetSetting(SettingValue1) > Value1[3] then
                SetSetting(SettingValue1, Value1[3])
            end
        end
        if Value2 and Type.Z == 2 then
            if not GetSetting(SettingValue2) or type(GetSetting(SettingValue2)) ~= "number" then
                SetSetting(SettingValue2, Value2[1])
            end
            if GetSetting(SettingValue2) < Value2[2] then
                SetSetting(SettingValue2, Value2[2])
            end
            if GetSetting(SettingValue2) > Value2[3] then
                SetSetting(SettingValue2, Value2[3])
            end
        end
        if Value1 and Value2 and Type.Y == 2 and Type.Z == 1 then
            if not GetSetting(SettingValue2) or type(GetSetting(SettingValue2)) ~= "number" then
                SetSetting(SettingValue2, Value2[1])
            end
            if GetSetting(SettingValue2) < GetSetting(SettingValue1) then
                SetSetting(SettingValue2, GetSetting(SettingValue1))
            end
            if GetSetting(SettingValue2) > Value1[3] then
                SetSetting(SettingValue2, Value1[3])
            end
            if GetSetting(SettingValue1) > GetSetting(SettingValue2) then
                SetSetting(SettingValue1, GetSetting(SettingValue2))
            end
        end
        if Value1 and Type.Y == 3 then
            if not GetSetting(SettingValue1) or type(GetSetting(SettingValue1)) ~= "string" then
                SetSetting(
                SettingValue1,
                type(Value1[Value1[1] + 1]) == "string" and Value1[Value1[1] + 1] or Value1[Value1[1] + 1][1]
                )
            end
            local Value1IsCorrect = false
            local ValueFromSettings = GetSetting(SettingValue1)
            if type(Value1[Value1[1] + 1]) == "string" then
                for Index, Value in pairs(Value1) do
                    if Index > 1 and ValueFromSettings == Value then
                        Value1IsCorrect = true
                    end
                end
            else
                for Index, Value in pairs(Value1) do
                    if Index > 1 and ValueFromSettings == Value[1] then
                        Value1IsCorrect = true
                    end
                end
            end
            if not Value1IsCorrect then
                SetSetting(
                SettingValue1,
                type(Value1[Value1[1] + 1]) == "string" and Value1[Value1[1] + 1] or Value1[Value1[1] + 1][1]
                )
            end
        end
        if Value2 and Type.Z == 3 then
            if not GetSetting(SettingValue2) or type(GetSetting(SettingValue2)) ~= "string" then
                SetSetting(
                SettingValue2,
                type(Value2[Value2[1] + 1]) == "string" and Value2[Value2[1] + 1] or Value2[Value2[1] + 1][1]
                )
            end
            local Value2IsCorrect = false
            local ValueFromSettings = GetSetting(SettingValue2)
            if type(Value2[Value2[1] + 1]) == "string" then
                for Index, Value in pairs(Value2) do
                    if Index > 1 and ValueFromSettings == Value then
                        Value2IsCorrect = true
                    end
                end
            else
                for Index, Value in pairs(Value2) do
                    if Index > 1 and ValueFromSettings == Value[1] then
                        Value2IsCorrect = true
                    end
                end
            end
            if not Value2IsCorrect then
                SetSetting(
                SettingValue2,
                type(Value2[Value2[1] + 1]) == "string" and Value2[Value2[1] + 1] or Value2[Value2[1] + 1][1]
                )
            end
        end
        if Value1 and Type.Y == 4 then
            if not GetSetting(SettingValue1) or type(GetSetting(SettingValue1)) ~= "string" then
                SetSetting(SettingValue1, Value1)
            end
        end
        if Value2 and Type.Z == 4 then
            if not GetSetting(SettingValue2) or type(GetSetting(SettingValue2)) ~= "string" then
                SetSetting(SettingValue2, Value2)
            end
        end
    end
    function UICmd()
        local Visible = UI:IsVisible()
        if Visible then
            UI:Hide()
        else
            UI:Show()
        end
        if Locale == "zh" then
            StatusUpdate(not Visible and "用户界面|cFF40FF00显示。" or "用户界面|cFFFF0000隐。")
            Overlay(not Visible and "用户界面|cFF40FF00显示" or "用户界面|cFFFF0000隐")
        else
            StatusUpdate(not Visible and "设置界面 |cFF40FF00显示." or "设置界面 |cFFFF0000隐藏.")
            Overlay(not Visible and "设置界面 |cFF40FF00显示" or "设置界面 |cFFFF0000隐藏")
        end
    end
    function SettingsCmd()
        local String = ""
        local function WriteLine(Line)
            String = String .. Line .. "\n"
        end
        local CurrentOptionName
        for i = 1, #OptionInfo do
            CurrentOptionName = OptionInfo[i].Name
            WriteLine(
            tostring(CurrentOptionName) ..
            "\nEnabled: " ..
            tostring(IsOptionEnabled(CurrentOptionName)) ..
            "\nValue1: " ..
            tostring(GetOptionValue(CurrentOptionName)) ..
            "\nValue2: " .. tostring(GetSecondOptionValue(CurrentOptionName)) .. "\n"
            )
        end
        WF(GetManagerDirectory() .. SettingsDirectoryChange, String)
        StatusUpdate("Settings Log Created! Please check your Manager folder.")
        return
    end
end
UnitsEngine = {}
UnitsEngine.Temp = { Friendly = {}, Healing = {}, Hostile = {}, UnitsInfos = {} }
UnitsEngine.Units = { Friendly = {}, Healing = {}, Hostile = {}, UnitsInfos = {} }
UnitInfoCache = {}
function UnitsEngine.Fetch()
    WipeTable(UnitsEngine.Temp.Friendly)
    WipeTable(UnitsEngine.Temp.Healing)
    WipeTable(UnitsEngine.Temp.Hostile)
    WipeTable(UnitsEngine.Temp.UnitsInfos)
    local ThisUnit, IsFriendly, IsType
    local X, Y, Z = OP("player")
    local AllowPlayers = true
    if Unlocker ~= "wToolkit64" then
        for Index = 1, GUNPC(X, Y, Z, 70) do
            ThisUnit = Unit(GUNPBI(Index))
            if ThisUnit.UnitID ~= nil then
                IsType = ThisUnit:CreatureType()
                if ThisUnit:Exists() and IsType ~= "Critter" and IsType ~= "Wild Pet" and not ThisUnit:IsPet() then
                    Attackable = Player:CanAttack(ThisUnit)
                    ThisUnit.X, ThisUnit.Y, ThisUnit.Z = OP(ThisUnit.UnitID)
                    UnitsEngine.Temp.UnitsInfos[ThisUnit:GUID()] = {
                        CanAttack = Attackable,
                        IsInCombat = ThisUnit:IsInCombat(true)
                    }
                    if Attackable and (AllowPlayers or not ThisUnit:IsPlayer()) then
                        UnitsEngine.Temp.Hostile[#UnitsEngine.Temp.Hostile + 1] = ThisUnit
                    else
                        UnitsEngine.Temp.Friendly[#UnitsEngine.Temp.Friendly + 1] = ThisUnit
                        if
                        UnitInRaid(ThisUnit.UnitID) or UnitInParty(ThisUnit.UnitID) or
                        UnitIsUnit("player", ThisUnit.UnitID)
                        then
                            UnitsEngine.Temp.Healing[#UnitsEngine.Temp.Healing + 1] = ThisUnit
                        end
                    end
                end
            end
        end
    else
        local GU = GOOT(ObjectTypes.Unit)
        for Index = 1, #GU do
            ThisUnit = Unit(GU[Index])
            if ThisUnit.UnitID ~= nil then
                IsType = ThisUnit:CreatureType()
                if IsType ~= nil and IsType ~= "Critter" and IsType ~= "Wild Pet" and not ThisUnit:IsPet() then
                    Attackable = Player:CanAttack(ThisUnit)
                    UnitsEngine.Temp.UnitsInfos[ThisUnit:GUID()] = {
                        CanAttack = Attackable,
                        IsInCombat = ThisUnit:IsInCombat(true)
                    }
                    if Attackable and (AllowPlayers or not ThisUnit:IsPlayer()) then
                        UnitsEngine.Temp.Hostile[#UnitsEngine.Temp.Hostile + 1] = ThisUnit
                    else
                        UnitsEngine.Temp.Friendly[#UnitsEngine.Temp.Friendly + 1] = ThisUnit
                        if
                        UnitInRaid(ThisUnit.UnitID) or UnitInParty(ThisUnit.UnitID) or
                        UnitIsUnit("player", ThisUnit.UnitID)
                        then
                            UnitsEngine.Temp.Healing[#UnitsEngine.Temp.Healing + 1] = ThisUnit
                        end
                    end
                end
            end
        end
    end
    Player.X, Player.Y, Player.Z = OP(Player.UnitID)
    if Target:Exists() then
        Target.X, Target.Y, Target.Z = OP(Target.UnitID)
    end
    UnitsEngine.Updated = true
end
UnitsEngine.NextUpdate = GetTime() + 0.2
function UnitsEngine.Update()
    if GetTime() > UnitsEngine.NextUpdate and (Player:GlobalCooldown() > 0.3 or Player:GlobalCooldown() < 0.1) then
        WipeTable(UnitsEngine.StoredPositions)
        UnitsEngine.Fetch()
        UnitsEngine.NextUpdate = GetTime() + 0.2
        UnitsEngine.ShouldCleanup = false
    end
    if UnitsEngine.ShouldCleanup then
        if (Unlocker == "FireHack" or Unlocker == "EWT") then
            WipeTable(UnitsEngine.Units.Hostile)
            for k, v in ipairs(UnitsEngine.Temp.Hostile) do
                if OE(v.UnitID) and not v:IsHardBlacklisted() then
                    UnitsEngine.Units.Hostile[#UnitsEngine.Units.Hostile + 1] = v
                else
                    UnitsEngine.Temp.Hostile[k] = nil
                end
            end
            WipeTable(UnitsEngine.Units.Friendly)
            for k, v in ipairs(UnitsEngine.Temp.Friendly) do
                if OE(v.UnitID) and not v:PreventHealingChecks() then
                    UnitsEngine.Units.Friendly[#UnitsEngine.Units.Friendly + 1] = v
                else
                    UnitsEngine.Temp.Friendly[k] = nil
                end
            end
            WipeTable(UnitsEngine.Units.Healing)
            for k, v in ipairs(UnitsEngine.Temp.Healing) do
                if OE(v.UnitID) and not v:PreventHealingChecks() then
                    UnitsEngine.Units.Healing[#UnitsEngine.Units.Healing + 1] = v
                else
                    UnitsEngine.Temp.Healing[k] = nil
                end
            end
        end
    else
        WipeTable(UnitsEngine.Units.Hostile)
        for i = 1, #UnitsEngine.Temp.Hostile do
            if not UnitsEngine.Temp.Hostile[i]:IsHardBlacklisted() then
                UnitsEngine.Units.Hostile[#UnitsEngine.Units.Hostile + 1] = UnitsEngine.Temp.Hostile[i]
            end
        end
        WipeTable(UnitsEngine.Units.Friendly)
        for i = 1, #UnitsEngine.Temp.Friendly do
            if not UnitsEngine.Temp.Friendly[i]:PreventHealingChecks() then
                UnitsEngine.Units.Friendly[#UnitsEngine.Units.Friendly + 1] = UnitsEngine.Temp.Friendly[i]
            end
        end
        WipeTable(UnitsEngine.Units.Healing)
        for i = 1, #UnitsEngine.Temp.Healing do
            if not UnitsEngine.Temp.Healing[i]:PreventHealingChecks() then
                UnitsEngine.Units.Healing[#UnitsEngine.Units.Healing + 1] = UnitsEngine.Temp.Healing[i]
            end
        end
    end
    UnitsEngine.ShouldCleanup = true
end
UnitsEngine.StoredTables = {}
function Unit:EnemiesWithinDistance(Distance, PlayerCenteredAoE, BypassCCAndCombat, PlayerUnitsOnly)
    if ResfreshStoredTables then
        ResfreshStoredTables = false
        WipeTable(UnitsEngine.StoredTables)
    end
    local EnemiesTable, ThisUnit = {}, nil
    local EnemyUnits, AdditionalDistance = nil, PlayerCenteredAoE and 0 or 1.5
    for i = 1, #UnitsEngine.StoredTables do
        if UnitsEngine.StoredTables[i].Distance >= Distance + AdditionalDistance then
            EnemyUnits = UnitsEngine.StoredTables[i].Table
        end
    end
    if EnemyUnits == nil then
        EnemyUnits = UnitsEngine.Units.Hostile
        for i = 1, #EnemyUnits do
            ThisUnit = EnemyUnits[i]
            if
            ThisUnit:Exists() and not ThisUnit:IsDeadOrGhost() and
            self:DistanceTo(ThisUnit, false, PlayerCenteredAoE) <= Distance and
            not ThisUnit:IsHardBlacklisted() and
            not ThisUnit:IsBlacklisted() and
            (BypassCCAndCombat or
            (ThisUnit:IsInCombat() and
            (not IsOptionEnabled("Check Group Threat") or ThisUnit:HasGroupThreat()))) and
            (BypassCCAndCombat or not ThisUnit:IsCrowdControlled()) and
            (not PlayerUnitsOnly or ThisUnit:IsPlayer()) and
            Unit.Player:CanAttack(ThisUnit)
            then
                EnemiesTable[#EnemiesTable + 1] = ThisUnit
            end
        end
    else
        for i = 1, #EnemyUnits do
            ThisUnit = EnemyUnits[i]
            if self:DistanceTo(ThisUnit, false, PlayerCenteredAoE) <= Distance then
                EnemiesTable[#EnemiesTable + 1] = ThisUnit
            end
        end
    end
    UnitsEngine.StoredTables[#UnitsEngine.StoredTables + 1] = {
        Distance = Distance + AdditionalDistance,
        Table = EnemiesTable
    }
    return EnemiesTable
end
function Unit:FilterEnemiesByDistance(Table, Distance, PlayerCenteredAoE)
    local EnemyUnitsWithinDistance = {}
    local Units = Table
    for Index = 1, #Units do
        local ThisUnit = Units[Index]
        if self:DistanceTo(ThisUnit, false, PlayerCenteredAoE) <= Distance then
            table.insert(EnemyUnitsWithinDistance, ThisUnit)
        end
    end
    return EnemyUnitsWithinDistance
end
function Unit:FilterEnemiesByDebuff(Table, Debuff)
    local EnemyUnitsWithDebuff = {}
    local Units = Table
    for Index = 1, #Units do
        local ThisUnit = Units[Index]
        if ThisUnit:Debuff(Debuff) then
            table.insert(EnemyUnitsWithDebuff, ThisUnit)
        end
    end
    return EnemyUnitsWithDebuff
end
function Unit:BestClusterOfMobsToDot(Debuff, Remains, Radius, Facing, Range, IncludeTarget)
    local AllUnits = {}
    local uX, uY, uZ = OP(Player.UnitID)
    local AllUnitsAround = GUNPC(uX, uY, uZ, 40)
    for i = 1, AllUnitsAround do
        local ThisUnit = Unit(GUNPBI(i))
        if
        (Facing ~= true or Player:IsFacing(ThisUnit)) and ThisUnit:Exists() and not ThisUnit:IsDeadOrGhost() and
        Player:DistanceTo(ThisUnit) <= 40 and
        not ThisUnit:IsHardBlacklisted() and
        (ThisUnit:IsInCombat() or ThisUnit:IsDummy()) and
        Player:CanAttack(ThisUnit) and
        not ThisUnit:IsCrowdControlled()
        then
            table.insert(AllUnits, ThisUnit)
        end
    end
    local BestUnit, BestUnitCount, ThisUnit, ThisUnitCount, ThisUnit2, Range, TargetGUID =     nil,
    0,
    nil,
    0,
    nil,
    Range or 40,
    IncludeTarget and UnitGUID("target") or nil
    for i = 1, #AllUnits do
        ThisUnit = AllUnits[i]
        if Player:DistanceTo(ThisUnit) <= Range then
            ThisUnitCount, TargetIncluded = 0, not IncludeTarget and true or false
            for j = 1, #AllUnits do
                ThisUnit2 = AllUnits[j]
                if ThisUnit:DistanceTo(ThisUnit2, true) <= Radius and ThisUnit:DebuffRemains(Debuff) <= Remains then
                    if not TargetIncluded and ThisUnit2:GUID() == TargetGUID then
                        TargetIncluded = true
                    end
                    ThisUnitCount = ThisUnitCount + 1
                end
            end
            if (not IncludeTarget or TargetIncluded) and ThisUnitCount > BestUnitCount then
                BestUnit = ThisUnit
                BestUnitCount = ThisUnitCount
            end
        end
    end
    return BestUnit
end
function Unit.FirstWhere(Function, Type)
    local Units = nil
    if Type == "Enemy" then
        Units = UnitsEngine.Units.Hostile
    elseif Type == "Friendly" then
        Units = UnitsEngine.Units.Friendly
    else
        Units = Units
    end
    for Index = 1, #Units do
        local ThisUnit = Units[Index]
        if ThisUnit:Exists() and Function(ThisUnit) then
            return ThisUnit
        end
    end
    return nil
end
function GetAnglesBetweenPositions(X1, Y1, Z1, X2, Y2, Z2)
    local Angle = math.sqrt(math.pow(X1 - X2, 2) + math.pow(Y1 - Y2, 2))
    if Angle == 0 then
        Angle = 1
    end
    return math.atan2(Y2 - Y1, X2 - X1) % (math.pi * 2), math.atan((Z1 - Z2) / Angle) % math.pi
end
function GetAnglesBetweenObjects(Object1, Object2)
    local X1, Y1, Z1 = GetUnitPosition(Object1)
    local X2, Y2, Z2 = GetUnitPosition(Object2)
    return GetAnglesBetweenPositions(X1, Y1, Z1, X2, Y2, Z2)
end
function Unit:UnitsInFrontConeAroundUnit(Unit, Range, Angle)
    local X1, Y1, Z1 = self:Position():Expand()
    local X2, Y2, Z2 = Unit:Position():Expand()
    if not X1 or not X2 then
        return {}
    end
    local MyAngleToTarget = GetAnglesBetweenPositions(X1, Y1, Z1, X2, Y2, Z2)
    local ConeUnits = {}
    local TheseEnemies = self:EnemiesWithinDistance(Range, true)
    for i = 1, #TheseEnemies do
        local ThisUnit = TheseEnemies[i]
        if not self:Equals(ThisUnit) then
            local X3, Y3, Z3 = ThisUnit:Position():Expand()
            if X1 and X3 then
                local MyAngleToOtherUnit = GetAnglesBetweenPositions(X1, Y1, Z1, X3, Y3, Z3)
                local AnglesDifference =                 MyAngleToTarget > MyAngleToOtherUnit and MyAngleToTarget - MyAngleToOtherUnit or
                MyAngleToOtherUnit - MyAngleToTarget
                local AnglesBetweenUnits =                 AnglesDifference < math.pi and AnglesDifference or math.pi * 2 - AnglesDifference
                local FinalAngle = AnglesBetweenUnits / math.pi * 360
                if (FinalAngle < Angle or (self:DistanceTo(ThisUnit) < 3 and self:IsFacing(ThisUnit))) then
                    table.insert(ConeUnits, ThisUnit)
                end
            end
        end
    end
    return ConeUnits
end
function Unit:SpecialHealthPercentage(Spell)
    if self:IsHardBlacklisted() or not Unit.Player:InLineOfSight(self) then
        return 101
    end
    local TotalHealth = 100
    local incomingHeals = UnitGetIncomingHeals(self.UnitID) or 0
    local absorbs = UnitGetTotalHealAbsorbs(self.UnitID) or 0
    local health = UnitHealth(self.UnitID) + incomingHeals - absorbs
    local maxHealth = UnitHealthMax(self.UnitID)
    healthaftermod = health
    if maxHealth == 0 then
        return 100
    end
    if healthaftermod / maxHealth * 100 > 100 then
        TotalHealth = 100
    else
        TotalHealth = healthaftermod / maxHealth * 100
    end
    return TotalHealth
end
function Unit.FirstGroupWhere(Function, IncludePlayer)
    if IsInGroup() then
        local Units = {}
        if IsInRaid() then
            for Index = 1, GetNumGroupMembers() do
                local ThisUnit = Unit("Raid" .. Index)
                if ThisUnit:Exists() and (IncludePlayer or ThisUnit ~= Unit.Player) and Function(ThisUnit) then
                    return ThisUnit
                end
            end
        else
            for Index = 1, GetNumGroupMembers() - 1 do
                local ThisUnit = Unit("Party" .. Index)
                if ThisUnit:Exists() and Function(ThisUnit) then
                    return ThisUnit
                end
            end
            if IncludePlayer and Function(Unit.Player) then
                return Unit.Player
            end
        end
        return nil
    else
        return (IncludePlayer and Function(Unit.Player)) and Unit.Player or nil
    end
end
ExcludedLowests = {
    [1784] = { { Spell(180166), "AbsorbDebuff" } },
    [1786] = { { Spell(181488), "Phase" } },
    [1783] = { { Spell(181295), "Phase" } },
    [1777] = { { Spell(181295), "Phase" } },
    [0] = { { Spell(209858), "Stacks", 30 }, { Spell(221270), "AbsorbDebuff" } }
}
function Unit.Lowest(Table, ExcludedUnit1, ExcludedUnit2)
    local Lowest, LowestHealth, Conditions, ThisUnit, ShouldExclude = nil, 101, {}, nil, false
    if ExcludedLowests[EncounterID] ~= nil then
        Conditions = ExcludedLowests[EncounterID]
    end
    for i = 1, #Table do
        ThisUnit, ShouldExclude = Table[i], false
        if
        (ExcludedUnit1 == nil or ThisUnit:GUID() ~= ExcludedUnit1:GUID()) and
        (ExcludedUnit2 == nil or ThisUnit:GUID() ~= ExcludedUnit2:GUID())
        then
            if not Lowest or ThisUnit:SpecialHealthPercentage() < LowestHealth then
                if #Conditions ~= 0 then
                    for j = 1, #Conditions do
                        if
                        Conditions[j][2] == "Phase" and
                        ((Player:DebuffAny(Conditions[j][1]) and not ThisUnit:DebuffAny(Conditions[j][1])) or
                        (not Player:DebuffAny(Conditions[j][1]) and ThisUnit:DebuffAny(Conditions[j][1])))
                        then
                            ShouldExclude = true
                        elseif Conditions[j][2] == "AbsorbDebuff" and (not Focus or not Focus:GUID() == ThisUnit:GUID()) then
                            ShouldExclude = true
                        elseif
                        Conditions[j][2] == "Stacks" and
                        ThisUnit:DebuffCountAny(Conditions[j][1]) >= Conditions[j][3]
                        then
                            ShouldExclude = true
                        end
                    end
                end
                if not ShouldExclude then
                    Lowest, LowestHealth = ThisUnit, ThisUnit:SpecialHealthPercentage()
                end
            end
        end
    end
    return Lowest
end
function Unit.GetMainTanks()
    local Player, Focus, Unit = Player, Unit.Focus, Unit
    local MainTank, MainTankTarget, OffTank, OffTankTarget
    local ThisUnit, TheseUnits, AllTanks = nil, {}, {}
    if IsInRaid() then
        for Index = 1, GetNumGroupMembers() do
            ThisUnit = Unit("Raid" .. Index)
            if ThisUnit:Exists() then
                table.insert(TheseUnits, ThisUnit)
            end
        end
    else
        for Index = 1, GetNumGroupMembers() - 1 do
            ThisUnit = Unit("Party" .. Index)
            if ThisUnit:Exists() then
                table.insert(TheseUnits, ThisUnit)
            end
        end
        table.insert(TheseUnits, Unit.Player)
    end
    for i = 1, #TheseUnits do
        ThisUnit = TheseUnits[i]
        if
        ThisUnit:Exists() and (UnitGroupRolesAssigned(ThisUnit.UnitID) == "TANK" or ThisUnit:CreatureID() == 72218) and
        not ThisUnit:IsDeadOrGhost() and
        not ThisUnit:PreventHealingChecks() and
        Player:InLineOfSight(ThisUnit)
        then
            table.insert(AllTanks, ThisUnit)
        end
    end
    table.sort(
    AllTanks,
    function(x, y)
        return x:MaxHealth() > y:MaxHealth()
    end
    )
    if
    IsOptionEnabled("焦点分配") and Focus:Exists() and not Focus:IsDeadOrGhost() and
    (Player:CanSupport(Focus) or Player:Equals(Focus))
    then
        if GetOptionValue("焦点分配") == "主坦" then
            MainTank = Focus
        else
            OffTank = Focus
        end
    end
    MainTank = not MainTank and IsInGroup() and AllTanks[1] or MainTank
    MainTankTarget = MainTank and Unit(MainTank.UnitID .. "target") or nil
    if not OffTank and MainTank and AllTanks[1] and IsInGroup() and not MainTank:Equals(AllTanks[1]) then
        OffTank = AllTanks[1]
    elseif not OffTank then
        OffTank = AllTanks[2]
    end
    OffTankTarget = OffTank and Unit(OffTank.UnitID .. "target") or nil
    MainTank = MainTank and OffTank and OffTank:Equals(MainTank) and AllTanks[2] or MainTank
    SetOutput("|cFF9A2EFE主T:", MainTank and MainTank:Name() or "没有主T")
    SetOutput("|cFF9A2EFE副T:", OffTank and OffTank:Name() or "没有副T")
    return MainTank, MainTankTarget, OffTank, OffTankTarget
end
HealingEngine = {}
function Unit:HealUnitsAround(HealthThreshold, Distance)
    if not HealingEngine[self.UnitID] or HealingEngine[self.UnitID].Refresh < GetTime() then
        if HealingEngine[self.UnitID] then
            table.wipe(HealingEngine[self.UnitID])
        else
            HealingEngine[self.UnitID] = {}
        end
        HealingEngine[self.UnitID].Refresh = GetTime()
        local HealingUnits, ThisUnit = UnitsEngine.Units.Healing, nil
        for i = 1, #HealingUnits do
            ThisUnit = HealingUnits[i]
            if ThisUnit:Exists() and not ThisUnit:IsDeadOrGhost() and Player:InLineOfSight(ThisUnit) then
                table.insert(
                HealingEngine[self.UnitID],
                { Unit = ThisUnit, Health = ThisUnit:SpecialHealthPercentage(), Distance = self:DistanceTo(ThisUnit) }
                )
            end
        end
    end
    local HealingEngineTable, HealingEngineUnits, AllHealingEngineUnits, ThisUnit =     HealingEngine[self.UnitID],
    {},
    {},
    nil
    for i = 1, #HealingEngineTable do
        ThisUnit = HealingEngineTable[i]
        if ThisUnit.Distance <= Distance then
            if ThisUnit.Health <= HealthThreshold then
                table.insert(HealingEngineUnits, ThisUnit.Unit)
            end
            table.insert(AllHealingEngineUnits, ThisUnit.Unit)
        end
    end
    return HealingEngineUnits, AllHealingEngineUnits
end
function Unit:UnitsInFrontCone(Range, Angle, Allies, AlliesHealth, PlayerUnitsOnly)
    local X1, Y1, Z1 = self:Position():Expand()
    local MyAngle = self:Facing()
    local playerVar = false
    if PlayerUnitsOnly then
        playerVar = true
    end
    local ConeUnits = {}
    local TheseEnemies =     Allies and self:HealUnitsAround(AlliesHealth, Range) or
    self:EnemiesWithinDistance(Range, true, false, playerVar)
    for i = 1, #TheseEnemies do
        local ThisUnit = TheseEnemies[i]
        if not self:Equals(ThisUnit) and (ThisUnit:Health() > 100 or ThisUnit:IsDummy()) then
            local X3, Y3, Z3 = ThisUnit:Position():Expand()
            if X1 and X3 then
                local MyAngleToOtherUnit = GetAnglesBetweenPositions(X1, Y1, Z1, X3, Y3, Z3)
                local AnglesDifference =                 MyAngle > MyAngleToOtherUnit and MyAngle - MyAngleToOtherUnit or MyAngleToOtherUnit - MyAngle
                local AnglesBetweenUnits =                 AnglesDifference < math.pi and AnglesDifference or math.pi * 2 - AnglesDifference
                local FinalAngle = AnglesBetweenUnits / math.pi * 360
                if FinalAngle < Angle then
                    table.insert(ConeUnits, ThisUnit)
                end
            end
        end
    end
    if Allies and self:SpecialHealthPercentage() <= AlliesHealth then
        table.insert(ConeUnits, self)
    end
    return ConeUnits
end
function Unit:UnitsInFrontRectangle(Range, Width, Allies, AlliesHealth)
    local X1, Y1, Z1 = self:Position():Expand()
    local MyAngle = self:Facing()
    local RectangleUnits = {}
    local TheseEnemies = Allies and self:HealUnitsAround(AlliesHealth, Range) or self:EnemiesWithinDistance(Range, true)
    local Left90 = MyAngle - math.pi / 2
    Left90 = Left90 < 0 and Left90 + math.pi * 2 or Left90
    local LeftProjX, LeftProjY = X1 + math.cos(Left90) * Width, Y1 + math.sin(Left90) * Width
    local Right90 = MyAngle + math.pi / 2
    Right90 = Right90 < math.pi * 2 and Right90 or Right90 - math.pi * 2
    local RightProjX, RightProjY = X1 + math.cos(Right90) * Width, Y1 + math.sin(Right90) * Width
    for i = 1, #TheseEnemies do
        local ThisUnit = TheseEnemies[i]
        if not self:Equals(ThisUnit) and (ThisUnit:Health() > 100 or ThisUnit:IsDummy()) then
            local X2, Y2, Z2 = ThisUnit:Position():Expand()
            if X2 then
                local LeftProjAngleToOtherUnit = GetAnglesBetweenPositions(LeftProjX, LeftProjY, Z1, X2, Y2, Z2)
                local RightProjAngleToOtherUnit = GetAnglesBetweenPositions(RightProjX, RightProjY, Z1, X2, Y2, Z2)
                local IsLeftOK =                 MyAngle > math.pi / 2 * 3 and LeftProjAngleToOtherUnit < math.pi / 2 and
                LeftProjAngleToOtherUnit + math.pi * 2 - MyAngle < math.pi / 2 or
                LeftProjAngleToOtherUnit - MyAngle > 0
                local IsRightOK =                 MyAngle < math.pi / 2 and RightProjAngleToOtherUnit > math.pi / 2 * 3 and
                MyAngle + math.pi * 2 - RightProjAngleToOtherUnit < math.pi / 2 or
                MyAngle - RightProjAngleToOtherUnit > 0
                if self:IsFacing(ThisUnit) and IsLeftOK and IsRightOK then
                    table.insert(RectangleUnits, ThisUnit)
                end
            end
        end
    end
    if Allies and self:SpecialHealthPercentage() <= AlliesHealth then
        table.insert(RectangleUnits, self)
    end
    return RectangleUnits
end
function Unit.DotCycle(TheseUnits, Spell, Debuff, Duration, OptionName, ExcludeTarget, ApplyOnce)
    if IsOptionEnabled(OptionName) then
        local OptionValue1, OptionValue2 =         GetOptionValue(OptionName),
        IsInInstance() and GetSecondOptionValue(OptionName) * 1000000 or 0
        local BestUnit, BestUnitHealth, BestUnitDuration, ThisUnit, ThisUnitHealth, ThisUnitDuration, ThisUnitIsDummy
        local DebuffsCount, MinimumDuration = 0, Duration * 0.3 - Spell:CastTime()
        for i = 1, #TheseUnits do
            ThisUnit = TheseUnits[i]
            ThisUnitHealth, ThisUnitDuration, ThisUnitIsDummy =             ThisUnit:Health(),
            ThisUnit:DebuffRemains(Debuff),
            ThisUnit:IsDummy()
            DebuffsCount =             ThisUnitDuration ~= 0 and ThisUnitDuration > MinimumDuration and DebuffsCount + 1 or DebuffsCount
            if
            ThisUnit:Exists() and (not ApplyOnce or not ThisUnit:Debuff(Debuff)) and
            (not ExcludeTarget or not ThisUnit:Equals(ExcludeTarget)) and
            (ThisUnitIsDummy or ThisUnit:IsInCombat()) and
            (ThisUnitIsDummy or ThisUnitHealth >= OptionValue2) and
            (ThisUnitDuration < MinimumDuration or ThisUnitDuration == 0) and
            ThisUnit:CanCast(Spell, false, false, false, true)
            then
                if
                (not BestUnit or ThisUnitDuration <= BestUnitDuration) and
                (not BestUnit or ThisUnitHealth >= BestUnitHealth)
                then
                    BestUnit, BestUnitHealth, BestUnitDuration = ThisUnit, ThisUnitHealth, ThisUnitDuration
                end
            end
        end
        return DebuffsCount < OptionValue1 and BestUnit or nil
    else
        return nil
    end
end
function Unit.LightEnemyAvailableForSpellHP(Enemies, Spell, Health, Inverted, TTD)
    local ThisUnit
    for i = 1, #Enemies do
        ThisUnit = Enemies[i]
        if
        (ThisUnit:HealthPercentage() < Health or Inverted and ThisUnit:HealthPercentage() > Health) and
        (ThisUnit:IsInCombat() or ThisUnit:IsDummy()) and
        ThisUnit:Exists() and
        not ThisUnit:IsHardBlacklisted() and
        not ThisUnit:IsCrowdControlled() and
        Player:CanAttack(ThisUnit) and
        (not TTD or ThisUnit:TimeToDie() <= TTD) and
        Player:IsWithinCastRange(ThisUnit, Spell) and
        (not Spell:IsFacingRequired() or Player:IsFacing(ThisUnit)) and
        Player:InLineOfSight(ThisUnit)
        then
            return ThisUnit
        end
    end
end
DontCastDebuff = {["Concealing Murk"] = Spell(230959) }
function Unit:CanCast(Spell, BypassMovingCheck, BypassUsable, BypassCrowdControl, BypassCooldown, APIRange)
    if Spell then
        if self:Exists() then
            if BypassUsable or Spell:IsUsable() then
                if BypassCooldown or not Spell:IsOnCooldown() then
                    if BypassMovingCheck or not Player:IsMoving() or Spell:CastTime() == 0 then
                        if
                        UnitIsUnit(Player.UnitID, self.UnitID) or
                        (Player:InLineOfSight(self) and
                        ((APIRange and Player:IsWithinCastRange(self, Spell, true)) or
                        Player:IsWithinCastRange(self, Spell)) and
                        (not Spell:IsFacingRequired() or Player:IsFacing(self)) and
                        (BypassCrowdControl or not self:IsCrowdControlled()) and
                        not self:IsBlacklisted())
                        then
                            if not Spell:IsHostile() then
                                if
                                (self == Player or Player:CanSupport(self)) and
                                (Spell:IsResurrect() or not self:IsDeadOrGhost())
                                then
                                    if not self:PreventHealingChecks() then
                                        return true
                                    end
                                end
                            elseif
                            not self:IsDead() and Player:CanAttack(self) and
                            (EncounterID ~= 2037 or not IsOptionEnabled("在昏暗隐匿中停止输出(主母绿水)") or
                            not Player:DebuffAny(DontCastDebuff["Concealing Murk"]))
                            then
                                return true
                            end
                        end
                    end
                end
            end
        end
    end
end
function Unit:PetCanCast(Spell)
    return Spell:IsUsable() and not Spell:IsOnCooldown() and
    ((self == Player and not Spell:IsHostile()) or (Player:CanAttack(self) == Spell:IsHostile()) or
    (Player:CanSupport(self) ~= Spell:IsHostile())) and
    PlayerPet:IsWithinCastRange(self, Spell) and
    PlayerPet:InLineOfSight(self)
end
function Unit:Cast(Spell, ByID)
    Player.WasMouselooking = IsMouselooking()
    if ByID then
        CastSpellByID(Spell:ID(), self.UnitID)
    else
        CastSpellByName(Spell:Name(), self.UnitID)
    end
    if IAP() then
        local PlayerPosition, SelfPosition = Player:Position(), self:Position()
        local RandomRange = 1.25
        local PositionX, PositionY, PositionZ =         SelfPosition["X"] + math.random(-100, 100) / 100 * RandomRange,
        SelfPosition["Y"] + math.random(-100, 100) / 100 * RandomRange,
        SelfPosition["Z"]
        local Distance =         math.sqrt(
        ((PlayerPosition["X"] - PositionX) ^ 2) + ((PlayerPosition["Y"] - PositionY) ^ 2) +
        ((PlayerPosition["Z"] - PositionZ) ^ 2)
        )
        if Spell:MaximumRange() > Distance then
            CAP(PositionX, PositionY, PositionZ)
        end
    end
    if CancelByMacro then
        RunMacroText("/stopspelltarget")
    else
        CPS()
    end
    if not Casted or (Casted ~= Spell:Name() or GetTime() - UpdatedTime1 > 0.7) then
        local SpellName, UnitName, UnitID = Spell:Name() or "", self:Name() or "", self.UnitID or ""
        Bug(
        "|cFFFF1100" ..
        SpellName ..
        " |cFFFFFFFFon |cFFFF1100" .. UnitID .. " |cFFFFFFFF(|cFFC0C0C0" .. UnitName .. "|cFFFFFFFF)"
        )
        Casted = Spell:Name()
        UpdatedTime1 = GetTime()
    end
    if Player.WasMouselooking then
        MouselookStart()
    end
    Spell.LastCastTime = GetTime()
end
function Unit:UseItem(Item)
    if Item:TimeSinceUse() >= 1 then
        local FoundItem = false
        for i = 1, #Equipment do
            if Equipment[i] == Item.Identifier then
                UseInventoryItem(i)
                FoundItem = true
            end
        end
        if not FoundItem then
            UseItemByName(Item.Identifier, self.UnitID)
        end
        local ItemName, UnitName, UnitID = Item:Name() or "", self:Name() or "", self.UnitID or ""
        Bug(
        "|cFFFF1100" ..
        ItemName ..
        " |cFFFFFFFFon |cFFFF1100" .. UnitID .. " |cFFFFFFFF(|cFFC0C0C0" .. UnitName .. "|cFFFFFFFF)"
        )
        Item.LastUseTime = GetTime()
    end
end
function Unit:CastGroundSpell(ThisSpell, OptionName, Radius, IgnoreBlacklist)
    GroundCastTarget = self.UnitID
    local MaxRange = ThisSpell:MaximumRange()
    local Mode, UnitsOption = GetOptionValue(OptionName), GetSecondOptionValue(OptionName)
    if not TemporaryBlackList[self.UnitID] or IgnoreBlacklist or TemporaryBlackList[self.UnitID] < GetTime() then
        if Mode == "目标" or (Mode == "Target Standing" and (not Target:IsMoving() or Player:DistanceTo(Target) < Radius)) then
            local TargetUnits = #Target:EnemiesWithinDistance(Radius)
            TargetUnits = TargetUnits == 0 and 1 or TargetUnits
            if TargetUnits >= UnitsOption and Target:CanCast(ThisSpell) and Player:DistanceTo(Target) <= MaxRange then
                Target:Cast(ThisSpell, nil, 8, 1.2)
                Player:ForceCastGroundTowardUnit(self, ThisSpell, Player:DistanceTo(Target), Radius - 1)
                return true
            end
        end
        if Mode == "Centered" or Mode == "Centered Standing" then
            local AllowInMovement = Mode == "Centered Standing" and false or true
            if Target:CastGround(ThisSpell, UnitsOption, Radius, MaxRange, AllowInMovement) then
                return true
            end
        end
        if Mode == "Under Player" and not IsFalling() and Target:CanCast(ThisSpell) then
            local ProjectionDistance, PlayerDistanceToTarget =             GetOptionValue(OptionName .. " Distance"),
            Player:DistanceTo(Target)
            ProjectionDistance =             ProjectionDistance < PlayerDistanceToTarget and ProjectionDistance or PlayerDistanceToTarget / 2
            if PlayerDistanceToTarget < Radius - 1 + ProjectionDistance then
                local TargetUnits = #Target:EnemiesWithinDistance(Radius)
                TargetUnits = TargetUnits == 0 and 1 or TargetUnits
                if TargetUnits >= UnitsOption then
                    Player:ForceCastGroundTowardUnit(self, ThisSpell, ProjectionDistance, 1.25)
                    return true
                end
            end
        end
        if Mode == "Under Player Standing" and Player:Standing() > 0.5 and not IsFalling() and Target:CanCast(ThisSpell) then
            local ProjectionDistance, PlayerDistanceToTarget =             GetOptionValue(OptionName .. " Distance"),
            Player:DistanceTo(Target)
            ProjectionDistance =             ProjectionDistance < PlayerDistanceToTarget and ProjectionDistance or PlayerDistanceToTarget / 2
            if PlayerDistanceToTarget < Radius - 1 + ProjectionDistance then
                local TargetUnits = #Target:EnemiesWithinDistance(Radius)
                TargetUnits = TargetUnits == 0 and 1 or TargetUnits
                if TargetUnits >= UnitsOption then
                    Player:ForceCastGroundTowardUnit(self, ThisSpell, ProjectionDistance, 1.25)
                    return true
                end
            end
        end
    end
end
function Unit:CastGround(Spell, MinimumUnits, Radius, RangeFromPlayer, AllowInMovement)
    if self == Player and (not MinimumUnits or MinimumUnits == nil or MinimumUnits == 0) then
        local ThisPosition = Player:Position()
        local pX, pY, pZ = ThisPosition["X"], ThisPosition["Y"], ThisPosition["Z"]
        Player.WasMouselooking = IsMouselooking()
        CastSpellByID(Spell:ID())
        if IAP() then
            CAP(pX, pY, pZ)
            if Player.WasMouselooking then
                MouselookStart()
            end
            return true
        end
        return false
    end
    local CurrentTarget = Target
    allUnits = {}
    allUnitsAround = Player:EnemiesWithinDistance(40, true, true)
    for i = 1, #allUnitsAround do
        local ThisUnit = allUnitsAround[i]
        if
        CurrentTarget:DistanceTo(ThisUnit) <= Radius * 2 and (AllowInMovement or not ThisUnit:IsMoving()) and
        ThisUnit:Exists() and
        Player:CanAttack(ThisUnit) and
        not ThisUnit:IsDeadOrGhost() and
        Player:DistanceTo(ThisUnit) <= RangeFromPlayer and
        (ThisUnit:IsInCombat() or ThisUnit:IsDummy()) and
        not ThisUnit:IsHardBlacklisted() and
        not ThisUnit:IsCrowdControlled()
        then
            table.insert(allUnits, ThisUnit)
        end
    end
    local bestUnits = {}
    for i = 1, #allUnits do
        local ThisUnit = allUnits[i]
        local theseUnits = {}
        for j = 1, #allUnits do
            local ThisUnit2 = allUnits[j]
            if ThisUnit:DistanceTo(ThisUnit2) <= Radius then
                table.insert(theseUnits, ThisUnit2)
            end
        end
        if #theseUnits >= MinimumUnits and #theseUnits >= #bestUnits then
            bestUnits = theseUnits
        end
    end
    if #bestUnits > 0 then
        if #bestUnits > 1 then
            local MidX, MidY, MidZ, TotalX, TotalY, TotalZ, UnitsCount, ThisPosition = 0, 0, 0, 0, 0, 0, 0, nil
            for i = 1, #bestUnits do
                UnitsCount = UnitsCount + 1
                ThisPosition = bestUnits[i]:Position()
                TotalX, TotalY, TotalZ =                 TotalX + ThisPosition["X"],
                TotalY + ThisPosition["Y"],
                TotalZ + ThisPosition["Z"]
            end
            if UnitsCount > 0 then
                MidX, MidY, MidZ = TotalX / UnitsCount, TotalY / UnitsCount, TotalZ / UnitsCount
                Player.WasMouselooking = IsMouselooking()
                CastSpellByID(Spell:ID())
                if IAP() then
                    CAP(MidX, MidY, MidZ)
                    if Player.WasMouselooking then
                        MouselookStart()
                    end
                    return true
                end
            end
        else
            local ThisPosition = bestUnits[1]:Position()
            local MidX, MidY, MidZ = ThisPosition["X"], ThisPosition["Y"], ThisPosition["Z"]
            Player.WasMouselooking = IsMouselooking()
            CastSpellByID(Spell:ID())
            if IAP() then
                CAP(MidX, MidY, MidZ)
                if Player.WasMouselooking then
                    MouselookStart()
                end
                return true
            end
        end
    end
end
function Unit:Casting(Spell)
    if Spell ~= nil then
        return UnitCastingInfo(self.UnitID) == GetSpellInfo(Spell:ID())
    else
        return UnitCastingInfo(self.UnitID) ~= nil
    end
end
function Unit:Channeling(Spell)
    if Spell ~= nil then
        return UnitChannelInfo(self.UnitID) == GetSpellInfo(Spell:ID())
    else
        return UnitChannelInfo(self.UnitID)
    end
end
function Unit.AutoTarget(Spell, GetTarget)
    if GetOptionValue("目标 | 攻击") ~= "禁用" then
        local TargetOption = GetOptionValue("目标优先级")
        local TargetPriority =         IsOptionEnabled("目标优先级") and
        ((TargetOption == "|cffD9D9DB骷髅" and 8) or (TargetOption == "|cffCC3122十字" and 7) or
        (TargetOption == "|cff019EE0方块" and 6) or
        (TargetOption == "|cffB2D1DF月亮" and 5) or
        (TargetOption == "|cff0AE201三角" and 4) or
        (TargetOption == "|cffB731C8菱形" and 3) or
        (TargetOption == "|cffD87E01圆形" and 2) or
        (TargetOption == "|cffFFEA00星形" and 1)) or
        9
        local Mode = GetOptionValue("目标 | 攻击")
        if Mode == "目标附近" and not Target:Exists() then
            Mode = "血量最多"
        end
        if Mode == "距离最近" then
            local Units, PotentialUnits, Count = UnitsEngine.Units.Hostile, {}, 1
            local ThisUnit
            for i = 1, #Units do
                ThisUnit = Units[i]
                if
                (ThisUnit:IsInCombat() and (not IsOptionEnabled("Check Group Threat") or ThisUnit:HasGroupThreat())) and
                not ThisUnit:IsHardBlacklisted() and
                not ThisUnit:IsBlacklisted() and
                Player:InLineOfSight(ThisUnit) and
                Player:IsFacing(ThisUnit) and
                not ThisUnit:IsDeadOrGhost() and
                Player:IsWithinCastRange(ThisUnit, Spell)
                then
                    if GetRaidTargetIndex(ThisUnit.UnitID) == TargetPriority then
                        return ThisUnit
                    end
                    PotentialUnits[Count] = { Unit = ThisUnit, Distance = Player:DistanceTo(ThisUnit) }
                    Count = Count + 1
                end
            end
            table.sort(
            PotentialUnits,
            function(a, b)
                return a.Distance < b.Distance
            end
            )
            if #PotentialUnits >= 1 then
                if GetTarget then
                    return PotentialUnits[1].Unit
                else
                    PotentialUnits[1].Unit:Attack()
                end
            end
        elseif Mode == "目标附近" then
            local Units, PotentialUnits, Count = UnitsEngine.Units.Hostile, {}, 1
            local ThisUnit
            for i = 1, #Units do
                ThisUnit = Units[i]
                if
                (ThisUnit:IsInCombat() and (not IsOptionEnabled("Check Group Threat") or ThisUnit:HasGroupThreat())) and
                not ThisUnit:IsHardBlacklisted() and
                not ThisUnit:IsBlacklisted() and
                Player:InLineOfSight(ThisUnit) and
                Player:IsFacing(ThisUnit) and
                not ThisUnit:IsDeadOrGhost() and
                Player:IsWithinCastRange(ThisUnit, Spell)
                then
                    if GetRaidTargetIndex(ThisUnit.UnitID) == TargetPriority then
                        return ThisUnit
                    end
                    PotentialUnits[Count] = { Unit = ThisUnit, Distance = Target:DistanceTo(ThisUnit) }
                    Count = Count + 1
                end
            end
            table.sort(
            PotentialUnits,
            function(a, b)
                return a.Distance < b.Distance
            end
            )
            if #PotentialUnits >= 1 then
                if GetTarget then
                    return PotentialUnits[1].Unit
                else
                    PotentialUnits[1].Unit:Attack()
                end
            end
        elseif Mode == "血量最多" then
            local Units, PotentialUnits, Count = UnitsEngine.Units.Hostile, {}, 1
            local ThisUnit
            for i = 1, #Units do
                ThisUnit = Units[i]
                if
                (ThisUnit:IsInCombat() and (not IsOptionEnabled("Check Group Threat") or ThisUnit:HasGroupThreat())) and
                not ThisUnit:IsHardBlacklisted() and
                not ThisUnit:IsBlacklisted() and
                Player:InLineOfSight(ThisUnit) and
                Player:IsFacing(ThisUnit) and
                not ThisUnit:IsDeadOrGhost() and
                Player:IsWithinCastRange(ThisUnit, Spell)
                then
                    if GetRaidTargetIndex(ThisUnit.UnitID) == TargetPriority then
                        return ThisUnit
                    end
                    PotentialUnits[Count] = { Unit = ThisUnit, Health = ThisUnit:Health() }
                    Count = Count + 1
                end
            end
            table.sort(
            PotentialUnits,
            function(a, b)
                return a.Health > b.Health
            end
            )
            if #PotentialUnits >= 1 then
                if GetTarget then
                    return PotentialUnits[1].Unit
                else
                    PotentialUnits[1].Unit:Attack()
                end
            end
        elseif Mode == "血量最少" then
            local Units, PotentialUnits, Count = UnitsEngine.Units.Hostile, {}, 1
            local ThisUnit
            for i = 1, #Units do
                ThisUnit = Units[i]
                if
                (ThisUnit:IsInCombat() and (not IsOptionEnabled("Check Group Threat") or ThisUnit:HasGroupThreat())) and
                not ThisUnit:IsHardBlacklisted() and
                not ThisUnit:IsBlacklisted() and
                Player:InLineOfSight(ThisUnit) and
                Player:IsFacing(ThisUnit) and
                not ThisUnit:IsDeadOrGhost() and
                Player:IsWithinCastRange(ThisUnit, Spell)
                then
                    if GetRaidTargetIndex(ThisUnit.UnitID) == TargetPriority then
                        return ThisUnit
                    end
                    PotentialUnits[Count] = { Unit = ThisUnit, Health = ThisUnit:Health() }
                    Count = Count + 1
                end
            end
            table.sort(
            PotentialUnits,
            function(a, b)
                return a.Health < b.Health
            end
            )
            if #PotentialUnits >= 1 then
                if GetTarget then
                    return PotentialUnits[1].Unit
                else
                    PotentialUnits[1].Unit:Attack()
                end
            end
        elseif Mode == "Farthest" then
            local Units, PotentialUnits, Count = UnitsEngine.Units.Hostile, {}, 1
            local ThisUnit
            for i = 1, #Units do
                ThisUnit = Units[i]
                if
                (ThisUnit:IsInCombat() and (not IsOptionEnabled("Check Group Threat") or ThisUnit:HasGroupThreat())) and
                not ThisUnit:IsHardBlacklisted() and
                not ThisUnit:IsBlacklisted() and
                Player:InLineOfSight(ThisUnit) and
                Player:IsFacing(ThisUnit) and
                not ThisUnit:IsDeadOrGhost() and
                Player:IsWithinCastRange(ThisUnit, Spell)
                then
                    if GetRaidTargetIndex(ThisUnit.UnitID) == TargetPriority then
                        return ThisUnit
                    end
                    PotentialUnits[Count] = { Unit = ThisUnit, Distance = Player:DistanceTo(ThisUnit) }
                    Count = Count + 1
                end
            end
            table.sort(
            PotentialUnits,
            function(a, b)
                return a.Distance > b.Distance
            end
            )
            if #PotentialUnits >= 1 then
                if GetTarget then
                    return PotentialUnits[1].Unit
                else
                    PotentialUnits[1].Unit:Attack()
                end
            end
        end
    end
end
function Unit:Attack()
    return TargetUnit(self.UnitID)
end
function Unit:IsBlacklisted()
    local BlacklistUnits = GetSetting("Custom Blacklist Table") or {}
    local UnitID = self:CreatureID()
    for i = 1, #BlacklistUnits do
        if tonumber(BlacklistUnits[i]) == tonumber(UnitID) then
            return true
        end
    end
    return false
end
function Unit:CanAttack(Other)
    return UnitCanAttack(self.UnitID, Other.UnitID)
end
function Unit:IsPVP()
    return UnitIsPVP(self.UnitID)
end
function Unit:CanSupport(Other)
    return not self:CanAttack(Other)
end
function Unit:Class()
    return UnitClass(self.UnitID)
end
function Unit:CombatReach()
    return UCR(self.UnitID)
end
function Unit:CreatureType()
    return UnitCreatureType(self.UnitID)
end
function Unit:CreatureID()
    local GUID = self:GUID()
    if GUID ~= nil then
        local ThisUnit, _, _, _, _, ThisCreatureID, _ = strsplit("-", GUID)
        if ThisUnit == "Creature" or "Pet" or "Vehicle" then
            return tonumber(ThisCreatureID)
        end
    end
end
function Unit:DistanceTo(Other, AbsoluteDistance, PlayerCenteredAoE)
    if Other == nil or not Other:Exists() then
        return 100
    end
    local SelfPosition = self:Position()
    local OtherPosition = Other:Position()
    local RealDistance = SelfPosition:DistanceTo(OtherPosition)
    if AbsoluteDistance then
        return RealDistance
    else
        if PlayerCenteredAoE then
            return RealDistance - (Other:CombatReach() or 0)
        else
            local Reach1 = self:CombatReach() or 0
            local Reach2 = Other:CombatReach() or 0
            local MeleeRange = self:MeleeRange(Other)
            local DistanceMelee = RealDistance / MeleeRange * 5
            if DistanceMelee <= 5 then
                return DistanceMelee
            end
            local DistanceReach = RealDistance - (Reach1 + Reach2)
            local WeirdZone = math.min(MeleeRange + 0.1, 7.9)
            if DistanceReach <= WeirdZone then
                return WeirdZone
            else
                return DistanceReach
            end
        end
    end
    return 100
end
function Unit:Equals(Other)
    return self:GUID() == Other:GUID()
end
function Unit:Exists()
    return ((Unlocker ~= "FireHack" and Unlocker ~= "EWT") or OE(self.UnitID)) and UnitExists(self.UnitID) and
    UnitIsVisible(self.UnitID)
end
function Unit:Facing()
    return OF(self.UnitID)
end
function Unit:GUID()
    return UnitGUID(self.UnitID)
end
function Unit:Health()
    return UnitHealth(self.UnitID)
end
local VehicleSpell = { Spell(157059), Spell(187819), Spell(181345) }
local VehiclePetMount = { 87082, 87078, 87081, 87080, 87079, 87076 }
function Unit:InVehicle()
    for i = 1, #VehicleSpell do
        if self:DebuffAny(VehicleSpell[i]) then
            return false
        end
    end
    if IsPetActive() then
        for i = 1, #VehiclePetMount do
            if PlayerPet:CreatureID() == VehiclePetMount[i] then
                return false
            end
        end
    end
    return UnitInVehicle(self.UnitID)
end
function Unit:IsInCombat(BypassUnitTable)
    return UnitAffectingCombat(self.UnitID) or self:IsDummy() or self:WithoutCombatFlags() or
    (IsOptionEnabled("主动寻怪攻击") and
    (GetOptionValue("主动寻怪攻击") == "无条件使用" or (EncounterID ~= 0 and GetOptionValue("主动寻怪攻击") == "Boss")))
end
MagicBuffs = {
    Spell(160312),
    Spell(164597),
    Spell(151548),
    Spell(150678),
    Spell(168041),
    Spell(168105),
    Spell(161203),
    Spell(155498),
    Spell(155173),
    Spell(160140),
    Spell(180025),
    Spell(174768),
    Spell(183863),
    Spell(174768),
    Spell(239808)
}
function Unit:IsMagicBuffed()
    local Spell = module.Spell
    for i = 1, #MagicBuffs do
        if self:BuffAny(MagicBuffs[i]) then
            return true
        end
    end
    return false
end
function Unit:MaxHealth()
    return UnitHealthMax(self.UnitID)
end
function Unit:HealthPercentage()
    return UnitHealthMax(self.UnitID) == 0 and 0 or UnitHealth(self.UnitID) / UnitHealthMax(self.UnitID) * 100
end
local LoSExceptions = {
    { Id = 44566 },
    { Id = 46753 },
    { Id = 56754 },
    { Id = 72156 },
    { Id = 76267 },
    { Id = 76379 },
    { Id = 76585 },
    { Id = 76973 },
    { Id = 76974 },
    { Id = 77182 },
    { Id = 91331, Phase = 3 },
    { Id = 90998 },
    { Id = 91000 },
    { Id = 91004 },
    { Id = 91005 },
    { Id = 91008 },
    { Id = 91808 },
    { Id = 96028 },
    { Id = 97220 },
    { Id = 97259 },
    { Id = 97260 },
    { Id = 96759 },
    { Id = 98363 },
    { Id = 98696 },
    { Id = 99801 },
    { Id = 100354 },
    { Id = 100360 },
    { Id = 100362 },
    { Id = 105443 },
    { Id = 105710 },
    { Id = 108212 },
    { Id = 105393 },
    { Id = 111052 },
    { Id = 114900 },
    { Id = 116939 },
    { Id = 120436 }
}
local losFlags = bit.bor(16, 256)
function Unit:InLineOfSight(Other)
    if GetOptionValue("视线判断") == "禁用" or self:GUID() == Other:GUID() then
        return true
    elseif Other.UnitID and self:Exists() and Other:Exists() then
        local ThatCreature = Other:CreatureID()
        for i = 1, #LoSExceptions do
            if
            ThatCreature == LoSExceptions[i].Id and
            (LoSExceptions[i].Phase == nil or LoSExceptions[i].Phase == EncounterPhase)
            then
                return true
            end
        end
        local SelfX, SelfY, SelfZ = OP(Player.UnitID)
        local OtherX, OtherY, OtherZ = OP(Other.UnitID)
        if SelfX and SelfY and SelfZ and OtherX and OtherY and OtherZ then
            return TL(SelfX, SelfY, SelfZ + 2.25, OtherX, OtherY, OtherZ + 2.25, losFlags) == nil
        end
    end
end
function Unit:IsBoss()
    if self:IsBossTarget() then
        return true
    end
    local inRaid = IsInRaid()
    if
    UnitLevel(self.UnitID) == -1 or (not inRaid and UnitLevel(self.UnitID) > 92 and UnitLevel("player") < 91) or
    (not inRaid and UnitLevel(self.UnitID) > 103 and UnitLevel("player") < 101) or
    (not inRaid and UnitLevel(self.UnitID) >= 113)
    then
        return true
    end
    if UnitIsPlayer(self.UnitID) and UnitCanAttack("player", self.UnitID) then
        return true
    end
    return false
end
function Unit:IsBossTarget()
    if
    UnitIsUnit(self.UnitID, "Boss1") or UnitIsUnit(self.UnitID, "Boss2") or UnitIsUnit(self.UnitID, "Boss3") or
    UnitIsUnit(self.UnitID, "Boss4")
    then
        return true
    end
    return false
end
function Unit:IsCasting()
    return UnitCastingInfo(self.UnitID)
end
function Unit:IsChanneling()
    return UnitChannelInfo(self.UnitID)
end
function Unit:CastedPercent(Spell)
    if UnitChannelInfo(self.UnitID) then
        if (Spell and UnitChannelInfo(self.UnitID) == GetSpellInfo(Spell.Identifier)) or not Spell then
            local spell, rank, displayName, icon, startTime, endTime, isTradeSkill, interrupt =             UnitChannelInfo(self.UnitID)
            if ChannelInterruptThreshold ~= nil then
                if GetTime() - startTime / 1000 > ChannelInterruptThreshold then
                    ChannelInterruptThreshold = nil
                    return 100
                end
            else
                ChannelInterruptThreshold = math.random(25, 75) / 100
            end
            return 0
        end
        return 0
    end
    if UnitCastingInfo(self.UnitID) then
        if (Spell and UnitCastingInfo(self.UnitID) == GetSpellInfo(Spell.Identifier)) or not Spell then
            local spell, rank, displayName, icon, startTime, endTime, isTradeSkill, castID, interrupt =             UnitCastingInfo(self.UnitID)
            local castLength = (endTime - startTime) / 1000
            local secondsLeft = endTime / 1000 - GetTime()
            return 100 - ((secondsLeft / castLength) * 100)
        end
    end
    return 0
end
local CrowdControlsTable = {
    Spell(118),
    Spell(339),
    Spell(710),
    Spell(2094),
    Spell(5246),
    Spell(5484),
    Spell(5782),
    Spell(6358),
    Spell(6770),
    Spell(8122),
    Spell(9484),
    Spell(19386),
    Spell(20066),
    Spell(28271),
    Spell(28272),
    Spell(33786),
    Spell(51514),
    Spell(61025),
    Spell(61305),
    Spell(61721),
    Spell(61780),
    Spell(82691),
    Spell(102359),
    Spell(115078),
    Spell(118699),
    Spell(115268),
    Spell(126819),
    Spell(161353),
    Spell(161354),
    Spell(161355),
    Spell(161372)
}
function Unit:IsCrowdControlled()
    if self.IsCCed ~= nil and GetTime() < self.IsCCedTime + 0.05 then
        return self.IsCCed
    else
        for i = 1, #CrowdControlsTable do
            if self:DebuffAny(CrowdControlsTable[i]) then
                self.IsCCed, self.IsCCedTime = true, GetTime()
                return true
            end
        end
        self.IsCCed, self.IsCCedTime = false, GetTime()
        return false
    end
end
function Unit:IsDead()
    return UnitIsDead(self.UnitID)
end
function Unit:IsDeadOrGhost()
    return UnitIsDeadOrGhost(self.UnitID)
end
DummiesUnitsTable = {
    [31144] = true,
    [31146] = true,
    [32542] = true,
    [32543] = true,
    [32545] = true,
    [32546] = true,
    [32666] = true,
    [32667] = true,
    [33229] = true,
    [33272] = true,
    [46647] = true,
    [54344] = true,
    [67127] = true,
    [83546] = true,
    [87317] = true,
    [87318] = true,
    [87320] = true,
    [87322] = true,
    [87760] = true,
    [87761] = true,
    [87762] = true,
    [88288] = true,
    [88314] = true,
    [88967] = true,
    [92164] = true,
    [92165] = true,
    [92166] = true,
    [100440] = true,
    [100441] = true,
    [100451] = true,
    [101956] = true,
    [102045] = true,
    [102048] = true,
    [102052] = true,
    [103397] = true,
    [103402] = true,
    [103404] = true,
    [107202] = true,
    [107483] = true,
    [107484] = true,
    [107555] = true,
    [107556] = true,
    [113636] = true,
    [113647] = true,
    [113673] = true,
    [113674] = true,
    [113676] = true,
    [113687] = true,
    [113860] = true,
    [113862] = true,
    [113863] = true,
    [113864] = true,
    [113871] = true,
    [114558] = true,
    [114559] = true,
    [114840] = true
}
function Unit:IsDummy()
    return DummiesUnitsTable[self:CreatureID()] ~= nil
end
function Unit:IsFacing(Other)
    if IHE and IHE("AlwaysFacing") and UnitIsUnit(self.UnitID, "player") then
        return true
    else
        local SelfX, SelfY, SelfZ = OP(self.UnitID)
        local SelfFacing = self:Facing()
        local OtherX, OtherY, OtherZ = OP(Other.UnitID)
        local Angle =         SelfX and SelfY and OtherX and OtherY and SelfFacing and
        ((SelfX - OtherX) * math.cos(-SelfFacing)) - ((SelfY - OtherY) * math.sin(-SelfFacing)) or
        0
        return Angle < 0
    end
end
HardBlacklistedUnitsTable = {
    [43612] = { Buff = Spell(82320) },
    [44819] = { Buff = Spell(84589) },
    [71064] = { Buff = Spell(142174), Facing = true },
    [71079] = { Buff = Spell(142174), Facing = true },
    [76806] = { Health = 100 },
    [76815] = { Buff = Spell(155176) },
    [76829] = { Health = 0 },
    [81305] = { Buff = Spell(164426) },
    [90269] = { Buff = Spell(180040) },
    [90486] = { Always = true },
    [92330] = { Buff = Spell(184053) },
    [93233] = { Buff = Spell(184658) },
    [103694] = { Always = true },
    [103217] = { Buff = Spell(212229) },
    [104154] = { Buff = Spell(206516) },
    [105906] = { Option = "无视伊格诺斯之眼" },
    [116409] = { Function = function(ThisUnit)
        return (ThisUnit:BuffAny(Spell(235089)) or ThisUnit:BuffAny(Spell(235091))) and true or false
    end },
    [116410] = { Buff = Spell(235308) },
    [116691] = { Function = function(ThisUnit)
        return (IsOptionEnabled("无视恶魔审判庭") and ThisUnit:BuffAny(Spell(235230))) and true or false
    end },
    [116689] = { Function = function(ThisUnit)
        return (IsOptionEnabled("无视恶魔审判庭") and ThisUnit:BuffAny(Spell(233441))) and true or false
    end },
    ["Spirit Realm"] = Spell(235621),
    ["Bonecage Armor"] = Spell(236513),
    [118462] = { Function = function()
        return not Player:DebuffAny(HardBlacklistedUnitsTable["Spirit Realm"]) and true or false
    end },
    [118729] = { Function = function()
        return not Player:DebuffAny(HardBlacklistedUnitsTable["Spirit Realm"]) and true or false
    end },
    [118730] = { Function = function()
        return not Player:DebuffAny(HardBlacklistedUnitsTable["Spirit Realm"]) and true or false
    end },
    [119938] = {
        Function = function(ThisUnit)
            return (not Player:DebuffAny(HardBlacklistedUnitsTable["Spirit Realm"]) or
            (IsOptionEnabled("无视骨牢护甲") and ThisUnit:BuffAny(HardBlacklistedUnitsTable["Bonecage Armor"]))) and
            true or
            false
        end
    },
    [119939] = {
        Function = function(ThisUnit)
            return (not Player:DebuffAny(HardBlacklistedUnitsTable["Spirit Realm"]) or
            (IsOptionEnabled("无视骨牢护甲") and ThisUnit:BuffAny(HardBlacklistedUnitsTable["Bonecage Armor"]))) and
            true or
            false
        end
    },
    [119940] = { Function = function()
        return Player:DebuffAny(HardBlacklistedUnitsTable["Spirit Realm"]) and true or false
    end },
    [119941] = { Function = function()
        return Player:DebuffAny(HardBlacklistedUnitsTable["Spirit Realm"]) and true or false
    end },
    [118924] = { Function = function()
        return Player:DebuffAny(HardBlacklistedUnitsTable["Spirit Realm"]) and true or false
    end },
    [118460] = { Function = function()
        return Player:DebuffAny(HardBlacklistedUnitsTable["Spirit Realm"]) and true or false
    end },
    [118715] = {
        Function = function(ThisUnit)
            return (Player:DebuffAny(HardBlacklistedUnitsTable["Spirit Realm"]) or
            (IsOptionEnabled("无视骨牢护甲") and ThisUnit:BuffAny(HardBlacklistedUnitsTable["Bonecage Armor"]))) and
            true or
            false
        end
    },
    [118728] = {
        Function = function(ThisUnit)
            return (Player:DebuffAny(HardBlacklistedUnitsTable["Spirit Realm"]) or
            (IsOptionEnabled("无视骨牢护甲") and ThisUnit:BuffAny(HardBlacklistedUnitsTable["Bonecage Armor"]))) and
            true or
            false
        end
    }
}
function Unit:IsHardBlacklisted()
    local ThisCreature, BlacklistUnit = self:CreatureID(), false
    if ThisCreature and HardBlacklistedUnitsTable[ThisCreature] ~= nil then
        if HardBlacklistedUnitsTable[ThisCreature].Option then
            BlacklistUnit = IsOptionEnabled(HardBlacklistedUnitsTable[ThisCreature].Option)
        elseif HardBlacklistedUnitsTable[ThisCreature].Buff then
            BlacklistUnit = self:BuffAny(HardBlacklistedUnitsTable[ThisCreature].Buff)
            if HardBlacklistedUnitsTable[ThisCreature].Facing then
                BlacklistUnit = self:IsFacing(Player) == HardBlacklistedUnitsTable[ThisCreature].Facing
            end
        elseif HardBlacklistedUnitsTable[ThisCreature].Health then
            BlacklistUnit = self:HealthPercentage() == HardBlacklistedUnitsTable[ThisCreature].Health
        elseif HardBlacklistedUnitsTable[ThisCreature].Always then
            BlacklistUnit = true
        elseif
        HardBlacklistedUnitsTable[ThisCreature].Function and HardBlacklistedUnitsTable[ThisCreature].Function(self)
        then
            BlacklistUnit = true
        end
    end
    return BlacklistUnit
end
function Unit:IsInterruptible()
    return select(9, UnitCastingInfo(self.UnitID)) == false or select(8, UnitChannelInfo(self.UnitID)) == false or false
end
IsNotMovingBuffs = { Spell(79206), Spell(108839), Spell(202461), Spell(194249), Spell(193223), Spell(236373) }
function Unit:IsMoving()
    if IHE and IHE("MovingCast") and UnitIsUnit(self.UnitID, "player") then
        return false
    end
    return self:Speed() > 0 and not self:BuffAny(IsNotMovingBuffs[1]) and not self:BuffAny(IsNotMovingBuffs[2]) and
    not self:BuffAny(IsNotMovingBuffs[3]) and
    not (self:BuffAny(IsNotMovingBuffs[4]) and self:BuffAny(IsNotMovingBuffs[5])) and
    not self:BuffAny(IsNotMovingBuffs[6])
end
function Unit:IsPet()
    local GUID = self:GUID()
    if not GUID then
        return nil
    end
    local ThisUnit = strsplit("-", GUID)
    return ThisUnit == "Pet"
end
function Unit:IsPlayer()
    return UnitIsPlayer(self.UnitID)
end
function Unit:IsAFK()
    return UnitIsAFK(self.UnitID)
end
function Unit:IsInParty()
    return UnitInParty(self.UnitID) or UnitIsUnit(self.UnitID, "Player")
end
function Unit:IsInRaid()
    return UnitInRaid(self.UnitID) ~= nil
end
function Unit:IsInGroup()
    return self:IsInParty() or self:IsInRaid()
end
function Unit:IsTank()
    return UnitGroupRolesAssigned(self.UnitID) == "TANK" or self:CreatureID() == 72218 or self:CreatureID() == 73967
end
function Unit:IsHealer()
    return UnitGroupRolesAssigned(self.UnitID) == "HEALER"
end
function Unit:IsCaster()
    return UnitGroupRolesAssigned(self.UnitID) == "DPS"
end
function Unit:IsTanking(Other)
    if UnitThreatSituation(self.UnitID, Other.UnitID) then
        local isTanking, status, scaledPercent, rawPercent, threatValue =         UnitDetailedThreatSituation(self.UnitID, Other.UnitID)
        return isTanking
    end
    return false
end
function Unit:ThreatSituation()
    return UnitThreatSituation(self.UnitID) or 0
end
function Unit:HasGroupThreat()
    if not IsInRaid() then
        if UnitThreatSituation(Player.UnitID, self.UnitID) then
            return true
        end
        if IsInGroup() then
            for i = 1, 4 do
                if UnitThreatSituation("Party" .. i, self.UnitID) then
                    return true
                end
            end
        end
    end
    return false
end
function Unit:IsWithinCastRange(Other, Spell)
    if Spell and Other:Exists() then
        local spellInRange = IsSpellInRange(Spell:Name(), Other.UnitID)
        if spellInRange ~= nil then
            return spellInRange == 1
        end
        local Range = Spell:IsMelee() and 5 or Spell:MaximumRange()
        return self:DistanceTo(Other) <= Range
    end
end
function Unit:Level()
    return UnitLevel(self.UnitID)
end
function Unit:MeleeRange(Other)
    return self:CombatReach() and Other:CombatReach() and
    math.max(
    self:CombatReach() + Other:CombatReach() + 4 / 3 + ((self:IsMoving() and Other:IsMoving()) and 8 / 3 or 0),
    5
    ) or
    1
end
function Unit:Name()
    return UnitName(self.UnitID)
end
UnitsEngine.StoredPositions = {}
function Unit:Position()
    if UnitsEngine.StoredPositions[self.UnitID] == nil then
        UnitsEngine.StoredPositions[self.UnitID] = Vector3(OP(self.UnitID))
    end
    return UnitsEngine.StoredPositions[self.UnitID]
end
local PhasedDebuffsList = {[89890] = Spell(179407), [90378] = Spell(181488), [91809] = Spell(181295) }
local PhasedDebuffByEncounterList = {[2054] = Spell(235621) }
local HealImmunityDebuffsList = {
    [78491] = Spell(159220),
    [92330] = Spell(190466),
    [91005] = Spell(199705),
    ["Necrotic Plague"] = Spell(209858)
}
function Unit:PreventHealingChecks()
    local BossID = Boss1:Exists() and Boss1:CreatureID() or 0
    local PhaseDebuff = BossID ~= 0 and PhasedDebuffsList[BossID] or nil
    if PhaseDebuff then
        if Player:DebuffAny(PhaseDebuff) ~= self:DebuffAny(PhaseDebuff) then
            return true
        end
    end
    local PhaseDebuffByEncounter = EncounterID ~= 0 and PhasedDebuffByEncounterList[EncounterID] or nil
    if PhaseDebuffByEncounter then
        if Player:DebuffAny(PhaseDebuffByEncounter) ~= self:DebuffAny(PhaseDebuffByEncounter) then
            return true
        end
    end
    local ImmunityDebuff = BossID ~= 0 and HealImmunityDebuffsList[BossID] or nil
    if ImmunityDebuff then
        if self:DebuffAny(ImmunityDebuff) then
            return true
        end
    end
    if self:DebuffCountAny(HealImmunityDebuffsList["Necrotic Plague"]) >= 30 then
        return true
    end
    return false
end
function Unit:Speed()
    return GetUnitSpeed(self.UnitID)
end
function Unit:TauntManager(TauntSpell, OptionName, TargetUnit, EnemiesTable, PlayerPetTank)
    local MainTank, MainTankTarget, OffTank, OffTankTarget = Unit.GetMainTanks()
    if TauntSpell:Exists() and IsOptionEnabled(OptionName) and not TauntSpell:IsOnCooldown() then
        if GetOptionValue(OptionName) == "只有目标" then
            if
            not TargetUnit:IsDummy() and (not self:IsTanking(TargetUnit)) and
            (not PlayerPetTank or not PlayerPetTank:IsTanking(TargetUnit)) and
            (not MainTank or not MainTank:IsTanking(TargetUnit)) and
            (not OffTank or not OffTank:IsTanking(TargetUnit)) and
            TargetUnit:CanCast(TauntSpell)
            then
                Bug("|cff9D00FFTaunt Manager|r - Single Target Taunt")
                TargetUnit:Cast(TauntSpell)
                return true
            end
        else
            local ThisUnit
            for i = 1, #EnemiesTable do
                ThisUnit = EnemiesTable[i]
                if
                not ThisUnit:IsDummy() and (not self:IsTanking(ThisUnit)) and
                (not PlayerPetTank or not PlayerPetTank:IsTanking(TargetUnit)) and
                (not MainTank or not MainTank:IsTanking(ThisUnit)) and
                (not OffTank or not OffTank:IsTanking(ThisUnit)) and
                ThisUnit:CanCast(TauntSpell)
                then
                    Bug("|cff9D00FFTaunt Manager|r - Multi Target Taunt")
                    ThisUnit:Cast(TauntSpell)
                    return true
                end
            end
        end
    end
    return false
end
TTD = {
    Settings = { Refresh = 1, HistoryTime = 10 + 0.4, HistoryCount = 100 },
    Cache = {},
    Units = {},
    ExistingUnits = {},
    Throttle = 0
}
function TTDRefresh()
    local CurrentTime = GetTime()
    local HistoryCount = TTD.Settings.HistoryCount
    local HistoryTime = TTD.Settings.HistoryTime
    local Cache = TTD.Cache
    local IterableUnits = UnitsEngine.Units.Hostile
    local Units = TTD.Units
    local ExistingUnits = TTD.ExistingUnits
    WipeTable(ExistingUnits)
    local ThisUnit
    for i = 1, #IterableUnits do
        ThisUnit = IterableUnits[i]
        if ThisUnit:Exists() then
            local GUID = ThisUnit:GUID()
            if not ExistingUnits[GUID] then
                ExistingUnits[GUID] = true
                local HealthPercentage = ThisUnit:HealthPercentage()
                if HealthPercentage < 100 then
                    local UnitTable = Units[GUID]
                    if not UnitTable or HealthPercentage > UnitTable[1][1][2] then
                        UnitTable = { {}, CurrentTime }
                        Units[GUID] = UnitTable
                    end
                    local Values = UnitTable[1]
                    local Time = CurrentTime - UnitTable[2]
                    if not Values or HealthPercentage ~= Values[2] then
                        local Value
                        local LastIndex = #Cache
                        if LastIndex == 0 then
                            Value = { Time, HealthPercentage }
                        else
                            Value = Cache[LastIndex]
                            Cache[LastIndex] = nil
                            Value[1] = Time
                            Value[2] = HealthPercentage
                        end
                        table.insert(Values, 1, Value)
                        local n = #Values
                        while (n > HistoryCount) or (Time - Values[n][1] > HistoryTime) do
                            Cache[#Cache + 1] = Values[n]
                            Values[n] = nil
                            n = n - 1
                        end
                    end
                end
            end
        end
    end
    for Key in pairs(Units) do
        if not ExistingUnits[Key] then
            Units[Key] = nil
        end
    end
end
function Unit:TimeToX(Percentage, MinSamples)
    if self:IsDummy() then
        return 6666
    end
    local Seconds = 8888
    local UnitTable = TTD.Units[self:GUID()]
    if UnitTable then
        local Values = UnitTable[1]
        local n = #Values
        if n > MinSamples then
            local a, b = 0, 0
            local Ex2, Ex, Exy, Ey = 0, 0, 0, 0
            local Value, x, y
            for i = 1, n do
                Value = Values[i]
                x, y = Value[1], Value[2]
                Ex2 = Ex2 + x * x
                Ex = Ex + x
                Exy = Exy + x * y
                Ey = Ey + y
            end
            local Invariant = 1 / (Ex2 * n - Ex * Ex)
            a = (-Ex * Exy * Invariant) + (Ex2 * Ey * Invariant)
            b = (n * Exy * Invariant) - (Ex * Ey * Invariant)
            if b ~= 0 then
                Seconds = (Percentage - a) / b
                Seconds = math.min(7777, Seconds - (GetTime() - UnitTable[2]))
                if Seconds < 0 then
                    Seconds = 9999
                end
            end
        end
    end
    return Seconds
end
SpecialTTDPercentageData = {[118566] = 85, [94960] = 10, [95674] = function(self)
    return (self:HealthPercentage() > 50 and 60) or 0
end, [95676] = 80, [96759] = 70, [114263] = 10, [93023] = 50, [88769] = 10, [76057] = 10 }
function Unit:SpecialTTDPercentage(NPCID)
    if SpecialTTDPercentageData[NPCID] then
        if type(SpecialTTDPercentageData[NPCID]) == "number" then
            return SpecialTTDPercentageData[NPCID]
        else
            return SpecialTTDPercentageData[NPCID](self)
        end
    end
    return 0
end
function Unit:TimeToDie(MinSamples)
    local GUID = self:GUID()
    if GUID then
        local MinSamples = MinSamples or 3
        local UnitInfo = UnitInfoCache[GUID]
        if not UnitInfo then
            UnitInfo = {}
            UnitInfoCache[GUID] = UnitInfo
        end
        local TTD = UnitInfo.TTD
        if not TTD then
            TTD = {}
            UnitInfo.TTD = TTD
        end
        if not TTD[MinSamples] then
            if
            IsOptionEnabled("忽略BOSS的死亡倒计时直到HP") and self:IsBoss() and
            self:HealthPercentage() > GetOptionValue("忽略BOSS的死亡倒计时直到HP")
            then
                TTD[MinSamples] = 5555
            else
                TTD[MinSamples] = self:TimeToX(self:SpecialTTDPercentage(self:CreatureID()), MinSamples)
            end
        end
        return TTD[MinSamples]
    end
    return 11111
end
function Unit:FilteredTimeToDie(Operator, Value, Offset, ValueThreshold, MinSamples)
    local TTD = self:TimeToDie(MinSamples)
    return TTD < (ValueThreshold or 7777) and CompareThis(Operator, TTD + (Offset or 0), Value) or false
end
function Unit:TimeToDieIsNotValid(MinSamples)
    return self:TimeToDie(MinSamples) >= 7777
end
WithoutCombatFlagsList = {
    [44566] = "Ozuma (Throne of the Tide - Cataclysm Dungeon - Timewalking)",
    [77252] = "Ore Crate (Oregorger)",
    [77665] = "Iron Soldier (Blackhand)",
    [77893] = "Grasping Earth (Kromog)",
    [78583] = "Dominator Turret (Iron Maidens)",
    [86752] = "Stone Pillar (Kromog)",
    [90387] = "Shadowy Construct (Gorefiend)",
    [90410] = "Felfire Crusher (Hellfire Assault)",
    [90432] = "Felfire Flamebelcher (HellFire Assault)",
    [90485] = "Felfire Artillery (HellFire Assault)",
    [91103] = "Felfire Demolisher (HellFire Assault)",
    [92208] = "Doomfire Spirit (Archimonde)",
    [93435] = "Felfire Transporter (HellFire Assault)",
    [93717] = "Volatile Firebomb (Iron Reaver)",
    [93838] = "Grasping Hand (Kormrok)",
    [93839] = "Dragging Hand (Kormrok)",
    [94312] = "Quick-Fuse Firebomb (Iron Reaver)",
    [94322] = "Burning Firebomb (Iron Reaver)",
    [94326] = "Reactive Firebomb (Iron Reaver)",
    [94955] = "Reinforced Firebomb (Iron Reaver)",
    [95656] = "Carrion Swarm (Socretar Trash)",
    [105630] = "Eye of Gul'dan (Gul'dan)",
    [106545] = "Empowered Eye of Gul'dan (Gul'dan)",
    [111047] = "Parasitic Shadow Demon",
    [118730] = "Soul Residue (Engine of Souls)"
}
function Unit:WithoutCombatFlags()
    return WithoutCombatFlagsList[self:CreatureID()] ~= nil
end
function Unit:GetAuras(GUID)
    if not AurasTable[GUID] then
        AurasTable[GUID] = {}
    end
    AurasTable[GUID].Auras = {}
    local Infos
    for Index = 1, C.MAXIMUM_BUFFS do
        Infos = { UnitAura(GUID, Index) }
        if not Infos[11] then
            break
        end
        table.insert(AurasTable[GUID].Auras, Infos)
    end
    AurasTable[GUID].Auras = true
end
AurasTable = {}
function Unit:Aura(Spell)
    local GUID = self.UnitID
    if not GUID then
        return nil
    end
    if not AurasTable[GUID] or not AurasTable[GUID].Auras then
        self:GetAuras(GUID)
    end
    if AurasTable[GUID].Auras then
        local SpellID = Spell:ID()
        local Table = AurasTable[GUID].Auras
        local Caster
        for Index = 1, #Table do
            Caster = Table[Index][8]
            if
            Caster and SpellID == Table[Index][11] and
            (UnitIsUnit(Caster, "Player") or UnitIsUnit(Caster, "PlayerPet"))
            then
                return unpack(Table[Index])
            end
        end
    end
    return nil
end
function Unit:AuraCount(Spell)
    return select(4, self:Aura(Spell)) or 0
end
function Unit:AuraAny(Spell)
    local GUID = self.UnitID
    if not GUID then
        return nil
    end
    if not AurasTable[GUID] or not AurasTable[GUID].Auras then
        self:GetAuras(GUID)
    end
    if AurasTable[GUID].Auras then
        local SpellID = Spell:ID()
        local Table = AurasTable[GUID].Auras
        for Index = 1, #Table do
            if SpellID == Table[Index][11] then
                return unpack(Table[Index])
            end
        end
    end
    return nil
end
function Unit:GetBuffs(GUID)
    if not AurasTable[GUID] then
        AurasTable[GUID] = {}
    end
    AurasTable[GUID].Buffs = {}
    local Infos
    for Index = 1, C.MAXIMUM_BUFFS do
        Infos = { UnitBuff(GUID, Index) }
        if not Infos[11] then
            break
        end
        table.insert(AurasTable[GUID].Buffs, Infos)
    end
    AurasTable[GUID].Buff = true
end
function Unit:Buff(Spell)
    local GUID = self.UnitID
    if not GUID then
        return nil
    end
    if not AurasTable[GUID] or not AurasTable[GUID].Buff then
        self:GetBuffs(GUID)
    end
    if AurasTable[GUID].Buff then
        local SpellID = Spell:ID()
        local Table = AurasTable[GUID].Buffs
        local Caster
        for Index = 1, #Table do
            Caster = Table[Index][8]
            if
            Caster and SpellID == Table[Index][11] and
            (UnitIsUnit(Caster, "Player") or UnitIsUnit(Caster, "PlayerPet"))
            then
                return unpack(Table[Index])
            end
        end
    end
    return nil
end
function Unit:BuffRemains(Spell)
    local ExpirationTime = select(7, self:Buff(Spell))
    return ExpirationTime and ExpirationTime - GetTime() or 0
end
function Unit:BuffDuration(Spell)
    return select(6, self:Buff(Spell)) or 0
end
function Unit:BuffRefreshable(Spell, PandemicThreshold)
    if not self:Buff(Spell) then
        return true
    end
    return PandemicThreshold and self:BuffRemains(Spell) <= PandemicThreshold or
    self:BuffRemains(Spell) < self:BuffDuration(Spell) * 0.3
end
function Unit:BuffCount(Spell)
    return select(4, self:Buff(Spell)) or 0
end
function Unit:BuffValue(Spell)
    if self:Buff(Spell) then
        return GetNumbersForBuff(self, Spell)[1] * 1
    else
        return 0
    end
end
function Unit:BuffAny(Spell)
    local GUID = self.UnitID
    if not GUID then
        return nil
    end
    if not AurasTable[GUID] or not AurasTable[GUID].Buff then
        self:GetBuffs(GUID)
    end
    if AurasTable[GUID].Buff then
        local SpellID = Spell:ID()
        local Table = AurasTable[GUID].Buffs
        for Index = 1, #Table do
            if SpellID == Table[Index][11] then
                return unpack(Table[Index])
            end
        end
    end
    return nil
end
function Unit:BuffRemainsAny(Spell)
    local ExpirationTime = select(7, self:BuffAny(Spell))
    return ExpirationTime and ExpirationTime - GetTime() or 0
end
function Unit:BuffDurationAny(Spell)
    return select(6, self:BuffAny(Spell)) or 0
end
function Unit:BuffCountAny(Spell)
    return select(4, self:BuffAny(Spell)) or 0
end
function Unit:GetDebuffs(GUID)
    if not AurasTable[GUID] then
        AurasTable[GUID] = {}
    end
    AurasTable[GUID].Debuffs = {}
    local Infos
    for Index = 1, C.MAXIMUM_BUFFS do
        Infos = { UnitDebuff(GUID, Index) }
        if not Infos[11] then
            break
        end
        table.insert(AurasTable[GUID].Debuffs, Infos)
    end
    AurasTable[GUID].Debuff = true
end
function Unit:Debuff(Spell)
    local GUID = self.UnitID
    if not GUID then
        return nil
    end
    if not AurasTable[GUID] or not AurasTable[GUID].Debuff then
        self:GetDebuffs(GUID)
    end
    if AurasTable[GUID].Debuff then
        local SpellID = Spell:ID()
        local Table = AurasTable[GUID].Debuffs
        local Caster
        for Index = 1, #Table do
            Caster = Table[Index][8]
            if
            Caster and SpellID == Table[Index][11] and
            (UnitIsUnit(Caster, "Player") or UnitIsUnit(Caster, "PlayerPet"))
            then
                return unpack(Table[Index])
            end
        end
    end
    return nil
end
function Unit:DebuffRemains(Spell)
    local ExpirationTime = select(7, self:Debuff(Spell))
    return ExpirationTime and ExpirationTime - GetTime() or 0
end
function Unit:DebuffDuration(Spell)
    return select(6, self:Debuff(Spell)) or 0
end
function Unit:DebuffRefreshable(Spell, PandemicThreshold)
    if not self:Debuff(Spell) then
        return true
    end
    return PandemicThreshold and self:DebuffRemains(Spell) <= PandemicThreshold or
    self:DebuffRemains(Spell) < self:DebuffDuration(Spell) * 0.3
end
function Unit:DebuffCount(Spell)
    return select(4, self:Debuff(Spell)) or 0
end
function Unit:DebuffValue(Spell)
    if self:Debuff(Spell) then
        return GetNumbersForDebuff(self, Spell)[1] * 1
    else
        return 0
    end
end
function Unit:DebuffAny(Spell)
    local GUID = self.UnitID
    if not GUID then
        return nil
    end
    if not AurasTable[GUID] or not AurasTable[GUID].Debuff then
        self:GetDebuffs(GUID)
    end
    if AurasTable[GUID].Debuff then
        local SpellID = Spell:ID()
        local Table = AurasTable[GUID].Debuffs
        for Index = 1, #Table do
            if SpellID == Table[Index][11] then
                return unpack(Table[Index])
            end
        end
    end
    return nil
end
function Unit:DebuffRemainsAny(Spell)
    local ExpirationTime = select(7, self:DebuffAny(Spell))
    return ExpirationTime and ExpirationTime - GetTime() or 0
end
function Unit:DebuffDurationAny(Spell)
    return select(6, self:DebuffAny(Spell)) or 0
end
function Unit:DebuffCountAny(Spell)
    return select(4, self:DebuffAny(Spell)) or 0
end
local CustomDispels = {
    { debuff = 184449 },
    { debuff = 184676 },
    { debuff = 184450 },
    { debuff = 185065 },
    { debuff = 179219 },
    { debuff = 181753, buffNeeded = 179202 },
    { debuff = 180166 },
    { debuff = 156954 },
    { debuff = 162185 },
    { debuff = 144351 },
    { debuff = 142913 }
}
function Unit:CanDispel(Types)
    for i = 1, 40 do
        local debuffName, _, _, _, dispelType, duration, expires, _, _, _, spellID, _, isBossDebuff, _, _, _ =         UnitDebuff(self.UnitID, i)
        if
        dispelType and
        ((Types == nil and
        ((select(2, UnitClass("player")) == "PRIEST" and (dispelType == "Magic" or dispelType == "Disease")) or
        ((select(2, UnitClass("player")) == "MONK" or select(2, UnitClass("player")) == "PALADIN") and
        (dispelType == "Poison" or dispelType == "Magic" or dispelType == "Disease")) or
        (select(2, UnitClass("player")) == "SHAMAN" and (dispelType == "Magic" or dispelType == "Curse")) or
        (select(2, UnitClass("player")) == "DRUID" and
        (dispelType == "Poison" or dispelType == "Magic" or dispelType == "Curse")))) or
        (Types ~= nil and (Types[1] == dispelType or Types[2] == dispelType)))
        then
            local ignore = false
            for j = 1, #CustomDispels do
                local ThisDispel = CustomDispels[j]
                if
                spellID == ThisDispel.debuff and
                (not ThisDispel.buffNeeded or not UnitBuff("player", GetSpellInfo(ThisDispel.buffNeeded)))
                then
                    ignore = true
                    break
                end
            end
            if not ignore then
                return true
            end
        end
        if not debuffName then
            break
        end
    end
    return false
end
function Unit.Dispel(Table, Spell, Types)
    local ThisUnit, BestUnit, BestUnitHealth = nil, nil, 100
    for i = 1, #Table do
        ThisUnit = Table[i]
        if
        ThisUnit:Exists() and not ThisUnit:IsDeadOrGhost() and
        (BestUnit == nil or ThisUnit:SpecialHealthPercentage() < BestUnitHealth) and
        ThisUnit:CanDispel(Types) and
        (UnitIsUnit(ThisUnit.UnitID, "Player") or
        (Player:IsWithinCastRange(ThisUnit, Spell) and Player:InLineOfSight(ThisUnit)))
        then
            BestUnit, BestUnitHealth = ThisUnit, ThisUnit:SpecialHealthPercentage()
        end
    end
    return BestUnit
end
function Unit:BestClusterOfAlliesToHeal(MinimumUnits, MinimumHealth, Radius, GroupCheck, BuffCheck)
    local inRaid = IsInRaid()
    local AllUnits = self:HealUnitsAround(MinimumHealth, 40)
    local BestUnit, BestUnitCount, ThisUnit, ThisUnitCount, UnitGroup, ThisUnit2, Unit2Group = nil, 0, nil, 0, 0, nil, 0
    for i = 1, #AllUnits do
        ThisUnit = AllUnits[i]
        ThisUnitCount = 0
        UnitGroup = 0
        if ThisUnit:Exists() and (not BuffCheck or ThisUnit:BuffRemains(BuffCheck) < 3) then
            if GroupCheck then
                if inRaid and UnitInRaid(ThisUnit) ~= nil then
                    UnitGroup = select(3, GetRaidRosterInfo(UnitInRaid(ThisUnit.UnitID)))
                end
            end
            for j = 1, #AllUnits do
                ThisUnit2 = AllUnits[j]
                Unit2Group = 0
                if GroupCheck then
                    if inRaid and UnitInRaid(ThisUnit2) ~= nil then
                        Unit2Group = select(3, GetRaidRosterInfo(UnitInRaid(ThisUnit2.UnitID)))
                    end
                end
                if
                ThisUnit2:Exists() and ThisUnit:DistanceTo(ThisUnit2) <= Radius and
                (not GroupCheck or Unit2Group == UnitGroup)
                then
                    ThisUnitCount = ThisUnitCount + 1
                end
            end
            if ThisUnitCount >= MinimumUnits and ThisUnitCount >= BestUnitCount then
                BestUnit = ThisUnit
                BestUnitCount = ThisUnitCount
            end
        end
    end
    return BestUnit
end
function Unit:BestGroundHealUnits(HealUnits, HealthThreshold, Distance)
    local BestHealUnits, AllBestHealUnits, ThisUnit, TheseHealUnits, AllTheseHealUnits = {}, {}, nil, {}, {}
    for i = 1, #HealUnits do
        ThisUnit = HealUnits[i]
        if not ThisUnit:IsMoving() then
            TheseHealUnits, AllTheseHealUnits = ThisUnit:HealUnitsAround(HealthThreshold, Distance)
            if #TheseHealUnits > #BestHealUnits then
                BestHealUnits, AllBestHealUnits = TheseHealUnits, AllTheseHealUnits
            end
        end
    end
    return #BestHealUnits, AllBestHealUnits
end
function Unit:UnitsWithBuff(TheseUnits, ThisBuff, ThisDuration, HealthThreshold)
    local ThisDuration, UnitsTable, ThisUnit = ThisDuration or 0, {}, nil
    for i = 1, #TheseUnits do
        ThisUnit = TheseUnits[i]
        if
        ThisUnit:Exists() and ThisUnit:BuffRemains(ThisBuff) >= ThisDuration and
        (not HealthThreshold or ThisUnit:SpecialHealthPercentage() <= HealthThreshold)
        then
            table.insert(UnitsTable, ThisUnit)
        end
    end
    return UnitsTable
end
function Unit.FriendliesNearMushroom(UnitsTable, Distance)
    if ShroomX then
        local FriendliesNearTheMushroom, ThisUnit, ShroomVector = 0, nil, Vector3(ShroomX, ShroomY, ShroomZ)
        for i = 1, #UnitsTable do
            ThisUnit = UnitsTable[i]
            if ThisUnit:Exists() and not ThisUnit:IsDeadOrGhost() and ShroomVector:DistanceTo(ThisUnit) < Distance then
                FriendliesNearTheMushroom = FriendliesNearTheMushroom + 1
            end
        end
        return FriendliesNearTheMushroom
    else
        return 0
    end
end
Unit.ShouldBeHealedUnits = {["88289"] = 100, ["88316"] = 100, ["90388"] = 100 }
function Unit:ShouldBeHealed()
    local ThisUnitID = select(6, strsplit("-", self:GUID() or ""))
    return Unit.ShouldBeHealedUnits[ThisUnitID] or 0
end
function Unit:CastGroundHeal(Spell, Units, NoMovement)
    local MidX, MidY, MidZ, TotalX, TotalY, TotalZ, UnitsCount, ThisUnit, ThisPosition = 0, 0, 0, 0, 0, 0, 0, nil, nil
    if #Units > 1 then
        for i = 1, #Units do
            ThisUnit = Units[i]
            if ThisUnit:Exists() and (not NoMovement or not ThisUnit:IsMoving()) then
                UnitsCount = UnitsCount + 1
                ThisPosition = ThisUnit:Position()
                TotalX, TotalY, TotalZ =                 TotalX + ThisPosition["X"],
                TotalY + ThisPosition["Y"],
                TotalZ + ThisPosition["Z"]
            end
        end
        if UnitsCount >= 1 then
            MidX, MidY, MidZ = TotalX / UnitsCount, TotalY / UnitsCount, TotalZ / UnitsCount
            CastSpellByID(Spell:ID())
            if IAP() then
                if (Spell:ID() == 145205 or Spell:ID() == 147349 or Spell:ID() == 115313) then
                    ShroomX, ShroomY, ShroomZ = MidX, MidY, MidZ
                end
                Bug("|cFF58ACFA" .. Spell:Name() .. " |cFFFFFFFFon |cFF58FA82injured units")
                CAP(MidX, MidY, MidZ)
                return
            end
        end
    elseif #Units == 1 and Units[1]:Exists() then
        ThisPosition = Units[1]:Position()
        local MidX, MidY, MidZ = ThisPosition["X"], ThisPosition["Y"], ThisPosition["Z"]
        CastSpellByID(Spell:ID())
        if IAP() then
            if (Spell:ID() == 145205 or Spell:ID() == 147349 or Spell:ID() == 115313) then
                ShroomX, ShroomY, ShroomZ = MidX, MidY, MidZ
            end
            Bug("|cFF58ACFA" .. Spell:Name() .. " |cFFFFFFFFon |cFF58FA82injured units")
            CAP(MidX, MidY, MidZ)
            return
        end
    end
end
function Unit.MergeUnitsTables(FirstTable, SecondTable)
    local AllUnits = FirstTable
    for i = 1, #SecondTable do
        Found = false
        for j = 1, #FirstTable do
            if SecondTable[i]:GUID() == FirstTable[j]:GUID() then
                Found = true
                break
            end
        end
        if not Found then
            table.insert(AllUnits, SecondTable[i])
        end
    end
    return AllUnits
end
function Unit:IsMfdBlacklisted()
    local ThisCreature = self:CreatureID()
    if ThisCreature == nil then
        return false
    end
    if ThisCreature == 93023 then
        return true
    end
    if ThisCreature == 88769 or ThisCreature == 76057 then
        return true
    end
    return false
end
function Vector3:ToString()
    return self.X .. ", " .. self.Y .. ", " .. self.Z
end
function Vector3:UnaryMinus()
    return Vector3(-self.X, -self.Y, -self.Z)
end
function Vector3:Add(Other)
    return Vector3(self.X + Other.X, self.Y + Other.Y, self.Z + Other.Z)
end
function Vector3:Subtract(Other)
    return Vector3(self.X - Other.X, self.Y - Other.Y, self.Z - Other.Z)
end
function Vector3:Multiply(Factor)
    return Vector3(self.X * Factor, self.Y * Factor, self.Z * Factor)
end
function Vector3:Divide(Divisor)
    return Vector3(self.X / Divisor, self.Y / Divisor, self.Z / Divisor)
end
function Vector3:Power(Exponent)
    return Vector3(self.X ^ Exponent, self.Y ^ Exponent, self.Z ^ Exponent)
end
function Vector3:Equals(Other)
    return self.X == Other.X and self.Y == Other.Y and self.Z == Other.Z
end
function Vector3:DistanceTo(Other)
    return Other.X and Other.Y and Other.Z and self.X and self.Y and self.Z and
    math.sqrt(((Other.X - self.X) ^ 2) + ((Other.Y - self.Y) ^ 2) + ((Other.Z - self.Z) ^ 2)) or
    100
end
function Vector3:AngleTo(Other)
    return math.atan2(Other.Y - self.Y, Other.X - self.X) % (math.pi * 2)
end
function Vector3:PitchTo(Other)
    return math.atan((Other.Z - self.Z) / math.sqrt(((Other.X - self.X) ^ 2) + ((Other.Y - self.Y) ^ 2))) % math.pi
end
function Vector3:Project(Direction, Distance)
    return Vector3(self.X + math.cos(Direction) * Distance, self.Y + math.sin(Direction) * Distance, self.Z)
end
function Vector3:Length()
    return math.sqrt(self.X ^ 2 + self.Y ^ 2 + self.Z ^ 2)
end
function Vector3:Normalize()
    return self / self:Length()
end
function Vector3:DotProduct(Other)
    return self.X * Other.X + self.Y * Other.Y + self.Z * Other.Z
end
function Vector3:CrossProduct(Other)
    return Vector3(
    self.Y * Other.Z - self.Z * Other.Y,
    self.Z * Other.X - self.X * Other.Z,
    self.X * Other.Y - self.Y * Other.X
    )
end
function Vector3:ScalarTripleProduct(Second, Third)
    return self:DotProduct(Second:CrossProduct(Third))
end
function Vector3:Max(Other)
    return Vector3(math.max(self.X, Other.X), math.max(self.Y, Other.Y), math.max(self.Z, Other.Z))
end
function Vector3:Min(Other)
    return Vector3(math.min(self.X, Other.X), math.min(self.Y, Other.Y), math.min(self.Z, Other.Z))
end
function Vector3:Between(Other, Distance)
    local Angle = self:AngleTo(Other)
    return self:Project(Angle, Distance)
end
function Vector3:Expand()
    return self.X, self.Y, self.Z
end
function Player:Specialization()
    return Player:Level() < 10 and select(2, Player:Class()) or select(1, GetSpecializationInfo(GetSpecialization()))
end
local IsReadyBuffs = {
    ChanneledMana = Spell(156432),
    InvisibilityPotion = Spell(175833),
    OldInvisibilityPotion = Spell(11392),
    LeytorrentPotion = Spell(188030)
}
function Player:IsReady()
    if not UnitIsDeadOrGhost("player") and (IAP() == 0 or IAP() == false) then
        if
        not Player:BuffAny(IsReadyBuffs.ChanneledMana) and not Player:BuffAny(IsReadyBuffs.InvisibilityPotion) and
        not Player:BuffAny(IsReadyBuffs.OldInvisibilityPotion) and
        not Player:BuffAny(IsReadyBuffs.LeytorrentPotion)
        then
            local Latency = select(4, GetNetStats())
            local Time = GetTime() * 1000
            local CastEndTime = select(6, self:IsCasting())
            local ChannelEndTime = select(6, self:Channeling())
            if self:Casting() and CastEndTime - Time > Latency then
                return false
            end
            local ChannelEndTime = select(6, self:Channeling())
            return not ChannelEndTime or ChannelEndTime - Time <= Latency
        end
    end
end
function Player:Moving()
    return isMovingStartTime ~= 0 and GetTime() - isMovingStartTime or 0
end
function Player:Standing()
    return isStandingStartTime ~= 0 and GetTime() - isStandingStartTime or 0
end
local IsMountedBuffs = { Spell(783), Spell(165962), Spell(131347) }
function Player:IsMounted()
    return (IsMounted() and not self:MountedCombat()) or self:BuffAny(IsMountedBuffs[1]) or
    self:BuffAny(IsMountedBuffs[2]) or
    self:BuffAny(IsMountedBuffs[3]) or
    false
end
local MountedCombatBuffs = {
    Spell(164222),
    Spell(165803),
    Spell(221883),
    Spell(221885),
    Spell(221886),
    Spell(221887),
    Spell(220504),
    Spell(220505),
    Spell(220506),
    Spell(220507),
    Spell(220480),
    Spell(220484),
    Spell(220488),
    Spell(220489),
    Spell(220491),
    Spell(232648)
}
function Player:MountedCombat()
    for i = 1, #MountedCombatBuffs do
        if self:BuffAny(MountedCombatBuffs[i]) then
            return true
        end
    end
    return false
end
function Player:AttackSpeed()
    return UnitAttackSpeed("player")
end
function Player:ExecuteTime()
    local imCasting, _, _, _, _, castEndTime = UnitCastingInfo("player")
    local imChanelling, _, _, _, _, channelEndTime = UnitChannelInfo("player")
    local currentTime = GetTime()
    local currentGCDEnds = GCDEnds - currentTime
    if currentGCDEnds <= 0 then
        currentGCDEnds = 0
    end
    if imCasting then
        local castingTime = castEndTime / 1000 - currentTime
        if castingTime > currentGCDEnds then
            return castingTime
        else
            return currentGCDEnds
        end
    elseif imChanelling then
        local channelTime = channelEndTime / 1000 - currentTime
        if channelTime > currentGCDEnds then
            return channelTime
        else
            return currentGCDEnds
        end
    else
        return currentGCDEnds
    end
end
function Player:GCD()
    if
    C.CLASSNAME == "ROGUE" or currentSpecName == "Feral" or currentSpecName == "Brewmaster" or
    currentSpecName == "Windwalker"
    then
        return 1
    else
        local GCD = 1.5 / (1 + (self:Haste() / 100))
        return GCD > 0.75 and GCD or 0.75
    end
end
function GetLatency()
    return IsOptionEnabled("延迟容限") and
    (select(4, GetNetStats()) + math.random(0, GetSetting("Latency Tolerance_Value2"))) / 1000 or
    0
end
function Player:GlobalCooldown()
    local CDTime, CDValue = 0, 0
    CDTime, CDValue = GetSpellCooldown(61304)
    return CDTime == 0 and 0 or CDTime + CDValue - GetTime()
end
local FoodTable = {
    select(1, GetSpellInfo(195472)),
    select(1, GetSpellInfo(104935)),
    select(1, GetSpellInfo(104270)),
    select(1, GetSpellInfo(174303))
}
function Player:IsEating()
    if not AurasTable["player"] or not AurasTable["player"].Buff then
        self:GetBuffs("player")
    end
    if AurasTable["player"].Buff then
        local Table = AurasTable["player"].Buffs
        for i = 1, #FoodTable do
            for j = 1, #Table do
                if FoodTable[i] == Table[j][1] then
                    return true
                end
            end
        end
    end
    return false
end
function Player:IsStealthed(Abilities, Special)
    local IsStealthedBuff = {
        { Spell(1784), Spell(115191), Spell(5215) },
        { Spell(11327), Spell(115193), Spell(115192), Spell(185422), Spell(102547) },
        { Spell(58984) }
    }
    for i = 1, #IsStealthedBuff[1] do
        if self:Buff(IsStealthedBuff[1][i]) then
            return true
        end
    end
    if Abilities then
        for i = 1, #IsStealthedBuff[2] do
            if self:Buff(IsStealthedBuff[2][i]) then
                return true
            end
        end
    end
    if Special then
        for i = 1, #IsStealthedBuff[3] do
            if self:Buff(IsStealthedBuff[3][i]) then
                return true
            end
        end
    end
    return false
end
function Player:TotemDuration(Spell)
    local TotemName, StartTime, Duration
    for i = 1, 4 do
        _, TotemName, StartTime, Duration = GetTotemInfo(i)
        if TotemName == select(1, GetSpellInfo(Spell:ID())) then
            return math.floor(StartTime + Duration - GetTime())
        end
    end
    return 0
end
IHT = {
    DarkSimSupport = false,
    PercentageTimer = 0,
    LowValue = 40,
    HighValue = 60,
    RandomValue = math.random(),
    Percentage = 50,
    CustomInterruptListEnabled = false,
    ArcaneTorrentEnabled = false,
    CustomFunction = function(ThisUnit)
        return false
    end,
    InterruptibleUnit = nil
}
function Player:UseInterrupt(SpellToCast, ArcaneTorrentSpell, PetInterrupt)
    if IsOptionEnabled("打断施法进度介于%") then
        if GetTime() >= IHT.PercentageTimer then
            IHT.LowValue, IHT.HighValue, IHT.RandomValue =             GetOptionValue("打断施法进度介于%") or 40,
            GetSecondOptionValue("打断施法进度介于%") or 60,
            math.random()
            IHT.Percentage =             IHT.LowValue and IHT.HighValue and IHT.RandomValue and
            IHT.LowValue + (IHT.RandomValue * (IHT.HighValue - IHT.LowValue)) or
            50
            IHT.PercentageTimer = GetTime() + 0.2
        end
        IHT.ArcaneTorrentEnabled =         ArcaneTorrentSpell and ArcaneTorrentSpell:Exists() and IsOptionEnabled("Arcane Torrent Interrupt") or false
        if
        Target:Exists() and Target:IsInterruptible() and
        (not IsOptionEnabled("自定义打断技能列表") or
        (Target:IsCasting() and TableContainsValue(CustomFrame.Lists[1], select(1, Target:IsCasting()))) or
        (Target:IsChanneling() and
        TableContainsValue(CustomFrame.Lists[1], select(1, Target:IsChanneling())))) and
        Target:CastedPercent() >= IHT.Percentage
        then
            if Target:CanCast(SpellToCast) or (PetInterrupt and Target:PetCanCast(SpellToCast)) then
                Target:Cast(SpellToCast)
                return
            elseif IHT.ArcaneTorrentEnabled and self:DistanceTo(Target) < 5 and self:CanCast(ArcaneTorrentSpell) then
                self:Cast(ArcaneTorrentSpell)
                return
            end
        end
        if IsOptionEnabled("打断任意目标施法") then
            IHT.CustomFunction = function(ThisUnit)
                return not ThisUnit:IsDeadOrGhost() and ThisUnit:IsInCombat() and ThisUnit:IsInterruptible() and
                (Player:IsWithinCastRange(ThisUnit, SpellToCast) or
                SpellToCast == nil and self:DistanceTo(ThisUnit, true) < 5) and
                Player:CanAttack(ThisUnit) and
                (not IsOptionEnabled("自定义打断技能列表") or
                (ThisUnit:IsCasting() and
                TableContainsValue(CustomFrame.Lists[1], select(1, ThisUnit:IsCasting()))) or
                (ThisUnit:IsChanneling() and
                TableContainsValue(CustomFrame.Lists[1], select(1, ThisUnit:IsChanneling())))) and
                ThisUnit:CastedPercent() >= IHT.Percentage
            end
            IHT.InterruptibleUnit = Unit.FirstWhere(IHT.CustomFunction, "Enemy")
            if IHT.InterruptibleUnit then
                if
                IHT.InterruptibleUnit:CanCast(SpellToCast) or
                (PetInterrupt and IHT.InterruptibleUnit:PetCanCast(SpellToCast))
                then
                    IHT.InterruptibleUnit:Cast(SpellToCast)
                elseif
                Player:DistanceTo(IHT.InterruptibleUnit, true) < 5 and IHT.ArcaneTorrentEnabled and
                self:CanCast(ArcaneTorrentSpell)
                then
                    self:Cast(ArcaneTorrentSpell)
                end
            end
        end
    end
end
function Player:RecentDamageTaken(Lapse, Type)
    local TotalDamageTaken = 0
    for Key, Value in pairs(DamageTakenTable) do
        if GetTime() - DamageTakenTable[Key][1] < Lapse and (Type == nil or Type == DamageTakenTable[Key][3]) then
            TotalDamageTaken = TotalDamageTaken + DamageTakenTable[Key][2]
        end
    end
    return TotalDamageTaken
end
function Player:RecentDamageTakenPercent(Lapse, Type)
    return UnitHealthMax(self.UnitID) ~= 0 and
    math.floor((Player:RecentDamageTaken(Lapse, Type) / UnitHealthMax(self.UnitID) * 100) * 100) / 100 or
    0
end
function Player:RealMaxHealth()
    return GetUnitMaxHealthModifier("player") == 0 and 0 or Player:MaxHealth() / GetUnitMaxHealthModifier("player") * 1
end
function Player:TargetUnit(GUID)
    TargetUnit(GUID)
end
local function GetAngleToObject(Object1, Object2)
    local X1, Y1, Z1 = Object1:Position():Expand()
    local X2, Y2, Z2 = Object2:Position():Expand()
    local Angle = math.sqrt(math.pow(X1 - X2, 2) + math.pow(Y1 - Y2, 2))
    if Angle == 0 then
        Angle = 1
    end
    return math.atan2(Y2 - Y1, X2 - X1) % (math.pi * 2), math.atan((Z1 - Z2) / Angle) % math.pi
end
function Player:ForceCastGroundTowardUnit(Unit, Spell, Distance, Radius)
    if NoPathTime < GetTime() then
        Player.WasMouselooking = IsMouselooking()
        CastSpellByID(Spell:ID())
        if IAP() then
            local PositionVector
            for i = 0, Radius do
                if NoPathTime < GetTime() then
                    PositionVector = self:Position():Project(GetAngleToObject(Player, Unit), Distance - i)
                    CAP(PositionVector["X"], PositionVector["Y"], PositionVector["Z"])
                end
            end
            SpellStopTargeting()
        end
        if Player.WasMouselooking then
            MouselookStart()
        end
    end
end
function Player:CastGround(Spell, MinimumUnits, Radius, RangeFromPlayer, AllowInMovement)
    local ThisPosition = Player:Position()
    local pX, pY, pZ = ThisPosition["X"], ThisPosition["Y"], ThisPosition["Z"]
    CastSpellByID(Spell:ID())
    if IAP() then
        CAP(pX, pY, pZ)
        return true
    end
    return false
end
RTHT = { NewTarget = nil, PreviousTarget = nil, TargetSwapTimer = 0, MainSpeed = 10, OffSpeed = 10 }
function Player:ReTarget(SpellToCheck, SupportMode)
    if IsOptionEnabled("自动将邪能炸药设为目标") and select(3, GetInstanceInfo()) == 8 then
        local KeystoneLevel, Affixes = _G.C_ChallengeMode.GetActiveKeystoneInfo()
        if KeystoneLevel > 3 and (Affixes[1] == 13 or Affixes[2] == 13 or Affixes[3] == 13) then
            local Units, PotentialUnits, Count = UnitsEngine.Units.Hostile, {}, 1
            local ThisUnit
            for i = 1, #Units do
                ThisUnit = Units[i]
                if ThisUnit:CreatureID() == 120651 and Player:InLineOfSight(ThisUnit) and not ThisUnit:IsDeadOrGhost() then
                    PotentialUnits[Count] = { Unit = ThisUnit, Distance = Player:DistanceTo(ThisUnit) }
                    Count = Count + 1
                end
            end
            table.sort(
            PotentialUnits,
            function(a, b)
                return a.Distance < b.Distance
            end
            )
            if #PotentialUnits >= 1 then
                Player:TargetUnit(PotentialUnits[1].Unit:GUID())
                RunMacroText("/startattack target")
                Target = PotentialUnits[1].Unit
            end
        end
    end
    if
    GetOptionValue("目标 | 攻击") ~= "禁用" and
    (not Target:Exists() or (Target:IsDeadOrGhost() and (not SupportMode or not Player:CanSupport(Target))) or
    (IsOptionEnabled("动态切换目标") and Target:Exists() and Player:CanAttack(Target) and
    (Player:DistanceTo(Target) > GetSecondOptionValue("动态切换目标") or not Player:IsFacing(Target))))
    then
        RTHT.NewTarget = Unit.AutoTarget(SpellToCheck, GetOptionValue("目标 | 攻击"), true)
        if RTHT.NewTarget then
            if
            not Target:Exists() or Target:IsDeadOrGhost() or
            (IsOptionEnabled("动态切换目标") and GetOptionValue("动态切换目标") == "变化")
            then
                RTHT.NewTarget:Attack()
            else
                if
                (GetSecondOptionValue("目标 | 攻击") == "启用" or
                (Player:IsInCombat() and GetSecondOptionValue("目标 | 攻击") == "仅战斗状态时")) and
                GetTime() > RTHT.TargetSwapTimer
                then
                    RTHT.PreviousTarget = Target:GUID()
                    Player:TargetUnit(RTHT.NewTarget:GUID())
                    RunMacroText("/startattack target")
                    Player:TargetUnit(RTHT.PreviousTarget)
                    RTHT.MainSpeed, RTHT.OffSpeed = Player:AttackSpeed()
                    RTHT.TargetSwapTimer = GetTime() + math.min(RTHT.MainSpeed, RTHT.OffSpeed or 10)
                end
                return RTHT.NewTarget
            end
            return nil
        end
    end
end
function Player:StartAttack(SpellID)
    SpellID = SpellID or 6603
    if SpellID == 6603 and not IsCurrentSpell(SpellID) then
        StartAttack()
    elseif SpellID == 75 and not IsAutoRepeatSpell(SpellID) then
        StartAttack()
    end
end
HealingItemTable = {
    Item(5512),
    Item(137222),
    Item(136569),
    Item(127834),
    Item(115498),
    Item(118917),
    Item(118916),
    Item(117415),
    Item(109223),
    Item(118006),
    Item(129196),
    Item(93742),
    Item(76097),
    Item(89640),
    Item(92954),
    Item(57191),
    Item(43569),
    Item(33447),
    Item(39671),
    Item(32947),
    Item(33934),
    Item(22829),
    Item(28100),
    Item(13446),
    Item(3928),
    Item(1710),
    Item(929),
    Item(4596),
    Item(858),
    Item(118)
}
function Player:UseHealingItem()
    if IsOptionEnabled("治疗物品") and self:HealthPercentage() <= GetOptionValue("治疗物品") then
        for i = 1, #HealingItemTable do
            if HealingItemTable[i]:IsUsable() then
                self:UseItem(HealingItemTable[i])
                return
            end
        end
    end
end
local Flasks = {
    ["Agility"] = { Item = Item(127848), Buff = Spell(188033) },
    ["邪能焦镜"] = { Item = Item(147707), Buff = Spell(242551) },
    ["智力药水"] = { Item = Item(127847), Buff = Spell(188031) },
    ["耐力药水"] = { Item = Item(127850), Buff = Spell(188035) },
    ["力量药水"] = { Item = Item(127849), Buff = Spell(188034) }
}
function Player:UseFlask()
    if IsOptionEnabled("自动喝药") and (Player.CheckedFlasks == nil or Player.CheckedFlasks < GetTime()) then
        Player.CheckedFlasks = GetTime() + 1
        if
        self:Level() >= 100 and self:IsReady() and not self:IsMounted() and not self:InVehicle() and
        not self:IsEating()
        then
            if
            (self:IsInCombat() or BMPullTime() < GetSecondOptionValue("自动喝药")) and
            not self:Buff(Flasks["Agility"].Buff) and
            not self:Buff(Flasks["邪能焦镜"].Buff) and
            not self:Buff(Flasks["智力药水"].Buff) and
            not self:Buff(Flasks["耐力药水"].Buff) and
            not self:Buff(Flasks["力量药水"].Buff)
            then
                local FlaskType = GetOptionValue("自动喝药")
                if Flasks[FlaskType].Item:InStock() and not Flasks[FlaskType].Item:IsOnCooldown() then
                    Flasks[FlaskType].Item:Use(self)
                end
            end
        end
    end
end
function Player:UsePotions(ModeValue, OptionalValue)
    local UsePotionValue, Potion, PotionBuff, ShouldPot = nil, nil, nil, false
    if ModeValue == "智力药水" then
        Potion = Item(122454):InStock() and Item(122454) or Item(109218)
        PotionBuff = Spell(156426, false, false, true)
    elseif ModeValue == "Agility" then
        Potion = Item(122453):InStock() and Item(122453) or Item(109217)
        PotionBuff = Spell(156423)
    elseif ModeValue == "力量药水" then
        Potion = Item(122455):InStock() and Item(122455) or Item(109219)
        PotionBuff = Spell(156428)
    elseif ModeValue == "全能药剂" then
        Potion = Item(122456):InStock() and Item(122456) or Item(109220)
        PotionBuff = Spell(156430)
    elseif ModeValue == "蓝量" then
        Potion = Item(127835):InStock() and Item(127835) or Item(109222)
        PotionBuff = nil
    elseif ModeValue == "治愈" then
        Potion = Item(122454):InStock() and Item(122454) or Item(109218)
        PotionBuff = Spell(156426)
    elseif ModeValue == "延时之力药水" then
        Potion = Item(142117)
        PotionBuff = Spell(229206)
    elseif ModeValue == "古代法力药水" then
        Potion = Item(127835)
        PotionBuff = nil
    elseif ModeValue == "魔力洪流药水" then
        Potion = Item(127846)
        PotionBuff = nil
    end
    if ModeValue ~= "延时之力药水" and ModeValue ~= "古代法力药水" and ModeValue ~= "魔力洪流药水" then
        if GetSecondOptionValue("使用药水") == "上古战神药水" then
            ModeValue = "上古战神药水"
            Potion = Item(127844)
            PotionBuff = Spell(188028)
        elseif GetSecondOptionValue("使用药水") == "致命优雅药水" then
            ModeValue = "致命优雅药水"
            Potion = Item(127843)
            PotionBuff = Spell(188027)
        elseif GetSecondOptionValue("使用药水") == "全能药剂" then
            ModeValue = "全能药剂"
            Potion = Item(122456):InStock() and Item(122456) or Item(109220)
            PotionBuff = Spell(156430)
        elseif GetSecondOptionValue("使用药水") == "延时之力药水" then
            ModeValue = "延时之力药水"
            Potion = Item(142117)
            PotionBuff = Spell(229206)
        end
    end
    if not PotionUsed and PreventPotion < GetTime() and (PotionBuff == nil or not Player:Buff(PotionBuff)) then
        if ModeValue == "蓝量" or ModeValue == "古代法力药水" or ModeValue == "魔力洪流药水" then
            if IsOptionEnabled("使用法力药水") and Player:ManaPercentage() < GetSecondOptionValue("使用法力药水") then
                if Potion:InStock() and not Potion:IsOnCooldown() then
                    self:UseItem(Potion)
                else
                    Bug(
                    "We should have used " ..
                    ModeValue .. " Potion but you do not have any or it is still on cooldown."
                    )
                end
                PotionUsed = true
                Bug("Using |cFF58ACFAMana|r Potion.")
            end
        elseif ModeValue == "治愈" then
            if IsOptionEnabled("Use Intellect Potions") and OptionalValue >= GetOptionValue("Use Intellect Potions") then
                if Potion:InStock() and not Potion:IsOnCooldown() then
                    self:UseItem(Potion)
                else
                    Bug(
                    "We should have used " ..
                    ModeValue .. " Potion but you do not have any or it is still on cooldown."
                    )
                end
                PotionUsed = true
                Bug("Using |cFF58ACFAIntellect|r Potion.")
            end
        else
            if not Player:IsInCombat() then
                if
                IsOptionEnabled("抢先使用药水") and
                (GetOptionValue("抢先使用药水") == "无条件使用" or
                (GetOptionValue("抢先使用药水") == "打BOSS使用" and Target:IsBoss()))
                then
                    local ThisPullTime =                     OptionalValue == nil and GetSecondOptionValue("抢先使用药水") + 0.1 or
                    type(OptionalValue) == "number" and OptionalValue or
                    type(OptionalValue) ~= "number" and
                    GetSecondOptionValue("抢先使用药水") + OptionalValue:CastTime() + 0.1
                    if BMPullTime() <= ThisPullTime or (not Target:IsDummy() and Target:IsInCombat()) then
                        if Potion:InStock() and not Potion:IsOnCooldown() then
                            self:UseItem(Potion)
                        else
                            Bug(
                            "We should have used " ..
                            ModeValue .. " Potion but you do not have any or it is still on cooldown."
                            )
                        end
                        PreventPotion = GetTime() + 61
                        if Player:IsInCombat() then
                            PotionUsed = true
                            Bug(
                            "Using |cFF58ACFA" ..
                            ModeValue ..
                            "|r Potion |cFF58ACFA" ..
                            tostring(math.floor(BMPullTime() * 100) / 100) ..
                            "s|r before pull with combat started."
                            )
                        else
                            Bug(
                            "Using |cFF58ACFA" ..
                            ModeValue ..
                            "|r Potion |cFF58ACFA" ..
                            tostring(math.floor(BMPullTime() * 100) / 100) .. "s|r before pull."
                            )
                        end
                    end
                end
            else
                if IsOptionEnabled("使用药水") then
                    UsePotionValue = GetOptionValue("使用药水")
                    if
                    UsePotionValue == "无条件使用" or (UsePotionValue == "大技能" and CooldownsAllowed()) or
                    (UsePotionValue == "英勇BUFF" and Player:HasHero()) or
                    (UsePotionValue == "副本BOSS英勇" and Player:HasHero() and EncounterID ~= 0) or
                    (UsePotionValue == "副本BOSS" and EncounterID ~= 0)
                    then
                        if Potion:InStock() and not Potion:IsOnCooldown() then
                            self:UseItem(Potion)
                        else
                            Bug(
                            "We should have used " ..
                            ModeValue .. " Potion but you do not have any or it is still on cooldown."
                            )
                        end
                        PotionUsed = true
                        Bug(
                        "Using |cFF58ACFA" ..
                        ModeValue .. "|r Potion during fight with |cFF58ACFA" .. UsePotionValue .. "|r mode."
                        )
                    end
                end
                if ModeValue == "延时之力药水" and IsOptionEnabled("延时之力药水") then
                    if Potion:InStock() and not Potion:IsOnCooldown() then
                        self:UseItem(Potion)
                    else
                        Bug(
                        "We should have used " ..
                        ModeValue .. " Potion but you do not have any or it is still on cooldown."
                        )
                    end
                    PotionUsed = true
                end
            end
        end
    end
end
function Player:PVPCombat()
    return (IsPlayerSpell(195710) and IsUsableSpell(195710))
end
function Player:UseTrinkets()
    if
    GetOptionValue("饰品: 1 | 2") ~= "禁用" and (CooldownsAllowed() or GetOptionValue("饰品: 1 | 2") == "无条件使用") and
    Item(13):IsUsableInventory()
    then
        Item(13):UseInventory()
    end
    if
    GetSecondOptionValue("饰品: 1 | 2") ~= "禁用" and
    (CooldownsAllowed() or GetSecondOptionValue("饰品: 1 | 2") == "无条件使用") and
    Item(14):IsUsableInventory()
    then
        Item(14):UseInventory()
    end
    if GetOptionValue("戒指 | 项链") ~= "禁用" and (CooldownsAllowed() or GetSecondOptionValue("戒指 | 项链") == "无条件使用") then
        if Item(11):IsUsableInventory() then
            if Item(11):ID() ~= 142173 or not Player:Debuff(Spell(234143)) then
                Item(11):UseInventory()
            end
        end
        if Item(12):IsUsableInventory() then
            if Item(12):ID() ~= 142173 or not Player:Debuff(Spell(234143)) then
                Item(12):UseInventory()
            end
        end
    end
    if
    GetSecondOptionValue("戒指 | 项链") ~= "禁用" and (CooldownsAllowed() or GetSecondOptionValue("戒指 | 项链") == "无条件使用") and
    Item(2):IsUsableInventory()
    then
        Item(2):UseInventory()
    end
end
BadDebuffs = {
    [1602] = { { { "Top", "Testing" }, 143436 } },
    [1705] = { { { "Debuff", "Fixate" }, 157763 } },
    [1] = { { { "Top", "Grievous Wound" }, 240559 } },
    [1785] = {
        { { "Expiration", "Artillery" }, 182108 },
        { { "Debuff", "Blitz" }, 179886 },
        { { "Debuff", "Unstable Orb", 1 }, 182001 },
        { { "Debuff", "Immolation", 1 }, 182074 },
        { { "速度", "Fuel Streak" }, 182003 }
    },
    [1778] = {
        { { "Debuff", "Corruption Siphon" }, 187448 },
        { { "坦克", "Slam" }, 184243 },
        { { "Expiration", "Unstable Orb" }, 184379 }
    },
    [1798] = { { { "Debuff", "Mark of the Necromander" }, 185074 } },
    [1787] = {
        { { "Expiration", "Explosive Burst" }, 181306 },
        { { "Debuff", "Crush" }, 187819 },
        { { "坦克", "Foul Crush" }, 181307 }
    },
    [1783] = {
        { { "Expiration", "Touch of Doom" }, 189434 },
        { { "Debuff", "Shared Fate" }, 179909 },
        { { "坦克", "Fel Fury", 5 }, 181282 },
        { { "速度", "Hunger for Life" }, 180146 }
    },
    [1788] = {
        { { "Debuff", "Fel Chakram" }, 182173 },
        { { "Debuff", "Fel Fire" }, 182600 },
        { { "速度", "Phantasmal Winds" }, 181956 },
        { { "速度", "Fel Beam Fixate" }, 181956 }
    },
    [1777] = {
        { { "速度", "Seed of Destruction" }, 181508 },
        { { "Debuff", "Rumbling Fissure" }, 179428 },
        { { "Shield", "Befouled" }, 179711 }
    },
    [1794] = {
        { { "Debuff", "Gift of the Man'ari" }, 184124 },
        { { "坦克", "Shattered Defenses", 3 }, 182038 },
        { { "速度", "Felblaze Residue" }, 182218 },
        { { "速度", "Voltatile Fel Orb" }, 189627 }
    },
    [1800] = {
        { { "Debuff", "Fel Surge" }, 186407 },
        { { "Debuff", "Void Surge" }, 186333 },
        { { "Debuff", "Wasting Void", 1 }, 186063 },
        { { "Debuff", "Felsinged", 1 }, 186073 },
        { { "Debuff", "Ablaze", 1 }, 188208 }
    },
    [1784] = {
        { { "Shield", "Touch of Harm" }, 180166 },
        { { "Debuff", "Font of Corruption" }, 180526 },
        { { "Expiration", "Annihiliating Strike" }, 180260 }
    },
    [1795] = {
        { { "Debuff", "Shadowforce" }, 182112 },
        { { "Expiration", "Mannoroth's Gaze" }, 181617 },
        { { "坦克", "Doom Spike" }, 181119 },
        { { "Debuff", "Mark of the Legion" }, 188514 },
        { { "Debuff", "Mark of Doom" }, 181099 },
        { { "Debuff", "Empowered Shadowforce" }, 182084 },
        { { "Debuff", "Empowered Mannoroth's Gaze" }, 182006 }
    },
    [1786] = {
        { { "Shield", "Rending Howl" }, 183917 },
        { { "Debuff", "Heart Seeker" }, 180389 },
        { { "坦克", " Shredded Armor" }, 180200 }
    },
    [1799] = {
        { { "Expiration", "Wrough Chaos" }, 184265 },
        { { "Expiration", "Focused Chaos" }, 185014 },
        { { "Debuff", "Devour Life" }, 187047 },
        { { "Debuff", "Doomfire", 1 }, 189897 },
        { { "Debuff", "Shackled Torment" }, 184931 },
        { { "速度", "Nether Banish" }, 186961 }
    },
    [1836] = { { { "Top", "Grevious Tear" }, 196376 }, { { "Top", "Grievous Wound" }, 240559 } },
    [2048] = { { { "驱散", "Echoing Anguish", 0, 8 }, 233983 } },
    [2050] = { { { "Top", "Embrace of the Eclipse" }, 233263 }, { { "Top", "Rapid Shot" }, 236596 } },
    [2054] = { { { "Top", "Spear of Anguish" }, 238442 } },
    [1849] = {},
    [1865] = { { { "Top", "Time Release" }, 219966 }, { { "Top", "Time Release" }, 219965 }, { { "Top", "Time Release" }, 219964 } },
    [1867] = { { { "Debuff", "Toxic Slice" }, 206789 } },
    [1871] = {},
    [1862] = { { { "Debuff", "Carrion Plague" }, 212997 } },
    [1863] = {},
    [1842] = {},
    [1886] = { { { "驱散", "Parasitic Fetter", 0, 8 }, 218424 } },
    [1872] = {},
    [1866] = {},
    [1853] = {},
    [1873] = {},
    [1876] = {},
    [1841] = {},
    [1854] = {},
    [1877] = {},
    [1864] = {}
}
BadDebuffsByMapID = {
    [1148] = {
        { { "Top", "Chomp" }, 145263 },
        { { "Debuff", "Chomp" }, 145263 },
        { { "Debuff", "Lava Burns", 2 }, 145403 },
        { { "驱散", "Aqua Bomb", 0, 0 }, 145206 }
    },
    [1530] = { { { "驱散", "Consuming Flame", 0, 0 }, 221270 } }
}
function Player:GetRaidDebuffs(TheseUnits)
    local bossID = EncounterID
    local _, dungeonType, dungeonDifficulty, _, _, _, _, mapID, _ = GetInstanceInfo()
    local debuffedUnits = {
        ["Tanks"] = {},
        ["Expiration"] = {},
        ["Shield"] = {},
        ["速度"] = {},
        ["Top"] = {},
        ["Debuff"] = {},
        ["Dispel"] = {}
    }
    if
    dungeonDifficulty == 8 or BadDebuffsByMapID[mapID] ~= nil or
    (Unit.Boss1 and Unit.Boss1:Exists() and BadDebuffs[bossID] ~= nil)
    then
        local thisBossTable =         BadDebuffs[bossID] or (dungeonDifficulty == 8 and BadDebuffs[1]) or BadDebuffsByMapID[mapID]
        local activeHealingValue = GetOptionValue("主动治疗")
        for i = 1, #thisBossTable do
            local thisBossDebuff = Spell(thisBossTable[i][2])
            local thisCategory = thisBossTable[i][1][1]
            if thisCategory == "Tanks" then
                for j = 1, #TheseUnits do
                    local thisUnit = TheseUnits[j]
                    local name, _, _, count, _, duration, expires = UnitDebuff(thisUnit.UnitID, thisBossDebuff:Name())
                    if
                    name ~= nil and (thisBossTable[i][1][3] == nil or count >= thisBossTable[i][1][3]) and
                    ((MainTank and thisUnit:Equals(MainTank)) or (OffTank and thisUnit:Equals(OffTank)))
                    then
                        table.insert(debuffedUnits.Tanks, thisUnit)
                    end
                end
            elseif thisCategory == "Expiration" then
                for j = 1, #TheseUnits do
                    local thisUnit = TheseUnits[j]
                    local name, _, _, count, _, duration, expires = UnitDebuff(thisUnit.UnitID, thisBossDebuff:Name())
                    if name ~= nil and expires - GetTime() < 10 then
                        table.insert(debuffedUnits.Expiration, thisUnit)
                    end
                end
            elseif thisCategory == "Shield" then
                for j = 1, #TheseUnits do
                    local thisUnit = TheseUnits[j]
                    local name, _, _, count, _, duration, expires = UnitDebuff(thisUnit.UnitID, thisBossDebuff:Name())
                    if name ~= nil then
                        table.insert(debuffedUnits.Shield, thisUnit)
                    end
                end
            elseif thisCategory == "速度" then
                for j = 1, #TheseUnits do
                    local thisUnit = TheseUnits[j]
                    local name, _, _, count, _, duration, expires = UnitDebuff(thisUnit.UnitID, thisBossDebuff:Name())
                    if name ~= nil then
                        table.insert(debuffedUnits.Speed, thisUnit)
                    end
                end
            elseif thisCategory == "Top" then
                for j = 1, #TheseUnits do
                    local thisUnit = TheseUnits[j]
                    local name, _, _, count, _, duration, expires = UnitDebuff(thisUnit.UnitID, thisBossDebuff:Name())
                    if name ~= nil then
                        table.insert(debuffedUnits.Top, thisUnit)
                    end
                end
            elseif thisCategory == "Debuff" then
                for j = 1, #TheseUnits do
                    local thisUnit = TheseUnits[j]
                    local name, _, _, count, _, duration, expires = UnitDebuff(thisUnit.UnitID, thisBossDebuff:Name())
                    if name ~= nil and (thisBossTable[i][1][3] == nil or count >= thisBossTable[i][1][3]) then
                        table.insert(debuffedUnits.Debuff, thisUnit)
                    end
                end
            elseif thisCategory == "Dispel" then
                if #debuffedUnits.Dispel == 0 then
                    for j = 1, #TheseUnits do
                        local thisUnit = TheseUnits[j]
                        local name, _, _, count, _, duration, expires =                         UnitDebuff(thisUnit.UnitID, thisBossDebuff:Name())
                        if
                        name ~= nil and (thisBossTable[i][1][3] == 0 or count >= thisBossTable[i][1][3]) and
                        (thisBossTable[i][1][4] == 0 or
                        #thisUnit:HealUnitsAround(100, thisBossTable[i][1][4]) <= 1)
                        then
                            table.insert(debuffedUnits.Dispel, thisUnit)
                        end
                    end
                end
            end
        end
        return debuffedUnits
    else
        return debuffedUnits
    end
end
Player.DispelWait = 0
function Player:DispelHandler(DispelSpell, DispelOption, DispelUnit, ActiveDispelTable, Priority)
    local BestUnit, BestUnitHealth, BestUnitRole, ThisUnit, ThisUnitHealth, ThisUnitRole, Option1, Option2 =     nil,
    100,
    "",
    nil,
    100,
    "",
    nil,
    nil
    Option1, Option2 = GetOptionValue(DispelOption), GetSecondOptionValue(DispelOption) or 0
    if DispelSpell:Exists() and IsOptionEnabled(DispelOption) then
        if #ActiveDispelTable > 0 and (Option1 == "自动" or Option1 == "正常" or Option1 == "高" or Priority == "正常") then
            BestUnit, BestUnitHealth, BestUnitRole = nil, 100, ""
            for i = 1, #ActiveDispelTable do
                ThisUnit, ThisUnitHealth, ThisUnitRole =                 ActiveDispelTable[i],
                ActiveDispelTable[i]:SpecialHealthPercentage(),
                UnitGroupRolesAssigned(ActiveDispelTable[i].UnitID)
                if
                (BestUnit == nil or ThisUnitRole == "TANK" or
                (ThisUnitRole == "HEALER" and not BestUnitRole == "TANK") or
                ThisUnitHealth < BestUnitHealth) and
                ThisUnit:CanCast(DispelSpell)
                then
                    BestUnit, BestUnitHealth, BestUnitRole = ThisUnit, ThisUnitHealth, ThisUnitRole
                end
            end
            if BestUnit then
                self.DispelWait = 0
                Bug("Active Dispel - Raid known Debuffs.")
                BestUnit:Cast(DispelSpell)
                return
            end
        end
        if DispelUnit then
            if Option1 == "自动" then
                local thisBossTable = BadDebuffs[EncounterID]
                if thisBossTable then
                    for i = 1, #thisBossTable do
                        if thisBossTable[i][1][1] == "Dispel" and DispelUnit:DebuffAny(Spell(thisBossTable[i][2])) then
                            Bug("Don't dispel as it's a Raid debuff with condition.")
                            return
                        end
                    end
                end
            end
            DispelOption, DispelUnitName = DispelOption or "", DispelUnit:Name() or ""
            if Option2 == 0 and DispelUnit:CanCast(DispelSpell) then
                Bug(DispelOption .. " on " .. DispelUnitName .. " without delays")
                DispelUnit:Cast(DispelSpell)
                return
            elseif Option2 ~= 0 and self.DispelWait == 0 then
                self.DispelWait = GetTime() + Option2
                Bug(DispelOption .. " in " .. Option2 .. " seconds")
            elseif self.DispelWait ~= 0 and self.DispelWait ~= nil then
                if self.DispelWait < GetTime() then
                    if (Priority == "正常" or Option1 == "高") then
                        if DispelUnit:CanCast(DispelSpell) then
                            self.DispelWait = 0
                            Bug(
                            DispelOption ..
                            " on " .. DispelUnitName .. " after " .. GetTime() - self.DispelWait + Option2
                            )
                            DispelUnit:Cast(DispelSpell)
                            return
                        end
                    end
                else
                    Bug(
                    DispelOption ..
                    " on " ..
                    DispelUnitName ..
                    " in " ..
                    tostring(math.floor((self.DispelWait - GetTime()) * 100) / 100) .. " seconds"
                    )
                end
            end
        end
    else
        self.DispelWait = 0
    end
end
function Player:CancelHeal(AllowedSpells, CastedPercent, IncomingPlayerModifier, IncomingOtherModifer)
    if not LastCastTarget then
        return
    end
    if CurrentBadDebuffs and #CurrentBadDebuffs.Top > 0 then
        for i = 1, #CurrentBadDebuffs.Top do
            if CurrentBadDebuffs.Top[i]:GUID() == LastCastTarget:GUID() then
                return false
            end
        end
    end
    CastedPercent = CastedPercent or 85
    local UsedSpell, MinimumEfficiency
    for ThisSpell, ThisEfficiency in pairs(AllowedSpells) do
        if self:Casting(ThisSpell) and self:CastedPercent() >= CastedPercent then
            UsedSpell, MinimumEfficiency = ThisSpell, ThisEfficiency
            break
        end
    end
    if not UsedSpell or not MinimumEfficiency then
        return
    end
    IncomingOtherModifer = IncomingOtherModifer or 1
    IncomingPlayerModifier = IncomingPlayerModifier or 1
    local IncomingPlayer = UnitGetIncomingHeals(LastCastTarget.UnitID, "player")
    local IncomingOther = (UnitGetIncomingHeals(LastCastTarget.UnitID) - IncomingPlayer) * IncomingOtherModifer
    IncomingPlayer = IncomingPlayer * IncomingPlayerModifier
    local MissingAfterOther = LastCastTarget:HealthDeficit() - IncomingOther
    Bug(
    "IncomingPlayer: " ..
    tostring(IncomingPlayer) ..
    " - IncomingOther: " ..
    tostring(IncomingOther) ..
    " - MissingAfterOther: " ..
    tostring(MissingAfterOther) .. " | Eff: " .. tostring(MissingAfterOther / IncomingPlayer)
    )
    if MissingAfterOther <= 0 or MissingAfterOther / IncomingPlayer < MinimumEfficiency() then
        Bug(
        "Stopped casting: " .. UsedSpell:Name() .. " | Efficiency: " .. tostring(MissingAfterOther / IncomingPlayer)
        )
        SpellStopCasting()
        return true
    end
    return false
end
MfDHT = { Enemies = {}, Coeff = 3, TTD = 0, BestUnit = nil, BestUnitTTD = 60 }
function Player:UseMarkedForDeath(MarkedForDeath, CPDiff)
    if
    IsOptionEnabled("死亡标记") and GetOptionValue("死亡标记") == "Adds" and
    (CooldownsAllowed() or GetSecondOptionValue("死亡标记") == "无条件使用") and
    MarkedForDeath:Exists() and
    not MarkedForDeath:IsOnCooldown() and
    CPDiff > 0
    then
        MfDHT.Enemies = Player:EnemiesWithinDistance(30, false)
        if CPDiff > 5 then
            CPDiff = 5
        end
        MfDHT.Coeff = Player:Power() < 50 and 3 or 2
        MfDHT.TTD = CPDiff * MfDHT.Coeff
        MfDHT.BestUnit, MfDHT.BestUnitTTD = nil, 60
        local ThisUnit, ThisUnitTTD
        for i = 1, #MfDHT.Enemies do
            ThisUnit = MfDHT.Enemies[i]
            ThisUnitTTD = ThisUnit:TimeToDie()
            if
            ThisUnitTTD < MfDHT.TTD and ThisUnitTTD < MfDHT.BestUnitTTD and not ThisUnit:IsMfdBlacklisted() and
            ThisUnit:CanCast(MarkedForDeath)
            then
                MfDHT.BestUnit, MfDHT.BestUnitTTD = ThisUnit, ThisUnitTTD
            end
        end
        if MfDHT.BestUnit then
            MfDHT.BestUnit:Cast(MarkedForDeath)
            return true
        end
    end
end
function Player:PickPocketInit()
    self.PickPocketed = {}
    local LootMessage
    local Locale = _G["GetLocale"]()
    local LOOT_ITEM_SELF = _G["LOOT_ITEM_SELF"]
    if Locale == "deDE" then
        LootMessage = string.sub(LOOT_ITEM_SELF, 1, 18)
    elseif Locale == "esES" or Locale == "esMX" then
        LootMessage = string.sub(LOOT_ITEM_SELF, 1, 13)
    elseif Locale == "frFR" then
        LootMessage = string.sub(LOOT_ITEM_SELF, 1, 21)
    elseif Locale == "itIT" then
        LootMessage = string.sub(LOOT_ITEM_SELF, 1, 12)
    elseif Locale == "koKR" then
        LootMessage = string.sub(LOOT_ITEM_SELF, 1, 11)
    elseif Locale == "ptBR" then
        LootMessage = string.sub(LOOT_ITEM_SELF, 1, 19)
    elseif Locale == "ruRU" then
        LootMessage = string.sub(LOOT_ITEM_SELF, 1, 11)
    elseif Locale == "zhCN" or Locale == "zhTW" then
        LootMessage = string.sub(LOOT_ITEM_SELF, 1, 6)
    else
        LootMessage = string.sub(LOOT_ITEM_SELF, 1, 16)
    end
    EventFrame:RegisterForEvent(
    function(MessageType, Message)
        if PickPocketAttempt and GetTime() - PickPocketAttempt >= 1.5 then
            PickPocketAttempt, PickPocketTarget = nil, nil
        end
        if
        PickPocketAttempt and
        (Message == _G["SPELL_FAILED_TARGET_NO_POCKETS"] or Message == _G["ERR_ALREADY_PICKPOCKETED"] or
        ((MessageType == _G["ERR_ITEM_MAX_COUNT"] or Message == _G["ERR_ITEM_MAX_COUNT"]) or
        (string.find(MessageType, LootMessage) or string.find(Message, LootMessage))))
        then
            for Key, Value in ipairs(Player.PickPocketed) do
                if not UnitsEngine.Units.UnitsInfos[Key] then
                    Player.PickPocketed[Key] = nil
                end
            end
            Player.PickPocketed[PickPocketTarget] = true
            PickPocketAttempt = nil
        end
    end,
    "UI_ERROR_MESSAGE",
    "CHAT_MSG_LOOT"
    )
    self.PickPocketInitialized = true
end
function Player:PowerMax()
    return UnitPowerMax(self.UnitID)
end
function Player:Power()
    return UnitPower(self.UnitID)
end
function PlayerPet:Power()
    return UnitPower(self.UnitID)
end
function Player:PowerPercentage()
    return (self:Power() / self:PowerMax()) * 100
end
function Player:PowerDeficit()
    return self:PowerMax() - self:Power()
end
function Player:PowerDeficitPercentage()
    return (self:PowerDeficit() / self:PowerMax()) * 100
end
function Player:PowerRegen()
    return select(2, GetPowerRegen(self.UnitID))
end
function Player:PowerRegenPercentage()
    return (self:PowerRegen() / self:PowerMax()) * 100
end
function Player:PowerTimeToMax()
    return self:PowerDeficit() * (1 / self:PowerRegen())
end
function Player:PowerTimeToX(Amount)
    if self:PowerRegen() > 0 then
        return Amount > self:Power() and (Amount - self:Power()) * (1 / self:PowerRegen()) or 0
    elseif self:PowerRegen() < 0 then
        return Amount < self:Power() and (self:Power() - Amount) * (1 / self:PowerRegen()) or 0
    else
        return -1
    end
end
function Player:PowerTimeToXPercentage(Amount)
    if self:PowerRegen() > 0 then
        return Amount > self:PowerPercentage() and (Amount - self:PowerPercentage()) * (1 / self:PowerRegenPercentage()) or
        0
    elseif self:PowerRegen() < 0 then
        return Amount < self:PowerPercentage() and (self:PowerPercentage() - Amount) * (1 / self:PowerRegenPercentage()) or
        0
    else
        return -1
    end
end
function Player:ManaMax()
    return UnitPowerMax(self.UnitID, Enum.PowerType.Mana)
end
function Player:Mana()
    return UnitPower(self.UnitID, Enum.PowerType.Mana)
end
function Player:ManaPercentage()
    return (self:Mana() / self:ManaMax()) * 100
end
function Player:ManaDeficit()
    return self:ManaMax() - self:Mana()
end
function Player:ManaDeficitPercentage()
    return (self:ManaDeficit() / self:ManaMax()) * 100
end
function Player:ManaRegen()
    return select(2, GetPowerRegen(self.UnitID))
end
function Player:ManaRegenPercentage()
    return (self:ManaRegen() / self:ManaMax()) * 100
end
function Player:ManaTimeToMax()
    return self:ManaDeficit() * (1 / self:ManaRegen())
end
function Player:ManaTimeToX(Amount)
    if self:ManaRegen() == 0 then
        return -1
    end
    return Amount > self:Mana() and (Amount - self:Mana()) * (1 / self:ManaRegen()) or 0
end
function Player:ManaTimeToXPercentage(Amount)
    if self:ManaRegen() == 0 then
        return -1
    end
    return Amount > self:ManaPercentage() and (Amount - self:ManaPercentage()) * (1 / self:ManaRegenPercentage()) or 0
end
function Player:RageMax()
    return UnitPowerMax(self.UnitID, Enum.PowerType.Rage)
end
function Player:Rage()
    return UnitPower(self.UnitID, Enum.PowerType.Rage)
end
function Player:RagePercentage()
    return (self:Rage() / self:RageMax()) * 100
end
function Player:RageDeficit()
    return self:RageMax() - self:Rage()
end
function Player:RageDeficitPercentage()
    return (self:RageDeficit() / self:RageMax()) * 100
end
function Player:RageRegen()
    return select(2, GetPowerRegen(self.UnitID))
end
function Player:RageRegenPercentage()
    return (self:RageRegen() / self:RageMax()) * 100
end
function Player:RageTimeToMax()
    return self:RageDeficit() * (1 / self:RageRegen())
end
function Player:RageTimeToX(Amount)
    if self:RageRegen() == 0 then
        return -1
    end
    return Amount < self:Rage() and (self:Rage() - Amount) * (1 / self:RageRegen()) or 0
end
function Player:RageTimeToXPercentage(Amount)
    if self:RageRegen() == 0 then
        return -1
    end
    return Amount < self:RagePercentage() and (self:RagePercentage() - Amount) * (1 / self:RageRegenPercentage()) or 0
end
function Player:FocusMax()
    return UnitPowerMax(self.UnitID, Enum.PowerType.Focus)
end
function Player:Focus()
    return UnitPower(self.UnitID, Enum.PowerType.Focus)
end
function Player:FocusPercentage()
    return (self:Focus() / self:FocusMax()) * 100
end
function Player:FocusDeficit()
    return self:FocusMax() - self:Focus()
end
function Player:FocusDeficitPercentage()
    return (self:FocusDeficit() / self:FocusMax()) * 100
end
function Player:FocusRegen()
    return select(2, GetPowerRegen(self.UnitID))
end
function Player:FocusRegenPercentage()
    return (self:FocusRegen() / self:FocusMax()) * 100
end
function Player:FocusTimeToMax()
    return self:FocusDeficit() * (1 / self:FocusRegen())
end
function Player:FocusTimeToX(Amount)
    if self:FocusRegen() == 0 then
        return -1
    end
    return Amount > self:Focus() and (Amount - self:Focus()) * (1 / self:FocusRegen()) or 0
end
function Player:FocusTimeToXPercentage(Amount)
    if self:FocusRegen() == 0 then
        return -1
    end
    return Amount > self:FocusPercentage() and (Amount - self:FocusPercentage()) * (1 / self:FocusRegenPercentage()) or
    0
end
function Player:EnergyMax()
    return UnitPowerMax(self.UnitID, Enum.PowerType.Energy)
end
function Player:Energy()
    return UnitPower(self.UnitID, Enum.PowerType.Energy)
end
function Player:EnergyPercentage()
    return (self:Energy() / self:EnergyMax()) * 100
end
function Player:EnergyDeficit()
    return self:EnergyMax() - self:Energy()
end
function Player:EnergyDeficitPercentage()
    return (self:EnergyDeficit() / self:EnergyMax()) * 100
end
function Player:EnergyRegen()
    return select(2, GetPowerRegen(self.UnitID))
end
function Player:EnergyRegenPercentage()
    return (self:EnergyRegen() / self:EnergyMax()) * 100
end
function Player:EnergyTimeToMax()
    return self:EnergyDeficit() * (1 / self:EnergyRegen())
end
function Player:EnergyTimeToX(Amount)
    if self:EnergyRegen() == 0 then
        return -1
    end
    return Amount > self:Energy() and (Amount - self:Energy()) * (1 / self:EnergyRegen()) or 0
end
function Player:EnergyTimeToXPercentage(Amount)
    if self:EnergyRegen() == 0 then
        return -1
    end
    return Amount > self:EnergyPercentage() and (Amount - self:EnergyPercentage()) * (1 / self:EnergyRegenPercentage()) or
    0
end
function Player:ComboPointsMax()
    return UnitPowerMax(self.UnitID, Enum.PowerType.ComboPoints)
end
function Player:ComboPoints()
    return UnitPower(self.UnitID, Enum.PowerType.ComboPoints)
end
function Player:ComboPointsDeficit()
    return self:ComboPointsMax() - self:ComboPoints()
end
function Player:Runes()
    local RuneCount = 6
    local NextRuneReady = 9
    local RechargeDuration
    for i = 1, 6 do
        local Start, Duration, RuneReady = GetRuneCooldown(i)
        if not RuneReady then
            RuneCount = RuneCount - 1
            local ReadyIn = Start + Duration - GetTime()
            NextRuneReady = ReadyIn < NextRuneReady and ReadyIn or NextRuneReady
        end
        RechargeDuration = Duration
    end
    RuneCount = RuneCount == 6 and RuneCount or RuneCount + 1 - NextRuneReady / RechargeDuration
    return RuneCount, NextRuneReady
end
function Player:RunicPowerMax()
    return UnitPowerMax(self.UnitID, Enum.PowerType.RunicPower)
end
function Player:RunicPower()
    return UnitPower(self.UnitID, Enum.PowerType.RunicPower)
end
function Player:RunicPowerPercentage()
    return (self:RunicPower() / self:RunicPowerMax()) * 100
end
function Player:RunicPowerDeficit()
    return self:RunicPowerMax() - self:RunicPower()
end
function Player:RunicPowerDeficitPercentage()
    return (self:RunicPowerDeficit() / self:RunicPowerMax()) * 100
end
function Player:RunicPowerRegen()
    return select(2, GetPowerRegen(self.UnitID))
end
function Player:RunicPowerRegenPercentage()
    return (self:RunicPowerRegen() / self:RunicPowerMax()) * 100
end
function Player:RunicPowerTimeToMax()
    return self:RunicPowerDeficit() * (1 / self:RunicPowerRegen())
end
function Player:RunicPowerTimeToX(Amount)
    if self:RunicPowerRegen() == 0 then
        return -1
    end
    return Amount < self:RunicPower() and (self:RunicPower() - Amount) * (1 / self:RunicPowerRegen()) or 0
end
function Player:RunicPowerTimeToXPercentage(Amount)
    if self:RunicPowerRegen() == 0 then
        return -1
    end
    return Amount < self:RunicPowerPercentage() and
    (self:RunicPowerPercentage() - Amount) * (1 / self:RunicPowerRegenPercentage()) or
    0
end
function Player:SoulShardsMax()
    return UnitPowerMax(self.UnitID, Enum.PowerType.SoulShards)
end
function Player:SoulShards()
    return UnitPower(self.UnitID, Enum.PowerType.SoulShards)
end
function Player:SoulShardsFragments()
    return UnitPower(self.UnitID, Enum.PowerType.SoulShards, true)
end
function Player:SoulShardsPercentage()
    return (self:SoulShards() / self:SoulShardsMax()) * 100
end
function Player:SoulShardsDeficit()
    return self:SoulShardsMax() - self:SoulShards()
end
function Player:SoulShardsDeficitPercentage()
    return (self:SoulShardsDeficit() / self:SoulShardsMax()) * 100
end
function Player:AstralPowerMax()
    return UnitPowerMax(self.UnitID, Enum.PowerType.LunarPower)
end
function Player:AstralPower()
    return UnitPower(self.UnitID, Enum.PowerType.LunarPower)
end
function Player:AstralPowerPercentage()
    return (self:AstralPower() / self:AstralPowerMax()) * 100
end
function Player:AstralPowerDeficit()
    return self:AstralPowerMax() - self:AstralPower()
end
function Player:AstralPowerDeficitPercentage()
    return (self:AstralPowerDeficit() / self:AstralPowerMax()) * 100
end
function Player:HolyPowerMax()
    return UnitPowerMax(self.UnitID, Enum.PowerType.HolyPower)
end
function Player:HolyPower()
    return UnitPower(self.UnitID, Enum.PowerType.HolyPower)
end
function Player:HolyPowerPercentage()
    return (self:HolyPower() / self:HolyPowerMax()) * 100
end
function Player:HolyPowerDeficit()
    return self:HolyPowerMax() - self:HolyPower()
end
function Player:HolyPowerDeficitPercentage()
    return (self:HolyPowerDeficit() / self:HolyPowerMax()) * 100
end
function Player:AlternatePowerMax()
    return UnitPowerMax(self.UnitID, Enum.PowerType.Alternate)
end
function Player:AlternatePower()
    return UnitPower(self.UnitID, Enum.PowerType.Alternate)
end
function Player:AlternatePowerPercentage()
    return (self:AlternatePower() / self:AlternatePowerMax()) * 100
end
function Player:AlternatePowerDeficit()
    return self:AlternatePowerMax() - self:AlternatePower()
end
function Player:AlternatePowerDeficitPercentage()
    return (self:AlternatePowerDeficit() / self:AlternatePowerMax()) * 100
end
function Player:MaelstromMax()
    return UnitPowerMax(self.UnitID, Enum.PowerType.Maelstrom)
end
function Player:Maelstrom()
    return UnitPower(self.UnitID, Enum.PowerType.Maelstrom)
end
function Player:MaelstromPercentage()
    return (self:Maelstrom() / self:MaelstromMax()) * 100
end
function Player:MaelstromDeficit()
    return self:MaelstromMax() - self:Maelstrom()
end
function Player:MaelstromDeficitPercentage()
    return (self:MaelstromDeficit() / self:MaelstromMax()) * 100
end
function Player:ChiMax()
    return UnitPowerMax(self.UnitID, Enum.PowerType.Chi)
end
function Player:Chi()
    return UnitPower(self.UnitID, Enum.PowerType.Chi)
end
function Player:ChiPercentage()
    return (self:Chi() / self:ChiMax()) * 100
end
function Player:ChiDeficit()
    return self:ChiMax() - self:Chi()
end
function Player:ChiDeficitPercentage()
    return (self:ChiDeficit() / self:ChiMax()) * 100
end
function Player:InsanityMax()
    return UnitPowerMax(self.UnitID, Enum.PowerType.Insanity)
end
function Player:Insanity()
    return UnitPower(self.UnitID, Enum.PowerType.Insanity) or 0
end
function Player:InsanityPercentage()
    return (self:Insanity() / self:InsanityMax()) * 100
end
function Player:InsanityDeficit()
    return self:InsanityMax() - self:Insanity()
end
function Player:InsanityDeficitPercentage()
    return (self:InsanityDeficit() / self:InsanityMax()) * 100
end
function Player:ArcaneChargesMax()
    return UnitPowerMax(self.UnitID, Enum.PowerType.ArcaneCharges)
end
function Player:ArcaneCharges()
    return UnitPower(self.UnitID, Enum.PowerType.ArcaneCharges)
end
function Player:ArcaneChargesPercentage()
    return (self:ArcaneCharges() / self:ArcaneChargesMax()) * 100
end
function Player:ArcaneChargesDeficit()
    return self:ArcaneChargesMax() - self:ArcaneCharges()
end
function Player:ArcaneChargesDeficitPercentage()
    return (self:ArcaneChargesDeficit() / self:ArcaneChargesMax()) * 100
end
function Player:FuryMax()
    return UnitPowerMax(self.UnitID, Enum.PowerType.Fury)
end
function Player:Fury()
    return UnitPower(self.UnitID, Enum.PowerType.Fury)
end
function Player:FuryPercentage()
    return (self:Fury() / self:FuryMax()) * 100
end
function Player:FuryDeficit()
    return self:FuryMax() - self:Fury()
end
function Player:FuryDeficitPercentage()
    return (self:FuryDeficit() / self:FuryMax()) * 100
end
function Player:PainMax()
    return UnitPowerMax(self.UnitID, Enum.PowerType.Pain)
end
function Player:Pain()
    return UnitPower(self.UnitID, Enum.PowerType.Pain)
end
function Player:PainPercentage()
    return (self:Pain() / self:PainMax()) * 100
end
function Player:PainDeficit()
    return self:PainMax() - self:Pain()
end
function Player:PainDeficitPercentage()
    return (self:PainDeficit() / self:PainMax()) * 100
end
local Procs = {}
function Procs.ProcIteration(Spell, PTable, VTrigger, Duration)
    local CastTime = 0
    if Spell then
        CastTime = Spell:CastTime()
    elseif Duration then
        CastTime = Duration
    end
    if not AurasTable[C.PLAYERGUID] or not AurasTable[C.PLAYERGUID].Buff then
        Player:GetBuffs(C.PLAYERGUID)
    end
    local ValueProc = 0
    if AurasTable[C.PLAYERGUID].Buff then
        local Table = AurasTable[C.PLAYERGUID].Buffs
        for i = 1, #PTable do
            for j = 1, #Table do
                if PTable[i].BuffID == Table[j][11] and Table[j][7] - GetTime() > CastTime then
                    if PTable[i].CountBuffID then
                        if PTable[i].CountBuffID == PTable[i].BuffID then
                            ValueProc = ValueProc + Table[j][4] * PTable[i].Coef
                        else
                            for k = 1, #Table do
                                if PTable[i].CountBuffID == Table[k][11] then
                                    ValueProc = ValueProc + Table[k][4] * PTable[i].Coef
                                    break
                                end
                            end
                        end
                    else
                        ValueProc = ValueProc + PTable[i].Coef
                    end
                    break
                end
            end
        end
    end
    return VTrigger and ValueProc >= VTrigger or ValueProc >= 1
end
function Player:HasAnyProc(Spell, ValueToTrigProc, Duration)
    return self:HasDmgProc(Spell, ValueToTrigProc, Duration) or self:HasAgiProc(Spell, ValueToTrigProc, Duration) or
    self:HasIntProc(Spell, ValueToTrigProc, Duration) or
    self:HasStrProc(Spell, ValueToTrigProc, Duration) or
    self:HasCritProc(Spell, ValueToTrigProc, Duration) or
    self:HasHasteProc(Spell, ValueToTrigProc, Duration) or
    self:HasMasteryProc(Spell, ValueToTrigProc, Duration) or
    self:HasVersaProc(Spell, ValueToTrigProc, Duration) or
    self:HasHealthProc(Spell, ValueToTrigProc, Duration)
end
Procs.DmgPTable = {
    { BuffID = 187615, Coef = 1 },
    { BuffID = 187611, Coef = 1 },
    { BuffID = 187614, Coef = 1 },
    { BuffID = 184293, Coef = 1 },
    { BuffID = 222705, Coef = 1 }
}
function Player:HasDmgProc(Spell, ValueToTrigProc, Duration)
    return Procs.ProcIteration(Spell, Procs.DmgPTable, ValueToTrigProc, Duration)
end
Procs.AgiPTable = {
    { BuffID = 156423, Coef = 1 },
    { BuffID = 182059, Coef = 1 },
    { BuffID = 182068, Coef = 1 },
    { BuffID = 60233, Coef = 1 },
    { BuffID = 177597, Coef = 1 },
    { BuffID = 177161, Coef = 1 },
    { BuffID = 177172, Coef = 1 }
}
function Player:HasAgiProc(Spell, ValueToTrigProc, Duration)
    return Procs.ProcIteration(Spell, Procs.AgiPTable, ValueToTrigProc, Duration)
end
Procs.IntPTable = {
    { BuffID = 156426, Coef = 1 },
    { BuffID = 182057, Coef = 1 },
    { BuffID = 182067, Coef = 1 },
    { BuffID = 60234, Coef = 1 },
    { BuffID = 177159, Coef = 1 },
    { BuffID = 177176, Coef = 1 },
    { BuffID = 183775, Coef = 1 },
    { BuffID = 183924, Coef = 1 },
    { BuffID = 215648, Coef = 1 },
    { BuffID = 215467, Coef = 1 },
    { BuffID = 215648, Coef = 1 }
}
function Player:HasIntProc(Spell, ValueToTrigProc, Duration)
    return Procs.ProcIteration(Spell, Procs.IntPTable, ValueToTrigProc, Duration)
end
Procs.StrPTable = {
    { BuffID = 156428, Coef = 1 },
    { BuffID = 182062, Coef = 1 },
    { BuffID = 182069, Coef = 1 },
    { BuffID = 60229, Coef = 1 },
    { BuffID = 177189, Coef = 1 },
    { BuffID = 177160, Coef = 1 },
    { BuffID = 177175, Coef = 1 }
}
function Player:HasStrProc(Spell, ValueToTrigProc, Duration)
    return Procs.ProcIteration(Spell, Procs.StrPTable, ValueToTrigProc, Duration)
end
Procs.CritPTable = {
    { BuffID = 159234, Coef = 1 },
    { BuffID = 159676, Coef = 1 },
    { BuffID = 177067, Coef = 0.125, CountBuffID = 177067 },
    { BuffID = 177063, Coef = 1 },
    { BuffID = 165832, Coef = 1 },
    { BuffID = 176878, Coef = 1 },
    { BuffID = 177046, Coef = 1 },
    { BuffID = 176982, Coef = 1 },
    { BuffID = 165542, Coef = 1 },
    { BuffID = 177040, Coef = 1 },
    { BuffID = 176881, Coef = 1 },
    { BuffID = 162917, Coef = 1 },
    { BuffID = 176978, Coef = 1 },
    { BuffID = 162915, Coef = 1 },
    { BuffID = 162919, Coef = 1 },
    { BuffID = 162920, Coef = 1 },
    { BuffID = 165532, Coef = 1 },
    { BuffID = 215813, Coef = 1 },
    { BuffID = 201409, Coef = 1 },
    { BuffID = 238498, Coef = 1 },
    { BuffID = 215813, Coef = 1 },
    { BuffID = 238499, Coef = 1 }
}
function Player:HasCritProc(Spell, ValueToTrigProc, Duration)
    return Procs.ProcIteration(Spell, Procs.CritPTable, ValueToTrigProc, Duration)
end
Procs.HastePTable = {
    { BuffID = 159675, Coef = 1 },
    { BuffID = 177051, Coef = 1 },
    { BuffID = 177086, Coef = 0.125, CountBuffID = 177086 },
    { BuffID = 177035, Coef = 1 },
    { BuffID = 177102, Coef = 0.125, CountBuffID = 177102 },
    { BuffID = 176879, Coef = 1 },
    { BuffID = 176984, Coef = 1 },
    { BuffID = 176943, Coef = 1 },
    { BuffID = 176937, Coef = 1 },
    { BuffID = 176874, Coef = 1 },
    { BuffID = 176980, Coef = 1 },
    { BuffID = 176875, Coef = 1 },
    { BuffID = 165822, Coef = 1 },
    { BuffID = 176882, Coef = 1 },
    { BuffID = 176885, Coef = 1 },
    { BuffID = 165531, Coef = 1 },
    { BuffID = 165822, Coef = 1 },
    { BuffID = 225125, Coef = 1 },
    { BuffID = 201409, Coef = 1 },
    { BuffID = 225142, Coef = 1 },
    { BuffID = 242458, Coef = 1 },
    { BuffID = 225125, Coef = 1 },
    { BuffID = 238498, Coef = 1 },
    { BuffID = 214120, Coef = 1 },
    { BuffID = 238501, Coef = 1 },
    { BuffID = 225774, Coef = 1 }
}
function Player:HasHasteProc(Spell, ValueToTrigProc, Duration)
    return Procs.ProcIteration(Spell, Procs.HastePTable, ValueToTrigProc, Duration)
end
Procs.MasteryPTable = {
    { BuffID = 173322, Coef = 1 },
    { BuffID = 177096, Coef = 0.125, CountBuffID = 177096 },
    { BuffID = 177081, Coef = 0.125, CountBuffID = 177083 },
    { BuffID = 177038, Coef = 1 },
    { BuffID = 176935, Coef = 1 },
    { BuffID = 177056, Coef = 1 },
    { BuffID = 177042, Coef = 1 },
    { BuffID = 176939, Coef = 1 },
    { BuffID = 176941, Coef = 1 },
    { BuffID = 165824, Coef = 1 },
    { BuffID = 176876, Coef = 1 },
    { BuffID = 165535, Coef = 1 },
    { BuffID = 176883, Coef = 1 },
    { BuffID = 176884, Coef = 1 },
    { BuffID = 165535, Coef = 1 },
    { BuffID = 165485, Coef = 1 },
    { BuffID = 201409, Coef = 1 },
    { BuffID = 215630, Coef = 1 },
    { BuffID = 238498, Coef = 1 },
    { BuffID = 215630, Coef = 1 },
    { BuffID = 238500, Coef = 1 }
}
function Player:HasMasteryProc(Spell, ValueToTrigProc, Duration)
    return Procs.ProcIteration(Spell, Procs.MasteryPTable, ValueToTrigProc, Duration)
end
Procs.VersaPTable = {
    { BuffID = 159679, Coef = 1 },
    { BuffID = 159678, Coef = 1 },
    { BuffID = 170397, Coef = 1 },
    { BuffID = 176974, Coef = 1 },
    { BuffID = 165543, Coef = 1 },
    { BuffID = 177060, Coef = 1 },
    { BuffID = 165833, Coef = 1 },
    { BuffID = 162913, Coef = 1 },
    { BuffID = 176873, Coef = 1 },
    { BuffID = 165543, Coef = 1 },
    { BuffID = 177053, Coef = 1 },
    { BuffID = 165534, Coef = 1 },
    { BuffID = 182073, Coef = 1 },
    { BuffID = 187613, Coef = 1 }
}
function Player:HasVersaProc(Spell, ValueToTrigProc, Duration)
    return Procs.ProcIteration(Spell, Procs.VersaPTable, ValueToTrigProc, Duration)
end
Procs.HealthPTable = { { BuffID = 176460, Coef = 1 }, { BuffID = 181706, Coef = 1 } }
function Player:HasHealthProc(Spell, ValueToTrigProc, Duration)
    return Procs.ProcIteration(Spell, Procs.HealthPTable, ValueToTrigProc, Duration)
end
function Player:AttackPower()
    local APBase, APPos, APNeg = UnitAttackPower("player")
    return APBase + APPos + APNeg
end
function Player:Mastery()
    return (1 + GetMasteryEffect() / 100)
end
function Player:MasteryEffect()
    return (GetMasteryEffect())
end
function Player:GetMasteryAbsolute()
    return GetCombatRating(26)
end
function Player:SpellHaste()
    return 1 / (1 + UnitSpellHaste("player") / 100)
end
function Player:Haste()
    return UnitSpellHaste("player")
end
function Player:Versatility()
    return GetCombatRatingBonus(29) + GetVersatilityBonus(29)
end
function Player:AttackPower()
    return UnitAttackPower(self.UnitID)
end
function Player:CritChancePct()
    return GetCritChance()
end
function Player:HastePct()
    return GetHaste()
end
function Player:MasteryPct()
    return GetMasteryEffect()
end
function Player:VersatilityDmgPct()
    return GetCombatRatingBonus(29) + GetVersatilityBonus(29)
end
function Player:BonusDamage()
    return select(7, UnitDamage("player"))
end
HeroismBuffs = { Spell(2825), Spell(32182), Spell(80353), Spell(90355), Spell(160452), Spell(178207) }
function Player:HasHero()
    for i = 1, #HeroismBuffs do
        if Player:BuffAny(HeroismBuffs[i]) then
            return true
        end
    end
    return false
end
function Player:HeroDuration()
    local HeroismBuffs = { 32182, 90355, 80353, 2825, 178207 }
    for i = 1, #HeroismBuffs do
        if Player:BuffAny(HeroismBuffs[i]) then
            return self:BuffRemainsAny()
        end
    end
    return 0
end
SpellsTable = {}
function Spell:CastTime()
    if not self:InfoID(4) then
        return 0
    else
        return self:InfoID(4) / 1000
    end
end
function Spell:Charges()
    return GetSpellCharges(self.Identifier)
end
function Spell:Recharge()
    local Charges, MaxCharges, CDTime, CDValue = GetSpellCharges(self.Identifier)
    if Charges == MaxCharges then
        return 0
    end
    local CD = CDTime + CDValue - GetTime() - GetLatency()
    if CD > 0 then
        return CD
    else
        return 0
    end
end
function Spell:Cooldown()
    local CDTime, CDValue = GetSpellCooldown(self.Identifier)
    if CDTime == 0 then
        return 0
    end
    local CD = CDTime + CDValue - GetTime()
    if CD > 0 then
        return CD
    else
        return 0
    end
end
function Spell:Count()
    return GetSpellCount(self.Identifier)
end
function Spell:CurrentID()
    return self:InfoName(7)
end
local StaticTip = CreateFrame("GameTooltip", "SpellScanningTooltip", nil, "GameTooltipTemplate")
StaticTip:SetOwner(_G["WorldFrame"], "ANCHOR_NONE")
StaticTip:AddFontStrings(
StaticTip:CreateFontString("$parentTextLeft1", nil, "GameTooltipText"),
StaticTip:CreateFontString("$parentTextRight1", nil, "GameTooltipText")
)
function Spell:DamageValue()
    StaticTip:ClearLines()
    StaticTip:SetSpellByID(self.Identifier)
    local function FindValue(StringValue)
        local RegexSearch = "%d,%d%d%d,%d%d%d"
        local RegexSearch2 = "%d%d%d,%d%d%d"
        local RegexSearch3 = "%d%d,%d%d%d"
        local RegexSearch4 = "%d,%d%d%d"
        local RegexSearch5 = "%d%d%d"
        local RegexSearch6 = "%d%d"
        return string.find(StringValue, RegexSearch) and
        string.gsub(string.sub(StringValue, string.find(StringValue, RegexSearch)), ",", "") or
        string.find(StringValue, RegexSearch2) and
        string.gsub(string.sub(StringValue, string.find(StringValue, RegexSearch2)), ",", "") or
        string.find(StringValue, RegexSearch3) and
        string.gsub(string.sub(StringValue, string.find(StringValue, RegexSearch3)), ",", "") or
        string.find(StringValue, RegexSearch4) and
        string.gsub(string.sub(StringValue, string.find(StringValue, RegexSearch4)), ",", "") or
        string.find(StringValue, RegexSearch5) and string.sub(StringValue, string.find(StringValue, RegexSearch5)) or
        string.find(StringValue, RegexSearch6) and string.sub(StringValue, string.find(StringValue, RegexSearch6)) or
        0
    end
    local TipValue = FindValue(_G["SpellScanningTooltipTextLeft4"]:GetText())
    TipValue = TipValue ~= 0 and TipValue or FindValue(_G["SpellScanningTooltipTextLeft5"]:GetText())
    return TipValue
end
function Spell:Exists()
    return IsPlayerSpell(self.Identifier)
end
function Spell:FractionalCharges()
    local CurrentCharges, MaxCharges, Start, Duration = GetSpellCharges(self.Identifier)
    if CurrentCharges ~= MaxCharges then
        return math.floor((CurrentCharges + (GetTime() - Start) / Duration) * 100) / 100
    else
        return CurrentCharges
    end
end
function Spell:Icon()
    return self:InfoID(3)
end
function Spell:ID()
    return self.Identifier
end
function Spell:RegisterDamage(Function)
    self.DamageFormula = Function
end
function Spell:Damage()
    return self.DamageFormula and self.DamageFormula() or 0
end
function Spell:InfoID(Index)
    local SpellID = self:ID()
    if SpellID then
        if not SpellsTable[SpellID] then
            SpellsTable[SpellID] = { GetSpellInfo(SpellID) }
        end
        if Index then
            return SpellsTable[SpellID][Index]
        else
            return unpack(SpellsTable[SpellID])
        end
    else
        return 0
    end
end
function Spell:InfoName(Index)
    local SpellName = self:Name()
    if SpellName then
        if not SpellsTable[SpellName] then
            SpellsTable[SpellName] = { GetSpellInfo(SpellName) }
        end
        if Index then
            return SpellsTable[SpellName][Index]
        else
            return unpack(SpellsTable[SpellName])
        end
    else
        return 0
    end
end
function Spell:IsFacingRequired()
    return self.FacingRequired
end
function Spell:IsHostile()
    return self.Hostile
end
function Spell:IsMelee()
    return self:MinimumRange() == 0 and self:MaximumRange() == 0
end
function Spell:IsOnCooldown()
    return self:Cooldown() ~= 0
end
function Spell:IsResurrect()
    return self.Resurrect
end
function Spell:IsUsable()
    return IsUsableSpell(self.Identifier)
end
function Spell:NeedsResources()
    return select(2, IsUsableSpell(self.Identifier))
end
function Spell:MaximumRange()
    return self:InfoID(6)
end
function Spell:MinimumRange()
    return self:InfoID(5)
end
function Spell:Name()
    return self:InfoID(1)
end
function Spell:PetKnown()
    return IsSpellKnown(self.Identifier, true)
end
function Spell:TimeSinceCast()
    return self.LastCastTime > 0 and GetTime() - self.LastCastTime or 99
end
function Spell:TotemDuration()
    local SpellName = self:Name()
    for index = 1, 4 do
        local _, totemName, startTime, duration = GetTotemInfo(index)
        if totemName == SpellName then
            return math.floor(startTime + duration - GetTime())
        end
    end
    return 0
end
TravelSpeedChart = {
    [116] = 25,
    [686] = 54,
    [11366] = 52,
    [19434] = 95,
    [29722] = 18,
    [30455] = 39,
    [105174] = 33,
    [120644] = 10,
    [122121] = 25,
    [127632] = 19,
    [185901] = 37,
    [205181] = 32,
    [205448] = 18
}
function Spell:TravelTime()
    return Unit.Player:DistanceTo(Unit.Target) / (TravelSpeedChart[self.Identifier] or 40)
end
function Spell:WasLastCast()
    return LastCastedSpells[self.Identifier] and GetTime() - LastCastedSpells[self.Identifier].Time < 1.6 or false
end
function Spell:WasLastCastOnUnit(Unit)
    return self:WasLastCast() and LastCastedSpells[self.Identifier].Unit == Unit:GUID()
end
function Item:Cooldown()
    local CDTime, CDValue = GetItemCooldown(self.Identifier)
    if CDTime == 0 then
        return 0
    end
    local CD = CDTime + CDValue - GetTime() - GetLatency()
    if CD > 0 then
        return CD
    else
        return 0
    end
end
function Item:CooldownInventory()
    local CDTime, CDValue, CDEnabled = GetInventoryItemCooldown(Player.UnitID, self.Identifier)
    if CDEnabled == 0 then
        return 1
    end
    if CDTime == 0 then
        return 0
    end
    local CD = CDTime + CDValue - GetTime() - GetLatency()
    if CD > 0 then
        return CD
    else
        return 0
    end
end
function Item:ID()
    return Equipment[self.Identifier]
end
function Item:IsEquipped(Slot, OtherSlot)
    local EquippedSlot = false
    if not Slot and not OtherSlot then
        for i = 0, #self.ItemSlotID do
            if Equipment[self.ItemSlotID[i]] == self.Identifier then
                EquippedSlot = true
                break
            end
        end
    else
        local ThisItem = Equipment[Slot]
        if ThisItem and ThisItem == self.Identifier then
            EquippedSlot = Slot
        end
        if OtherSlot then
            local ThisItem = Equipment[OtherSlot]
            if ThisItem and ThisItem == self.Identifier then
                EquippedSlot = OtherSlot
            end
        end
    end
    return EquippedSlot
end
function Item:InStock()
    return GetItemCount(self.Identifier) > 0
end
function Item:IsOnCooldown()
    return self:Cooldown() ~= 0
end
function Item:IsOnCooldownInventory()
    return self:CooldownInventory() ~= 0
end
function Item:IsUsable()
    return self:InStock() and not self:IsOnCooldown()
end
function Item:IsUsableInventory()
    return not self:IsOnCooldownInventory()
end
function Item:Name()
    return ({ GetItemInfo(self.Identifier) })[1]
end
function Item:Use(ThisUnit)
    selectedUnit = ThisUnit and ThisUnit.UnitID or "player"
    if self:TimeSinceUse() >= 1 then
        UseItemByName(self.Identifier, selectedUnit)
        self.LastUseTime = GetTime()
    end
end
function Item:UseInventory()
    if self:TimeSinceUse() >= 1 then
        UseInventoryItem(self.Identifier)
        self.LastUseTime = GetTime()
    end
end
function Item:TimeSinceUse()
    return self.LastUseTime ~= 0 and GetTime() - self.LastUseTime or 3
end
Equipment = {}
EventFrame:RegisterForEvent(
function()
    ArtifactScan()
end,
"ZONE_CHANGED_NEW_AREA",
"PLAYER_TALENT_UPDATE",
"PLAYER_EQUIPMENT_CHANGED",
"LOADING_SCREEN_DISABLED"
)
ArtifactUI = C_ArtifactUI
Powers, PowerTableByPowerID, PowerTableBySpellID = {}, {}, {}
function ArtifactScan()
    if HasArtifactEquipped() and not (ArtifactFrame and ArtifactFrame:IsShown()) then
        UIParent:UnregisterEvent("ARTIFACT_UPDATE")
        SocketInventoryItem(INVSLOT_MAINHAND)
        Powers = ArtifactUI.GetPowers()
        if Powers then
            WipeTable(PowerTableByPowerID)
            WipeTable(PowerTableBySpellID)
            local PowerInfo
            for Index, Power in pairs(Powers) do
                PowerInfo = ArtifactUI.GetPowerInfo(Power)
                PowerTableByPowerID[Power] = PowerInfo
                PowerTableBySpellID[PowerInfo.spellID] = PowerInfo
            end
        end
        ArtifactUI.Clear()
        UIParent:RegisterEvent("ARTIFACT_UPDATE")
    end
    local ThisItem
    for i = 1, 19 do
        ThisItem = select(1, GetInventoryItemID("玩家", i))
        if ThisItem ~= nil then
            Equipment[i] = ThisItem
        end
    end
    HasT19_2Pc, HasT19_4Pc = Player:HasTier("T19")
    HasT20_2Pc, HasT20_4Pc = Player:HasTier("T20")
end
function Spell:ArtifactRank()
    return PowerTableBySpellID[self.Identifier] and PowerTableBySpellID[self.Identifier].currentRank or 0
end
function Spell:ArtifactRankPowerID()
    return PowerTableByPowerID[self.Identifier] and PowerTableByPowerID[self.Identifier].currentRank or 0
end
function Spell:ArtifactEnabled()
    return self:ArtifactRank() > 0
end
function Spell:ArtifactEnabledPowerID()
    return self:ArtifactRankPowerID() > 0
end
HasTierSlots = { 1, 3, 5, 7, 10, 15 }
HasTierSets = {
    ["T19"] = {
        [1] = {[5] = 138351, [10] = 138354, [1] = 138357, [7] = 138360, [3] = 138363, [15] = 138374 },
        [2] = {[5] = 138350, [10] = 138353, [1] = 138356, [7] = 138359, [3] = 138362, [15] = 138369 },
        [3] = {[5] = 138339, [10] = 138340, [1] = 138342, [7] = 138344, [3] = 138347, [15] = 138368 },
        [4] = {[5] = 138326, [10] = 138329, [1] = 138332, [7] = 138335, [3] = 138338, [15] = 138371 },
        [5] = {[5] = 138319, [10] = 138310, [1] = 138313, [7] = 138316, [3] = 138322, [15] = 138370 },
        [6] = {[5] = 138349, [10] = 138352, [1] = 138355, [7] = 138358, [3] = 138361, [15] = 138364 },
        [7] = {[5] = 138346, [10] = 138341, [1] = 138343, [7] = 138345, [3] = 138348, [15] = 138372 },
        [8] = {[5] = 138318, [10] = 138309, [1] = 138312, [7] = 138315, [3] = 138321, [15] = 138365 },
        [9] = {[5] = 138320, [10] = 138311, [1] = 138314, [7] = 138317, [3] = 138323, [15] = 138373 },
        [10] = {[5] = 138325, [10] = 138328, [1] = 138331, [7] = 138334, [3] = 138337, [15] = 138367 },
        [11] = {[5] = 138324, [10] = 138327, [1] = 138330, [7] = 138333, [3] = 138336, [15] = 138366 },
        [12] = {[5] = 138376, [10] = 138377, [1] = 138378, [7] = 138379, [3] = 138380, [15] = 138375 }
    },
    ["T20"] = {
        [1] = {[5] = 147187, [15] = 147188, [10] = 147189, [1] = 147190, [7] = 147191, [3] = 147192 },
        [2] = {[5] = 147157, [15] = 147158, [10] = 147159, [1] = 147160, [7] = 147161, [3] = 147162 },
        [3] = {[5] = 147139, [15] = 147140, [10] = 147141, [1] = 147142, [7] = 147143, [3] = 147144 },
        [4] = {[5] = 147169, [15] = 147170, [10] = 147171, [1] = 147172, [7] = 147173, [3] = 147174 },
        [5] = {[5] = 147167, [15] = 147163, [10] = 147164, [1] = 147165, [7] = 147166, [3] = 147168 },
        [6] = {[5] = 147121, [15] = 147122, [10] = 147123, [1] = 147124, [7] = 147125, [3] = 147126 },
        [7] = {[5] = 147175, [15] = 147176, [10] = 147177, [1] = 147178, [7] = 147179, [3] = 147180 },
        [8] = {[5] = 147149, [15] = 147145, [10] = 147146, [1] = 147147, [7] = 147148, [3] = 147150 },
        [9] = {[5] = 147185, [15] = 147181, [10] = 147182, [1] = 147183, [7] = 147184, [3] = 147186 },
        [10] = {[5] = 147151, [15] = 147152, [10] = 147153, [1] = 147154, [7] = 147155, [3] = 147156 },
        [11] = {[5] = 147133, [15] = 147134, [10] = 147135, [1] = 147136, [7] = 147137, [3] = 147138 },
        [12] = {[5] = 147127, [15] = 147128, [10] = 147129, [1] = 147130, [7] = 147131, [3] = 147132 }
    }
}
function Player:HasTier(Tier)
    local Count = 0
    local Item, Slot
    for i = 1, #HasTierSlots do
        Slot = HasTierSlots[i]
        Item = Equipment[Slot]
        if Item and Item == HasTierSets[Tier][C.CLASSINDEX][Slot] then
            Count = Count + 1
        end
    end
    return Count > 1, Count > 3
end
function BMPullTime()
    if not BossModTime or BossModTime == 0 or BossModEndTime - GetTime() < 0 then
        return 60
    else
        return BossModEndTime - GetTime()
    end
end
local PVPEnabled = false
function AddCommonOptions()
    local IsMeleeHybrid = currentSpecName == "Windwalker" or currentSpecName == "Feral" and true or false
    local IsMeleeNonHybrid =     currentSpecName == "Subtlety" or currentSpecName == "Outlaw" or currentSpecName == "Assassination" or
    currentSpecName == "浩劫" or
    currentSpecName == "Vengeance" and true or
    false
    AddPage("Raid")
    AddSection("Raid", { "目标选定", "打靶" }, "Yellow")
    AddNewOption(
    "Raid",
    { "目标优先级", "目标优先" },
    230,
    true,
    {
        1,
        { "|cffD9D9DB骷髅", "|cffD9D9DB头骨" },
        { "|cffCC3122十字", "|cffCC3122交叉" },
        { "|cff019EE0方块", "|cff019EE0广场" },
        { "|cffB2D1DF月亮", "|cffB2D1DF月亮" },
        { "|cff0AE201三角", "|cff0AE201三角形" },
        { "|cffB731C8菱形", "|cffB731C8钻石" },
        { "|cffD87E01圆形", "|cffD87E01圈" },
        { "|cffFFEA00星形", "|cffFFEA00星" }
    },
    nil,
    {
        'Check this to always priorise the target with the selected symbol when retargetting. If no target with this symbol can be found, the mode selected for the 1st option of "Target | Attack" will be used.',
        "选中此项可以在重新定位时始终使用所选符号对目标进行优先级排序。 如果没有找到具有该符号的目标，则将使用为“目标|攻击”第一选项选择的模式。"
    }
    )
    AddSection("Raid", { "自定义团本行为", "自定义袭击行为" }, "Yellow")
    AddNewOption(
    "Raid",
    { "无视伊格诺斯之眼", "黑名单 Eye of Il'gynoth" },
    210,
    true,
    nil,
    nil,
    { "Check this to avoid hitting Eye of Il'gynoth in Emerald Nightmare.", "检查这个以避免击中 Eye of Il'gynoth 在翡翠梦魇。" }
    )
    AddNewOption(
    "Raid",
    { "【速度:慢】效果下禁用大技能", "没有冷却时间：慢" },
    210,
    false,
    nil,
    nil,
    {
        "Enable this option to avoid using Cooldowns when you are affected by Speed Slow in the Chromatic Anomaly encounter." ..
        C.TOOLTIP_HINT(
        "Will not work if the cooldown state is set to Always. It needs to be set to Cooldowns Only."
        ),
        "启用此选项以避免在“色差异常”遭遇速度慢影响时使用冷却时间。" .. C.TOOLTIP_HINT("如果冷却状态设置为始终，将不起作用。 它需要设置为冷却时间。")
    }
    )
    AddNewOption(
    "Raid",
    { "无视骨牢护甲", "黑名单Bonecage Armor" },
    210,
    true,
    nil,
    nil,
    {
        "Check this to avoid hitting Enemies at Desolate Host with Bonecage Armor.",
        "检查这个，以避免在带有Bonecage Armor的Desolate Host上击敌。"
    }
    )
    AddNewOption(
    "Raid",
    { "无视恶魔审判庭", "黑名单恶魔宗教裁判" },
    210,
    true,
    nil,
    nil,
    {
        "Check this to blacklist Belac/Atrigan when they are using their channel cast. Will still cast on them if you target them manually.",
        "检查这个黑名单Belac / Atrigan当他们使用他们的频道演员。 如果您手动定位他们，仍然会对它们施加压力。"
    }
    )
    AddNewOption(
    "Raid",
    { "在昏暗隐匿中停止输出(主母绿水)", "停在Murk" },
    210,
    false,
    nil,
    nil,
    { "Stop attacking while standing in murk when fighting Mistress Sassz'ine.", "在与Mistress Sassz'ine进行战斗时，不要再打扰，" }
    )
    AddNewOption(
    "Raid",
    { "自动将邪能炸药设为目标", "自动目标邪恶炸药" },
    210,
    true,
    nil,
    nil,
    { "Check this to automatically target the Fel Explosives.", "检查这个，以自动瞄准邪魔爆炸物。" }
    )
    AddPage("高级设置")
    AddNewOption(
    "高级设置",
    { "自动切换配置", "配置文件切换器" },
    230,
    false,
    { 1, { "常规", "一般" }, { "按图切换", "具体" } },
    nil,
    {
        "Automatically change profile based on the current location or encounter." ..
        C.TOOLTIP_VALUE .. "Use general raiding profile or specific profiles per boss in raid.",
        "根据当前位置或遭遇自动更改配置文件。" .. C.TOOLTIP_VALUE .. "使用一般的袭击概况或特定的配置文件，每个老板进行突袭。"
    }
    )
    MacroOption = GetOptionValue("宏命令_Value1") ~= nil and GetOptionValue("宏命令_Value1") or ""
    AddNewOption(
    "高级设置",
    { "宏命令", "宏" },
    140,
    true,
    MacroOption,
    nil,
    {
        "Set the macro command you want to use." ..
        C.TOOLTIP_HINT('In example, enter "shark" to use /shark as your macro command.'),
        "设置要使用的宏命令。" .. C.TOOLTIP_HINT('例如，输入 "shark" 使用 /shark 作为您的宏命令。')
    }
    )
    AddSection("高级设置", { "安全", "安全" }, "Yellow")
    AddOption("高级设置", { "聊天栏信息", "聊天通知" }, true, { "Display notifications in the chat.", "在聊天中显示通知。" })
    AddOption("高级设置", { "聊天栏上层信息", "聊天叠加" }, true, { "Display notifications over the chat.", "通过聊天显示通知。" })
    AddOption("高级设置", { "忽略敌对玩家", "忽略敌人" }, false, { "Will not engage in PVP.", "不会参与玩家与玩家。" })
    AddOption(
    "高级设置",
    { "AFK时暂停循环", "从键盘中暂停" },
    true,
    { "Will not execute the rotation while you are afk.", "远离键盘时不会执行旋转。" }
    )
    AddOption(
    "高级设置",
    { "聊天时暂停循环", "在聊天中暂停" },
    false,
    { "This will pause the rotation while your chat box is open.", "这将在您的聊天框打开时暂停旋转。" }
    )
    AddNewOption(
    "高级设置",
    "开关状态切换按键",
    230,
    false,
    { 1, "LSHIFT", "RSHIFT", "LCTRL", "RCTRL", "LALT", "RALT" },
    nil,
    "Will toggle the rotation status when modifer key is pressed and released."
    )
    AddSection("高级设置", { "高级设置", "高级" }, "Yellow")
    AddNewOption(
    "高级设置",
    "自动进副本",
    220,
    false,
    { 3, 3, 10, 1 },
    nil,
    "Accept Proposal automatically." .. C.TOOLTIP_VALUE_1 .. "Minimum time to wait in seconds before accepting."
    )
    AddNewOption(
    "Hidden",
    "Check Group Threat",
    210,
    false,
    nil,
    nil,
    "Checks if enemies are on Player or Groups threat table to be considered in combat."
    )
    AddNewOption(
    "高级设置",
    { "强制学习天赋", "力学习人才" },
    210,
    false,
    nil,
    nil,
    {
        "Enable this option to allow changing talents without using a Tome.\n\n|cffEE0000WARNING: This feature exploits a bug in the WoW API and using it might be risky.",
        "启用此选项以允许更改天赋而不使用清心书卷。\n\n|cffEE0000警告：此功能利用了WoW API中的一个错误，并且使用它可能有风险。"
    }
    )
    AddNewOption(
    "高级设置",
    { "视线判断", "视线" },
    130,
    true,
    { 2, { "禁用", "残" }, { "启用", "启用" } },
    nil,
    {
        C.TOOLTIP_VALUE ..
        "Disabled Line of Sight checks. This check should always be Enabled. If it do not work, fall back to Disabled.",
        C.TOOLTIP_VALUE .. "禁用视线检查线。 此检查应始终为启用。 如果不行，请回到残疾人士。"
    }
    )
    AddNewOption(
    "高级设置",
    "主动寻怪攻击",
    230,
    false,
    { 2, "无条件使用", "Boss" },
    nil,
    "Force enemies to be considered in combat. Should only be activated if needed." ..
    C.TOOLTIP_VALUE_1 ..
    C.TOOLTIP_SUBVALUE("无条件使用", true) ..
    "Always consider enemies in combat." ..
    C.TOOLTIP_SUBVALUE("Boss") .. "Only consider enemies in combat while fighting a boss encounter."
    )
    AddNewOption(
    "高级设置",
    { "延迟容限", "延迟宽容" },
    232,
    (IsMeleeHybrid or IsMeleeNonHybrid) and true or false,
    { 1, { "Cast Only", "只有演员" }, { "Cast & Core", "铸造与核心" } },
    { 5, 0, 50, 1 },
    {
        "Enabled to use the Latency Tolerance." ..
        C.TOOLTIP_VALUE_1 ..
        C.TOOLTIP_SUBVALUE("Cast Only", true) ..
        "Cast abilities before the CD come back to queue them on server and then cast quickly." ..
        C.TOOLTIP_SUBVALUE("Cast + Core") ..
        "Same as Cast Only + Will update Core infos at your latency rate. Recommended if your world latency is lower than 50 ms." ..
        C.TOOLTIP_VALUE_2 ..
        "Set your latency jitter." ..
        C.TOOLTIP_HINT(
        "Works best with WoW built-in Latency Tolerance option enabled and set way higher than your world latency."
        ),
        "启用使用延迟容限。" ..
        C.TOOLTIP_VALUE_1 ..
        C.TOOLTIP_SUBVALUE("只有演员", true) ..
        "在冷却时间之前施放的能力回来，在服务器上排队，然后快速施法。" ..
        C.TOOLTIP_SUBVALUE("铸造+核心") ..
        "相同于只转载+将更新您的延迟率的核心信息。 如果您的世界延迟低于50 ms，建议使用。" ..
        C.TOOLTIP_VALUE_2 .. "设置延迟抖动。" .. C.TOOLTIP_HINT("最好使用WoW内置拼写队列选项，并将其设置为高于您的世界延迟。")
    }
    )
    AddNewOption(
    "高级设置",
    { "暂停自动技能", "脉冲控制" },
    230,
    true,
    { 4, { "Chat", "聊" }, { "Overlay", "覆盖" }, { "Both", "都" }, { "None", "没有" } },
    nil,
    {
        "Enable Pulse Control to allow the manager to stop pulsing for a short delay after specific events including dying, zoning, taking flight path, flying with mount, using vehicles, looting and gathering." ..
        C.TOOLTIP_VALUE ..
        C.TOOLTIP_SUBVALUE("Chat", true) ..
        "Will display a notification in your chat." ..
        C.TOOLTIP_SUBVALUE("Overlay") ..
        "Will display a notification in your overlay." ..
        C.TOOLTIP_SUBVALUE("Both") ..
        "Will display a notification in both your chat and overlay." ..
        C.TOOLTIP_SUBVALUE("None") ..
        "Will not display any notification about the Pulse State.",
        "启用脉冲控制允许管理员在特定事件（包括垂死，分区，飞行路径，搭载飞行，使用车辆，抢劫和收集）之后，短暂延迟停止脉冲。" ..
        C.TOOLTIP_VALUE ..
        C.TOOLTIP_SUBVALUE("聊", true) ..
        "将在您的聊天中显示通知。" ..
        C.TOOLTIP_SUBVALUE("覆盖") ..
        "将在您的叠加层中显示通知。" ..
        C.TOOLTIP_SUBVALUE("都") ..
        "将在聊天和重叠式广告中显示通知。" .. C.TOOLTIP_SUBVALUE("没有") .. "不会显示关于脉冲状态的任何通知。"
    }
    )
    AddNewOption(
    "高级设置",
    { "忽略BOSS的死亡倒计时直到HP", "忽略死亡老板的时间，直到％" },
    220,
    false,
    { 20, 0, 40, 1 },
    nil,
    {
        "Enable to ignore the result of TTD if the unit is a boss until a given % HP." ..
        C.TOOLTIP_VALUE ..
        "Set the given % HP." ..
        C.TOOLTIP_HINT(
        "Useful if you're in a raid with a Big Burst Comp to avoid letting fall off DoTs due to wrong TTD."
        ),
        "如果单位是老板，直到给定的％健康状态，才能忽略时间的结果。" ..
        C.TOOLTIP_VALUE .. "设置给定的％健康状况。" .. C.TOOLTIP_HINT("如果您是在大爆炸组合中进行突袭，避免由于错误的时间而死亡，因此随着时间的流逝而遭受损失。")
    }
    )
    AddSection("高级设置", { "语言", "语言" }, "Yellow")
    AddNewOption(
    "高级设置",
    { "中文", "English" },
    210,
    false,
    nil,
    nil,
    "Check this to translate the user interface to Chinese. Uncheck to translate the user interface to English." ..
    C.TOOLTIP_HINT("The chinese font need to be added to your World of Warcraft/Fonts folder.")
    )
    if PetBattlesAuthorized then
        PetBattles.UI()
    end
    RotationInitialized = true
end
function AddPresetOption(Name, SecondOptions, ThirdOptions, FourthOptions, FifthOptions, SixthOptions)
    if Name == "常规" then
        AddNewOption(
        "Hidden",
        "Cooldowns On Bosses",
        210,
        false,
        nil,
        nil,
        "Enable to save Cooldowns for Bosses." ..
        C.TOOLTIP_HINT("You can always Right Click the CDs option of the Toolbox to enable this option.")
        )
        AddSection("常规", { "目标选定", "目标处理" }, "Yellow")
        if SecondOptions == "Caster" then
            AddNewOption(
            "常规",
            { "目标 | 攻击", "目标 | 攻击" },
            133,
            true,
            { 4, { "禁用", "残" }, { "距离最近", "最近的" }, { "血量最少", "最不健康" }, { "血量最多", "最健康" }, { "目标附近", "目标最近" } },
            { 1, { "禁用", "残" }, { "仅战斗状态时", "仅作战" }, { "启用", "启用" } },
            {
                C.TOOLTIP_VALUE_1 ..
                "Target - Choose which mode to use to choose a new target when needed." ..
                C.TOOLTIP_SUBVALUE("距离最近") ..
                "Closest enemy." ..
                C.TOOLTIP_SUBVALUE("血量最少") ..
                "Least health remaining." ..
                C.TOOLTIP_SUBVALUE("血量最多") ..
                "Most health remaining." ..
                C.TOOLTIP_SUBVALUE("目标附近") ..
                "Closest to our previous target." ..
                C.TOOLTIP_VALUE_2 ..
                "Attack - Should we use /startattack when changing target. Enable to use /startattack when changing target. (Melee classes should keep Attack Enabled.)",
                C.TOOLTIP_VALUE_1 ..
                "目标 - 选择魁方法用来选择一个新的目标在需要的时候。" ..
                C.TOOLTIP_SUBVALUE("最近的") ..
                "最近的敌人。" ..
                C.TOOLTIP_SUBVALUE("至少希思") ..
                "最健康的剩余。" ..
                C.TOOLTIP_SUBVALUE("最健康") ..
                "最健康的剩余。" ..
                C.TOOLTIP_SUBVALUE("最近的目标") ..
                "最接近我们先前的目标。" ..
                C.TOOLTIP_VALUE_2 ..
                "攻击 - 我们应该使用 /startattack 当改变目标。启用，可以使用 /startattack 当改变目标。（近战类不宜继续攻击启用。）"
            }
            )
            AddNewOption(
            "常规",
            { "动态切换目标", "动态定位" },
            232,
            true,
            { 1, { "保持", "保持" }, { "变化", "更改" } },
            { 40, 5, 40, 1 },
            {
                "Attack units that are closer around the player when the actual target is out of range." ..
                C.TOOLTIP_VALUE_1 ..
                "Choose preferred Dynamic Mode." ..
                C.TOOLTIP_SUBVALUE("保持") ..
                "Never change target but attack units around the player." ..
                C.TOOLTIP_SUBVALUE("变化") ..
                "Change target to units around the player." ..
                C.TOOLTIP_VALUE_2 ..
                "Use Dynamic Targetting when our range to the target is farter than this value.",
                "当实际目标超出范围时，攻击单位靠近玩家。" ..
                C.TOOLTIP_VALUE_1 ..
                "选择首选动态模式。" ..
                C.TOOLTIP_SUBVALUE("保持") ..
                "不要改变目标，而是围绕玩家攻击单位。" ..
                C.TOOLTIP_SUBVALUE("更改") ..
                "将目标更改为玩家周围的单位。" .. C.TOOLTIP_VALUE_2 .. "当我们到目标的范围比此值更远时，使用动态定位。"
            }
            )
        elseif SecondOptions == "Hunter" then
            AddNewOption(
            "常规",
            { "目标 | 攻击", "目标 | 攻击" },
            133,
            true,
            { 4, { "禁用", "残" }, { "距离最近", "最近的" }, { "血量最少", "最不健康" }, { "血量最多", "最健康" }, { "目标附近", "目标最近" } },
            { 2, { "禁用", "残" }, { "仅战斗状态时", "仅作战" }, { "启用", "启用" } },
            {
                C.TOOLTIP_VALUE_1 ..
                "Target - Choose which mode to use to choose a new target when needed." ..
                C.TOOLTIP_SUBVALUE("距离最近") ..
                "Closest enemy." ..
                C.TOOLTIP_SUBVALUE("血量最少") ..
                "Least health remaining." ..
                C.TOOLTIP_SUBVALUE("血量最多") ..
                "Most health remaining." ..
                C.TOOLTIP_SUBVALUE("目标附近") ..
                "Closest to our previous target." ..
                C.TOOLTIP_VALUE_2 ..
                "Attack - Should we use /startattack when changing target. Enable to use /startattack when changing target. (Melee classes should keep Attack Enabled.)",
                C.TOOLTIP_VALUE_1 ..
                "目标 - 选择魁方法用来选择一个新的目标在需要的时候。" ..
                C.TOOLTIP_SUBVALUE("最近的") ..
                "最近的敌人。" ..
                C.TOOLTIP_SUBVALUE("至少希思") ..
                "最健康的剩余。" ..
                C.TOOLTIP_SUBVALUE("最健康") ..
                "最健康的剩余。" ..
                C.TOOLTIP_SUBVALUE("最近的目标") ..
                "最接近我们先前的目标。" ..
                C.TOOLTIP_VALUE_2 ..
                "攻击 - 我们应该使用 /startattack 当改变目标。启用，可以使用 /startattack 当改变目标。（近战类不宜继续攻击启用。）"
            }
            )
            AddNewOption(
            "常规",
            { "动态切换目标", "动态定位" },
            232,
            true,
            { 1, { "保持", "保持" }, { "变化", "更改" } },
            { 40, 5, 40, 1 },
            {
                "Attack units that are closer around the player when the actual target is out of range." ..
                C.TOOLTIP_VALUE_1 ..
                "Choose preferred Dynamic Mode." ..
                C.TOOLTIP_SUBVALUE("保持") ..
                "Never change target but attack units around the player." ..
                C.TOOLTIP_SUBVALUE("变化") ..
                "Change target to units around the player." ..
                C.TOOLTIP_VALUE_2 ..
                "Use Dynamic Targetting when our range to the target is farter than this value.",
                "当实际目标超出范围时，攻击单位靠近玩家。" ..
                C.TOOLTIP_VALUE_1 ..
                "选择首选动态模式。" ..
                C.TOOLTIP_SUBVALUE("保持") ..
                "不要改变目标，而是围绕玩家攻击单位。" ..
                C.TOOLTIP_SUBVALUE("更改") ..
                "将目标更改为玩家周围的单位。" .. C.TOOLTIP_VALUE_2 .. "当我们到目标的范围比此值更远时，使用动态定位。"
            }
            )
        else
            AddNewOption(
            "常规",
            { "目标 | 攻击", "目标 | 攻击" },
            133,
            true,
            { 4, { "禁用", "残" }, { "距离最近", "最近的" }, { "血量最少", "最不健康" }, { "血量最多", "最健康" }, { "目标附近", "目标最近" } },
            { 3, { "禁用", "残" }, { "仅战斗状态时", "仅作战" }, { "启用", "启用" } },
            {
                C.TOOLTIP_VALUE_1 ..
                "Target - Choose which mode to use to choose a new target when needed." ..
                C.TOOLTIP_SUBVALUE("距离最近") ..
                "Closest enemy." ..
                C.TOOLTIP_SUBVALUE("血量最少") ..
                "Least health remaining." ..
                C.TOOLTIP_SUBVALUE("血量最多") ..
                "Most health remaining." ..
                C.TOOLTIP_SUBVALUE("目标附近") ..
                "Closest to our previous target." ..
                C.TOOLTIP_VALUE_2 ..
                "Attack - Should we use /startattack when changing target. Enable to use /startattack when changing target. (Melee classes should keep Attack Enabled.)",
                C.TOOLTIP_VALUE_1 ..
                "目标 - 选择魁方法用来选择一个新的目标在需要的时候。" ..
                C.TOOLTIP_SUBVALUE("最近的") ..
                "最近的敌人。" ..
                C.TOOLTIP_SUBVALUE("至少希思") ..
                "最健康的剩余。" ..
                C.TOOLTIP_SUBVALUE("最健康") ..
                "最健康的剩余。" ..
                C.TOOLTIP_SUBVALUE("最近的目标") ..
                "最接近我们先前的目标。" ..
                C.TOOLTIP_VALUE_2 ..
                "攻击 - 我们应该使用 /startattack 当改变目标。启用，可以使用 /startattack 当改变目标。（近战类不宜继续攻击启用。）"
            }
            )
            AddNewOption(
            "常规",
            { "动态切换目标", "动态定位" },
            232,
            true,
            { 1, { "保持", "保持" }, { "变化", "更改" } },
            { 5, 5, 40, 1 },
            {
                "Attack units that are closer around the player when the actual target is out of range." ..
                C.TOOLTIP_VALUE_1 ..
                "Choose preferred Dynamic Mode." ..
                C.TOOLTIP_SUBVALUE("保持") ..
                "Never change target but attack units around the player." ..
                C.TOOLTIP_SUBVALUE("变化") ..
                "Change target to units around the player." ..
                C.TOOLTIP_VALUE_2 ..
                "Use Dynamic Targetting when our range to the target is farter than this value.",
                "当实际目标超出范围时，攻击单位靠近玩家。" ..
                C.TOOLTIP_VALUE_1 ..
                "选择首选动态模式。" ..
                C.TOOLTIP_SUBVALUE("保持") ..
                "不要改变目标，而是围绕玩家攻击单位。" ..
                C.TOOLTIP_SUBVALUE("更改") ..
                "将目标更改为玩家周围的单位。" .. C.TOOLTIP_VALUE_2 .. "当我们到目标的范围比此值更远时，使用动态定位。"
            }
            )
        end
        AddSection("常规", { "作战与药水", "吸引力和魔药" }, "Yellow")
        local OptionSet, ThirdOptionsTooltip = 210, { "Engage combat when in range of an enemy.", "在敌人的范围内进行作战。" }
        if ThirdOptions then
            OptionSet, ThirdOptionsTooltip =             230,
            {
                C.TOOLTIP_VALUE .. "Choose the spell you want to use to start the rotation.",
                C.TOOLTIP_VALUE .. "选择要用于开始旋转的拼写。"
            }
        end
        AddNewOption("常规", { "自动进入战斗", "自动战斗搞" }, OptionSet, false, ThirdOptions, nil, ThirdOptionsTooltip)
        if FourthOptions then
            AddNewOption(
            "常规",
            { "开怪技能", "开瓶器" },
            230,
            true,
            { 2, { "无条件使用", "总是" }, { "打BOSS使用", "老板只" }, { "大技能用法", "冷却时间" } },
            nil,
            { "Use the opener in the first 10 seconds when we engage.", "在我们参与的前10秒钟内使用开瓶器。" }
            )
        end
        AddNewOption(
        "常规",
        { "抢先使用药水", "前锅老板模" },
        232,
        true,
        { 1, { "打BOSS使用", "老板只" }, { "无条件使用", "总是" }, { "不使用", "决不" } },
        { 1.2, 0, 3, 0.1 },
        {
            "Use a Potion when the BossMod timer will be lower than the second value." ..
            C.TOOLTIP_VALUE_1 ..
            "When should we use a potion in the opener." ..
            C.TOOLTIP_SUBVALUE("无条件使用") ..
            "Always use a potion." ..
            C.TOOLTIP_SUBVALUE("打BOSS使用") ..
            "Only use a potion if the Target is a Boss." ..
            C.TOOLTIP_SUBVALUE("不使用") ..
            "Never use potions in the opener." ..
            C.TOOLTIP_VALUE_2 ..
            "Time in seconds on the DBM countdown at which we would like to take our potion." ..
            C.TOOLTIP_HINT(
            "Pre-Pull should always be lower than Pre-Pot. The type of potion used will be the one selected in the Use Potions option."
            ),
            "当老板拉计时器将低于第二个值时使用药水。" ..
            C.TOOLTIP_VALUE_1 ..
            "我们什么时候应该在开瓶器中使用药水。" ..
            C.TOOLTIP_SUBVALUE("总是") ..
            "总是用药水。" ..
            C.TOOLTIP_SUBVALUE("老板只") ..
            "如果目标是老板，只能使用魔药。" ..
            C.TOOLTIP_SUBVALUE("决不") ..
            "不要在开瓶器中使用药水。" ..
            C.TOOLTIP_VALUE_2 ..
            "老板拉秒倒计时的时间在我们想要服用我们的药水。" ..
            C.TOOLTIP_HINT("预拉力应始终低于“预浸”。 使用的药水类型将是“使用药水”选项中选择的药水。")
        }
        )
        AddNewOption(
        "常规",
        { "抢先施放(需DBM插件)", "预拉式模具" },
        232,
        true,
        { 1, { "打BOSS使用", "老板只" }, { "无条件使用", "总是" }, { "不使用", "决不" } },
        { 0.2, 0, 3, 0.1 },
        {
            "Use a spell when the BossMod timer will be lower than the second value." ..
            C.TOOLTIP_VALUE_1 ..
            "When should we use a spell in the opener." ..
            C.TOOLTIP_SUBVALUE("无条件使用") ..
            "Always use a spell." ..
            C.TOOLTIP_SUBVALUE("打BOSS使用") ..
            "Only use a spell if the Target is a Boss." ..
            C.TOOLTIP_SUBVALUE("不使用") ..
            "Never use a spell in the opener." ..
            C.TOOLTIP_VALUE_2 ..
            "Time in seconds on the DBM countdown at which we would like our spell to land." ..
            C.TOOLTIP_HINT(
            "Pre-Pull should always be lower than Pre-Pot."
            ),
            "当老板拉计时器将低于第二个值时使用法术。" ..
            C.TOOLTIP_VALUE_1 ..
            "我们什么时候在开瓶器中使用咒语。" ..
            C.TOOLTIP_SUBVALUE("总是") ..
            "始终使用法术。" ..
            C.TOOLTIP_SUBVALUE("老板只") ..
            "如果目标是老板，只能使用咒语。" ..
            C.TOOLTIP_SUBVALUE("决不") ..
            "不要在开瓶器中使用咒语。" ..
            C.TOOLTIP_VALUE_2 ..
            "在我们希望我们的法术降落的DBM倒计时的秒数内。" .. C.TOOLTIP_HINT("预拉应始终低于预浸。")
        }
        )
        AddFlasksOptions()
        AddPotionsOption()
        AddSection("常规", { "打断施法", "中断" }, "Yellow")
        AddNewOption(
        "常规",
        { "打断施法进度介于%", "中间％" },
        221,
        true,
        { C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP },
        { C.INTERRUPT_DEFAULT2 },
        {
            "Use interrupt spells when the unit's casted percentage is above a random value between value 1 and value 2." ..
            C.TOOLTIP_VALUE_1 .. "Minimum random value." .. C.TOOLTIP_VALUE_2 .. "Maximum random value.",
            "当单位的投入百分比高于值1和值2之间的随机值时，请使用中断法术。" .. C.TOOLTIP_VALUE_1 .. "最小随机值。" .. C.TOOLTIP_VALUE_2 .. "最大随机值。"
        }
        )
        if ArcaneTorrent and ArcaneTorrent:Exists() then
            AddNewOption(
            "常规",
            { "Arcane Torrent Interrupt", "奥术洪流中断" },
            210,
            false,
            nil,
            nil,
            { "Enable to also use Arcane Torrent to interrupt.", "启用也可以使用奥术洪流中断。" }
            )
        end
        AddNewOption(
        "常规",
        { "打断任意目标施法", "中断任何单位" },
        210,
        false,
        nil,
        nil,
        {
            "Enable to interrupt any units in range." ..
            C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."),
            "允许中断任何单位的范围。" .. C.TOOLTIP_HINT("只有在中间％启用。")
        }
        )
        AddNewOption(
        "常规",
        { "自定义打断技能列表", "自定义中断列表" },
        210,
        false,
        nil,
        nil,
        { "Enable to interrupt only spells in the Custom Interrupt List.", "启用仅中断自定义中断列表中的法术。" }
        )
    elseif Name == "GeneralRogue" then
        AddNewOption(
        "Hidden",
        "Cooldowns On Bosses",
        210,
        false,
        nil,
        nil,
        "Enable to save Cooldowns for Bosses." ..
        C.TOOLTIP_HINT("You can always Right Click the CDs option of the Toolbox to enable this option.")
        )
        AddSection("常规", { "目标选定", "目标处理" }, "Yellow")
        AddNewOption(
        "常规",
        { "目标 | 攻击", "目标 | 攻击" },
        133,
        true,
        { 4, { "禁用", "残" }, { "距离最近", "最近的" }, { "血量最少", "最不健康" }, { "血量最多", "最健康" }, { "目标附近", "目标最近" } },
        { 3, { "禁用", "残" }, { "仅战斗状态时", "仅作战" }, { "启用", "启用" } },
        {
            C.TOOLTIP_VALUE_1 ..
            "Target - Choose which mode to use to choose a new target when needed." ..
            C.TOOLTIP_SUBVALUE("距离最近") ..
            "Closest enemy." ..
            C.TOOLTIP_SUBVALUE("血量最少") ..
            "Least health remaining." ..
            C.TOOLTIP_SUBVALUE("血量最多") ..
            "Most health remaining." ..
            C.TOOLTIP_SUBVALUE("目标附近") ..
            "Closest to our previous target." ..
            C.TOOLTIP_VALUE_2 ..
            "Attack - Should we use /startattack when changing target. Enable to use /startattack when changing target. (Melee classes should keep Attack Enabled.)",
            C.TOOLTIP_VALUE_1 ..
            "目标 - 选择魁方法用来选择一个新的目标在需要的时候。" ..
            C.TOOLTIP_SUBVALUE("最近的") ..
            "最近的敌人。" ..
            C.TOOLTIP_SUBVALUE("至少希思") ..
            "最健康的剩余。" ..
            C.TOOLTIP_SUBVALUE("最健康") ..
            "最健康的剩余。" ..
            C.TOOLTIP_SUBVALUE("最近的目标") ..
            "最接近我们先前的目标。" ..
            C.TOOLTIP_VALUE_2 ..
            "攻击 - 我们应该使用 /startattack 当改变目标。启用，可以使用 /startattack 当改变目标。（近战类不宜继续攻击启用。）"
        }
        )
        AddNewOption(
        "常规",
        { "动态切换目标", "动态定位" },
        232,
        true,
        { 1, { "保持", "保持" }, { "变化", "更改" } },
        { 5, 5, 40, 1 },
        {
            "Attack units that are closer around the player when the actual target is out of range." ..
            C.TOOLTIP_VALUE_1 ..
            "Choose preferred Dynamic Mode." ..
            C.TOOLTIP_SUBVALUE("保持") ..
            "Never change target but attack units around the player." ..
            C.TOOLTIP_SUBVALUE("变化") ..
            "Change target to units around the player." ..
            C.TOOLTIP_VALUE_2 ..
            "Use Dynamic Targetting when our range to the target is farter than this value.",
            "当实际目标超出范围时，攻击单位靠近玩家。" ..
            C.TOOLTIP_VALUE_1 ..
            "选择首选动态模式。" ..
            C.TOOLTIP_SUBVALUE("保持") ..
            "不要改变目标，而是围绕玩家攻击单位。" ..
            C.TOOLTIP_SUBVALUE("更改") ..
            "将目标更改为玩家周围的单位。" .. C.TOOLTIP_VALUE_2 .. "当我们到目标的范围比此值更远时，使用动态定位。"
        }
        )
        AddSection("常规", { "作战与药水", "吸引力和魔药" }, "Yellow")
        local OptionSet, ThirdOptionsTooltip = 210, { "Engage combat when in range of an enemy.", "在敌人的范围内进行作战。" }
        if ThirdOptions then
            OptionSet, ThirdOptionsTooltip =             230,
            {
                C.TOOLTIP_VALUE .. "Choose the spell you want to use to start the rotation.",
                C.TOOLTIP_VALUE .. "选择要用于开始旋转的拼写。"
            }
        end
        AddNewOption("常规", { "自动进入战斗", "自动战斗搞" }, OptionSet, false, ThirdOptions, nil, ThirdOptionsTooltip)
        if FourthOptions then
            AddNewOption(
            "常规",
            { "开怪技能", "开瓶器" },
            230,
            true,
            { 2, { "无条件使用", "总是" }, { "打BOSS使用", "老板只" }, { "大技能用法", "冷却时间" } },
            nil,
            { "Use the opener in the first 10 seconds when we engage.", "在我们参与的前10秒钟内使用开瓶器。" }
            )
        end
        AddNewOption(
        "常规",
        { "抢先使用药水", "前锅老板模" },
        232,
        true,
        { 1, { "打BOSS使用", "老板只" }, { "无条件使用", "总是" }, { "不使用", "决不" } },
        { 1.2, 0, 3, 0.1 },
        {
            "Use a Potion when the BossMod timer will be lower than the second value." ..
            C.TOOLTIP_VALUE_1 ..
            "When should we use a potion in the opener." ..
            C.TOOLTIP_SUBVALUE("无条件使用") ..
            "Always use a potion." ..
            C.TOOLTIP_SUBVALUE("打BOSS使用") ..
            "Only use a potion if the Target is a Boss." ..
            C.TOOLTIP_SUBVALUE("不使用") ..
            "Never use potions in the opener." ..
            C.TOOLTIP_VALUE_2 ..
            "Time in seconds on the DBM countdown at which we would like to take our potion." ..
            C.TOOLTIP_HINT(
            "Pre-Pull should always be lower than Pre-Pot. The type of potion used will be the one selected in the Use Potions option."
            ),
            "当老板拉计时器将低于第二个值时使用药水。" ..
            C.TOOLTIP_VALUE_1 ..
            "我们什么时候应该在开瓶器中使用药水。" ..
            C.TOOLTIP_SUBVALUE("总是") ..
            "总是用药水。" ..
            C.TOOLTIP_SUBVALUE("老板只") ..
            "如果目标是老板，只能使用魔药。" ..
            C.TOOLTIP_SUBVALUE("决不") ..
            "不要在开瓶器中使用药水。" ..
            C.TOOLTIP_VALUE_2 ..
            "老板拉秒倒计时的时间在我们想要服用我们的药水。" ..
            C.TOOLTIP_HINT("预拉力应始终低于“预浸”。 使用的药水类型将是“使用药水”选项中选择的药水。")
        }
        )
        AddFlasksOptions()
        AddPotionsOption()
        AddSection("常规", { "打断施法", "中断" }, "Yellow")
        AddNewOption(
        "常规",
        { "打断施法进度介于%", "中间％" },
        221,
        true,
        { C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP },
        { C.INTERRUPT_DEFAULT2 },
        {
            "Use interrupt spells when the unit's casted percentage is above a random value between value 1 and value 2." ..
            C.TOOLTIP_VALUE_1 .. "Minimum random value." .. C.TOOLTIP_VALUE_2 .. "Maximum random value.",
            "当单位的投入百分比高于值1和值2之间的随机值时，请使用中断法术。" .. C.TOOLTIP_VALUE_1 .. "最小随机值。" .. C.TOOLTIP_VALUE_2 .. "最大随机值。"
        }
        )
        if ArcaneTorrent and ArcaneTorrent:Exists() then
            AddNewOption(
            "常规",
            { "Arcane Torrent Interrupt", "奥术洪流中断" },
            210,
            false,
            nil,
            nil,
            { "Enable to also use Arcane Torrent to interrupt.", "启用也可以使用奥术洪流中断。" }
            )
        end
        AddNewOption(
        "常规",
        { "打断任意目标施法", "中断任何单位" },
        210,
        false,
        nil,
        nil,
        {
            "Enable to interrupt any units in range." ..
            C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."),
            "允许中断任何单位的范围。" .. C.TOOLTIP_HINT("只有在中间％启用。")
        }
        )
        AddNewOption(
        "常规",
        { "自定义打断技能列表", "自定义中断列表" },
        210,
        false,
        nil,
        nil,
        { "Enable to interrupt only spells in the Custom Interrupt List.", "启用仅中断自定义中断列表中的法术。" }
        )
    elseif Name == "GeneralHealer" then
        AddSection("常规", { "作战与药水", "引人入胜" }, "Yellow")
        local OptionSet, ThirdOptionsTooltip = 210, { "Engage combat when in range of an enemy.", "在敌人的范围内进行作战。" }
        if ThirdOptions then
            OptionSet, ThirdOptionsTooltip =             230,
            {
                C.TOOLTIP_VALUE .. "Choose the spell you want to use to start the rotation.",
                C.TOOLTIP_VALUE .. "选择要用于开始旋转的拼写。"
            }
        end
        AddNewOption("常规", { "自动进入战斗", "自动战斗搞" }, OptionSet, false, ThirdOptions, nil, ThirdOptionsTooltip)
        AddNewOption(
        "常规",
        { "抢先使用药水", "前锅老板模" },
        232,
        true,
        { 1, { "打BOSS使用", "老板只" }, { "无条件使用", "总是" }, { "不使用", "决不" } },
        { 1.2, 0, 3, 0.1 },
        {
            "Use a Potion when the BossMod timer will be lower than the second value." ..
            C.TOOLTIP_VALUE_1 ..
            "When should we use a potion in the opener." ..
            C.TOOLTIP_SUBVALUE("无条件使用") ..
            "Always use a potion." ..
            C.TOOLTIP_SUBVALUE("打BOSS使用") ..
            "Only use a potion if the Target is a Boss." ..
            C.TOOLTIP_SUBVALUE("不使用") ..
            "Never use potions in the opener." ..
            C.TOOLTIP_VALUE_2 ..
            "Time in seconds on the DBM countdown at which we would like to take our potion." ..
            C.TOOLTIP_HINT(
            "Pre-Pull should always be lower than Pre-Pot. The type of potion used will be the one selected in the Use Potions option."
            ),
            "当老板拉计时器将低于第二个值时使用药水。" ..
            C.TOOLTIP_VALUE_1 ..
            "我们什么时候应该在开瓶器中使用药水。" ..
            C.TOOLTIP_SUBVALUE("总是") ..
            "总是用药水。" ..
            C.TOOLTIP_SUBVALUE("老板只") ..
            "如果目标是老板，只能使用魔药。" ..
            C.TOOLTIP_SUBVALUE("决不") ..
            "不要在开瓶器中使用药水。" ..
            C.TOOLTIP_VALUE_2 ..
            "老板拉秒倒计时的时间在我们想要服用我们的药水。" ..
            C.TOOLTIP_HINT("预拉力应始终低于“预浸”。 使用的药水类型将是“使用药水”选项中选择的药水。")
        }
        )
        AddNewOption(
        "常规",
        { "抢先施放(需DBM插件)", "预拉式模具" },
        232,
        true,
        { 1, { "打BOSS使用", "老板只" }, { "无条件使用", "总是" }, { "不使用", "决不" } },
        { 0.2, 0, 3, 0.1 },
        {
            "Use a spell when the BossMod timer will be lower than the second value." ..
            C.TOOLTIP_VALUE_1 ..
            "When should we use a spell in the opener." ..
            C.TOOLTIP_SUBVALUE("无条件使用") ..
            "Always use a spell." ..
            C.TOOLTIP_SUBVALUE("打BOSS使用") ..
            "Only use a spell if the Target is a Boss." ..
            C.TOOLTIP_SUBVALUE("不使用") ..
            "Never use a spell in the opener." ..
            C.TOOLTIP_VALUE_2 ..
            "Time in seconds on the DBM countdown at which we would like our spell to land." ..
            C.TOOLTIP_HINT(
            "Pre-Pull should always be lower than Pre-Pot."
            ),
            "当老板拉计时器将低于第二个值时使用法术。" ..
            C.TOOLTIP_VALUE_1 ..
            "我们什么时候在开瓶器中使用咒语。" ..
            C.TOOLTIP_SUBVALUE("总是") ..
            "始终使用法术。" ..
            C.TOOLTIP_SUBVALUE("老板只") ..
            "如果目标是老板，只能使用咒语。" ..
            C.TOOLTIP_SUBVALUE("决不") ..
            "不要在开瓶器中使用咒语。" ..
            C.TOOLTIP_VALUE_2 ..
            "在我们希望我们的法术降落的DBM倒计时的秒数内。" .. C.TOOLTIP_HINT("预拉应始终低于预浸。")
        }
        )
        AddFlasksOptions()
        AddPotionsOption()
        AddNewOption(
        "常规",
        { "脱离战斗后暂停治疗", "出战斗旋转" },
        233,
        true,
        { 2, { "禁用", "残" }, { "启用", "启用" } },
        { 1, { "禁用", "残" }, { "启用", "启用" } },
        {
            "Pulse rotation while Out of Combat." ..
            C.TOOLTIP_VALUE_1 ..
            "Allow healing rotation while out of combat." ..
            C.TOOLTIP_VALUE_2 .. "Allow dps rotation while out of combat.",
            "搏动时脉冲旋转。" .. C.TOOLTIP_VALUE_1 .. "允许在出战时进行治疗旋转。" .. C.TOOLTIP_VALUE_2 .. "在战斗中允许伤害旋转。"
        }
        )
        if (ArcaneTorrent and ArcaneTorrent:Exists()) or (WindShear and WindShear:Exists()) then
            AddSection("常规", { "打断施法", "中断" }, "Yellow")
            AddNewOption(
            "常规",
            { "打断施法进度介于%", "中间％" },
            221,
            true,
            { C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP },
            { C.INTERRUPT_DEFAULT2 },
            {
                "Use interrupt spells when the unit's casted percentage is above a random value between value 1 and value 2." ..
                C.TOOLTIP_VALUE_1 .. "Minimum random value." .. C.TOOLTIP_VALUE_2 .. "Maximum random value.",
                "当单位的投入百分比高于值1和值2之间的随机值时，请使用中断法术。" .. C.TOOLTIP_VALUE_1 .. "最小随机值。" .. C.TOOLTIP_VALUE_2 .. "最大随机值。"
            }
            )
            if ArcaneTorrent and ArcaneTorrent:Exists() then
                AddNewOption(
                "常规",
                { "Arcane Torrent Interrupt", "奥术洪流中断" },
                210,
                false,
                nil,
                nil,
                { "Enable to also use Arcane Torrent to interrupt.", "启用也可以使用奥术洪流中断。" }
                )
            end
            AddNewOption(
            "常规",
            { "打断任意目标施法", "中断任何单位" },
            210,
            false,
            nil,
            nil,
            {
                "Enable to interrupt any units in range." ..
                C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."),
                "允许中断任何单位的范围。" .. C.TOOLTIP_HINT("只有在中间％启用。")
            }
            )
            AddNewOption(
            "常规",
            { "自定义打断技能列表", "自定义中断列表" },
            210,
            false,
            nil,
            nil,
            { "Enable to interrupt only spells in the Custom Interrupt List.", "启用仅中断自定义中断列表中的法术。" }
            )
        end
        AddSection("常规", { "辅助", "效用" }, "Yellow")
        AddNewOption(
        "常规",
        { "焦点分配", "焦点分配" },
        230,
        true,
        { 2, { "主坦", "主坦克" }, { "副坦", "关罐" } },
        nil,
        { "Select which Tank slot should be given to the focussed unit.", "选择应将哪个槽槽给予聚焦单元。" }
        )
        AddNewOption(
        "常规",
        { "驱散", "打消" },
        232,
        false,
        { 1, { "自动", "自动" }, { "高", "高" }, { "正常", "正常" } },
        { 0.2, 0, 3, 0.1 },
        {
            "Remove bad debuffs on allied units." ..
            C.TOOLTIP_VALUE_1 ..
            "Choose preferred mode." ..
            C.TOOLTIP_SUBVALUE("自动") ..
            "Dispel Active Dispel Raid debuffs as High Priority and other not listed debuffs as Normal Priority." ..
            C.TOOLTIP_SUBVALUE("高") ..
            "Dispel all debuffs as High Priority even before urgent cooldowns." ..
            C.TOOLTIP_SUBVALUE("正常") ..
            "Dispel all debuffs as Normal Priority after urgent cooldowns." ..
            C.TOOLTIP_VALUE_2 ..
            "Define how long you want to wait before dispelling to look more human. This does not apply to Active Dispels Raid debuffs which will always be as soon as Global Cooldown ends." ..
            C.TOOLTIP_HINT(
            "Active Raid Dispels are based on an hardcoded list. Please report of any dispels you may encounter that requires specific strategies so that they can be properly added to the list."
            ),
            "删除负面效果不好是友军。" ..
            C.TOOLTIP_VALUE_1 ..
            "选择最佳模式。" ..
            C.TOOLTIP_SUBVALUE("自动") ..
            "消除空袭活动驱散负面效果具有高优先级和其他未列出的减益有正常的优先级。" ..
            C.TOOLTIP_SUBVALUE("高") ..
            "即使按冷却时间前消除所有负面状态为高优先级。" ..
            C.TOOLTIP_SUBVALUE("正常") ..
            "消除所有负面状态为正常优先级按后冷却时间。" ..
            C.TOOLTIP_VALUE_2 ..
            "定义多久你想消除看起来更加人性化之前要等待。这并不适用于主动RAID驱散减益魁总是会尽快全球冷却时间结束是。"
        }
        )
        AddSection("大技能", { "药水,饰品和种族技能", "药水，饰品和种族技能" }, "Yellow")
        AddNewOption(
        "大技能",
        { "延时之力药水", "延长电源药水" },
        222,
        false,
        { 5, 1, 25, 1 },
        { 40, 0, 100, 1 },
        {
            "Use when selected number of units are under health threshold. It will also be used without health checks if we have two charges." ..
            C.TOOLTIP_VALUE_1 .. "Number of Units." .. C.TOOLTIP_VALUE_2 .. "Health threshold.",
            "使用时的单位选择数量正在健康阈值。它将被用于没有健康检查，澳大利亚游泳，如果我们具备两个负载。" ..
            C.TOOLTIP_VALUE_1 .. "单位数。" .. C.TOOLTIP_VALUE_2 .. "健康阈值。"
        }
        )
        AddNewOption(
        "大技能",
        { "使用法力药水", "使用法力药水" },
        232,
        false,
        { 1, { "古代法力药水", "古代法力药水" }, { "魔力洪流药水", "魔力洪流药水" } },
        { 20, 1, 100, 1 },
        {
            "Use Mana Potions during combat." .. C.TOOLTIP_VALUE .. "Mana threshold to use.",
            "使用法力药水在战斗。" .. C.TOOLTIP_VALUE .. "法力阈值而使用。"
        }
        )
        if (ArcaneTorrent and ArcaneTorrent:Exists()) then
            AddNewOption(
            "大技能",
            { "使用种族技能", "使用种族技能" },
            220,
            true,
            { 80, 0, 100, 1 },
            nil,
            {
                "Use Racials." .. C.TOOLTIP_VALUE .. "Use Arcane Torrent when our mana is under threshold.",
                "使用种族技能。" .. C.TOOLTIP_VALUE .. "使用奥术洪流当我们的法力下阈值。"
            }
            )
        end
        AddNewOption(
        "大技能",
        { "使用种族技能和饰品的单位数量", "软冷却时间单位" },
        120,
        true,
        { 3, 1, 25, 1 },
        nil,
        {
            "Number of units that needs to be under thresholds to use Racials and Trinkets with Health.",
            "单位数量必须是下阈值使用种族技能和饰品与健康。"
        }
        )
        if (BloodFury and BloodFury:Exists()) or (Berserking and Berserking:Exists()) then
            AddNewOption(
            "大技能",
            { "使用种族技能", "使用种族技能" },
            220,
            true,
            { 80, 0, 100, 1 },
            nil,
            {
                "Use Racials." ..
                C.TOOLTIP_VALUE ..
                "Use when number of units under threshold is greater or equal to Soft Cooldowns Units value.",
                "使用种族技能。" .. C.TOOLTIP_VALUE .. "当使用阈值下的单元的数量是等于或大于软冷却时间单位值。"
            }
            )
        end
        AddNewOption(
        "大技能",
        { "使用饰品 1", "使用饰品1" },
        232,
        true,
        { 2, { "无条件使用", "总是" }, { "血量", "健康" }, { "蓝量", "法力" } },
        { 90, 0, 100, 1 },
        {
            "Use Trinket 1 with selected values." ..
            C.TOOLTIP_VALUE_1 ..
            "Choose preferred mode." ..
            C.TOOLTIP_SUBVALUE("无条件使用") ..
            " Use Always." ..
            C.TOOLTIP_SUBVALUE("血量") ..
            " Use when number of units under threshold is greater or equal to Soft Cooldowns Units value." ..
            C.TOOLTIP_SUBVALUE("蓝量") ..
            " Use when your mana fall under selected threshold." ..
            C.TOOLTIP_VALUE_2 .. "Define Health or Mana threshold.",
            "使用饰品1使用选定的值。" ..
            C.TOOLTIP_VALUE_1 ..
            "选择最佳模式。" ..
            C.TOOLTIP_SUBVALUE("总是") ..
            " 始终使用。" ..
            C.TOOLTIP_SUBVALUE("健康") ..
            " 当使用阈值下的单元的数量是等于或大于软冷却时间单位值。" ..
            C.TOOLTIP_SUBVALUE("法力") ..
            " 使用当你的法力下选择的阈值下降。" .. C.TOOLTIP_VALUE_2 .. "定义健康法力金门槛。"
        }
        )
        AddNewOption(
        "大技能",
        { "使用饰品 2", "使用饰品2" },
        232,
        true,
        { 2, { "无条件使用", "总是" }, { "血量", "健康" }, { "蓝量", "法力" } },
        { 90, 0, 100, 1 },
        {
            "Use Trinket 1 with selected values." ..
            C.TOOLTIP_VALUE_1 ..
            "Choose preferred mode." ..
            C.TOOLTIP_SUBVALUE("无条件使用") ..
            " Use Always." ..
            C.TOOLTIP_SUBVALUE("血量") ..
            " Use when number of units under threshold is greater or equal to Soft Cooldowns Units value." ..
            C.TOOLTIP_SUBVALUE("蓝量") ..
            " Use when your mana fall under selected threshold." ..
            C.TOOLTIP_VALUE_2 .. "Define Health or Mana threshold.",
            "使用饰品2使用选定的值。" ..
            C.TOOLTIP_VALUE_1 ..
            "选择最佳模式。" ..
            C.TOOLTIP_SUBVALUE("总是") ..
            " 始终使用。" ..
            C.TOOLTIP_SUBVALUE("健康") ..
            " 当使用阈值下的单元的数量是等于或大于软冷却时间单位值。" ..
            C.TOOLTIP_SUBVALUE("法力") ..
            " 使用当你的法力下选择的阈值下降。" .. C.TOOLTIP_VALUE_2 .. "定义健康法力金门槛。"
        }
        )
        AddSection("攻/防", { "目标选定", "目标处理" }, "Yellow")
        AddNewOption(
        "攻/防",
        { "目标 | 攻击", "目标 | 攻击" },
        133,
        true,
        { 4, { "禁用", "残" }, { "距离最近", "最近的" }, { "血量最少", "最不健康" }, { "血量最多", "最健康" }, { "目标附近", "目标最近" } },
        { 3, { "禁用", "残" }, { "仅战斗状态时", "仅作战" }, { "启用", "启用" } },
        {
            C.TOOLTIP_VALUE_1 ..
            "Target - Choose which mode to use to choose a new target when needed." ..
            C.TOOLTIP_SUBVALUE("距离最近") ..
            "Closest enemy." ..
            C.TOOLTIP_SUBVALUE("血量最少") ..
            "Least health remaining." ..
            C.TOOLTIP_SUBVALUE("血量最多") ..
            "Most health remaining." ..
            C.TOOLTIP_SUBVALUE("目标附近") ..
            "Closest to our previous target." ..
            C.TOOLTIP_VALUE_2 ..
            "Attack - Should we use /startattack when changing target. Enable to use /startattack when changing target. (Melee classes should keep Attack Enabled.)",
            C.TOOLTIP_VALUE_1 ..
            "目标 - 选择魁方法用来选择一个新的目标在需要的时候。" ..
            C.TOOLTIP_SUBVALUE("最近的") ..
            "最近的敌人。" ..
            C.TOOLTIP_SUBVALUE("至少希思") ..
            "最健康的剩余。" ..
            C.TOOLTIP_SUBVALUE("最健康") ..
            "最健康的剩余。" ..
            C.TOOLTIP_SUBVALUE("最近的目标") ..
            "最接近我们先前的目标。" ..
            C.TOOLTIP_VALUE_2 ..
            "攻击 - 我们应该使用 /startattack 当改变目标。启用，可以使用 /startattack 当改变目标。（近战类不宜继续攻击启用。）"
        }
        )
        AddNewOption(
        "攻/防",
        { "动态切换目标", "动态定位" },
        232,
        true,
        { 1, { "保持", "保持" }, { "变化", "更改" } },
        { 5, 5, 40, 1 },
        {
            "Attack units that are closer around the player when the actual target is out of range." ..
            C.TOOLTIP_VALUE_1 ..
            "Choose preferred Dynamic Mode." ..
            C.TOOLTIP_SUBVALUE("保持") ..
            "Never change target but attack units around the player." ..
            C.TOOLTIP_SUBVALUE("变化") ..
            "Change target to units around the player." ..
            C.TOOLTIP_VALUE_2 ..
            "Use Dynamic Targetting when our range to the target is farter than this value.",
            "当实际目标超出范围时，攻击单位靠近玩家。" ..
            C.TOOLTIP_VALUE_1 ..
            "选择首选动态模式。" ..
            C.TOOLTIP_SUBVALUE("保持") ..
            "不要改变目标，而是围绕玩家攻击单位。" ..
            C.TOOLTIP_SUBVALUE("更改") ..
            "将目标更改为玩家周围的单位。" .. C.TOOLTIP_VALUE_2 .. "当我们到目标的范围比此值更远时，使用动态定位。"
        }
        )
    elseif Name == "进攻" then
        AddSection("进攻", { "常规", "常见" }, "Yellow")
        if
        (ArcaneTorrent and ArcaneTorrent:Exists()) or (Berserking and Berserking:Exists()) or
        (BloodFury and BloodFury:Exists())
        then
            AddNewOption(
            "进攻",
            { "进攻性种族技能", "进攻种族" },
            230,
            true,
            { 2, { "无条件使用", "总是" }, { "Boss中无条件使用", "老板总是" }, { "Boss中大技能用法", "老板冷却" }, { "大技能用法", "冷却时间" } },
            nil,
            {
                "Use Offensive Racials." ..
                C.TOOLTIP_VALUE ..
                C.TOOLTIP_SUBVALUE("无条件使用", true) ..
                "Will use the ability even if CDs are disabled." ..
                C.TOOLTIP_SUBVALUE("Boss中无条件使用") ..
                "Will use the ability even if CDs are disabled as long as the current target is a boss." ..
                C.TOOLTIP_SUBVALUE("打BOSS使用") ..
                "Will only use the ability if the actual Target is a Boss." ..
                C.TOOLTIP_SUBVALUE("大技能用法") ..
                "Will only use the ability if CDs are enabled.",
                "使用进攻种族。" ..
                C.TOOLTIP_VALUE_1 ..
                C.TOOLTIP_SUBVALUE("总是", true) ..
                "即使冷却被禁用也会使用该功能。" ..
                C.TOOLTIP_SUBVALUE("老板总是") ..
                "只要目前的目标是老板，就会使用这种能力，即使冷却被禁用。" ..
                C.TOOLTIP_SUBVALUE("老板只") ..
                "只有实际的目标是老板才会使用能力。" .. C.TOOLTIP_SUBVALUE("冷却时间") .. "只有启用冷却时才会使用该功能。"
            }
            )
        end
        AddNewOption(
        "进攻",
        { "戒指 | 项链", "戒指 | 颈部" },
        133,
        true,
        { 2, { "无条件使用", "总是" }, { "大技能用法", "冷却时间" }, { "禁用", "残" } },
        { 2, { "无条件使用", "总是" }, { "大技能用法", "冷却时间" }, { "禁用", "残" } },
        {
            "Use Rings and Neck." ..
            C.TOOLTIP_VALUE_1 .. "Enable both Rings." .. C.TOOLTIP_VALUE_2 .. "Enable Neck.",
            "使用戒指和颈部。" .. C.TOOLTIP_VALUE_1 .. "启用两个环。" .. C.TOOLTIP_VALUE_2 .. "启用颈部。"
        }
        )
        AddNewOption(
        "进攻",
        { "饰品: 1 | 2", "小饰品： 1 | 2" },
        133,
        true,
        { 2, { "无条件使用", "总是" }, { "大技能用法", "冷却时间" }, { "禁用", "残" } },
        { 2, { "无条件使用", "总是" }, { "大技能用法", "冷却时间" }, { "禁用", "残" } },
        {
            "Use Trinkets." ..
            C.TOOLTIP_VALUE_1 .. "Enable Trinket Slot 1." .. C.TOOLTIP_VALUE_2 .. "Enable Trinket Slot 2.",
            "使用小饰品。" .. C.TOOLTIP_VALUE_1 .. "启用小饰品插槽1。" .. C.TOOLTIP_VALUE_2 .. "启用小饰品插槽2。"
        }
        )
    elseif Name == "防御" then
        AddSection("防御", { "常规", "常见" }, "Yellow")
        if (GiftOfTheNaaru and GiftOfTheNaaru:Exists()) then
            AddNewOption(
            "防御",
            { "纳鲁的赐福", "纳鲁的赐福" },
            220,
            true,
            { 50, 1, 95, 1 },
            nil,
            { "Health Percentage to use Gift of the Naaru on self.", "健康百分比使用纳鲁的赐福自我。" }
            )
        end
        AddNewOption(
        "防御",
        { "治疗物品", "治疗项目" },
        220,
        true,
        { 35, 1, 95, 1 },
        nil,
        { "Health Percentage to use Healthstone / Healing Potion.", "健康百分比使用治疗石/治疗药水。" }
        )
    elseif Name == "TankingFeatures" then
        AddSection("常规", { "坦克功能", "油罐特点" }, "Yellow")
        AddNewOption(
        "常规",
        SecondOptions,
        230,
        false,
        { 1, { "任何单位", "任何单位" }, { "只有目标", "目标" } },
        nil,
        {
            "Use " ..
            SecondOptions[1] ..
            " on ennemies that are not tanked." ..
            C.TOOLTIP_VALUE_2 ..
            "Enable taunting target that is not tanked. Use Any Unit to taunt Any unit within 30 yard or Target only to only check current Target.",
            "使用 " ..
            SecondOptions[2] ..
            " 对未排名的敌人。" .. C.TOOLTIP_VALUE_2 .. "启用不被打扰的嘲讽目标。 使用任何单位嘲笑30码以内的任何单位或目标只能检查目前的目标。"
        }
        )
        AddNewOption(
        "常规",
        { "自动取消保护之手", "手防护取消" },
        220,
        true,
        { 1, 0, 3, 0.1 },
        nil,
        {
            "Enable this option to auto cancel Hand of Protection when it is applied on you to remove your debuffs.",
            "启用此选项可以在应用于您时清除不良光环时自动取消防护手。"
        }
        )
    elseif Name == "Cooldown" then
        if type(SecondOptions) ~= "string" then
            SecondOptionsName = Locale == "zh" and SecondOptions[2] or SecondOptions[1]
        else
            SecondOptionsName = SecondOptions
        end
        if type(FifthOptions) ~= "string" and type(FifthOptions) ~= "nil" then
            FifthOptionsEnglish, FifthOptionsChinese = FifthOptions[1], FifthOptions[2]
        else
            FifthOptionsEnglish, FifthOptionsChinese = FifthOptions, FifthOptions
        end
        ThirdOptions = ThirdOptions or 4
        if FourthOptions ~= nil and type(FourthOptions[2]) == "number" then
            AddNewOption(
            "进攻",
            SecondOptions,
            232,
            true,
            { ThirdOptions, { "无条件使用", "总是" }, { "Boss中无条件使用", "老板总是" }, { "Boss中大技能用法", "老板冷却" }, { "大技能用法", "冷却时间" } },
            FourthOptions,
            {
                "Use " ..
                SecondOptionsName ..
                "." ..
                C.TOOLTIP_VALUE_1 ..
                C.TOOLTIP_SUBVALUE("无条件使用", true) ..
                "Will use the ability even if CDs are disabled." ..
                C.TOOLTIP_SUBVALUE("Boss中无条件使用") ..
                "Will use the ability even if CDs are disabled as long as the current target is a boss." ..
                C.TOOLTIP_SUBVALUE("打BOSS使用") ..
                "Will only use the ability if the actual Target is a Boss." ..
                C.TOOLTIP_SUBVALUE("大技能用法") ..
                "Will only use the ability if CDs are enabled." ..
                C.TOOLTIP_VALUE_2 .. FifthOptionsEnglish,
                "使用" ..
                SecondOptionsName ..
                "。" ..
                C.TOOLTIP_VALUE_1 ..
                C.TOOLTIP_SUBVALUE("总是", true) ..
                "即使冷却被禁用也会使用该功能。" ..
                C.TOOLTIP_SUBVALUE("老板总是") ..
                "只要目前的目标是老板，就会使用这种能力，即使冷却被禁用。" ..
                C.TOOLTIP_SUBVALUE("老板只") ..
                "只有实际的目标是老板才会使用能力。" ..
                C.TOOLTIP_SUBVALUE("冷却时间") ..
                "只有启用冷却时才会使用该功能。" ..
                C.TOOLTIP_VALUE_2 .. FifthOptionsChinese
            }
            )
        elseif FourthOptions ~= nil and type(FourthOptions[2]) == "string" then
            AddNewOption(
            "进攻",
            SecondOptions,
            233,
            true,
            { ThirdOptions, { "无条件使用", "总是" }, { "Boss中无条件使用", "老板总是" }, { "Boss中大技能用法", "老板冷却" }, { "大技能用法", "冷却时间" } },
            FourthOptions,
            {
                "Use " ..
                SecondOptionsName ..
                "." ..
                C.TOOLTIP_VALUE_1 ..
                C.TOOLTIP_SUBVALUE("无条件使用", true) ..
                "Will use the ability even if CDs are disabled." ..
                C.TOOLTIP_SUBVALUE("Boss中无条件使用") ..
                "Will use the ability even if CDs are disabled as long as the current target is a boss." ..
                C.TOOLTIP_SUBVALUE("打BOSS使用") ..
                "Will only use the ability if the actual Target is a Boss." ..
                C.TOOLTIP_SUBVALUE("大技能用法") ..
                "Will only use the ability if CDs are enabled." ..
                C.TOOLTIP_VALUE_2 .. FifthOptionsEnglish,
                "使用" ..
                SecondOptionsName ..
                "。" ..
                C.TOOLTIP_VALUE_1 ..
                C.TOOLTIP_SUBVALUE("总是", true) ..
                "即使冷却被禁用也会使用该功能。" ..
                C.TOOLTIP_SUBVALUE("老板总是") ..
                "只要目前的目标是老板，就会使用这种能力，即使冷却被禁用。" ..
                C.TOOLTIP_SUBVALUE("老板只") ..
                "只有实际的目标是老板才会使用能力。" ..
                C.TOOLTIP_SUBVALUE("冷却时间") ..
                "只有启用冷却时才会使用该功能。" ..
                C.TOOLTIP_VALUE_2 .. FifthOptionsChinese
            }
            )
        else
            AddNewOption(
            "进攻",
            SecondOptions,
            230,
            true,
            { ThirdOptions, { "无条件使用", "总是" }, { "Boss中无条件使用", "老板总是" }, { "Boss中大技能用法", "老板冷却" }, { "大技能用法", "冷却时间" } },
            nil,
            {
                "Use " ..
                SecondOptionsName ..
                "." ..
                C.TOOLTIP_VALUE_1 ..
                C.TOOLTIP_SUBVALUE("无条件使用", true) ..
                "Will use the ability even if CDs are disabled." ..
                C.TOOLTIP_SUBVALUE("Boss中无条件使用") ..
                "Will use the ability even if CDs are disabled as long as the current target is a boss." ..
                C.TOOLTIP_SUBVALUE("打BOSS使用") ..
                "Will only use the ability if the actual Target is a Boss." ..
                C.TOOLTIP_SUBVALUE("大技能用法") ..
                "Will only use the ability if CDs are enabled.",
                "使用" ..
                SecondOptionsName ..
                "。" ..
                C.TOOLTIP_VALUE_1 ..
                C.TOOLTIP_SUBVALUE("总是", true) ..
                "即使冷却被禁用也会使用该功能。" ..
                C.TOOLTIP_SUBVALUE("老板总是") ..
                "只要目前的目标是老板，就会使用这种能力，即使冷却被禁用。" ..
                C.TOOLTIP_SUBVALUE("老板只") ..
                "只有实际的目标是老板才会使用能力。" ..
                C.TOOLTIP_SUBVALUE("冷却时间") .. "只有启用冷却时才会使用该功能。"
            }
            )
        end
    elseif Name == "DirectHealingTankRaid" then
        AddNewOption(
        SecondOptions,
        ThirdOptions,
        222,
        FourthOptions,
        FifthOptions,
        SixthOptions,
        {
            "Use " ..
            ThirdOptions[1] ..
            "." ..
            C.TOOLTIP_VALUE_1 ..
            "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid.",
            "使用" .. ThirdOptions[2] .. "。" .. C.TOOLTIP_VALUE_1 .. "在坦克上使用的门槛。" .. C.TOOLTIP_VALUE_2 .. "突袭使用的门槛。"
        }
        )
    elseif Name == "DirectHealingSingle" then
        AddNewOption(
        SecondOptions,
        ThirdOptions,
        220,
        FourthOptions,
        FifthOptions,
        nil,
        {
            "Use " .. ThirdOptions[1] .. "." .. C.TOOLTIP_VALUE .. "Threshold to use on the Lowest unit.",
            "使用" .. ThirdOptions[2] .. "。" .. C.TOOLTIP_VALUE .. "在最低单位使用的阈值。"
        }
        )
    elseif Name == "AoEHealingUnitsHealth" then
        AddNewOption(
        SecondOptions,
        ThirdOptions,
        222,
        FourthOptions,
        FifthOptions,
        SixthOptions,
        {
            "Use when selected number of units are under health threshold." ..
            C.TOOLTIP_VALUE_1 .. "Number of Units." .. C.TOOLTIP_VALUE_2 .. "Health threshold.",
            "当选择的单位数目在健康阈值以下时使用。" .. C.TOOLTIP_VALUE_1 .. "单位数。" .. C.TOOLTIP_VALUE_2 .. "健康阈值。"
        }
        )
    elseif Name == "HealerOffensive" then
        AddNewOption(
        "攻/防",
        SecondOptions,
        210,
        true,
        nil,
        nil,
        {
            "Use " ..
            SecondOptions[1] ..
            " in the DPS rotation." ..
            C.TOOLTIP_HINT(
            "Only used when the Lowest unit's health is higher than the DPS health threshold."
            ),
            "使用" .. SecondOptions[2] .. "在进攻旋转。" .. C.TOOLTIP_HINT("只有当最低单位的健康高于进攻健康阈值时才使用。")
        }
        )
    end
end
function AddCommonMeleeStatus()
    if Locale == "zh" then
        AddOutput("位置")
        AddOutput("范围")
    else
        AddOutput("位置")
        AddOutput("范围")
    end
end
function SetCommonMeleeStatus()
    if Locale == "zh" then
        if Target:Exists() and not Player:Equals(Target) then
            local Distance = math.floor(Player:DistanceTo(Target, true))
            if Distance < 100 then
                if Player:DistanceTo(Target) <= 5 then
                    SetOutput("范围", "|CFF939393( |CFFFFFFFF" .. Distance .. "|CFF939393 )  |cFF00FF00在混战|r")
                else
                    SetOutput("范围", "|CFF939393( |CFFFFFFFF" .. Distance .. "|CFF939393 )  |cFFFF0000不在混战|r")
                end
                local IsBehind = not Target:IsFacing(Player) and "|CFF2E64FE背后|r" or "|CFFFE9A2E前|r"
                local InSight = Player:InLineOfSight(Target) and "|cFF00FF00可见" or "|cFFFF0000不可见"
                SetOutput("位置", InSight .. " |CFFFFFFFF/ " .. IsBehind)
            else
                SetOutput("范围", "")
                SetOutput("位置", "")
            end
        else
            SetOutput("范围", "")
            SetOutput("位置", "")
        end
    else
        if Target:Exists() and not Player:Equals(Target) then
            local Distance = math.floor(Player:DistanceTo(Target, true))
            if Distance < 100 then
                if Player:DistanceTo(Target) <= 5 then
                    SetOutput("范围", "|CFF939393( |CFFFFFFFF" .. Distance .. "|CFF939393 )  |cFF00FF00近战内|r")
                else
                    SetOutput("范围", "|CFF939393( |CFFFFFFFF" .. Distance .. "|CFF939393 )  |cFFFF0000近战范围外|r")
                end
                local IsBehind = not Target:IsFacing(Player) and "|CFF2E64FE背后|r" or "|CFFFE9A2E在前面|r"
                local InSight = Player:InLineOfSight(Target) and "|cFF00FF00视线内" or "|cFF00FF00不在视线"
                SetOutput("位置", InSight .. " |CFFFFFFFF/ " .. IsBehind)
            else
                SetOutput("范围", "")
                SetOutput("位置", "")
            end
        else
            SetOutput("范围", "")
            SetOutput("位置", "")
        end
    end
end
function CreateMacros(...)
    if (18 - select(2, _G["GetNumMacros"]())) >= 9 then
        CreateMacro("TOGGLE", "inv_misc_bomb_04", "/" .. DisplayName .. " " .. CmdArgument.toggle, 1, 1)
        CreateMacro("大技能", "inv_misc_bomb_09", "/" .. DisplayName .. " " .. CmdArgument.cds, 1, 1)
        CreateMacro("AOE", "inv_misc_bomb_07", "/" .. DisplayName .. " " .. CmdArgument.aoe, 1, 1)
        CreateMacro("GUI", "trade_archaeology_highborne_scroll", "/" .. DisplayName .. " " .. CmdArgument.ui, 1, 1)
        CreateMacro("TB", "inv_glyph_minormage", "/" .. DisplayName .. " " .. CmdArgument.tb, 1, 1)
        CreateMacro("CS", "inv_glyph_majorpaladin", "/" .. DisplayName .. " " .. CmdArgument.cs, 1, 1)
        CreateMacro("STATUS", "inv_misc_note_06", "/" .. DisplayName .. " " .. CmdArgument.status, 1, 1)
        CreateMacro(
        "Load Default UI",
        "Achievement_BG_AB_defendflags",
        "/" .. DisplayName .. " " .. CmdArgument.loadui .. " Default",
        1,
        1
        )
        CreateMacro(
        "Re-create Default UI",
        "Achievement_BG_returnXflags_def_WSG",
        "/" .. DisplayName .. " " .. CmdArgument.saveui .. " Default",
        1,
        1
        )
        Print("Macros Loaded")
    else
        Error("Not enough Macro slots ('Character Specific Macros' tab)")
    end
end
local SpecsStats = {
    [62] = { Flasks = { { "智力药水", "耳语契约合剂" } }, Potions = { { "致命优雅药水", "致命优雅药水" }, { "智力药水", "德拉诺智力药水" }, { "延时之力药水", "延时之力药水" } } },
    [63] = { Flasks = { { "智力药水", "耳语契约合剂" } }, Potions = { { "致命优雅药水", "致命优雅药水" }, { "智力药水", "德拉诺智力药水" }, { "延时之力药水", "延时之力药水" } } },
    [64] = { Flasks = { { "智力药水", "耳语契约合剂" } }, Potions = { { "致命优雅药水", "致命优雅药水" }, { "智力药水", "德拉诺智力药水" }, { "延时之力药水", "延时之力药水" } } },
    [65] = { Flasks = { { "智力药水", "耳语契约合剂" } }, Potions = { { "延时之力药水", "延时之力药水" }, { "智力药水", "德拉诺智力药水" } } },
    [66] = {
        Flasks = { { "力量药水", "无尽大军合剂" }, { "耐力药水", "千万战痕合剂" } },
        Potions = { { "延时之力药水", "延时之力药水" }, { "力量药水", "德拉诺力量药水" }, { "全能药剂", "德拉诺全能药水" }, { "上古战神药水", "上古战神药水" } }
    },
    [70] = {
        Flasks = { { "力量药水", "无尽大军合剂" } },
        Potions = { { "上古战神药水", "上古战神药水" }, { "力量药水", "德拉诺力量药水" }, { "全能药剂", "德拉诺全能药水" }, { "延时之力药水", "延时之力药水" } }
    },
    [71] = {
        Flasks = { { "力量药水", "无尽大军合剂" } },
        Potions = { { "上古战神药水", "上古战神药水" }, { "力量药水", "德拉诺力量药水" }, { "全能药剂", "德拉诺全能药水" }, { "延时之力药水", "延时之力药水" } }
    },
    [72] = {
        Flasks = { { "力量药水", "无尽大军合剂" } },
        Potions = { { "上古战神药水", "上古战神药水" }, { "力量药水", "德拉诺力量药水" }, { "全能药剂", "德拉诺全能药水" }, { "延时之力药水", "延时之力药水" } }
    },
    [73] = {
        Flasks = { { "力量药水", "无尽大军合剂" }, { "耐力药水", "千万战痕合剂" } },
        Potions = { { "延时之力药水", "延时之力药水" }, { "力量药水", "德拉诺力量药水" }, { "全能药剂", "德拉诺全能药水" }, { "上古战神药水", "上古战神药水" } }
    },
    [102] = { Flasks = { { "智力药水", "耳语契约合剂" } }, Potions = { { "致命优雅药水", "致命优雅药水" }, { "智力药水", "德拉诺智力药水" }, { "延时之力药水", "延时之力药水" } } },
    [103] = {
        Flasks = { { "Agility", "第七恶魔合剂" } },
        Potions = { { "上古战神药水", "上古战神药水" }, { "Agility", "德拉诺敏捷药水" }, { "全能药剂", "德拉诺全能药水" }, { "延时之力药水", "延时之力药水" } }
    },
    [104] = {
        Flasks = { { "Agility", "第七恶魔合剂" }, { "耐力药水", "千万战痕合剂" } },
        Potions = { { "延时之力药水", "延时之力药水" }, { "Agility", "德拉诺敏捷药水" }, { "全能药剂", "德拉诺全能药水" }, { "上古战神药水", "上古战神药水" } }
    },
    [105] = { Flasks = { { "智力药水", "耳语契约合剂" } }, Potions = { { "延时之力药水", "延时之力药水" }, { "智力药水", "德拉诺智力药水" } } },
    [250] = {
        Flasks = { { "力量药水", "无尽大军合剂" }, { "耐力药水", "千万战痕合剂" } },
        Potions = { { "延时之力药水", "延时之力药水" }, { "力量药水", "德拉诺力量药水" }, { "全能药剂", "德拉诺全能药水" }, { "上古战神药水", "上古战神药水" } }
    },
    [251] = {
        Flasks = { { "力量药水", "无尽大军合剂" } },
        Potions = {
            { "上古战神药水", "上古战神药水" },
            { "力量药水", "德拉诺力量药水" },
            { "全能药剂", "德拉诺全能药水" },
            { "致命优雅药水", "致命优雅药水" },
            { "延时之力药水", "延时之力药水" }
        }
    },
    [252] = {
        Flasks = { { "力量药水", "无尽大军合剂" } },
        Potions = {
            { "上古战神药水", "上古战神药水" },
            { "力量药水", "德拉诺力量药水" },
            { "全能药剂", "德拉诺全能药水" },
            { "致命优雅药水", "致命优雅药水" },
            { "延时之力药水", "延时之力药水" }
        }
    },
    [253] = {
        Flasks = { { "Agility", "第七恶魔合剂" } },
        Potions = { { "致命优雅药水", "致命优雅药水" }, { "Agility", "德拉诺敏捷药水" }, { "延时之力药水", "延时之力药水" } }
    },
    [254] = {
        Flasks = { { "Agility", "第七恶魔合剂" } },
        Potions = { { "致命优雅药水", "致命优雅药水" }, { "Agility", "德拉诺敏捷药水" }, { "延时之力药水", "延时之力药水" } }
    },
    [255] = {
        Flasks = { { "Agility", "第七恶魔合剂" } },
        Potions = { { "致命优雅药水", "致命优雅药水" }, { "Agility", "德拉诺敏捷药水" }, { "延时之力药水", "延时之力药水" } }
    },
    [256] = { Flasks = { { "智力药水", "耳语契约合剂" } }, Potions = { { "延时之力药水", "延时之力药水" }, { "智力药水", "德拉诺智力药水" } } },
    [257] = { Flasks = { { "智力药水", "耳语契约合剂" } }, Potions = { { "延时之力药水", "延时之力药水" }, { "智力药水", "德拉诺智力药水" } } },
    [258] = { Flasks = { { "智力药水", "耳语契约合剂" } }, Potions = { { "致命优雅药水", "致命优雅药水" }, { "智力药水", "德拉诺智力药水" }, { "延时之力药水", "延时之力药水" } } },
    [259] = {
        Flasks = { { "Agility", "第七恶魔合剂" } },
        Potions = { { "上古战神药水", "上古战神药水" }, { "Agility", "德拉诺敏捷药水" }, { "全能药剂", "德拉诺全能药水" }, { "延时之力药水", "延时之力药水" } }
    },
    [260] = {
        Flasks = { { "Agility", "第七恶魔合剂" } },
        Potions = { { "上古战神药水", "上古战神药水" }, { "Agility", "德拉诺敏捷药水" }, { "全能药剂", "德拉诺全能药水" }, { "延时之力药水", "延时之力药水" } }
    },
    [261] = {
        Flasks = { { "Agility", "第七恶魔合剂" } },
        Potions = { { "上古战神药水", "上古战神药水" }, { "Agility", "德拉诺敏捷药水" }, { "全能药剂", "德拉诺全能药水" }, { "延时之力药水", "延时之力药水" } }
    },
    [262] = { Flasks = { { "智力药水", "耳语契约合剂" } }, Potions = { { "致命优雅药水", "致命优雅药水" }, { "智力药水", "德拉诺智力药水" }, { "延时之力药水", "延时之力药水" } } },
    [263] = {
        Flasks = { { "Agility", "第七恶魔合剂" } },
        Potions = { { "上古战神药水", "上古战神药水" }, { "Agility", "德拉诺敏捷药水" }, { "全能药剂", "德拉诺全能药水" }, { "延时之力药水", "延时之力药水" } }
    },
    [264] = { Flasks = { { "智力药水", "耳语契约合剂" } }, Potions = { { "延时之力药水", "延时之力药水" }, { "智力药水", "德拉诺智力药水" } } },
    [265] = { Flasks = { { "智力药水", "耳语契约合剂" } }, Potions = { { "致命优雅药水", "致命优雅药水" }, { "智力药水", "德拉诺智力药水" }, { "延时之力药水", "延时之力药水" } } },
    [266] = { Flasks = { { "智力药水", "耳语契约合剂" } }, Potions = { { "致命优雅药水", "致命优雅药水" }, { "智力药水", "德拉诺智力药水" }, { "延时之力药水", "延时之力药水" } } },
    [267] = { Flasks = { { "智力药水", "耳语契约合剂" } }, Potions = { { "致命优雅药水", "致命优雅药水" }, { "智力药水", "德拉诺智力药水" }, { "延时之力药水", "延时之力药水" } } },
    [268] = {
        Flasks = { { "Agility", "第七恶魔合剂" }, { "耐力药水", "千万战痕合剂" } },
        Potions = { { "延时之力药水", "延时之力药水" }, { "Agility", "德拉诺敏捷药水" }, { "全能药剂", "德拉诺全能药水" }, { "上古战神药水", "上古战神药水" } }
    },
    [269] = {
        Flasks = { { "Agility", "第七恶魔合剂" } },
        Potions = { { "上古战神药水", "上古战神药水" }, { "Agility", "德拉诺敏捷药水" }, { "全能药剂", "德拉诺全能药水" }, { "延时之力药水", "延时之力药水" } }
    },
    [270] = { Flasks = { { "智力药水", "耳语契约合剂" } }, Potions = { { "延时之力药水", "延时之力药水" }, { "智力药水", "德拉诺智力药水" } } },
    [577] = {
        Flasks = { { "Agility", "第七恶魔合剂" } },
        Potions = {
            { "上古战神药水", "上古战神药水" },
            { "Agility", "德拉诺敏捷药水" },
            { "全能药剂", "德拉诺全能药水" },
            { "致命优雅药水", "致命优雅药水" },
            { "延时之力药水", "延时之力药水" }
        }
    },
    [581] = {
        Flasks = { { "Agility", "第七恶魔合剂" }, { "耐力药水", "千万战痕合剂" } },
        Potions = {
            { "延时之力药水", "延时之力药水" },
            { "Agility", "德拉诺敏捷药水" },
            { "全能药剂", "德拉诺全能药水" },
            { "致命优雅药水", "致命优雅药水" },
            { "上古战神药水", "上古战神药水" }
        }
    }
}
local GetShapeshiftForm_Trampoline = GetShapeshiftForm
GetShapeshiftForm = function()
    local ShapeshiftForm = GetShapeshiftForm_Trampoline()
    local Class = select(2, UnitClass("Player"))
    local Spec = GetSpecialization()
    return ShapeshiftForm
end
function AddFlasksOptions()
    if Player:Level() >= 100 and Player:Specialization() ~= nil then
        local ModeValue = SpecsStats[Player:Specialization()].Flasks
        local FlaskValues = { 1, { "邪能焦镜", "改装的邪能焦镜" } }
        for i = 1, #ModeValue do
            table.insert(FlaskValues, ModeValue[i])
        end
        AddNewOption(
        "常规",
        { "自动喝药", "烧瓶" },
        232,
        false,
        FlaskValues,
        { 4.5, 0, 5, 0.05 },
        {
            "Use Flask in combat." ..
            C.TOOLTIP_VALUE_1 ..
            "Which kind of Flask do we want to use." ..
            C.TOOLTIP_VALUE_2 ..
            "Time on Boss Mode timer at which we want to use Flask if we do not have the buff already.",
            "在战斗中使用烧瓶。" .. C.TOOLTIP_VALUE_1 .. "我们想要使用哪种烧瓶。" .. C.TOOLTIP_VALUE_2 .. "如果我们没有光环，DBM计时器的时间在我们想要使用烧瓶。"
        }
        )
    end
end
function AddPotionsOption()
    if Player:Level() >= 100 and Player:Specialization() ~= nil then
        local ModeValue = SpecsStats[Player:Specialization()].Potions
        local PotionsValues = { 1 }
        for i = 1, #ModeValue do
            table.insert(PotionsValues, ModeValue[i])
        end
        AddNewOption(
        "常规",
        { "使用药水", "用药水" },
        233,
        false,
        { 4, { "无条件使用", "总是" }, { "大技能", "冷却时间" }, { "英勇BUFF", "英雄主义" }, { "副本BOSS英勇", "英雄主义袭击老板" }, { "副本BOSS", "袭击老板" } },
        PotionsValues,
        {
            "Use Potions during combat." ..
            C.TOOLTIP_VALUE_1 ..
            "Choose when you want to use potions." ..
            C.TOOLTIP_SUBVALUE("无条件使用") ..
            "Always during combat." ..
            C.TOOLTIP_SUBVALUE("大技能") ..
            "Always when Cooldowns are enabled." ..
            C.TOOLTIP_SUBVALUE("英勇BUFF") ..
            "Use during Heroism." ..
            C.TOOLTIP_SUBVALUE("副本BOSS英勇") ..
            "Use during Heroism while fighting a Raid Encounter." ..
            C.TOOLTIP_SUBVALUE("副本BOSS") ..
            "Use Anytime during a Raid Encounter." ..
            C.TOOLTIP_VALUE_2 ..
            "Which potions would you like to use." ..
            C.TOOLTIP_HINT(
            "The same potion type will be used in the Pre-Pot handler."
            ),
            "在战斗中使用药水。" ..
            C.TOOLTIP_VALUE_1 ..
            "选择何时使用药水。" ..
            C.TOOLTIP_SUBVALUE("总是") ..
            "总是在战斗中。" ..
            C.TOOLTIP_SUBVALUE("冷却时间") ..
            "始终在启用冷却时间。" ..
            C.TOOLTIP_SUBVALUE("英雄主义") ..
            "在英雄主义期间使用。" ..
            C.TOOLTIP_SUBVALUE("英雄主义袭击老板") ..
            "在英雄主义期间使用，同时打击突击相遇。" ..
            C.TOOLTIP_SUBVALUE("袭击老板") ..
            "在袭击过程中随时使用。" ..
            C.TOOLTIP_VALUE_2 ..
            "你想要使用哪些药水？" ..
            C.TOOLTIP_HINT("相同的药水类型将被用于前锅老板模。")
        }
        )
    end
end
EventFrame:RegisterForSelfCombatEvent(
function(...)
    SpellID = select(12, ...)
    if SpellID == WaitForOpenerSpell then
        OpenerStep = OpenerStep + 1
    end
end,
"SPELL_CAST_SUCCESS"
)
OpenerStep = 1
function OpenerParser(OpenerTable)
    if OpenerStep > #OpenerTable - 1 then
        Bug("Opener Ended at Step " .. tostring(OpenerStep))
        OpenerEnded = true
        return
    end
    if OpenerTable[OpenerStep][1] == "Trinkets" then
        OpenerStep = OpenerStep + 1
        Player:UseTrinkets()
    elseif OpenerTable[OpenerStep][1] == "Racials" then
        for i = 1, #OpenerTable[OpenerStep][2] do
            ThisSpell = OpenerTable[OpenerStep][2][i]
            if ThisSpell and ThisSpell:Exists() and Player:CanCast(ThisSpell) then
                Bug(OpenerTable[#OpenerTable] .. " Step(Racial): " .. tostring(OpenerStep))
                Player:Cast(ThisSpell)
                OpenerStep = OpenerStep + 1
                return
            end
        end
        OpenerStep = OpenerStep + 1
    else
        OpenerSpell, OpenerTarget, OpenerConditions, OpenerSkip =         OpenerTable[OpenerStep][1],
        OpenerTable[OpenerStep][2],
        OpenerTable[OpenerStep][3],
        OpenerTable[OpenerStep][4]
        if not OpenerSpell:Exists() then
            OpenerStep = OpenerStep + 1
            Bug(OpenerSpell:Name() .. "[" .. tostring(OpenerStep - 1) .. "] was skipped as it is not known.")
            return
        end
        if OpenerSpell:Cooldown() > 1.5 then
            OpenerStep = OpenerStep + 1
            Bug(OpenerSpell:Name() .. "[" .. tostring(OpenerStep - 1) .. "] was skipped as it was on Cooldown.")
            return
        end
        if OpenerSkip == true then
            OpenerStep = OpenerStep + 1
            Bug(
            OpenerSpell:Name() ..
            "[" .. tostring(OpenerStep - 1) .. "] was skipped as it's requirements were not met.[1]"
            )
            return
        end
        if OpenerConditions ~= true then
            OpenerStep = OpenerStep + 1
            Bug(
            OpenerSpell:Name() ..
            "[" .. tostring(OpenerStep - 1) .. "] was skipped as it's requirements were not met.[2]"
            )
            return
        end
        if OpenerSpell:Exists() and OpenerTarget:CanCast(OpenerSpell) then
            Bug(OpenerTable[#OpenerTable] .. " Step: " .. tostring(OpenerStep))
            WaitForOpenerSpell = OpenerSpell:ID()
            OpenerTarget:Cast(OpenerSpell)
            return
        end
    end
end
function UpdateOverlay(self, elapsed)
    self:SetSize(_G["ChatFrame1"]:GetWidth(), 30)
    if self.time < GetTime() - 1 then
        if self:GetAlpha() == 0 then
            self:Hide()
        else
            self:SetAlpha(self:GetAlpha() - 0.05)
        end
    end
end
OverlayName = Randomize()
for i = 1, 10 do
    _G[OverlayName .. i] = CreateFrame("Frame", nil, _G["ChatFrame" .. i])
    _G[OverlayName .. i]:SetSize(_G[OverlayName .. i]:GetWidth(), 30)
    _G[OverlayName .. i]:Hide()
    _G[OverlayName .. i]:SetPoint("TOP", 0, 0)
    _G[OverlayName .. i].text = _G[OverlayName .. i]:CreateFontString(nil, "OVERLAY", "MovieSubtitleFont")
    _G[OverlayName .. i].text:SetAllPoints()
    _G[OverlayName .. i].texture = _G[OverlayName .. i]:CreateTexture()
    _G[OverlayName .. i].texture:SetAllPoints()
    _G[OverlayName .. i].texture:SetTexture(0, 0, 0, 0.7)
    _G[OverlayName .. i].time = 0
    _G[OverlayName .. i]:SetScript("OnUpdate", UpdateOverlay)
end
function Overlay(Message)
    if GetSetting("聊天栏上层信息_Checked") then
        for i = 1, 10 do
            _G[OverlayName .. i]:SetSize(_G["ChatFrame1"]:GetWidth(), 30)
            _G[OverlayName .. i].text:SetText(Message)
            _G[OverlayName .. i]:SetAlpha(1)
            _G[OverlayName .. i].time = GetTime()
            _G[OverlayName .. i]:Show()
        end
    end
end
function CDOptionEnabled(OptionName)
    return IsOptionEnabled(OptionName) and
    (GetOptionValue(OptionName) == "无条件使用" or (GetOptionValue(OptionName) == "大技能用法" and CooldownsAllowed()) or
    (GetOptionValue(OptionName) == "Boss中无条件使用" and Target:IsBossTarget()) or
    (GetOptionValue(OptionName) == "Boss中大技能用法" and Target:IsBossTarget() and CooldownsAllowed()))
end
function NumbersInString(String)
    local Numbers = {}
    String = String:gsub("%,", "")
    local Position = String:find("%d+")
    local Number
    while Position do
        Number = String:match("%d+")
        table.insert(Numbers, Number)
        String = String:sub(Position + Number:len())
        Position = String:find("%d+")
    end
    return Numbers
end
ScanningTooltip = CreateFrame("GameTooltip", "MyScanningTooltip", nil, "GameTooltipTemplate")
ScanningTooltip:SetOwner(_G["WorldFrame"], "ANCHOR_NONE")
ScanningTooltip:AddFontStrings(
ScanningTooltip:CreateFontString("$parentTextLeft1", nil, "GameTooltipText"),
ScanningTooltip:CreateFontString("$parentTextRight1", nil, "GameTooltipText")
)
function GetNumbers()
    local String, Text, TextString = "", "", ""
    for Index = 1, 6 do
        Text = _G["MyScanningTooltipTextLeft" .. Index]
        if Text then
            TextString = Text:GetText()
            if TextString then
                String = String .. TextString
            else
                break
            end
        else
            break
        end
    end
    return NumbersInString(String)
end
function GetNumbersForAuraIndex(Unit, Index)
    ScanningTooltip:SetUnitAura(Unit, Index, "Player")
    return GetNumbers()
end
function GetNumbersForAura(Other, Spell)
    local SpellID = Spell:ID()
    for Index = 1, C.MAXIMUM_BUFFS do
        if select(11, UnitAura(Other.UnitID, Index)) == SpellID then
            return GetNumbersForAuraIndex(Other.UnitID, Index)
        end
    end
end
function GetNumbersForBuffIndex(Unit, Index)
    ScanningTooltip:SetUnitBuff(Unit, Index, "Player")
    return GetNumbers()
end
function GetNumbersForBuff(Other, Spell)
    local SpellID = Spell:ID()
    for Index = 1, C.MAXIMUM_BUFFS do
        if select(11, UnitBuff(Other.UnitID, Index)) == SpellID then
            return GetNumbersForBuffIndex(Other.UnitID, Index)
        end
    end
end
function GetNumbersForDebuffIndex(Unit, Index)
    ScanningTooltip:SetUnitDebuff(Unit, Index, "Player")
    return GetNumbers()
end
function GetNumbersForDebuff(Other, Spell)
    local SpellID = Spell:ID()
    for Index = 1, C.MAXIMUM_BUFFS do
        if select(11, UnitDebuff(Other.UnitID, Index)) == SpellID then
            return GetNumbersForDebuffIndex(Other.UnitID, Index)
        end
    end
end
function math.round(number, decimal)
    local multiplier = 10 ^ (decimal or 0)
    return math.floor(number * multiplier + 0.5) / multiplier
end
CompareThisTable = {[">"] = function(A, B)
    return A > B
end, ["<"] = function(A, B)
    return A < B
end, [">="] = function(A, B)
    return A >= B
end, ["<="] = function(A, B)
    return A <= B
end, ["=="] = function(A, B)
    return A == B
end }
function CompareThis(Operator, A, B)
    return CompareThisTable[Operator](A, B)
end
CurrentBuildInfo = { GetBuildInfo() }
function Pre72Build()
    return CurrentBuildInfo[1] ~= "7.2.0" and CurrentBuildInfo[1] ~= "7.2.5"
end
function LiveRealmBuild()
    return CurrentBuildInfo[1] == "7.2.0"
end
function PTRRealmBuild()
    return CurrentBuildInfo[1] == "7.2.5"
end
function BetaRealmBuild()
    return CurrentBuildInfo[1] == "7.2.5"
end
if Pre72Build() then
    Enum = {}
    Enum.PowerType = {
        Mana = SPELL_POWER_MANA,
        Rage = SPELL_POWER_RAGE,
        Focus = SPELL_POWER_FOCUS,
        Energy = SPELL_POWER_ENERGY,
        ComboPoints = SPELL_POWER_COMBO_POINTS,
        Runes = SPELL_POWER_RUNES,
        RunicPower = SPELL_POWER_RUNIC_POWER,
        SoulShards = SPELL_POWER_SOUL_SHARDS,
        LunarPower = SPELL_POWER_LUNAR_POWER,
        HolyPower = SPELL_POWER_HOLY_POWER,
        Alternate = SPELL_POWER_ALTERNATE_POWER,
        Maelstrom = SPELL_POWER_MAELSTROM,
        Chi = SPELL_POWER_CHI,
        Insanity = SPELL_POWER_INSANITY,
        ArcaneCharges = SPELL_POWER_ARCANE_CHARGES,
        Fury = SPELL_POWER_FURY,
        Pain = SPELL_POWER_PAIN,
        Obsolete = SPELL_POWER_OBSOLETE,
        Obsolete2 = SPELL_POWER_OBSOLETE2
    }
elseif LiveRealmBuild() then
    Enum.PowerType = {
        Mana = SPELL_POWER_MANA,
        Rage = SPELL_POWER_RAGE,
        Focus = SPELL_POWER_FOCUS,
        Energy = SPELL_POWER_ENERGY,
        ComboPoints = SPELL_POWER_COMBO_POINTS,
        Runes = SPELL_POWER_RUNES,
        RunicPower = SPELL_POWER_RUNIC_POWER,
        SoulShards = SPELL_POWER_SOUL_SHARDS,
        LunarPower = SPELL_POWER_LUNAR_POWER,
        HolyPower = SPELL_POWER_HOLY_POWER,
        Alternate = SPELL_POWER_ALTERNATE_POWER,
        Maelstrom = SPELL_POWER_MAELSTROM,
        Chi = SPELL_POWER_CHI,
        Insanity = SPELL_POWER_INSANITY,
        ArcaneCharges = SPELL_POWER_ARCANE_CHARGES,
        Fury = SPELL_POWER_FURY,
        Pain = SPELL_POWER_PAIN,
        Obsolete = SPELL_POWER_OBSOLETE,
        Obsolete2 = SPELL_POWER_OBSOLETE2
    }
end
local ArtifactsInitialized = false
local ShouldCollect = 0
local Rotation
local IsAuthorized = nil
local function Pulse()
    xpcall(
    function()
        UnitsEngine.Update()
        MemorizedGetTime = GetRealTime()
        if SpellIsTargeting() and NoPathCleared == false and NoPathTime > GetTime() then
            NoPathCleared = true
            SpellStopTargeting()
        end
        if not ArtifactsInitialized then
            ArtifactsInit()
        end
        Queue.Parse()
        if InLoadingScreen > GetTime() then
            return
        end
        if GetTime() > TTD.Throttle then
            TTD.Throttle = GetTime() + TTD.Settings.Refresh
            TTDRefresh()
        end
        if Settings.Initialized then
            ActionLogUpdate()
            Rotation = Rotations[Player:Specialization()]
            if PetBattlesAuthorized and IsOptionEnabled("自动宠物对战") and not Player:IsInCombat() then
                PetBattles.Rotation()
            end
            if Rotation ~= nil then
                Rotations:Init(Rotation)
                DebugFrame:Update()
                CustomFrame:Update()
                SetCommonMeleeStatus()
                AutoProfilesChanger()
                IsAuthorized = Authorized()
                if EngineRunning then
                    if not IsAuthorized then
                        StatusUpdate(
                        Locale == "zh" and "|cFFFE2E2E哎呀！ 看起来你不拥有这个旋转。" or
                        "|cFFFE2E2EPOops! It looks like you do not own this Rotation."
                        )
                        SetRunning(false)
                        return
                    end
                    if PauseRotation == true then
                        if
                        SpellStartCastingTime and
                        GetTime() - SpellStartCastingTime >
                        0.5 + select(4, GetSpellInfo(StartedSpell)) / 1000
                        then
                            Bug("Spell Timed Out: |cFF0040FFRotation Resumed. SpellID: " .. StartedSpell)
                            PauseRotation = false
                        end
                        return
                    elseif type(PauseRotation) == "number" then
                        if PauseRotation > GetTime() then
                            return
                        else
                            PauseRotation = false
                        end
                    end
                    if IsOptionEnabled("AFK时暂停循环") and Player:IsAFK() and GetCVar("autoClearAFK") == "1" then
                        return
                    end
                    if IsOptionEnabled("聊天时暂停循环") and _G["ChatEdit_GetActiveWindow"]() then
                        return
                    end
                    if IsOptionEnabled("忽略敌对玩家") and Target:IsPlayer() and Player:CanAttack(Target) then
                        return
                    end
                    PulseControl:Check()
                    if PulseControl.IsInControl == "Complete" then
                        WipeTable(UnitInfoCache)
                        WipeTable(SpellsTable)
                        WipeTable(AurasTable)
                        Player:UseFlask()
                        Rotation:Pulse()
                    end
                else
                    if EngineRunning then
                        message(Locale == "zh" and "不支持此专业化。" or "This Specialization is not supported.")
                        SetRunning(false)
                    end
                end
            end
        end
    end,
    LUAErrorHandler
    )
end
function LUAErrorHandler(errormsg)
    Toolbox.TitleBar.LuaErrorButton.Error(true)
    if not ErrorTime or GetTime() - ErrorTime > 5 then
        local ErrorMsg = ParseError(errormsg)
        local Stacks = ParseError(_G["debugstack"](2))
        ErrorTime = GetRealTime()
        local String = ""
        local function WriteLine(Line)
            String = String .. Line .. "\n"
        end
        local ClassName = select(2, UnitClass("player"))
        local CurrentSpec = GetSpecialization()
        local CurrentSpecName = CurrentSpec and select(2, GetSpecializationInfo(CurrentSpec)) or UnitClass("Player")
        local CurrentProfile = "" .. ProfileName
        WriteLine("Rotation File Version: " .. RotationFileVersion)
        WriteLine("WoW Version: " .. CurrentBuildInfo[1])
        WriteLine("Unlocker Used: " .. Unlocker)
        WriteLine("Character Level: " .. UnitLevel("player"))
        WriteLine("Race: " .. _G["UnitRace"]("player"))
        WriteLine("Class: " .. ClassName)
        WriteLine("Spec: " .. CurrentSpecName)
        WriteLine("Profile: " .. CurrentProfile)
        WriteLine("Time Of Error: " .. _G["date"]("%m/%d/%y %H:%M:%S"))
        WriteLine("Zone: " .. _G["GetRealZoneText"]())
        WriteLine("Error Message: " .. ErrorMsg)
        WriteLine("Stacks : " .. Stacks)
        WF(C.PROFILESPATH .. "../../" .. ClassName .. "" .. CurrentSpecName .. " - Error.txt", String)
        Error(
        DisplayName ..
        " has encountered an Error that may be affecting performance. Please report the contents of '" ..
        ClassName ..
        "" ..
        CurrentSpecName ..
        " - Error.txt' in your /Errors/ folder on our website's forum or to one of our developer's on Discord so that we can fix it."
        )
    end
end
function RemoveVariable(ThisString, RemoveThis)
    local LeftPosition, RightPosition, Before, After, Trial = nil, nil, "", "", 0
    while string.find(ThisString, RemoveThis) ~= nil and Trial < 20 do
        LeftPosition = string.find(ThisString, RemoveThis)
        RightPosition = string.find(ThisString, '"', LeftPosition + string.len(RemoveThis) + 5)
        if LeftPosition ~= nil and RightPosition ~= nil then
            Before = string.sub(ThisString, 1, LeftPosition - 1)
            After = string.sub(ThisString, RightPosition + 5, -1)
            ThisString = Before .. After
        end
        Trial = Trial + 1
    end
    return ThisString
end
function ParseError(ThisString)
    ThisString = RemoveVariable(ThisString, "GetUserName")
    ThisString = RemoveVariable(ThisString, "GetCalqKey")
    ThisString = RemoveVariable(ThisString, "GetMembershipKey")
    return ThisString
end
function WipeTable(Table)
    for Key, Value in pairs(Table) do
        Table[Key] = nil
    end
end
local LoadStartTime = GetTime()
function ArtifactsInit()
    if GetTime() - LoadStartTime > 5 then
        ArtifactsInitialized = true
        ArtifactScan()
        print("[|cFFFF0000" .. DisplayName .. "|r] " .. (Locale == "zh" and "工件初始化" or "神器初始化"))
    end
end
CoreFrame = CreateFrame("Frame", Randomize(24))
CoreFrame:SetScript("OnUpdate", Pulse)
CoreFrame:Show()
Queue = CreateFrame("Frame", Randomize())
function Queue.Parse()
    if Queue.SpellToCast then
        local Start, Duration
        if Queue.SpellToCast ~= "trinket1" and Queue.SpellToCast ~= "trinket2" then
            Start, Duration = GetSpellCooldown(Queue.SpellToCast)
            if EngineRunning and Player:IsReady() and Start == 0 then
                if Queue.MouseoverCast and Queue.MouseoverCast > GetTime() then
                    local FoundUnit = nil
                    for i = 1, #UnitsEngine.Units.Hostile do
                        if FoundUnit == nil and UnitsEngine.Units.Hostile[i]:GUID() == Queue.MouseoverUnit then
                            FoundUnit = UnitsEngine.Units.Hostile[i]
                        end
                    end
                    for i = 1, #UnitsEngine.Units.Healing do
                        if FoundUnit == nil and UnitsEngine.Units.Healing[i]:GUID() == Queue.MouseoverUnit then
                            FoundUnit = UnitsEngine.Units.Healing[i]
                        end
                    end
                    if FoundUnit ~= nil then
                        QueueSystem(
                        Locale == "zh" and "铸件 " .. Queue.SpellToCast .. " 在鼠标悬停单元上 (" .. FoundUnit:Name() .. ")" or
                        "Casting " .. Queue.SpellToCast .. " on Mouseover unit (" .. FoundUnit:Name() .. ")"
                        )
                        CastSpellByName(Queue.SpellToCast, FoundUnit.UnitID)
                        LastSpell = Queue.SpellToCast
                        Queue.MouseoverCast = nil
                        Queue.SpellToCast = nil
                        return true
                    end
                else
                    CastSpellByName(Queue.SpellToCast)
                    LastSpell = Queue.SpellToCast
                    if Queue.MouseCast and Queue.MouseCast > GetTime() then
                        if SpellIsTargeting() then
                            QueueSystem(
                            Locale == "zh" and "铸件 " .. Queue.SpellToCast .. " 光标" or
                            "Casting " .. Queue.SpellToCast .. " on Cursor"
                            )
                            CameraOrSelectOrMoveStart()
                            CameraOrSelectOrMoveStop()
                            SpellStopTargeting()
                            Queue.MouseCast = nil
                            Queue.Time = nil
                            Queue.SpellToCast = nil
                            return true
                        end
                    end
                    QueueSystem(Locale == "zh" and "铸件 " .. Queue.SpellToCast or "Casting " .. Queue.SpellToCast)
                    Queue.SpellToCast = nil
                    return true
                end
            end
        else
            Start, Duration = GetInventoryItemCooldown("player", Queue.SpellToCast == "trinket1" and 13 or 14)
            if EngineRunning and Player:IsReady() and Start == 0 then
                QueueSystem(Locale == "zh" and "铸件 " .. Queue.SpellToCast or "Casting " .. Queue.SpellToCast)
                if Queue.SpellToCast == "trinket1" then
                    local Trinket1 = Item(13, false, false, true)
                    Trinket1:UseInventory()
                elseif Queue.SpellToCast == "trinket2" then
                    local Trinket2 = Item(14, false, false, true)
                    Trinket2:UseInventory()
                end
                LastSpell = Queue.SpellToCast
                Queue.SpellToCast = nil
                Queue.MouseCast = nil
                Queue.Time = nil
                return true
            end
        end
        if Start + Duration - GetTime() > 1.4 then
            QueueSystem(
            Locale == "zh" and "删除 " .. Queue.SpellToCast .. " 从排队，因为它在冷却时间。" or
            "Removing " .. Queue.SpellToCast .. " from the queue as it is on cooldown."
            )
            Queue.SpellToCast = nil
            Queue.MouseCast = nil
            Queue.Time = nil
        end
        if Queue.Time and Queue.Time < GetTime() then
            QueueSystem(
            Locale == "zh" and "删除 " .. Queue.SpellToCast .. "从排队，因为它是队列3秒钟。" or
            "Removing " .. Queue.SpellToCast .. " from the queue as it's been 3 seconds since it was queued."
            )
            Queue.SpellToCast = nil
            Queue.MouseCast = nil
            Queue.Time = nil
        end
    end
end
function Queue.CastCmd(Spell, MouseCast, MouseoverCast)
    if MouseCast == true then
        Queue.MouseCast = GetTime() + 3
    end
    if MouseoverCast == true then
        Queue.MouseoverCast = GetTime() + 3
        Queue.MouseoverUnit = Mouseover:GUID()
    end
    if EngineRunning then
        if GetSpellInfo(Spell) then
            if Queue.SpellToCast == Spell then
                return
            end
            local Start, Duration = GetSpellCooldown(Spell)
            TriggerTime = GetTime()
            if Start == 0 then
                Queue.SpellToCast = Spell
                Queue.Time = GetTime() + 3
                QueueSystem(Locale == "zh" and "排队 " .. Spell or "Queued " .. Spell)
            elseif Start + Duration - GetTime() < 1.4 then
                Queue.SpellToCast = Spell
                Queue.Time = GetTime() + 3
                QueueSystem("Queued " .. Spell)
            else
                QueueSystem(Locale == "zh" and "排队 " .. Spell or "Queued " .. Spell)
            end
        elseif string.lower(Spell) == "trinket1" then
            if Queue.SpellToCast == Spell then
                return
            end
            local Start, Duration = GetInventoryItemCooldown("player", 13)
            if Start == 0 or Start + Duration - GetTime() < 1.4 then
                Queue.SpellToCast = string.lower(Spell)
                Queue.Time = GetTime() + 3
                QueueSystem(Locale == "zh" and "排队 " .. Spell or "Queued " .. Spell)
            else
                QueueSystem(Spell, "On Cooldown")
            end
        elseif string.lower(Spell) == "trinket2" then
            if Queue.SpellToCast == Spell then
                return
            end
            local Start, Duration = GetInventoryItemCooldown("player", 14)
            if Start == 0 or Start + Duration - GetTime() < 1.4 then
                Queue.SpellToCast = string.lower(Spell)
                Queue.Time = GetTime() + 3
                QueueSystem(Locale == "zh" and "排队 " .. Spell or "Queued " .. Spell)
            else
                QueueSystem(Locale == "zh" and Spell .. " 冷却时间" or Spell .. " On Cooldown")
            end
        else
            QueueSystem(Locale == "zh" and "未知法术: " .. Spell or "Unknown spell: " .. Spell)
        end
    else
        QueueSystem(Locale == "zh" and "脉冲被禁用时不排队法术。" or "Not queueing spells as the pulse is disabled.")
    end
end
function Queue.CancelCmd()
    if Queue.SpellToCast then
        Queue.SpellToCast = nil
        QueueSystem(Locale == "zh" and "已取消队列" or "Queue Canceled")
    else
        QueueSystem(Locale == "zh" and "没有排队的法术" or "No Queued Spell")
    end
end
PulseControl = CreateFrame("Frame", Randomize())
function PulseControl:Check()
    if IsOptionEnabled("暂停自动技能") then
        if self.IsInControl == "Complete" or self.QueuedControl == true then
            if UnitOnTaxi("player") then
                self:DisableControl("Flight Path")
            end
            if not Player:IsInCombat() and IsFlying() then
                self:DisableControl("Flying")
            end
            if Player:IsDeadOrGhost() then
                self:DisableControl("Dying")
            end
            if not Player:IsInCombat() and Player:InVehicle() then
                self:DisableControl("Vehicle")
            end
        end
        if self.QueuedControl == false then
            if self.IsInControl == "Flight Path" and not UnitOnTaxi("player") then
                self:QueueControl(2)
            end
            if self.IsInControl == "Flying" and not IsFlying() and not IsMounted() and not IsFalling() then
                self:QueueControl(2)
            end
            if self.IsInControl == "Dying" and not Player:IsDeadOrGhost() then
                self:QueueControl(2)
            end
            if self.IsInControl == "Vehicle" and not Player:InVehicle() then
                self:QueueControl(2)
            end
        end
        if self.IsInControl ~= "Complete" and self.QueuedControl == true and self.QueuedControlTime < GetTime() then
            self:RestoreControl()
        end
    else
        self.IsInControl, self.QueuedControl, self.QueuedControlTime = "Complete", false, 0
    end
end
PulseControl.IsInControl, PulseControl.QueuedControl, PulseControl.QueuedControlTime = "Loading Screen",
true,
GetRealTime() + 3
function PulseControl:Print(State, Comments)
    if (GetOptionValue("暂停自动技能") == "Chat" or GetOptionValue("暂停自动技能") == "Both") and IsOptionEnabled("聊天栏信息") then
        print(State .. Comments)
    end
    if (GetOptionValue("暂停自动技能") == "Overlay" or GetOptionValue("暂停自动技能") == "Both") and IsOptionEnabled("聊天栏信息") then
        Overlay(State)
    end
end
function PulseControl:DisableControl(Reason)
    self.IsInControl, self.QueuedControl = Reason, false
    self:Print(
    "|cffffffff[|cffcc0000" .. DisplayName .. " - Disabling Control|cffffffff]",
    " Temporarily for " .. self.IsInControl .. "."
    )
end
function PulseControl:QueueControl(Delay)
    self.QueuedControl, self.QueuedControlTime = true, GetTime() + Delay
    self:Print(
    "|cffffffff[|cffffcc00" .. DisplayName .. " - Recovering Control|cffffffff]",
    " In " .. Delay .. " seconds after " .. self.IsInControl .. "."
    )
end
function PulseControl:RestoreControl()
    self:Print(
    "|cffffffff[|cff00ff00" .. DisplayName .. " - Control Restored|cffffffff]",
    " After " .. self.IsInControl .. "."
    )
    self.IsInControl, self.QueuedControl, self.QueuedControlTime = "Complete", false, 0
end
EventFrame:RegisterForEvent(
function()
    PulseControl:DisableControl("Loading Screen")
end,
"LOADING_SCREEN_ENABLED"
)
EventFrame:RegisterForEvent(
function()
    if PulseControl.IsInControl == "Loading Screen" then
        PulseControl:QueueControl(4)
    end
end,
"LOADING_SCREEN_DISABLED"
)
EventFrame:RegisterForEvent(
function()
    PulseControl:DisableControl("Looting")
end,
"LOOT_OPENED"
)
EventFrame:RegisterForEvent(
function()
    if PulseControl.IsInControl == "Looting" and not PulseControl.QueuedControl then
        PulseControl:QueueControl(0.75)
    end
end,
"LOOT_CLOSED"
)
EventFrame:RegisterForEvent(
function(Arg1, Arg2, Arg3, Arg4, Arg5)
    if Arg1 == "player" and Event == "UNIT_SPELLCAST_START" then
        if Arg5 == 170691 then
            PulseControl:DisableControl("Gathering Herb")
        end
        if Arg5 == 170599 then
            PulseControl:DisableControl("Gathering Mineral")
        end
        if Arg5 == 158756 then
            PulseControl:DisableControl("Skinning")
        end
    end
end,
"UNIT_SPELLCAST_START"
)
EventFrame:RegisterForEvent(
function(Arg1, Arg2, Arg3, Arg4, Arg5)
    if Arg1 == "player" and Event == "UNIT_SPELLCAST_STOP" then
        if PulseControl.IsInControl == "Gathering Herb" and Arg5 == 170691 then
            PulseControl:QueueControl(0.5)
        end
        if PulseControl.IsInControl == "Gathering Mineral" and Arg5 == 170599 then
            PulseControl:QueueControl(0.5)
        end
        if PulseControl.IsInControl == "Skinning" and Arg5 == 158756 then
            PulseControl:QueueControl(0.5)
        end
    end
end,
"UNIT_SPELLCAST_STOP"
)
EventFrame:RegisterForEvent(
function(...)
    PulseControl:DisableControl("Talents Changed")
    PulseControl:QueueControl(5)
end,
"ACTIVE_TALENT_GROUP_CHANGED"
)
EventFrame:RegisterForEvent(
function(...)
    if select(1, ...) == "player" then
        PulseControl:DisableControl("Specialization Changed")
        PulseControl:QueueControl(5)
    end
end,
"PLAYER_SPECIALIZATION_CHANGED"
)
SetRotation("DRUID", {})
local Rotation = Rotations["DRUID"]
function Rotation:Initialize()
    Berserking = Spell(26297, false, false, true)
    CatForm = Spell(768, false, false, true)
    FerociousBite = Spell(22568, true, true, true)
    Moonfire = Spell(8921, true, true, true)
    MoonfireDebuff = Spell(164812)
    Rake = Spell(1822, true, true, true)
    RakeDebuff = Spell(155722)
    Shred = Spell(5221, true, true, true)
    SolarWrath = Spell(190984, true, true, false)
    AddPage("常规")
    AddCommonOptions()
    AddSection("常规", "常规", "Green")
    AddNewOption(
    "常规",
    "目标 | 攻击",
    133,
    true,
    { 4, "禁用", "距离最近", "血量最少", "血量最多", "目标附近" },
    { 2, "禁用", "启用" },
    "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target." ..
    C.TOOLTIP_VALUE_1 ..
    C.TOOLTIP_SUBVALUE("距离最近", true) ..
    "Target the closest enemy." ..
    C.TOOLTIP_SUBVALUE("血量最少") ..
    "Target the enemy with the least health remaining." ..
    C.TOOLTIP_SUBVALUE("血量最多") ..
    "Target the enemy with the most health remaining." ..
    C.TOOLTIP_SUBVALUE("目标附近") ..
    "Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining." ..
    C.TOOLTIP_VALUE_2 ..
    "Enable for the automatic usage of /startattack." ..
    C.TOOLTIP_HINT("/startattack is good for melee classes.")
    )
    AddNewOption(
    "常规",
    "动态切换目标",
    232,
    true,
    { 1, "保持", "变化" },
    { 30, 5, 30, 1 },
    "Attack units that are closer around the player when the actual target is out of range." ..
    C.TOOLTIP_VALUE_1 ..
    "Choose preferred Dynamic Mode." ..
    C.TOOLTIP_SUBVALUE("保持", true) ..
    "Never change target but attack units around the player." ..
    C.TOOLTIP_SUBVALUE("变化") ..
    "Change target to units around the player." ..
    C.TOOLTIP_VALUE_2 ..
    "Use Dynamic Targetting when our range to the target is farter than this value."
    )
    AddNewOption("常规", "自动进入战斗", 210, true, nil, nil, "Run the combat logic even when out of combat.")
    AddNewOption("常规", "Cat Form", 210, true, nil, nil, "Automatically Shapeshift into Cat Form.")
    if Berserking:Exists() then
        AddSection("常规", "Offensive Cooldowns", "Green")
        AddNewOption(
        "常规",
        "进攻性种族技能",
        230,
        true,
        { 1, "无条件使用", "大技能用法" },
        nil,
        "Enable for the automatic usage of Racials." ..
        C.TOOLTIP_VALUE ..
        C.TOOLTIP_SUBVALUE("无条件使用", true) ..
        "Will use the ability even if CDs are disabled." ..
        C.TOOLTIP_SUBVALUE("大技能用法") .. "Will only use the ability if CDs are enabled."
        )
    end
    AddSection("常规", "Defensive Items", "Green")
    AddNewOption(
    "常规",
    "治疗物品",
    220,
    true,
    { 35, 1, 95, 1 },
    nil,
    "Use Healing Belt / Healing Pot / Healthstone." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
end
function Rotation:Events()
end
function Rotation:Pulse()
    if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
        return
    end
    if GetTime() < Rotation.SpamPrevention then
        return
    end
    Rotation.SpamPrevention = GetTime() + 0.05
    Target = Unit.Target
    local InCombat = Player:IsInCombat()
    if not InCombat then
        self:OutOfCombat()
        return
    end
    if InCombat then
        self:Defensives()
    end
    Target = Player:ReTarget(Shred, false) or Unit.Target
    if Target:Exists() then
        Rotations:RefreshUnitTables(Rotation.Identifier)
        self:OffGCDAbilities()
        if Player:GlobalCooldown() == 0 then
            self:Combat()
        end
    end
end
function Rotation:Defensives()
    Player:UseHealingItem()
end
function Rotation:OffGCDAbilities()
end
function Rotation:UnitTables()
end
function Rotation:Combat()
    if CatForm:Exists() and IsOptionEnabled("Cat Form") and not Player:Buff(CatForm) and Player:CanCast(CatForm) then
        Player:Cast(CatForm)
        return
    end
    if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        if Player:Buff(CatForm) then
            if Player:IsWithinCastRange(Target, Shred) then
                if IsOptionEnabled("进攻性种族技能") and (CooldownsAllowed() or GetOptionValue("进攻性种族技能") == "无条件使用") then
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        Player:Cast(Berserking)
                    end
                end
            end
            if FerociousBite:Exists() and Player:ComboPoints() >= 2 and Target:CanCast(FerociousBite) then
                Target:Cast(FerociousBite)
                return
            end
            if Rake:Exists() and not Target:Debuff(RakeDebuff) and Target:CanCast(Rake) then
                Target:Cast(Rake)
                return
            end
            if Shred:Exists() and Target:CanCast(Shred) then
                Target:Cast(Shred)
                return
            end
        else
            if Moonfire:Exists() and not Target:Debuff(MoonfireDebuff) and Target:CanCast(Moonfire) then
                Target:Cast(Moonfire)
                return
            end
            if SolarWrath:Exists() and Target:CanCast(SolarWrath) then
                Target:Cast(SolarWrath)
                return
            end
        end
    end
end
function Rotation:OutOfCombat()
    if CatForm:Exists() and IsOptionEnabled("Cat Form") and not Player:Buff(CatForm) and Player:CanCast(CatForm) then
        Player:Cast(CatForm)
        return
    end
    if IsOptionEnabled("自动进入战斗") then
        self:Combat()
    end
end
SetRotation("HUNTER", {})
local Rotation = Rotations["HUNTER"]
function Rotation:Initialize()
    ArcaneTorrent = Spell(80483, false, false, true)
    BloodFury = Spell(20572, false, false, true)
    Berserking = Spell(26297, false, false, true)
    GiftOfTheNaaru = Spell(59543, false, false, true)
    CobraShot = Spell(193455, true, true, false)
    ConcussiveShot = Spell(5116, true, true, true)
    KillCommand = Spell(34026, false, true, true)
    CallPets = {
        Spell(883, false, false, true),
        Spell(83242, false, false, true),
        Spell(83243, false, false, true),
        Spell(83244, false, false, true),
        Spell(83245, false, false, true)
    }
    MendPet = Spell(982, false, false, true)
    MendPetBuff = Spell(136, false, false, true)
    RevivePet = Spell(982, false, false, false)
    AddPage("常规")
    AddCommonOptions()
    AddSection("常规", "常规", "Yellow")
    AddNewOption(
    "常规",
    "目标 | 攻击",
    133,
    true,
    { 4, "禁用", "距离最近", "血量最少", "血量最多", "目标附近" },
    { 2, "禁用", "启用" },
    "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target." ..
    C.TOOLTIP_VALUE_1 ..
    C.TOOLTIP_SUBVALUE("距离最近", true) ..
    "Target the closest enemy." ..
    C.TOOLTIP_SUBVALUE("血量最少") ..
    "Target the enemy with the least health remaining." ..
    C.TOOLTIP_SUBVALUE("血量最多") ..
    "Target the enemy with the most health remaining." ..
    C.TOOLTIP_SUBVALUE("目标附近") ..
    "Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining." ..
    C.TOOLTIP_VALUE_2 ..
    "Enable for the automatic usage of /startattack." ..
    C.TOOLTIP_HINT("/startattack is good for melee classes.")
    )
    AddNewOption(
    "常规",
    "动态切换目标",
    232,
    true,
    { 1, "保持", "变化" },
    { 30, 5, 30, 1 },
    "Attack units that are closer around the player when the actual target is out of range." ..
    C.TOOLTIP_VALUE_1 ..
    "Choose preferred Dynamic Mode." ..
    C.TOOLTIP_SUBVALUE("保持", true) ..
    "Never change target but attack units around the player." ..
    C.TOOLTIP_SUBVALUE("变化") ..
    "Change target to units around the player." ..
    C.TOOLTIP_VALUE_2 ..
    "Use Dynamic Targetting when our range to the target is farter than this value."
    )
    AddNewOption("常规", "自动进入战斗", 210, true, nil, nil, "Run the combat logic even when out of combat.")
    AddNewOption(
    "常规",
    "自动召唤/复活宠物",
    222,
    true,
    { 3, 1, 25, 0.5 },
    { 1, 1, 1, 1 },
    "Automatically Whistle/Revive your Pet." ..
    C.TOOLTIP_VALUE_1 ..
    " How long would you like to wait before using Whistle when your pet is dismissed." ..
    C.TOOLTIP_VALUE_2 .. "Which pet you would like to auto summon? (Only 1 enabled for leveling 1-10)"
    )
    if ArcaneTorrent:Exists() or Berserking:Exists() or BloodFury:Exists() then
        AddSection("常规", "Offensive Cooldowns", "Yellow")
        AddNewOption(
        "常规",
        "进攻性种族技能",
        230,
        true,
        { 1, "无条件使用", "大技能用法" },
        nil,
        "Enable for the automatic usage of Racials." ..
        C.TOOLTIP_VALUE ..
        C.TOOLTIP_SUBVALUE("无条件使用", true) ..
        "Will use the ability even if CDs are disabled." ..
        C.TOOLTIP_SUBVALUE("大技能用法") .. "Will only use the ability if CDs are enabled."
        )
    end
    AddSection("常规", "Offensive Abilities", "Yellow")
    AddNewOption("常规", "震荡射击", 210, false, nil, nil, "Maintain Concussive Shot on our current target.")
    AddSection("常规", "Defensive Items", "Yellow")
    AddNewOption(
    "常规",
    "治疗物品",
    220,
    true,
    { 35, 1, 95, 1 },
    nil,
    "Use Healing Belt / Healing Pot / Healthstone." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddSection("常规", "Defensive Abilities", "Yellow")
    if GiftOfTheNaaru:Exists() then
        AddNewOption(
        "常规",
        "纳鲁的赐福",
        220,
        true,
        { 50, 1, 100, 1 },
        nil,
        "Use Gift Of The Naaru." .. C.TOOLTIP_VALUE .. "Health threshold."
        )
    end
    AddNewOption(
    "常规",
    "治疗宠物",
    222,
    true,
    { 35, 0, 100, 1 },
    { 85, 0, 100, 1 },
    "Enable use of Mend Pet when pet health fall under threshold." ..
    C.TOOLTIP_VALUE_1 .. "In combat threshold." .. C.TOOLTIP_VALUE_2 .. "Out of combat threshold."
    )
end
function Rotation:Events()
    PetDismissed = 0
    EventFrame:RegisterForSelfCombatEvent(
    function(...)
        if select(12, ...) == 2641 then
            PetDismissed = GetTime() + 5
        end
    end,
    "SPELL_CAST_SUCCESS"
    )
end
function Rotation:Pulse()
    if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
        return
    end
    if GetTime() < Rotation.SpamPrevention then
        return
    end
    Rotation.SpamPrevention = GetTime() + 0.05
    Target = Unit.Target
    local InCombat = Player:IsInCombat()
    if not InCombat then
        self:OutOfCombat()
        return
    end
    if InCombat then
        self:Defensives()
    end
    Target = Player:ReTarget(CobraShot, false) or Unit.Target
    if Target:Exists() then
        Rotations:RefreshUnitTables(Rotation.Identifier)
        self:OffGCDAbilities()
        if Player:GlobalCooldown() == 0 then
            self:Combat()
        end
    end
end
function Rotation:Defensives()
    Player:UseHealingItem()
    if
    GiftOfTheNaaru:Exists() and IsOptionEnabled("纳鲁的赐福") and Player:HealthPercentage() <= GetOptionValue("纳鲁的赐福") and
    Player:CanCast(GiftOfTheNaaru)
    then
        Player:Cast(GiftOfTheNaaru)
        return
    end
end
function Rotation:OffGCDAbilities()
end
function Rotation:UnitTables()
end
function Rotation:ManagePet()
    if IsOptionEnabled("自动召唤/复活宠物") and (InstantWhistle or PetDismissed + GetOptionValue("自动召唤/复活宠物") < GetTime()) then
        InstantWhistle = false
        if
        not PlayerPet:Exists() and GetTime() > TriedToSummonPet and
        Player:CanCast(CallPets[GetSecondOptionValue("自动召唤/复活宠物")])
        then
            TriedToSummonPet = GetTime() + 5
            Player:Cast(CallPets[GetSecondOptionValue("自动召唤/复活宠物")])
            return
        end
        if
        not Player:IsMoving() and (not PlayerPet:Exists() or PlayerPet:IsDead()) and Player:CanCast(RevivePet) and
        GetTime() > TriedToResurrectPet
        then
            TriedToResurrectPet = GetTime() + 3
            Player:Cast(MendPet)
            return
        end
    end
    if
    PlayerPet:Exists() and IsOptionEnabled("治疗宠物") and Player:CanCast(MendPet) and not PlayerPet:Buff(MendPetBuff) and
    MendPet:TimeSinceCast() > 8
    then
        if
        (Player:IsInCombat() and PlayerPet:HealthPercentage() <= GetOptionValue("治疗宠物")) or
        (not Player:IsInCombat() and PlayerPet:HealthPercentage() <= GetSecondOptionValue("治疗宠物"))
        then
            PlayerPet:Cast(MendPet)
            return
        end
    end
end
function Rotation:Combat()
    self:ManagePet()
    if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        if ConcussiveShot:Exists() and IsOptionEnabled("震荡射击") and Target:CanCast(ConcussiveShot) then
            Target:Cast(ConcussiveShot)
            return
        end
        if Player:IsWithinCastRange(Target, CobraShot) then
            if IsOptionEnabled("进攻性种族技能") and (CooldownsAllowed() or GetOptionValue("进攻性种族技能") == "无条件使用") then
                if BloodFury:Exists() and Player:CanCast(BloodFury) then
                    Player:Cast(BloodFury)
                end
                if Berserking:Exists() and Player:CanCast(Berserking) then
                    Player:Cast(Berserking)
                end
                if ArcaneTorrent:Exists() and Player:CanCast(ArcaneTorrent) and Player:Focus() < Player:FocusMax() - 40 then
                    Player:Cast(ArcaneTorrent)
                end
            end
        end
        if CobraShot:Exists() and (Player:Focus() >= 80 or not KillCommand:Exists()) and Target:CanCast(CobraShot) then
            Target:Cast(CobraShot)
            return
        end
    end
end
function Rotation:OutOfCombat()
    self:ManagePet()
    if IsOptionEnabled("自动进入战斗") then
        self:Combat()
    end
end
SetRotation("MAGE", {})
local Rotation = Rotations["MAGE"]
function Rotation:Initialize()
    ArcaneTorrent = Spell(28730, false, false, true)
    BloodFury = Spell(33702, false, false, true)
    Berserking = Spell(26297, false, false, true)
    GiftOfTheNaaru = Spell(59548, false, false, true)
    Fireblast = Spell(108853, true, true, true)
    Frostbolt = Spell(116, true, true, false)
    AddPage("常规")
    AddCommonOptions()
    AddSection("常规", "常规", "Yellow")
    AddNewOption(
    "常规",
    "目标 | 攻击",
    133,
    true,
    { 4, "禁用", "距离最近", "血量最少", "血量最多", "目标附近" },
    { 2, "禁用", "启用" },
    "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target." ..
    C.TOOLTIP_VALUE_1 ..
    C.TOOLTIP_SUBVALUE("距离最近", true) ..
    "Target the closest enemy." ..
    C.TOOLTIP_SUBVALUE("血量最少") ..
    "Target the enemy with the least health remaining." ..
    C.TOOLTIP_SUBVALUE("血量最多") ..
    "Target the enemy with the most health remaining." ..
    C.TOOLTIP_SUBVALUE("目标附近") ..
    "Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining." ..
    C.TOOLTIP_VALUE_2 ..
    "Enable for the automatic usage of /startattack." ..
    C.TOOLTIP_HINT("/startattack is good for melee classes.")
    )
    AddNewOption(
    "常规",
    "动态切换目标",
    232,
    true,
    { 1, "保持", "变化" },
    { 30, 5, 30, 1 },
    "Attack units that are closer around the player when the actual target is out of range." ..
    C.TOOLTIP_VALUE_1 ..
    "Choose preferred Dynamic Mode." ..
    C.TOOLTIP_SUBVALUE("保持", true) ..
    "Never change target but attack units around the player." ..
    C.TOOLTIP_SUBVALUE("变化") ..
    "Change target to units around the player." ..
    C.TOOLTIP_VALUE_2 ..
    "Use Dynamic Targetting when our range to the target is farter than this value."
    )
    AddNewOption("常规", "自动进入战斗", 210, true, nil, nil, "Run the combat logic even when out of combat.")
    if ArcaneTorrent:Exists() or Berserking:Exists() or BloodFury:Exists() then
        AddSection("常规", "Offensive Cooldowns", "Yellow")
        AddNewOption(
        "常规",
        "进攻性种族技能",
        230,
        true,
        { 1, "无条件使用", "大技能用法" },
        nil,
        "Enable for the automatic usage of Racials." ..
        C.TOOLTIP_VALUE ..
        C.TOOLTIP_SUBVALUE("无条件使用", true) ..
        "Will use the ability even if CDs are disabled." ..
        C.TOOLTIP_SUBVALUE("大技能用法") .. "Will only use the ability if CDs are enabled."
        )
    end
    AddSection("常规", "Defensive Items", "Yellow")
    AddNewOption(
    "常规",
    "治疗物品",
    220,
    true,
    { 35, 1, 95, 1 },
    nil,
    "Use Healing Belt / Healing Pot / Healthstone." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    if GiftOfTheNaaru:Exists() then
        AddSection("常规", "Defensive Abilities", "Yellow")
        AddNewOption(
        "常规",
        "纳鲁的赐福",
        220,
        true,
        { 50, 1, 100, 1 },
        nil,
        "Use Gift Of The Naaru." .. C.TOOLTIP_VALUE .. "Health threshold."
        )
    end
end
function Rotation:Events()
end
function Rotation:Pulse()
    if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
        return
    end
    if GetTime() < Rotation.SpamPrevention then
        return
    end
    Rotation.SpamPrevention = GetTime() + 0.05
    Target = Unit.Target
    local InCombat = Player:IsInCombat()
    if not InCombat then
        self:OutOfCombat()
        return
    end
    if InCombat then
        self:Defensives()
    end
    Target = Player:ReTarget(Frostbolt, false) or Unit.Target
    if Target:Exists() then
        Rotations:RefreshUnitTables(Rotation.Identifier)
        self:OffGCDAbilities()
        if Player:GlobalCooldown() == 0 then
            self:Combat()
        end
    end
end
function Rotation:Defensives()
    Player:UseHealingItem()
    if
    GiftOfTheNaaru:Exists() and IsOptionEnabled("纳鲁的赐福") and Player:HealthPercentage() <= GetOptionValue("纳鲁的赐福") and
    Player:CanCast(GiftOfTheNaaru)
    then
        Player:Cast(GiftOfTheNaaru)
        return
    end
end
function Rotation:OffGCDAbilities()
end
function Rotation:UnitTables()
end
function Rotation:Combat()
    if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        if Player:IsWithinCastRange(Target, Frostbolt) and not Player:IsMoving() then
            if IsOptionEnabled("进攻性种族技能") and (CooldownsAllowed() or GetOptionValue("进攻性种族技能") == "无条件使用") then
                if BloodFury:Exists() and Player:CanCast(BloodFury) then
                    Player:Cast(BloodFury)
                end
                if Berserking:Exists() and Player:CanCast(Berserking) then
                    Player:Cast(Berserking)
                end
                if ArcaneTorrent:Exists() and Player:CanCast(ArcaneTorrent) and Player:PowerPercentage() < 95 then
                    Player:Cast(ArcaneTorrent)
                end
            end
        end
        if Fireblast:Exists() and Target:CanCast(Fireblast) then
            Target:Cast(Fireblast)
            return
        end
        if Frostbolt:Exists() and Target:CanCast(Frostbolt) then
            Target:Cast(Frostbolt)
            return
        end
    end
end
function Rotation:OutOfCombat()
    if IsOptionEnabled("自动进入战斗") then
        self:Combat()
    end
end
SetRotation("MONK", {})
local Rotation = Rotations["MONK"]
function Rotation:Initialize()
    ArcaneTorrent = Spell(129597, false, false, true)
    BloodFury = Spell(33697, false, false, true)
    Berserking = Spell(26297, false, false, true)
    GiftOfTheNaaru = Spell(121093, false, false, true)
    BlackoutKick = Spell(100784, true, true, true)
    Effuse = Spell(166694, false, false, false)
    TigerPalm = Spell(100780, true, true, true)
    AddPage("常规")
    AddCommonOptions()
    AddSection("常规", "常规", "Yellow")
    AddNewOption(
    "常规",
    "目标 | 攻击",
    133,
    true,
    { 4, "禁用", "距离最近", "血量最少", "血量最多", "目标附近" },
    { 2, "禁用", "启用" },
    "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target." ..
    C.TOOLTIP_VALUE_1 ..
    C.TOOLTIP_SUBVALUE("距离最近", true) ..
    "Target the closest enemy." ..
    C.TOOLTIP_SUBVALUE("血量最少") ..
    "Target the enemy with the least health remaining." ..
    C.TOOLTIP_SUBVALUE("血量最多") ..
    "Target the enemy with the most health remaining." ..
    C.TOOLTIP_SUBVALUE("目标附近") ..
    "Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining." ..
    C.TOOLTIP_VALUE_2 ..
    "Enable for the automatic usage of /startattack." ..
    C.TOOLTIP_HINT("/startattack is good for melee classes.")
    )
    AddNewOption(
    "常规",
    "动态切换目标",
    232,
    true,
    { 1, "保持", "变化" },
    { 5, 5, 30, 1 },
    "Attack units that are closer around the player when the actual target is out of range." ..
    C.TOOLTIP_VALUE_1 ..
    "Choose preferred Dynamic Mode." ..
    C.TOOLTIP_SUBVALUE("保持", true) ..
    "Never change target but attack units around the player." ..
    C.TOOLTIP_SUBVALUE("变化") ..
    "Change target to units around the player." ..
    C.TOOLTIP_VALUE_2 ..
    "Use Dynamic Targetting when our range to the target is farter than this value."
    )
    AddNewOption("常规", "自动进入战斗", 210, true, nil, nil, "Run the combat logic even when out of combat.")
    if ArcaneTorrent:Exists() or Berserking:Exists() or BloodFury:Exists() then
        AddSection("常规", "Offensive Cooldowns", "Yellow")
        AddNewOption(
        "常规",
        "进攻性种族技能",
        230,
        true,
        { 1, "无条件使用", "大技能用法" },
        nil,
        "Enable for the automatic usage of Racials." ..
        C.TOOLTIP_VALUE ..
        C.TOOLTIP_SUBVALUE("无条件使用", true) ..
        "Will use the ability even if CDs are disabled." ..
        C.TOOLTIP_SUBVALUE("大技能用法") .. "Will only use the ability if CDs are enabled."
        )
    end
    AddSection("常规", "Defensive Items", "Yellow")
    AddNewOption(
    "常规",
    "治疗物品",
    220,
    true,
    { 35, 1, 95, 1 },
    nil,
    "Use Healing Belt / Healing Pot / Healthstone." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddSection("常规", "Defensive Abilities", "Yellow")
    AddNewOption(
    "常规",
    "真气贯通",
    220,
    true,
    { 25, 1, 100, 1 },
    nil,
    "Use Effuse to heal ourself." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    if GiftOfTheNaaru:Exists() then
        AddNewOption(
        "常规",
        "纳鲁的赐福",
        220,
        true,
        { 50, 1, 100, 1 },
        nil,
        "Use Gift Of The Naaru." .. C.TOOLTIP_VALUE .. "Health threshold."
        )
    end
end
function Rotation:Events()
end
function Rotation:Pulse()
    if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
        return
    end
    if GetTime() < Rotation.SpamPrevention then
        return
    end
    Rotation.SpamPrevention = GetTime() + 0.05
    Target = Unit.Target
    local InCombat = Player:IsInCombat()
    if not InCombat then
        self:OutOfCombat()
        return
    end
    if InCombat then
        self:Defensives()
    end
    Target = Player:ReTarget(TigerPalm, false) or Unit.Target
    if Target:Exists() then
        Rotations:RefreshUnitTables(Rotation.Identifier)
        self:OffGCDAbilities()
        if Player:GlobalCooldown() == 0 then
            self:Combat()
        end
    end
end
function Rotation:Defensives()
    Player:UseHealingItem()
    if
    GiftOfTheNaaru:Exists() and IsOptionEnabled("纳鲁的赐福") and Player:HealthPercentage() <= GetOptionValue("纳鲁的赐福") and
    Player:CanCast(GiftOfTheNaaru)
    then
        Player:Cast(GiftOfTheNaaru)
        return
    end
end
function Rotation:OffGCDAbilities()
end
function Rotation:UnitTables()
end
function Rotation:Combat()
    if
    Effuse:Exists() and IsOptionEnabled("真气贯通") and Player:HealthPercentage() <= GetOptionValue("真气贯通") and
    Player:CanCast(Effuse)
    then
        Player:Cast(Effuse)
        return
    end
    if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        if Player:IsWithinCastRange(Target, TigerPalm) then
            if IsOptionEnabled("进攻性种族技能") and (CooldownsAllowed() or GetOptionValue("进攻性种族技能") == "无条件使用") then
                if BloodFury:Exists() and Player:CanCast(BloodFury) then
                    Player:Cast(BloodFury)
                end
                if Berserking:Exists() and Player:CanCast(Berserking) then
                    Player:Cast(Berserking)
                end
                if ArcaneTorrent:Exists() and Player:CanCast(ArcaneTorrent) and Player:Chi() < 5 then
                    Player:Cast(ArcaneTorrent)
                end
            end
        end
        if BlackoutKick:Exists() and Player:Chi() >= 1 and Target:CanCast(BlackoutKick) then
            Target:Cast(BlackoutKick)
            return
        end
        if TigerPalm:Exists() and Target:CanCast(TigerPalm) then
            Target:Cast(TigerPalm)
            return
        end
    end
end
function Rotation:OutOfCombat()
    if
    Effuse:Exists() and IsOptionEnabled("真气贯通") and Player:HealthPercentage() <= GetOptionValue("真气贯通") and
    Player:CanCast(Effuse)
    then
        Player:Cast(Effuse)
        return
    end
    if IsOptionEnabled("自动进入战斗") then
        self:Combat()
    end
end
SetRotation("PALADIN", {})
local Rotation = Rotations["PALADIN"]
function Rotation:Initialize()
    GiftOfTheNaaru = Spell(59542, false, false, true)
    CrusaderStrike = Spell(35395, true, true, true)
    FlashOfLight = Spell(19750, false, false, false)
    Judgment = Spell(20271, false, true, true)
    AddPage("常规")
    AddCommonOptions()
    AddSection("常规", "常规", "Yellow")
    AddNewOption(
    "常规",
    "目标 | 攻击",
    133,
    true,
    { 4, "禁用", "距离最近", "血量最少", "血量最多", "目标附近" },
    { 2, "禁用", "启用" },
    "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target." ..
    C.TOOLTIP_VALUE_1 ..
    C.TOOLTIP_SUBVALUE("距离最近", true) ..
    "Target the closest enemy." ..
    C.TOOLTIP_SUBVALUE("血量最少") ..
    "Target the enemy with the least health remaining." ..
    C.TOOLTIP_SUBVALUE("血量最多") ..
    "Target the enemy with the most health remaining." ..
    C.TOOLTIP_SUBVALUE("目标附近") ..
    "Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining." ..
    C.TOOLTIP_VALUE_2 ..
    "Enable for the automatic usage of /startattack." ..
    C.TOOLTIP_HINT("/startattack is good for melee classes.")
    )
    AddNewOption(
    "常规",
    "动态切换目标",
    232,
    true,
    { 1, "保持", "变化" },
    { 5, 5, 30, 1 },
    "Attack units that are closer around the player when the actual target is out of range." ..
    C.TOOLTIP_VALUE_1 ..
    "Choose preferred Dynamic Mode." ..
    C.TOOLTIP_SUBVALUE("保持", true) ..
    "Never change target but attack units around the player." ..
    C.TOOLTIP_SUBVALUE("变化") ..
    "Change target to units around the player." ..
    C.TOOLTIP_VALUE_2 ..
    "Use Dynamic Targetting when our range to the target is farter than this value."
    )
    AddNewOption("常规", "自动进入战斗", 210, true, nil, nil, "Run the combat logic even when out of combat.")
    AddSection("常规", "Defensive Items", "Yellow")
    AddNewOption(
    "常规",
    "治疗物品",
    220,
    true,
    { 35, 1, 95, 1 },
    nil,
    "Use Healing Belt / Healing Pot / Healthstone." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddSection("常规", "Defensive Abilities", "Yellow")
    AddNewOption(
    "常规",
    "圣光闪现",
    220,
    true,
    { 25, 1, 100, 1 },
    nil,
    "Use Flash of Light to heal ourself." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    if GiftOfTheNaaru:Exists() then
        AddNewOption(
        "常规",
        "纳鲁的赐福",
        220,
        true,
        { 50, 1, 100, 1 },
        nil,
        "Use Gift Of The Naaru." .. C.TOOLTIP_VALUE .. "Health threshold."
        )
    end
end
function Rotation:Events()
end
function Rotation:Pulse()
    if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
        return
    end
    if GetTime() < Rotation.SpamPrevention then
        return
    end
    Rotation.SpamPrevention = GetTime() + 0.05
    Target = Unit.Target
    local InCombat = Player:IsInCombat()
    if not InCombat then
        self:OutOfCombat()
        return
    end
    if InCombat then
        self:Defensives()
    end
    Target = Player:ReTarget(CrusaderStrike, false) or Unit.Target
    if Target:Exists() then
        Rotations:RefreshUnitTables(Rotation.Identifier)
        self:OffGCDAbilities()
        if Player:GlobalCooldown() == 0 then
            self:Combat()
        end
    end
end
function Rotation:Defensives()
    Player:UseHealingItem()
    if
    GiftOfTheNaaru:Exists() and IsOptionEnabled("纳鲁的赐福") and Player:HealthPercentage() <= GetOptionValue("纳鲁的赐福") and
    Player:CanCast(GiftOfTheNaaru)
    then
        Player:Cast(GiftOfTheNaaru)
        return
    end
end
function Rotation:Defensives()
    Player:UseHealingItem()
end
function Rotation:OffGCDAbilities()
end
function Rotation:UnitTables()
end
function Rotation:Combat()
    if
    FlashOfLight:Exists() and IsOptionEnabled("圣光闪现") and Player:HealthPercentage() <= GetOptionValue("圣光闪现") and
    Player:CanCast(FlashOfLight)
    then
        Player:Cast(FlashOfLight)
        return
    end
    if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        if Judgment:Exists() and Target:CanCast(Judgment) then
            Target:Cast(Judgment)
            return
        end
        if CrusaderStrike:Exists() and Target:CanCast(CrusaderStrike) then
            Target:Cast(CrusaderStrike)
            return
        end
    end
end
function Rotation:OutOfCombat()
    if
    FlashOfLight:Exists() and IsOptionEnabled("圣光闪现") and Player:HealthPercentage() <= GetOptionValue("圣光闪现") and
    Player:CanCast(FlashOfLight)
    then
        Player:Cast(FlashOfLight)
        return
    end
    if IsOptionEnabled("自动进入战斗") then
        self:Combat()
    end
end
SetRotation("PRIEST", {})
local Rotation = Rotations["PRIEST"]
function Rotation:Initialize()
    ArcaneTorrent = Spell(28730, false, false, true)
    Berserking = Spell(26297, false, false, true)
    GiftOfTheNaaru = Spell(59544, false, false, true)
    FlashHeal = Spell(2061, false, false, false)
    Pain = Spell(589, false, true, true)
    Shield = Spell(17, false, false, true)
    Smite = Spell(585, true, true, false)
    AddPage("常规")
    AddCommonOptions()
    AddSection("常规", "常规", "Yellow")
    AddNewOption(
    "常规",
    "目标 | 攻击",
    133,
    true,
    { 4, "禁用", "距离最近", "血量最少", "血量最多", "目标附近" },
    { 2, "禁用", "启用" },
    "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target." ..
    C.TOOLTIP_VALUE_1 ..
    C.TOOLTIP_SUBVALUE("距离最近", true) ..
    "Target the closest enemy." ..
    C.TOOLTIP_SUBVALUE("血量最少") ..
    "Target the enemy with the least health remaining." ..
    C.TOOLTIP_SUBVALUE("血量最多") ..
    "Target the enemy with the most health remaining." ..
    C.TOOLTIP_SUBVALUE("目标附近") ..
    "Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining." ..
    C.TOOLTIP_VALUE_2 ..
    "Enable for the automatic usage of /startattack." ..
    C.TOOLTIP_HINT("/startattack is good for melee classes.")
    )
    AddNewOption(
    "常规",
    "动态切换目标",
    232,
    true,
    { 1, "保持", "变化" },
    { 30, 5, 30, 1 },
    "Attack units that are closer around the player when the actual target is out of range." ..
    C.TOOLTIP_VALUE_1 ..
    "Choose preferred Dynamic Mode." ..
    C.TOOLTIP_SUBVALUE("保持", true) ..
    "Never change target but attack units around the player." ..
    C.TOOLTIP_SUBVALUE("变化") ..
    "Change target to units around the player." ..
    C.TOOLTIP_VALUE_2 ..
    "Use Dynamic Targetting when our range to the target is farter than this value."
    )
    AddNewOption("常规", "自动进入战斗", 210, true, nil, nil, "Run the combat logic even when out of combat.")
    if ArcaneTorrent:Exists() or Berserking:Exists() then
        AddSection("常规", "Offensive Cooldowns", "Yellow")
        AddNewOption(
        "常规",
        "进攻性种族技能",
        230,
        true,
        { 1, "无条件使用", "大技能用法" },
        nil,
        "Enable for the automatic usage of Racials." ..
        C.TOOLTIP_VALUE ..
        C.TOOLTIP_SUBVALUE("无条件使用", true) ..
        "Will use the ability even if CDs are disabled." ..
        C.TOOLTIP_SUBVALUE("大技能用法") .. "Will only use the ability if CDs are enabled."
        )
    end
    AddSection("常规", "Defensive Items", "Yellow")
    AddNewOption(
    "常规",
    "治疗物品",
    220,
    true,
    { 35, 1, 95, 1 },
    nil,
    "Use Healing Belt / Healing Pot / Healthstone." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddSection("常规", "Defensive Abilities", "Yellow")
    if GiftOfTheNaaru:Exists() then
        AddNewOption(
        "常规",
        "纳鲁的赐福",
        220,
        true,
        { 50, 1, 100, 1 },
        nil,
        "Use Gift Of The Naaru." .. C.TOOLTIP_VALUE .. "Health threshold."
        )
    end
    AddNewOption(
    "常规",
    "快速治疗",
    220,
    true,
    { 60, 1, 100, 1 },
    nil,
    "Use Flash of Light to heal ourself." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddNewOption(
    "常规",
    "真言术：盾",
    220,
    true,
    { 80, 1, 100, 1 },
    nil,
    "Use Power Word: Shield on ourself." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
end
function Rotation:Events()
end
function Rotation:Pulse()
    if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
        return
    end
    if GetTime() < Rotation.SpamPrevention then
        return
    end
    Rotation.SpamPrevention = GetTime() + 0.05
    Target = Unit.Target
    local InCombat = Player:IsInCombat()
    if not InCombat then
        self:OutOfCombat()
        return
    end
    if InCombat then
        self:Defensives()
    end
    Target = Player:ReTarget(Smite, false) or Unit.Target
    if Target:Exists() then
        Rotations:RefreshUnitTables(Rotation.Identifier)
        self:OffGCDAbilities()
        if Player:GlobalCooldown() == 0 then
            self:Combat()
        end
    end
end
function Rotation:Defensives()
    Player:UseHealingItem()
    if
    GiftOfTheNaaru:Exists() and IsOptionEnabled("纳鲁的赐福") and Player:HealthPercentage() <= GetOptionValue("纳鲁的赐福") and
    Player:CanCast(GiftOfTheNaaru)
    then
        Player:Cast(GiftOfTheNaaru)
        return
    end
end
function Rotation:OffGCDAbilities()
end
function Rotation:UnitTables()
end
function Rotation:Combat()
    if
    Shield:Exists() and IsOptionEnabled("真言术：盾") and Player:HealthPercentage() <= GetOptionValue("真言术：盾") and
    Player:CanCast(Shield)
    then
        Player:Cast(Shield)
        return
    end
    if
    FlashHeal:Exists() and IsOptionEnabled("快速治疗") and Player:HealthPercentage() <= GetOptionValue("快速治疗") and
    Player:CanCast(FlashHeal)
    then
        Player:Cast(FlashHeal)
        return
    end
    if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        if Player:IsWithinCastRange(Target, Smite) and not Player:IsMoving() then
            if IsOptionEnabled("进攻性种族技能") and (CooldownsAllowed() or GetOptionValue("进攻性种族技能") == "无条件使用") then
                if Berserking:Exists() and Player:CanCast(Berserking) then
                    Player:Cast(Berserking)
                end
                if ArcaneTorrent:Exists() and Player:CanCast(ArcaneTorrent) and Player:ManaPercentage() < 95 then
                    Player:Cast(ArcaneTorrent)
                end
            end
        end
        if Pain:Exists() and not Target:Debuff(Pain) and Target:CanCast(Pain) then
            Target:Cast(Pain)
            return
        end
        if Smite:Exists() and Target:CanCast(Smite) then
            Target:Cast(Smite)
            return
        end
    end
end
function Rotation:OutOfCombat()
    if
    FlashHeal:Exists() and IsOptionEnabled("快速治疗") and Player:HealthPercentage() <= GetOptionValue("快速治疗") and
    Player:CanCast(FlashHeal)
    then
        Player:Cast(FlashHeal)
        return
    end
    if IsOptionEnabled("自动进入战斗") then
        self:Combat()
    end
end
SetRotation("ROGUE", {})
local Rotation = Rotations["ROGUE"]
function Rotation:Initialize()
    ArcaneTorrent = Spell(25046, false, false, true)
    BloodFury = Spell(20572, false, false, true)
    Berserking = Spell(26297, false, false, true)
    GiftOfTheNaaru = Spell(59547, false, false, true)
    Eviscerate = Spell(196819, true, true, true)
    SinisterStrike = Spell(1752, true, true, true)
    AddPage("常规")
    AddCommonOptions()
    AddSection("常规", "常规", "Yellow")
    AddNewOption(
    "常规",
    "目标 | 攻击",
    133,
    true,
    { 4, "禁用", "距离最近", "血量最少", "血量最多", "目标附近" },
    { 2, "禁用", "启用" },
    "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target." ..
    C.TOOLTIP_VALUE_1 ..
    C.TOOLTIP_SUBVALUE("距离最近", true) ..
    "Target the closest enemy." ..
    C.TOOLTIP_SUBVALUE("血量最少") ..
    "Target the enemy with the least health remaining." ..
    C.TOOLTIP_SUBVALUE("血量最多") ..
    "Target the enemy with the most health remaining." ..
    C.TOOLTIP_SUBVALUE("目标附近") ..
    "Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining." ..
    C.TOOLTIP_VALUE_2 ..
    "Enable for the automatic usage of /startattack." ..
    C.TOOLTIP_HINT("/startattack is good for melee classes.")
    )
    AddNewOption(
    "常规",
    "动态切换目标",
    232,
    true,
    { 1, "保持", "变化" },
    { 5, 5, 30, 1 },
    "Attack units that are closer around the player when the actual target is out of range." ..
    C.TOOLTIP_VALUE_1 ..
    "Choose preferred Dynamic Mode." ..
    C.TOOLTIP_SUBVALUE("保持", true) ..
    "Never change target but attack units around the player." ..
    C.TOOLTIP_SUBVALUE("变化") ..
    "Change target to units around the player." ..
    C.TOOLTIP_VALUE_2 ..
    "Use Dynamic Targetting when our range to the target is farter than this value."
    )
    AddNewOption("常规", "自动进入战斗", 210, true, nil, nil, "Run the combat logic even when out of combat.")
    if ArcaneTorrent:Exists() or Berserking:Exists() or BloodFury:Exists() then
        AddSection("常规", "Offensive Cooldowns", "Yellow")
        AddNewOption(
        "常规",
        "进攻性种族技能",
        230,
        true,
        { 1, "无条件使用", "大技能用法" },
        nil,
        "Enable for the automatic usage of Racials." ..
        C.TOOLTIP_VALUE ..
        C.TOOLTIP_SUBVALUE("无条件使用", true) ..
        "Will use the ability even if CDs are disabled." ..
        C.TOOLTIP_SUBVALUE("大技能用法") .. "Will only use the ability if CDs are enabled."
        )
    end
    AddSection("常规", "Defensive Items", "Yellow")
    AddNewOption(
    "常规",
    "治疗物品",
    220,
    true,
    { 35, 1, 95, 1 },
    nil,
    "Use Healing Belt / Healing Pot / Healthstone." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddSection("常规", "Defensive Abilities", "Yellow")
    AddNewOption("常规", "闪避", 220, true, { 30, 1, 100, 1 }, nil, "Use Evasion." .. C.TOOLTIP_VALUE .. "Health threshold.")
end
function Rotation:Events()
end
function Rotation:Pulse()
    if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
        return
    end
    if GetTime() < Rotation.SpamPrevention then
        return
    end
    Rotation.SpamPrevention = GetTime() + 0.05
    Target = Unit.Target
    local InCombat = Player:IsInCombat()
    if not InCombat then
        self:OutOfCombat()
        return
    end
    if InCombat then
        self:Defensives()
    end
    Target = Player:ReTarget(SinisterStrike, false) or Unit.Target
    if Target:Exists() then
        Rotations:RefreshUnitTables(Rotation.Identifier)
        self:OffGCDAbilities()
        if Player:GlobalCooldown() == 0 then
            self:Combat()
        end
    end
end
function Rotation:Defensives()
    Player:UseHealingItem()
    if
    GiftOfTheNaaru:Exists() and IsOptionEnabled("纳鲁的赐福") and Player:HealthPercentage() <= GetOptionValue("纳鲁的赐福") and
    Player:CanCast(GiftOfTheNaaru)
    then
        Player:Cast(GiftOfTheNaaru)
        return
    end
end
function Rotation:OffGCDAbilities()
end
function Rotation:UnitTables()
end
function Rotation:Combat()
    if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        if Player:IsWithinCastRange(Target, SinisterStrike) then
            if IsOptionEnabled("进攻性种族技能") and (CooldownsAllowed() or GetOptionValue("进攻性种族技能") == "无条件使用") then
                if BloodFury:Exists() and Player:CanCast(BloodFury) then
                    Player:Cast(BloodFury)
                end
                if Berserking:Exists() and Player:CanCast(Berserking) then
                    Player:Cast(Berserking)
                end
                if
                ArcaneTorrent:Exists() and Player:CanCast(ArcaneTorrent) and
                Player:Energy() < Player:EnergyMax() - 25
                then
                    Player:Cast(ArcaneTorrent)
                end
            end
        end
        if Eviscerate:Exists() and Player:ComboPoints() >= 3 and Target:CanCast(Eviscerate) then
            Target:Cast(Eviscerate)
            return
        end
        if SinisterStrike:Exists() and Target:CanCast(SinisterStrike) then
            Target:Cast(SinisterStrike)
            return
        end
    end
end
function Rotation:OutOfCombat()
    if IsOptionEnabled("自动进入战斗") then
        self:Combat()
    end
end
SetRotation("SHAMAN", {})
local Rotation = Rotations["SHAMAN"]
function Rotation:Initialize()
    BloodFury = Spell(33697, false, false, true)
    Berserking = Spell(26297, false, false, true)
    GiftOfTheNaaru = Spell(59547, false, false, true)
    EarthShock = Spell(8042, true, true, true)
    FlameShock = Spell(188389, true, true, true)
    HealingSurge = Spell(8004, false, false, false)
    LightningBolt = Spell(188196, true, true, false)
    AddPage("常规")
    AddCommonOptions()
    AddSection("常规", "常规", "Yellow")
    AddNewOption(
    "常规",
    "目标 | 攻击",
    133,
    true,
    { 4, "禁用", "距离最近", "血量最少", "血量最多", "目标附近" },
    { 2, "禁用", "启用" },
    "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target." ..
    C.TOOLTIP_VALUE_1 ..
    C.TOOLTIP_SUBVALUE("距离最近", true) ..
    "Target the closest enemy." ..
    C.TOOLTIP_SUBVALUE("血量最少") ..
    "Target the enemy with the least health remaining." ..
    C.TOOLTIP_SUBVALUE("血量最多") ..
    "Target the enemy with the most health remaining." ..
    C.TOOLTIP_SUBVALUE("目标附近") ..
    "Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining." ..
    C.TOOLTIP_VALUE_2 ..
    "Enable for the automatic usage of /startattack." ..
    C.TOOLTIP_HINT("/startattack is good for melee classes.")
    )
    AddNewOption(
    "常规",
    "动态切换目标",
    232,
    true,
    { 1, "保持", "变化" },
    { 30, 5, 30, 1 },
    "Attack units that are closer around the player when the actual target is out of range." ..
    C.TOOLTIP_VALUE_1 ..
    "Choose preferred Dynamic Mode." ..
    C.TOOLTIP_SUBVALUE("保持", true) ..
    "Never change target but attack units around the player." ..
    C.TOOLTIP_SUBVALUE("变化") ..
    "Change target to units around the player." ..
    C.TOOLTIP_VALUE_2 ..
    "Use Dynamic Targetting when our range to the target is farter than this value."
    )
    AddNewOption("常规", "自动进入战斗", 210, true, nil, nil, "Run the combat logic even when out of combat.")
    if Berserking:Exists() or BloodFury:Exists() then
        AddSection("常规", "Offensive Cooldowns", "Yellow")
        AddNewOption(
        "常规",
        "进攻性种族技能",
        230,
        true,
        { 1, "无条件使用", "大技能用法" },
        nil,
        "Enable for the automatic usage of Racials." ..
        C.TOOLTIP_VALUE ..
        C.TOOLTIP_SUBVALUE("无条件使用", true) ..
        "Will use the ability even if CDs are disabled." ..
        C.TOOLTIP_SUBVALUE("大技能用法") .. "Will only use the ability if CDs are enabled."
        )
    end
    AddSection("常规", "Defensive Items", "Yellow")
    AddNewOption(
    "常规",
    "治疗物品",
    220,
    true,
    { 35, 1, 95, 1 },
    nil,
    "Use Healing Belt / Healing Pot / Healthstone." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddSection("常规", "Defensive Abilities", "Yellow")
    if GiftOfTheNaaru:Exists() then
        AddNewOption(
        "常规",
        "纳鲁的赐福",
        220,
        true,
        { 50, 1, 100, 1 },
        nil,
        "Use Gift Of The Naaru." .. C.TOOLTIP_VALUE .. "Health threshold."
        )
    end
    AddNewOption(
    "常规",
    "治疗之涌",
    220,
    true,
    { 25, 1, 100, 1 },
    nil,
    "Use Healing Surge to heal ourself." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
end
function Rotation:Events()
end
function Rotation:Pulse()
    if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
        return
    end
    if GetTime() < Rotation.SpamPrevention then
        return
    end
    Rotation.SpamPrevention = GetTime() + 0.05
    Target = Unit.Target
    local InCombat = Player:IsInCombat()
    if not InCombat then
        self:OutOfCombat()
        return
    end
    if InCombat then
        self:Defensives()
    end
    Target = Player:ReTarget(Shred, false) or Unit.Target
    if Target:Exists() then
        Rotations:RefreshUnitTables(Rotation.Identifier)
        self:OffGCDAbilities()
        if Player:GlobalCooldown() == 0 then
            self:Combat()
        end
    end
end
function Rotation:Defensives()
    Player:UseHealingItem()
    if
    GiftOfTheNaaru:Exists() and IsOptionEnabled("纳鲁的赐福") and Player:HealthPercentage() <= GetOptionValue("纳鲁的赐福") and
    Player:CanCast(GiftOfTheNaaru)
    then
        Player:Cast(GiftOfTheNaaru)
        return
    end
end
function Rotation:OffGCDAbilities()
end
function Rotation:UnitTables()
end
function Rotation:Combat()
    if
    HealingSurge:Exists() and IsOptionEnabled("治疗之涌") and Player:HealthPercentage() <= GetOptionValue("治疗之涌") and
    Player:CanCast(HealingSurge)
    then
        Player:Cast(HealingSurge)
        return
    end
    if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        if Player:IsWithinCastRange(Target, LightningBolt) and not Player:IsMoving() then
            if IsOptionEnabled("进攻性种族技能") and (CooldownsAllowed() or GetOptionValue("进攻性种族技能") == "无条件使用") then
                if BloodFury:Exists() and Player:CanCast(BloodFury) then
                    Player:Cast(BloodFury)
                end
                if Berserking:Exists() and Player:CanCast(Berserking) then
                    Player:Cast(Berserking)
                end
            end
        end
        if FlameShock:Exists() and not Target:Debuff(FlameShock) and Target:CanCast(FlameShock) then
            Target:Cast(FlameShock)
            return
        end
        if EarthShock:Exists() and Player:Maelstrom() >= 10 and Target:CanCast(EarthShock) then
            Target:Cast(EarthShock)
            return
        end
        if LightningBolt:Exists() and Target:CanCast(LightningBolt) then
            Target:Cast(LightningBolt)
            return
        end
    end
end
function Rotation:OutOfCombat()
    if
    HealingSurge:Exists() and IsOptionEnabled("治疗之涌") and Player:HealthPercentage() <= GetOptionValue("治疗之涌") and
    Player:CanCast(HealingSurge)
    then
        Player:Cast(HealingSurge)
        return
    end
    if IsOptionEnabled("自动进入战斗") then
        self:Combat()
    end
end
SetRotation("WARLOCK", {})
local Rotation = Rotations["WARLOCK"]
function Rotation:Initialize()
    ArcaneTorrent = Spell(28730, false, false, true)
    BloodFury = Spell(33702, false, false, true)
    Berserking = Spell(26297, false, false, true)
    Healthstone = Item(5512, false, false, true)
    Agony = Spell(980, false, true, true)
    Corruption = Spell(172, false, true, true)
    CorruptionDebuff = Spell(146739)
    CreateHealthstone = Spell(6201, false, false, false)
    ShadowBolt = Spell(232670, true, true, false)
    SummonImp = Spell(688, false, false, false)
    AddPage("常规")
    AddCommonOptions()
    AddSection("常规", "常规", "Yellow")
    AddNewOption(
    "常规",
    "目标 | 攻击",
    133,
    true,
    { 4, "禁用", "距离最近", "血量最少", "血量最多", "目标附近" },
    { 2, "禁用", "启用" },
    "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target." ..
    C.TOOLTIP_VALUE_1 ..
    C.TOOLTIP_SUBVALUE("距离最近", true) ..
    "Target the closest enemy." ..
    C.TOOLTIP_SUBVALUE("血量最少") ..
    "Target the enemy with the least health remaining." ..
    C.TOOLTIP_SUBVALUE("血量最多") ..
    "Target the enemy with the most health remaining." ..
    C.TOOLTIP_SUBVALUE("目标附近") ..
    "Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining." ..
    C.TOOLTIP_VALUE_2 ..
    "Enable for the automatic usage of /startattack." ..
    C.TOOLTIP_HINT("/startattack is good for melee classes.")
    )
    AddNewOption(
    "常规",
    "动态切换目标",
    232,
    true,
    { 1, "保持", "变化" },
    { 30, 5, 30, 1 },
    "Attack units that are closer around the player when the actual target is out of range." ..
    C.TOOLTIP_VALUE_1 ..
    "Choose preferred Dynamic Mode." ..
    C.TOOLTIP_SUBVALUE("保持", true) ..
    "Never change target but attack units around the player." ..
    C.TOOLTIP_SUBVALUE("变化") ..
    "Change target to units around the player." ..
    C.TOOLTIP_VALUE_2 ..
    "Use Dynamic Targetting when our range to the target is farter than this value."
    )
    AddNewOption("常规", "自动进入战斗", 210, true, nil, nil, "Run the combat logic even when out of combat.")
    AddSection("常规", "恶魔管理", "Yellow")
    AddNewOption("常规", "恶魔管理器", 210, true, nil, nil, "Enable summoning our Imp.")
    if ArcaneTorrent:Exists() or Berserking:Exists() or BloodFury:Exists() then
        AddSection("常规", "Offensive Cooldowns", "Yellow")
        AddNewOption(
        "常规",
        "进攻性种族技能",
        230,
        true,
        { 1, "无条件使用", "大技能用法" },
        nil,
        "Enable for the automatic usage of Racials." ..
        C.TOOLTIP_VALUE ..
        C.TOOLTIP_SUBVALUE("无条件使用", true) ..
        "Will use the ability even if CDs are disabled." ..
        C.TOOLTIP_SUBVALUE("大技能用法") .. "Will only use the ability if CDs are enabled."
        )
    end
    AddSection("常规", "Defensive Items", "Yellow")
    AddNewOption(
    "常规",
    "制造治疗石",
    210,
    true,
    nil,
    nil,
    "Will create you a new healthstone if you have none in your bags and are out of combat."
    )
    AddNewOption(
    "常规",
    "治疗物品",
    220,
    true,
    { 35, 1, 95, 1 },
    nil,
    "Use Healing Belt / Healing Pot / Healthstone." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
end
function Rotation:Events()
end
function Rotation:Pulse()
    if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
        return
    end
    if GetTime() < Rotation.SpamPrevention then
        return
    end
    Rotation.SpamPrevention = GetTime() + 0.05
    Target = Unit.Target
    local InCombat = Player:IsInCombat()
    if not InCombat then
        self:OutOfCombat()
        return
    end
    if InCombat then
        self:Defensives()
    end
    Target = Player:ReTarget(ShadowBolt, false) or Unit.Target
    if Target:Exists() then
        Rotations:RefreshUnitTables(Rotation.Identifier)
        self:OffGCDAbilities()
        if Player:GlobalCooldown() == 0 then
            self:Combat()
        end
    end
end
function Rotation:Defensives()
    Player:UseHealingItem()
end
function Rotation:OffGCDAbilities()
end
function Rotation:UnitTables()
end
function Rotation:PetsManager()
    if
    SummonImp:Exists() and not Player:IsMoving() and IsOptionEnabled("恶魔管理器") and
    (not PlayerPet:Exists() or PlayerPet:IsDeadOrGhost()) and
    Player:SoulShards() >= 1
    then
        if SummonImp:TimeSinceCast() > 2.5 and Player:CanCast(SummonImp) then
            SummonImp.LastCastTime = GetTime()
            Player:Cast(SummonImp)
            return
        end
    end
end
function Rotation:Combat()
    self:PetsManager()
    if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        if Player:IsWithinCastRange(Target, ShadowBolt) and not Player:IsMoving() then
            if IsOptionEnabled("进攻性种族技能") and (CooldownsAllowed() or GetOptionValue("进攻性种族技能") == "无条件使用") then
                if BloodFury:Exists() and Player:CanCast(BloodFury) then
                    Player:Cast(BloodFury)
                end
                if Berserking:Exists() and Player:CanCast(Berserking) then
                    Player:Cast(Berserking)
                end
                if ArcaneTorrent:Exists() and Player:CanCast(ArcaneTorrent) and Player:PowerPercentage() < 95 then
                    Player:Cast(ArcaneTorrent)
                end
            end
        end
        if Agony:Exists() and not Target:Debuff(Agony) and Target:CanCast(Agony) then
            Target:Cast(Agony)
            return
        end
        if Corruption:Exists() and not Target:Debuff(CorruptionDebuff) and Target:CanCast(Corruption) then
            Target:Cast(Corruption)
            return
        end
        if ShadowBolt:Exists() and Target:CanCast(ShadowBolt) then
            Target:Cast(ShadowBolt)
            return
        end
    end
end
function Rotation:OutOfCombat()
    self:PetsManager()
    if CreateHealthstone:Exists() and IsOptionEnabled("制造治疗石") and Player:Standing() > 0.25 then
        if not Healthstone:InStock() and CreateHealthstone:TimeSinceCast() >= 5 and Player:CanCast(CreateHealthstone) then
            CreateHealthstone.LastCastTime = GetTime()
            Player:Cast(CreateHealthstone)
            return
        end
    end
    if IsOptionEnabled("自动进入战斗") then
        self:Combat()
    end
end
SetRotation("WARRIOR", {})
local Rotation = Rotations["WARRIOR"]
function Rotation:Initialize()
    ArcaneTorrent = Spell(69179, false, false, true)
    BloodFury = Spell(20572, false, false, true)
    Berserking = Spell(26297, false, false, true)
    GiftOfTheNaaru = Spell(28880, false, false, true)
    Charge = Spell(100, true, true, true)
    Execute = Spell(163201, true, true, true)
    VictoryRush = Spell(34428, true, true, true)
    VictoryRushBuff = Spell(32216)
    Slam = Spell(1464, true, true, true)
    AddPage("常规")
    AddCommonOptions()
    AddSection("常规", "常规", "Yellow")
    AddNewOption(
    "常规",
    "目标 | 攻击",
    133,
    true,
    { 4, "禁用", "距离最近", "血量最少", "血量最多", "目标附近" },
    { 2, "禁用", "启用" },
    "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target." ..
    C.TOOLTIP_VALUE_1 ..
    C.TOOLTIP_SUBVALUE("距离最近", true) ..
    "Target the closest enemy." ..
    C.TOOLTIP_SUBVALUE("血量最少") ..
    "Target the enemy with the least health remaining." ..
    C.TOOLTIP_SUBVALUE("血量最多") ..
    "Target the enemy with the most health remaining." ..
    C.TOOLTIP_SUBVALUE("目标附近") ..
    "Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining." ..
    C.TOOLTIP_VALUE_2 ..
    "Enable for the automatic usage of /startattack." ..
    C.TOOLTIP_HINT("/startattack is good for melee classes.")
    )
    AddNewOption(
    "常规",
    "动态切换目标",
    232,
    true,
    { 1, "保持", "变化" },
    { 5, 5, 30, 1 },
    "Attack units that are closer around the player when the actual target is out of range." ..
    C.TOOLTIP_VALUE_1 ..
    "Choose preferred Dynamic Mode." ..
    C.TOOLTIP_SUBVALUE("保持", true) ..
    "Never change target but attack units around the player." ..
    C.TOOLTIP_SUBVALUE("变化") ..
    "Change target to units around the player." ..
    C.TOOLTIP_VALUE_2 ..
    "Use Dynamic Targetting when our range to the target is farter than this value."
    )
    AddNewOption("常规", "自动进入战斗", 210, true, nil, nil, "Run the combat logic even when out of combat.")
    AddNewOption(
    "常规",
    "Auto Charge",
    220,
    false,
    { 15, 6.5, 22, 0.5 },
    nil,
    "Distance away from the target to auto use charge."
    )
    if ArcaneTorrent:Exists() or Berserking:Exists() or BloodFury:Exists() then
        AddSection("常规", "Offensive Cooldowns", "Yellow")
        AddNewOption(
        "常规",
        "进攻性种族技能",
        230,
        true,
        { 1, "无条件使用", "大技能用法" },
        nil,
        "Enable for the automatic usage of Racials." ..
        C.TOOLTIP_VALUE ..
        C.TOOLTIP_SUBVALUE("无条件使用", true) ..
        "Will use the ability even if CDs are disabled." ..
        C.TOOLTIP_SUBVALUE("大技能用法") .. "Will only use the ability if CDs are enabled."
        )
    end
    AddSection("常规", "Defensive Items", "Yellow")
    AddNewOption(
    "常规",
    "治疗物品",
    220,
    true,
    { 35, 1, 95, 1 },
    nil,
    "Use Healing Belt / Healing Pot / Healthstone." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddSection("常规", "Defensive Abilities", "Yellow")
    if GiftOfTheNaaru:Exists() then
        AddNewOption(
        "常规",
        "纳鲁的赐福",
        220,
        true,
        { 50, 1, 100, 1 },
        nil,
        "Use Gift Of The Naaru." .. C.TOOLTIP_VALUE .. "Health threshold."
        )
    end
    AddNewOption(
    "防御",
    "乘胜追击",
    220,
    true,
    { 50, 1, 100, 1 },
    nil,
    "Use Victory Rush." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
end
function Rotation:Events()
end
function Rotation:Pulse()
    if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
        return
    end
    if GetTime() < Rotation.SpamPrevention then
        return
    end
    Rotation.SpamPrevention = GetTime() + 0.05
    Target = Unit.Target
    local InCombat = Player:IsInCombat()
    if not InCombat then
        self:OutOfCombat()
        return
    end
    if InCombat then
        self:Defensives()
    end
    Target = Player:ReTarget(Slam, false) or Unit.Target
    if Target:Exists() then
        Rotations:RefreshUnitTables(Rotation.Identifier)
        self:OffGCDAbilities()
        if Player:GlobalCooldown() == 0 then
            self:Combat()
        end
    end
end
function Rotation:Defensives()
    Player:UseHealingItem()
    if
    GiftOfTheNaaru:Exists() and IsOptionEnabled("纳鲁的赐福") and Player:HealthPercentage() <= GetOptionValue("纳鲁的赐福") and
    Player:CanCast(GiftOfTheNaaru)
    then
        Player:Cast(GiftOfTheNaaru)
        return
    end
end
function Rotation:OffGCDAbilities()
end
function Rotation:UnitTables()
end
function Rotation:Combat()
    if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        if
        Charge:Exists() and IsOptionEnabled("Auto Charge") and Player:DistanceTo(Target) >= 6.5 and
        Player:DistanceTo(Target) <= GetOptionValue("Auto Charge") and
        Target:CanCast(Charge)
        then
            Target:Cast(Charge)
            return
        end
        if Player:IsWithinCastRange(Target, Slam) then
            if IsOptionEnabled("进攻性种族技能") and (CooldownsAllowed() or GetOptionValue("进攻性种族技能") == "无条件使用") then
                if BloodFury:Exists() and Player:CanCast(BloodFury) then
                    Player:Cast(BloodFury)
                end
                if Berserking:Exists() and Player:CanCast(Berserking) then
                    Player:Cast(Berserking)
                end
                if ArcaneTorrent:Exists() and Player:CanCast(ArcaneTorrent) and Player:Rage() < Player:RageMax() - 40 then
                    Player:Cast(ArcaneTorrent)
                end
            end
        end
        if
        VictoryRush:Exists() and IsOptionEnabled("乘胜追击") and Player:Buff(VictoryRushBuff) and
        Player:HealthPercentage() <= GetOptionValue("乘胜追击") and
        Target:CanCast(VictoryRush)
        then
            Target:Cast(VictoryRush)
            return
        end
        if Execute:Exists() and Player:Rage() >= 10 and Target:HealthPercentage() < 20 and Target:CanCast(Execute) then
            Target:Cast(Execute)
            return
        end
        if Slam:Exists() and Target:CanCast(Slam) then
            Target:Cast(Slam)
            return
        end
    end
end
function Rotation:OutOfCombat()
    if IsOptionEnabled("自动进入战斗") then
        self:Combat()
    end
end
SetRotation(250, {})
local Rotation = Rotations[250]
function Rotation:Initialize()
    ArcaneTorrent = Spell(50613, false, false, true)
    Berserking = Spell(26297, false, false, true)
    BloodFury = Spell(20572, false, false, true)
    GiftOfTheNaaru = Spell(59545, false, false, true)
    AntiMagicShell = Spell(48707, false, false, true)
    Asphyxiate = Spell(221562, true, true, true)
    BloodBoil = Spell(50842, false, false, true)
    BloodDrinker = Spell(206931, true, true, true)
    BloodMirror = Spell(206977, true, true, true)
    BloodPlague = Spell(55078, false, false, true)
    BloodTap = Spell(221699, false, false, true)
    BoneShield = Spell(195181, false, false, true)
    Bonestorm = Spell(194844, false, false, true)
    Consumption = Spell(205223, true, true, true)
    ControlUndead = Spell(111673, true, true, true)
    DancingRuneWeapon = Spell(49028, false, true, true)
    DancingRuneWeaponBuff = Spell(81256, false, false, true)
    DarkCommand = Spell(56222, true, true, true)
    DeathAndDecay = Spell(43265, false, true, true)
    DeathAndDecayBuff = Spell(188290, false, false, true)
    DeathGrip = Spell(49576, true, true, true)
    DeathStrike = Spell(49998, true, true, true)
    DeathsCaress = Spell(195292, true, true, true)
    HeartOfIce = Spell(246426)
    HearthStrike = Spell(206930, true, true, true)
    IceboundFortitude = Spell(48792, false, false, true)
    MarkOfBlood = Spell(206940, true, true, true)
    MarrowRend = Spell(195182, true, true, true)
    MindFreeze = Spell(47528, true, true, true)
    RaiseAlly = Spell(61999, false, false, true, true)
    RuneTap = Spell(194679, false, false, true)
    Tombstone = Spell(219809, false, false, true)
    VampiricBlood = Spell(55233, false, false, true)
    WraithWalk = Spell(212552, false, false, true)
    HandOfProtection = Spell(1022, false, false, true)
    HandOfProtectionName = GetSpellInfo(1022)
    AddPage("常规")
    AddPage("进攻")
    AddPage("防御")
    AddCommonOptions()
    AddPresetOption("常规", "Melee", nil, false)
    AddPresetOption("TankingFeatures", { "黑暗命令", "黑暗命令" })
    AddSection("常规", { "辅助", "效用" }, "Yellow")
    AddNewOption("常规", { "复活盟友", "复活盟友" }, 210, true, nil, nil, { "Use Raise Ally on dead target.", "使用提升盟友死亡目标。" })
    AddSection("常规", { "移动", "运动" }, "Yellow")
    AddNewOption(
    "常规",
    { "幽魂步", "幻影步" },
    210,
    false,
    nil,
    nil,
    { "Automatically use Wraith Walk while moving and Out of Combat.", "自动使用幻影步移动和离开战斗。" }
    )
    AddPresetOption("进攻")
    AddSection("进攻", { "能力", "能力" }, "Yellow")
    AddNewOption(
    "进攻",
    { "Blood Boil", "血液沸腾" },
    222,
    true,
    { 1.5, 1, 3, 0.1 },
    { 1, 1, 3, 0.1 },
    {
        "Use Blood Boil with the given amount of fractional charges." ..
        C.TOOLTIP_VALUE_1 ..
        "High Priority. Set it above 2 to not be used." ..
        C.TOOLTIP_VALUE_2 .. "Low Priority (Filler). Set it above 2 to not be used.",
        "使用给定量的分数收费的血液煮沸。" ..
        C.TOOLTIP_VALUE_1 .. "高优先。 将其设置为2以上不使用。" .. C.TOOLTIP_VALUE_2 .. "低优先级（填充）。 将其设置为2以上不使用。"
    }
    )
    AddPresetOption("Cooldown", { "Blooddrinker", "饮血者" }, 1, { 100, 1, 100, 1 }, { "Health threshold.", "健康阈值。" })
    AddPresetOption("Cooldown", { "血之镜像", "血之镜像" })
    AddNewOption(
    "进攻",
    { "Blood Mirror Setting", "血之镜像" },
    122,
    true,
    { 50, 1, 100, 1 },
    { 3, 0, 25, 0.1 },
    {
        "Use Blood Mirror." ..
        C.TOOLTIP_VALUE_1 ..
        "Health threshold." .. C.TOOLTIP_VALUE_2 .. "Minimum enemy health (in million) to apply.",
        "使用 血之镜像。" .. C.TOOLTIP_VALUE_1 .. "健康阈值。" .. C.TOOLTIP_VALUE_2 .. "最小敌人健康（百万）申请。"
    }
    )
    AddPresetOption("Cooldown", { "白骨风暴", "白骨风暴" }, 1)
    AddNewOption(
    "进攻",
    { "Bonestorm Setting", "白骨风暴" },
    122,
    true,
    { 2, 1, 10, 1 },
    { 90, 10, 100, 5 },
    {
        "Use Bonestorm." ..
        C.TOOLTIP_VALUE ..
        "Amount of enemies that must be in melee range to use." ..
        C.TOOLTIP_VALUE_2 .. "Required Runic Power to use.",
        "使用 白骨风暴。" .. C.TOOLTIP_VALUE .. "必须在近战范围内使用的敌人的数量。" .. C.TOOLTIP_VALUE_2 .. "所需的符文力使用。"
    }
    )
    AddPresetOption("Cooldown", { "吞噬", "吞噬" }, 1)
    AddNewOption(
    "进攻",
    { "Consumption Setting", "吞噬" },
    122,
    true,
    { 1, 1, 10, 1 },
    { 100, 1, 100, 1 },
    {
        "Use Consumption." ..
        C.TOOLTIP_VALUE ..
        "Amount of enemies that must be in range to use." .. C.TOOLTIP_VALUE_2 .. "Health threshold.",
        "使用 吞噬。" .. C.TOOLTIP_VALUE .. "必须在使用范围内的敌人的数量。" .. C.TOOLTIP_VALUE_2 .. "健康阈值。"
    }
    )
    AddNewOption(
    "进攻",
    { "枯萎凋零", "枯萎凋零" },
    232,
    true,
    {
        2,
        { "目标", "目标" },
        { "Target Standing", "目标站立" },
        { "Centered", "中心" },
        { "Centered Standing", "中心站立" },
        { "Under Player", "在球员下" },
        { "Under Player Standing", "在球员站立下" }
    },
    { 1, 1, 10, 1 },
    {
        "Use Death and Decay." ..
        C.TOOLTIP_VALUE_1 ..
        "Choose preferred mode." ..
        C.TOOLTIP_SUBVALUE("目标") ..
        "Always use on the current target." ..
        C.TOOLTIP_SUBVALUE("Target Standing") ..
        "Always use on the current target. Target must be standing still." ..
        C.TOOLTIP_SUBVALUE("Centered") ..
        "Use centered on a cluster of enemies." ..
        C.TOOLTIP_SUBVALUE("Centered Standing") ..
        "Use centered on a cluster of enemies. Enemies must be standing still." ..
        C.TOOLTIP_VALUE_2 ..
        "Amount of enemies that must be in the spell effect to use.",
        "使用 枯萎凋零。" ..
        C.TOOLTIP_VALUE_1 ..
        "选择首选模式。" ..
        C.TOOLTIP_SUBVALUE("目标") ..
        "始终使用当前目标。" ..
        C.TOOLTIP_SUBVALUE("目标站立") ..
        "始终使用当前目标。 目标必须站稳" ..
        C.TOOLTIP_SUBVALUE("中心") ..
        "以一群敌人为中心。" ..
        C.TOOLTIP_SUBVALUE("中心站立") ..
        "以一群敌人为中心。 敌人必须站稳" .. C.TOOLTIP_VALUE_2 .. "必须使用法术效果的敌人的数量。"
    }
    )
    AddNewOption(
    "进攻",
    { "枯萎凋零 距离", "枯萎凋零 距离" },
    220,
    true,
    { 3, 0, 5, 1 },
    nil,
    {
        "Distance from Player we want to use Death and Decay for the Under Player options." ..
        C.TOOLTIP_VALUE .. "Distance in yards from Player.",
        "与玩家的距离我们想要使用“死亡与堕落”为“玩家”选项。" .. C.TOOLTIP_VALUE .. "距球员距离。"
    }
    )
    AddPresetOption("防御")
    AddSection("防御", { "减伤", "减轻" }, "Yellow")
    AddNewOption(
    "防御",
    { "灵界打击", "灵界打击" },
    222,
    true,
    { 45, 1, 100, 1 },
    { 15, 1, 100, 1 },
    {
        "Use Death Strike when we are receiving Damage." ..
        C.TOOLTIP_VALUE_1 ..
        "Health percentage lost in last 5 seconds to use as high priority with as few as 40 Runic Power." ..
        C.TOOLTIP_VALUE_2 ..
        "Health percentage lost in last 5 seconds to use as low priority with at least 80 Runic Power." ..
        C.TOOLTIP_HINT(
        "Death Strike will always be used regardless when we have 100+ Runic Power."
        ),
        "当我们受到伤害时使用死亡打击。" ..
        C.TOOLTIP_VALUE_1 ..
        "在最近5秒内，健康百分比损失最少，达到40符文力量。" ..
        C.TOOLTIP_VALUE_2 ..
        "健康百分比在最近5秒内用至少80符文力量作为低优先级使用。" .. C.TOOLTIP_HINT("无论何时我们有100多万的符文力量，死亡打击总是会被使用。")
    }
    )
    AddNewOption(
    "防御",
    { "符文分流", "符文分流" },
    222,
    true,
    { 50, 1, 100, 1 },
    { 20, 1, 100, 1 },
    {
        "Use Rune Tap when we are receiving Damage." ..
        C.TOOLTIP_VALUE_1 ..
        "Health percentage lost in last 5 seconds to use as high priority." ..
        C.TOOLTIP_VALUE_2 .. "Health percentage lost in last 5 seconds to use when we have two charges.",
        "当我们收到伤害时使用符文敲击。" ..
        C.TOOLTIP_VALUE_1 .. "健康百分比在最近5秒内被丢失，用作高优先级。" .. C.TOOLTIP_VALUE_2 .. "在两次收费时，最近5秒钟的健康百分比损失。"
    }
    )
    AddNewOption(
    "进攻",
    { "刷新骨盾", "白骨之盾刷新" },
    220,
    true,
    { 4, 0, 20, 0.5 },
    nil,
    {
        "Use Marrowrend when Bone Shield buff expires in less than given seconds." ..
        C.TOOLTIP_VALUE ..
        "Remaining seconds on the Bone Shield buff." .. C.TOOLTIP_HINT("Lesser is usually better."),
        "白骨之盾在不到一秒钟内到期时使用骨髓分裂。" .. C.TOOLTIP_VALUE .. "骨盾上剩下秒数" .. C.TOOLTIP_HINT("小通常更好。")
    }
    )
    AddSection("防御", { "能力", "能力" }, "Yellow")
    AddNewOption(
    "防御",
    { "鲜血印记", "鲜血印记" },
    222,
    true,
    { 100, 1, 100, 1 },
    { 5, 0, 25, 0.1 },
    {
        "Use Mark of Blood." ..
        C.TOOLTIP_VALUE_1 ..
        "Health threshold." .. C.TOOLTIP_VALUE_2 .. "Minimum enemy health (in million) to apply.",
        "使用 鲜血印记。" .. C.TOOLTIP_VALUE_1 .. "健康阈值。" .. C.TOOLTIP_VALUE_2 .. "最小敌人健康（百万）申请。"
    }
    )
    AddSection("防御", { "大技能", "酷唐斯" }, "Yellow")
    AddNewOption(
    "防御",
    { "反魔法护罩", "反魔法护罩" },
    220,
    false,
    { 50, 1, 100, 1 },
    nil,
    { "Use Anti-Magic Shell." .. C.TOOLTIP_VALUE .. "Health threshold.", "使用 反魔法护罩。" .. C.TOOLTIP_VALUE .. "健康阈值。" }
    )
    AddNewOption(
    "防御",
    { "符文刃舞", "符文刃舞" },
    220,
    true,
    { 40, 1, 100, 1 },
    nil,
    { "Use Dancing Rune Weapon." .. C.TOOLTIP_VALUE .. "Health threshold.", "使用 符文刃舞。" .. C.TOOLTIP_VALUE .. "健康阈值。" }
    )
    AddNewOption(
    "防御",
    { "冰封之韧", "冰封之韧" },
    220,
    true,
    { 30, 1, 100, 1 },
    nil,
    { "Use Icebound Fortitude." .. C.TOOLTIP_VALUE .. "Health threshold.", "使用冰封之韧。" .. C.TOOLTIP_VALUE .. "健康阈值。" }
    )
    AddNewOption(
    "防御",
    { "墓石", "墓石" },
    222,
    true,
    { 5, 1, 10, 1 },
    { 40, 1, 100, 1 },
    {
        "Use Tombstone." ..
        C.TOOLTIP_VALUE_1 .. "Minimum Bone Shield stacks to use." .. C.TOOLTIP_VALUE_2 .. "Health threshold.",
        "使用 墓石。" .. C.TOOLTIP_VALUE_1 .. "最小骨盾堆叠使用。" .. C.TOOLTIP_VALUE_2 .. "健康阈值。"
    }
    )
    AddNewOption(
    "防御",
    { "吸血鬼之血", "吸血鬼之血" },
    220,
    true,
    { 20, 1, 100, 1 },
    nil,
    { "Use Vampiric Blood." .. C.TOOLTIP_VALUE .. "Health threshold.", "使用 吸血鬼之血。" .. C.TOOLTIP_VALUE .. "健康阈值。" }
    )
end
function Rotation:Events()
end
function Rotation:Pulse()
    if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
        return
    end
    if Target:Exists() and BMPullTime() < 5 then
        self:Opening()
        return
    end
    if GetTime() < Rotation.SpamPrevention then
        return
    end
    Rotation.SpamPrevention = GetTime() + 0.05
    Target = Unit.Target
    local InCombat = Player:IsInCombat()
    if not InCombat then
        self:OutOfCombat()
        return
    end
    if InCombat then
        self:Defensives()
    end
    Target = Player:ReTarget(HearthStrike, true) or Unit.Target
    if Target:Exists() then
        Rotations:RefreshUnitTables(Rotation.Identifier)
        self:Interrupts()
        self:OffGCDAbilities()
        if Player:GlobalCooldown() == 0 then
            self:Combat()
        end
    end
end
function Rotation:Opening()
    Player:UsePotions(GetSecondOptionValue("使用药水"))
    if
    IsOptionEnabled("抢先施放(需DBM插件)") and BMPullTime() < GetSecondOptionValue("抢先施放(需DBM插件)") and
    (GetOptionValue("抢先施放(需DBM插件)") == "无条件使用" or
    (GetOptionValue("抢先施放(需DBM插件)") == "打BOSS使用" and Target:IsBoss()))
    then
        if DeathsCaress:Exists() and Target:CanCast(DeathsCaress) then
            Player:StartAttack()
            Target:Cast(DeathsCaress)
            return
        end
        if DarkCommand:Exists() and Target:CanCast(DarkCommand) then
            Target:Cast(DarkCommand)
            return
        end
    end
end
function Rotation:Defensives()
    DamageTakenLast5Seconds =     Player:RecentDamageTakenPercent(5, "Physical") + Player:RecentDamageTakenPercent(5, "Spell")
    Player:UseHealingItem()
    if
    CooldownsAllowed() and not Player:Buff(Tombstone) and not Player:Buff(RuneTap) and
    not Player:Buff(DancingRuneWeaponBuff) and
    not Player:Buff(VampiricBlood) and
    not Player:Buff(IceboundFortitude)
    then
        local Shielded = false
        if
        Tombstone:Exists() and IsOptionEnabled("墓石") and Player:BuffCount(BoneShield) >= GetOptionValue("墓石") and
        Player:HealthPercentage() <= GetSecondOptionValue("墓石") and
        Player:CanCast(Tombstone)
        then
            Player:Cast(Tombstone)
            Shielded = true
        end
        if
        not Shielded and RuneTap:Exists() and not Player:Buff(RuneTap) and IsOptionEnabled("符文分流") and
        ((DamageTakenLast5Seconds >= GetOptionValue("符文分流")) or
        (RuneTap:Charges() >= 2 and DamageTakenLast5Seconds >= GetSecondOptionValue("符文分流"))) and
        Player:CanCast(RuneTap)
        then
            Bug("Mitigation via Rune Tap with " .. tostring(RuneTap:Charges()) .. " charges.")
            Player:Cast(RuneTap)
            Shielded = true
        end
        if
        not Shielded and IceboundFortitude:Exists() and IsOptionEnabled("冰封之韧") and
        Player:HealthPercentage() <= GetOptionValue("冰封之韧") and
        Player:CanCast(IceboundFortitude)
        then
            Player:Cast(IceboundFortitude)
            Shielded = true
        end
        if
        not Shielded and DancingRuneWeapon:Exists() and IsOptionEnabled("符文刃舞") and
        Player:HealthPercentage() <= GetOptionValue("符文刃舞") and
        Target:CanCast(DancingRuneWeapon)
        then
            Target:Cast(DancingRuneWeapon)
            Shielded = true
        end
        if
        not Shielded and VampiricBlood:Exists() and IsOptionEnabled("吸血鬼之血") and
        Player:HealthPercentage() <= GetOptionValue("吸血鬼之血") and
        Player:CanCast(VampiricBlood)
        then
            Player:Cast(VampiricBlood)
        end
    end
    if
    AntiMagicShell:Exists() and IsOptionEnabled("反魔法护罩") and Player:HealthPercentage() <= GetOptionValue("反魔法护罩") and
    Player:CanCast(AntiMagicShell)
    then
        Player:Cast(AntiMagicShell)
    end
    if
    GiftOfTheNaaru:Exists() and IsOptionEnabled("纳鲁的赐福") and
    Player:SpecialHealthPercentage() <= GetOptionValue("纳鲁的赐福") and
    Player:CanCast(GiftOfTheNaaru)
    then
        Player:Cast(GiftOfTheNaaru)
    end
end
function Rotation:Interrupts()
    Player:UseInterrupt(MindFreeze, ArcaneTorrent)
end
function Rotation:OffGCDAbilities()
    if IsOptionEnabled("自动取消保护之手") and Player:BuffRemainsAny(HandOfProtection) <= 10 - GetOptionValue("自动取消保护之手") then
        RunMacroText("/cancelaura " .. HandOfProtectionName)
    end
    if DarkCommand:Exists() and Player:TauntManager(DarkCommand, "黑暗命令", Target, TauntEnemies) then
        return
    end
end
function Rotation:UnitTables()
    ConsumptionEnemies = UseAOE() and Player:UnitsInFrontCone(6.5, 140) or {}
    Enemies_10y = UseAOE() and Player:EnemiesWithinDistance(10, true) or {}
    Enemies_5y = UseAOE() and CDOptionEnabled("白骨风暴") and Player:FilterEnemiesByDistance(Enemies_10y, 6.5, true) or {}
    TauntEnemies = Player:EnemiesWithinDistance(30, false)
end
function Rotation:Combat()
    if
    RaiseAlly:Exists() and IsOptionEnabled("复活盟友") and Target:Exists() and Target:IsDeadOrGhost() and
    Target:IsPlayer() and
    Target:CanCast(RaiseAlly)
    then
        Target:Cast(RaiseAlly)
        return
    end
    RuneCount, NextRune = Player:Runes()
    if Target:Exists() and Player:CanAttack(Target) and not Target:IsDeadOrGhost() then
        Player:StartAttack()
        if Player:IsWithinCastRange(Target, HearthStrike) then
            Player:UsePotions(GetSecondOptionValue("使用药水"))
            Player:UseTrinkets()
            if CDOptionEnabled("进攻性种族技能") then
                if BloodFury:Exists() and Player:CanCast(BloodFury) then
                    Player:Cast(BloodFury)
                end
                if Berserking:Exists() and Player:CanCast(Berserking) then
                    Player:Cast(Berserking)
                end
            end
        end
        if
        MarrowRend:Exists() and Player:Buff(BoneShield) and Player:BuffRemains(BoneShield) < GetOptionValue("刷新骨盾") and
        Target:CanCast(MarrowRend)
        then
            Bug("Refresh Bone Shield buff.")
            Target:Cast(MarrowRend)
            return
        end
        if DeathAndDecay:Exists() and IsOptionEnabled("枯萎凋零") and Target:CanCast(DeathAndDecay) then
            if Target:CastGroundSpell(DeathAndDecay, "枯萎凋零", 10) then
                return
            end
        end
        if
        DeathStrike:Exists() and IsOptionEnabled("灵界打击") and
        (not CDOptionEnabled("白骨风暴") or not Bonestorm:Exists() or Bonestorm:Cooldown() > 2 or
        #Enemies_5y < GetOptionValue("Bonestorm Setting")) and
        Player:RunicPower() >= 100 and
        Target:CanCast(DeathStrike)
        then
            Bug("Mitigation via Death Strike Full Runic Power")
            Target:Cast(DeathStrike)
            return
        end
        if MarrowRend:Exists() and Target:CanCast(MarrowRend) and Player:BuffCount(BoneShield) < 2 then
            Target:Cast(MarrowRend)
            return
        end
        if
        DeathStrike:Exists() and IsOptionEnabled("灵界打击") and DamageTakenLast5Seconds >= GetOptionValue("灵界打击") and
        Target:CanCast(DeathStrike)
        then
            Bug("Mitigation via Death Strike High Priority")
            Target:Cast(DeathStrike)
            return
        end
        if
        BloodMirror:Exists() and CDOptionEnabled("血之镜像") and
        Player:HealthPercentage() <= GetOptionValue("Blood Mirror Setting") and
        Target:Health() >= GetSecondOptionValue("Blood Mirror Setting") * 1000000 and
        Target:CanCast(BloodMirror)
        then
            Target:Cast(BloodMirror)
            return
        end
        if
        Bonestorm:Exists() and CDOptionEnabled("白骨风暴") and #Enemies_5y >= GetOptionValue("Bonestorm Setting") and
        Player:RunicPower() >= GetSecondOptionValue("Bonestorm Setting") and
        Player:CanCast(Bonestorm)
        then
            Player:Cast(Bonestorm)
            return
        end
        if
        BloodBoil:Exists() and IsOptionEnabled("Blood Boil") and
        BloodBoil:FractionalCharges() >= GetOptionValue("Blood Boil") and
        Player:CanCast(BloodBoil)
        then
            for i = 1, #Enemies_10y do
                local ThisUnit = Enemies_10y[i]
                if ThisUnit:DebuffRemains(BloodPlague) < 3 then
                    Player:Cast(BloodBoil)
                    return
                end
            end
            if #Enemies_10y > 0 then
                Bug("Avoid Blood Boil capping.")
                Player:Cast(BloodBoil)
                return
            end
        end
        if
        Consumption:Exists() and CDOptionEnabled("吞噬") and
        #ConsumptionEnemies >= GetOptionValue("Consumption Setting") and
        Player:HealthPercentage() <= GetSecondOptionValue("Consumption Setting") and
        Target:CanCast(Consumption)
        then
            Target:Cast(Consumption)
            return
        end
        if BloodTap:Exists() and RuneCount < 3 and Player:CanCast(BloodTap) then
            Player:Cast(BloodTap)
            return
        end
        if DeathAndDecay:Exists() and IsOptionEnabled("枯萎凋零") and Target:CanCast(DeathAndDecay) then
            if Player:CastGroundSpell(DeathAndDecay, "枯萎凋零", 10) then
                return
            end
        end
        if
        MarkOfBlood:Exists() and Player:RunicPower() >= 70 and IsOptionEnabled("鲜血印记") and
        not Target:Debuff(MarkOfBlood) and
        Player:HealthPercentage() <= GetOptionValue("鲜血印记") and
        Target:Health() >= GetSecondOptionValue("鲜血印记") * 1000000 and
        Target:CanCast(MarkOfBlood)
        then
            Target:Cast(MarkOfBlood)
            return
        end
        if
        DeathStrike:Exists() and IsOptionEnabled("灵界打击") and DamageTakenLast5Seconds >= GetSecondOptionValue("灵界打击") and
        Target:CanCast(DeathStrike)
        then
            Bug("Mitigation via Death Strike Low Priority")
            Target:Cast(DeathStrike)
            return
        end
        if
        BloodDrinker:Exists() and CDOptionEnabled("Blooddrinker") and
        Player:HealthPercentage() <= GetSecondOptionValue("Blooddrinker") and
        Target:CanCast(BloodDrinker)
        then
            Target:Cast(BloodDrinker)
            return
        end
        if RuneCount >= 2.5 then
            if Player:DistanceTo(Target) > 10 then
                if DeathsCaress:Exists() and Target:CanCast(DeathsCaress) and not Target:Debuff(BloodPlague) then
                    Target:Cast(DeathsCaress)
                    return
                end
            else
                if MarrowRend:Exists() and Target:CanCast(MarrowRend) and Player:BuffCount(BoneShield) <= 6 then
                    Target:Cast(MarrowRend)
                    return
                end
                if HearthStrike:Exists() and Target:CanCast(HearthStrike) then
                    Target:Cast(HearthStrike)
                    return
                end
            end
        end
        if
        BloodBoil:Exists() and IsOptionEnabled("Blood Boil") and
        BloodBoil:FractionalCharges() >= GetSecondOptionValue("Blood Boil") and
        Player:IsWithinCastRange(Target, HearthStrike) and
        Player:CanCast(BloodBoil)
        then
            Player:Cast(BloodBoil)
            return
        end
    end
end
function Rotation:OutOfCombat()
    if WraithWalk:Exists() and IsOptionEnabled("幽魂步") and Player:IsMoving() and Player:CanCast(WraithWalk) then
        Player:Cast(WraithWalk)
        return
    end
end
SetRotation(251, {})
local Rotation = Rotations[251]
function Rotation:Initialize()
    ArcaneTorrent = Spell(50613, false, false, true)
    Berserking = Spell(26297, false, false, true)
    BloodFury = Spell(20572, false, false, true)
    GiftOfTheNaaru = Spell(59545, false, false, true)
    AntiMagicShell = Spell(48707, false, false, true)
    BreathOfSindragosa = Spell(152279, false, false, true)
    ChainsOfIce = Spell(45524, true, true, true)
    ChilledHeart = Spell(235599)
    ControlUndead = Spell(111673, true, true, true)
    DarkCommand = Spell(56222, true, true, true)
    DarkSuccor = Spell(178819)
    DarkSuccorBuff = Spell(101568)
    DeathStrike = Spell(49998, true, true, true)
    EmpowerRuneWeapon = Spell(47568, false, false, true)
    FrostFever = Spell(55095)
    Frostscythe = Spell(207230, false, false, true)
    FrostStrike = Spell(49143, true, true, true)
    FrozenPulse = Spell(194909)
    GatheringStorm = Spell(194912)
    GlacialAdvance = Spell(194913, false, false, true)
    KillingMachine = Spell(51124)
    HornOfWinter = Spell(57330, false, false, true)
    HowlingBlast = Spell(49184, true, true, true)
    HungeringRuneWeapon = Spell(207127, false, false, true)
    IceboundFortitude = Spell(48792, false, false, true)
    IcyTalons = Spell(194878)
    IcyTalonsBuff = Spell(194879)
    MindFreeze = Spell(47528, true, true, true)
    Obliterate = Spell(49020, true, true, true)
    Obliteration = Spell(207256)
    PillarOfFrost = Spell(51271, false, false, true)
    RaiseAlly = Spell(61999, false, false, true, true)
    Razorice = Spell(51714)
    RemorselessWinter = Spell(196770, false, false, true)
    Rime = Spell(59052)
    RunicAttenuation = Spell(207104)
    ShatteringStrikes = Spell(207057)
    SindragosasFury = Spell(190778, false, false, true)
    UnholyStrength = Spell(53365)
    WraithWalk = Spell(212552, false, false, true)
    KoltirasNewfoundWill = Item(132366)
    PerseveranceOfTheEbonMartyr = Item(132459)
    AddPage("常规")
    AddPage("进攻")
    AddPage("防御")
    AddCommonOptions()
    AddPresetOption("常规")
    AddSection("常规", { "辅助", "效用" }, "Yellow")
    AddNewOption("常规", { "复活盟友", "复活盟友" }, 210, true, nil, nil, { "Use Raise Ally on dead target.", "使用复活盟友死亡目标。" })
    AddSection("常规", { "移动", "运动" }, "Yellow")
    AddNewOption(
    "常规",
    { "幽魂步", "幻影步" },
    210,
    false,
    nil,
    nil,
    { "Automatically use Wraith Walk while moving and Out of Combat.", "使用幻影步移动和离开战斗。" }
    )
    AddPresetOption("进攻")
    AddSection("进攻", { "大技能", "冷却时间" }, "Yellow")
    AddPresetOption(
    "Cooldown",
    { "冰龙吐息", "冰龙吐息" },
    nil,
    { 95, 80, 101, 1 },
    {
        "Use Frost Strike during Breath of Sindragosa while Hungering Rune Weapon is active when our Runic Power is higher than this value. Set to 101 to never use Frost Strike during Breath of Sindragosa.",
        "使用冰霜打击中冰龙吐息而饥饿符文武器是活跃的和我们的符文能量高于此值。 置为101，不要使用冰霜打击中冰龙吐息。"
    }
    )
    AddPresetOption("Cooldown", { "符文武器", "符文武器" })
    AddNewOption(
    "进攻",
    { "符文武器施放条件", "符文武器阈值" },
    122,
    true,
    { 50, 1, 100, 1 },
    { 3, 1, 5, 1 },
    {
        "Thresholds to use Empower Rune Weapon." ..
        C.TOOLTIP_VALUE_1 ..
        "Use if less or equal to this amount of Runic Power." ..
        C.TOOLTIP_VALUE_2 .. "Use if less or equal to this amount of Runes.",
        "使用阈值饥饿符文武器。" .. C.TOOLTIP_VALUE_1 .. "如果少于或等于此数量的话符文能量。" .. C.TOOLTIP_VALUE_2 .. "如果少于或等于此数量的话符文。"
    }
    )
    AddPresetOption("Cooldown", { "湮灭", "湮没" })
    AddPresetOption("Cooldown", { "冰霜之柱", "冰霜之柱" })
    AddSection("进攻", { "能力", "能力" }, "Yellow")
    AddNewOption(
    "进攻",
    { "白霜效果期间施放凛风冲击", "总是凛风冲击同白霜" },
    220,
    true,
    { 40, 1, 100, 1 },
    nil,
    {
        "Always use Rime Procs, even while Breath of Sindragosa and Hungering Rune Weapon are active." ..
        C.TOOLTIP_VALUE .. "Minimum amount of Runic Power to use Rime procs during Breath of Sindragosa.",
        "一直使用白霜特效即使冰龙吐息和饥饿符文武器活跃。" .. C.TOOLTIP_VALUE .. "最小量符文能量使用白霜过程中冰龙吐息。"
    }
    )
    AddNewOption(
    "进攻",
    "冰冻之心",
    210,
    true,
    nil,
    nil,
    "Use Chain of Ice while wearing the Cold Heart legendary chest. (according to SimC)"
    )
    AddNewOption(
    "进攻",
    { "冰霜之镰", "冰霜之镰" },
    222,
    true,
    { 2, 1, 10, 1 },
    { 3, 1, 10, 1 },
    {
        "Use Frostscythe." ..
        C.TOOLTIP_VALUE_1 ..
        "Amount of enemies that must be in 8y in front of player to use with Killing Machine proc." ..
        C.TOOLTIP_VALUE_2 ..
        "Amount of enemies that must be in 8y in front of player to use without Killing Machine proc.",
        "使用冰霜之镰。" ..
        C.TOOLTIP_VALUE_1 .. "在玩家面前8码的敌人数量杀戮机器特效。" .. C.TOOLTIP_VALUE_2 .. "在没有玩家的情况下，必须在8码范围内的敌人的数量杀戮机器特效。"
    }
    )
    AddNewOption(
    "进攻",
    { "冰川突进", "冰川突进" },
    222,
    true,
    { 2, 1, 10, 1 },
    { 1, 1, 10, 1 },
    {
        "Use Glacial Advance." ..
        C.TOOLTIP_VALUE_1 ..
        "Amount of enemies that must be in the 20y corridor in front of player to use as high priority." ..
        C.TOOLTIP_VALUE_2 ..
        "Amount of enemies that must be in the 20y corridor in front of player to use as low priority.",
        "使用冰川突进。" ..
        C.TOOLTIP_VALUE_1 .. "在玩家面前20码走廊的敌人的数量应该高度优先。" .. C.TOOLTIP_VALUE_2 .. "在玩家面前的20码走廊中的敌人的数量应该低优先级。"
    }
    )
    AddNewOption(
    "进攻",
    { "凛风冲击", "凛风冲击" },
    220,
    true,
    { 7, 1, 20, 1 },
    nil,
    {
        "Use Howling Blast filler rather than Obliterate." ..
        C.TOOLTIP_VALUE ..
        "Amount of enemies that must be in 8 yards around our target to use Howling Blast instead of Obliterate when no procs and we have at least 3 Runes." ..
        C.TOOLTIP_HINT("Lower it if you use the Freezing Fog talent."),
        "使用凛风冲击填充而不是湮灭。" ..
        C.TOOLTIP_VALUE .. "在我们的目标使用周围必须有8码的敌人的数量凛风冲击代替湮灭当没有特效我们至少有3个符文。" .. C.TOOLTIP_HINT("如果您使用，请降低它冰冻之雾天赋。")
    }
    )
    AddNewOption(
    "进攻",
    { "冷酷严冬", "冷酷严冬" },
    222,
    true,
    { 1, 1, 10, 1 },
    { 2, 1, 10, 1 },
    {
        "Use Remorseless Winter." ..
        C.TOOLTIP_VALUE_1 ..
        "Amount of enemies that must be in 8y around player to use when using the Gathering Storm talent." ..
        C.TOOLTIP_VALUE_2 ..
        "Amount of enemies that must be in 8y around player to use without the Gathering Storm talent.",
        "使用冷酷严冬。" ..
        C.TOOLTIP_VALUE_1 ..
        "在使用时玩家使用时必须在8码范围内的敌人的数量风暴汇聚天赋。" .. C.TOOLTIP_VALUE_2 .. "数量的敌人必须在8码左右，玩家使用没有风暴汇聚天赋。"
    }
    )
    AddNewOption(
    "进攻",
    { "单个目标使用冷酷严冬", "冷酷严冬单" },
    210,
    true,
    nil,
    nil,
    { "Use Remorseless Winter in single target as filler.", "使用冷酷严冬在单目标作为填料。" }
    )
    AddNewOption(
    "进攻",
    { "辛达苟萨之怒", "辛达苟萨之怒" },
    222,
    true,
    { 2, 1, 10, 1 },
    { 1, 1, 10, 1 },
    {
        "Use Sindragosa's Fury." ..
        C.TOOLTIP_VALUE_1 ..
        "Amount of enemies that must be in the 40y corridor in front of player to use as high priority." ..
        C.TOOLTIP_VALUE_2 ..
        "Amount of enemies that must be in the 40y corridor in front of player to use as low priority.",
        "使用辛达苟萨之怒。" ..
        C.TOOLTIP_VALUE_1 .. "在玩家面前40码走廊的敌人的数量要高度优先使用。" .. C.TOOLTIP_VALUE_2 .. "在玩家面前的40码走廊中的敌人的数量应该低优先级。"
    }
    )
    AddPresetOption("防御")
    AddSection("防御", { "能力", "能力" }, "Yellow")
    AddNewOption(
    "防御",
    { "灵界打击", "灵界打击" },
    222,
    true,
    { 20, 1, 100, 1 },
    { 70, 1, 100, 1 },
    {
        "Use Death Strike." ..
        C.TOOLTIP_VALUE_1 ..
        "Health threshold to use." .. C.TOOLTIP_VALUE_2 .. "Health threshold to use with Dark Succor buff.",
        "使用灵界打击。" .. C.TOOLTIP_VALUE_1 .. "健康阈值。" .. C.TOOLTIP_VALUE_2 .. "健康阈值使用同黑暗援助灵气。"
    }
    )
    AddSection("防御", { "大技能", "冷却时间" }, "Yellow")
    AddNewOption(
    "防御",
    { "冰封之韧", "冰封之韧" },
    220,
    true,
    { 30, 1, 100, 1 },
    nil,
    { "Use Icebound Fortitude." .. C.TOOLTIP_VALUE .. "Health threshold.", "使用冰封之韧。" .. C.TOOLTIP_VALUE .. "健康阈值。" }
    )
    AddNewOption(
    "防御",
    { "反魔法护罩", "反魔法护罩" },
    220,
    false,
    { 50, 1, 100, 1 },
    nil,
    { "Use Anti-Magic Shell." .. C.TOOLTIP_VALUE .. "Health threshold.", "使用反魔法护罩。" .. C.TOOLTIP_VALUE .. "健康阈值。" }
    )
end
function Rotation:Events()
end
function Rotation:Pulse()
    if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
        return
    end
    if Target:Exists() and BMPullTime() < 5 then
        self:Opening()
        return
    end
    if GetTime() < Rotation.SpamPrevention then
        return
    end
    Rotation.SpamPrevention = GetTime() + 0.05
    Target = Unit.Target
    local InCombat = Player:IsInCombat()
    if not InCombat then
        self:OutOfCombat()
        return
    end
    if InCombat then
        self:Defensives()
    end
    Target = Player:ReTarget(Obliterate, true) or Unit.Target
    if Target:Exists() then
        Rotations:RefreshUnitTables(Rotation.Identifier)
        self:Interrupts()
        if
        IsOptionEnabled("开怪技能") and
        (GetOptionValue("开怪技能") == "无条件使用" or (GetOptionValue("开怪技能") == "打BOSS使用" and Target:IsBoss()) or
        (GetOptionValue("开怪技能") == "CDs Only" and CooldownsAllowed())) and
        not OpenerEnded
        then
            self:Opener()
            return
        elseif CombatTime() > 10 then
            OpenerEnded = true
        end
        self:OffGCDAbilities()
        if Player:GlobalCooldown() == 0 then
            self:Combat()
        end
    end
end
function Rotation:Opening()
    Player:UsePotions("力量药水")
    if
    IsOptionEnabled("抢先施放(需DBM插件)") and
    (GetOptionValue("抢先施放(需DBM插件)") == "无条件使用" or
    (GetOptionValue("抢先施放(需DBM插件)") == "打BOSS使用" and Target:IsBoss()))
    then
        if
        HowlingBlast:Exists() and BMPullTime() < GetSecondOptionValue("抢先施放(需DBM插件)") and
        Target:CanCast(HowlingBlast)
        then
            Player:StartAttack()
            Target:Cast(HowlingBlast)
            return
        end
    end
end
function Rotation:Opener()
    self.ChoosenOpener = nil
    if self.ChoosenOpener ~= nil then
        OpenerParser(self.ChoosenOpener)
    else
        Bug("Invalid Talents combination, Opener will not be used.")
        OpenerEnded = true
    end
end
function Rotation:Defensives()
    Player:UseHealingItem()
    if
    AntiMagicShell:Exists() and IsOptionEnabled("反魔法护罩") and Player:HealthPercentage() <= GetOptionValue("反魔法护罩") and
    Player:CanCast(AntiMagicShell)
    then
        Player:Cast(AntiMagicShell)
    end
    if
    IceboundFortitude:Exists() and IsOptionEnabled("冰封之韧") and Player:HealthPercentage() <= GetOptionValue("冰封之韧") and
    Player:CanCast(IceboundFortitude)
    then
        Player:Cast(IceboundFortitude)
    end
    if
    GiftOfTheNaaru:Exists() and IsOptionEnabled("纳鲁的赐福") and
    Player:SpecialHealthPercentage() <= GetOptionValue("纳鲁的赐福") and
    Player:CanCast(GiftOfTheNaaru)
    then
        Player:Cast(GiftOfTheNaaru)
    end
end
function Rotation:Interrupts()
    Player:UseInterrupt(MindFreeze, ArcaneTorrent)
end
function Rotation:OffGCDAbilities()
end
function Rotation:UnitTables()
    TargetDistance = Target:Exists() and Player:DistanceTo(Target, false) or 100
    NumEnemies_8y = UseAOE() and #Player:EnemiesWithinDistance(8, true) or 0
    FrostscytheUnits = UseAOE() and #Player:UnitsInFrontCone(8, 180) or 0
    GlacialAdvanceEnemies = UseAOE() and #Player:UnitsInFrontRectangle(20, 5) or 0
    SindragosasFuryEnemies = UseAOE() and #Player:UnitsInFrontRectangle(40, 5) or 0
    NumTargetEnemies_8y = UseAOE() and #Target:EnemiesWithinDistance(10) or 0
end
function Rotation:bos()
    if
    FrostStrike:Exists() and IcyTalons:Exists() and Player:BuffRemains(IcyTalonsBuff) < 1.5 and
    (not BreathOfSindragosaEnabled or BreathOfSindragosa:Cooldown() > 6) and
    not ShouldDeathStrike and
    Target:CanCast(FrostStrike)
    then
        Target:Cast(FrostStrike)
        return
    end
    if HowlingBlast:Exists() and not Target:Debuff(FrostFever) and Target:CanCast(HowlingBlast) then
        Target:Cast(HowlingBlast)
        return
    end
    if
    BreathOfSindragosa:Exists() and BreathOfSindragosaEnabled and Player:RunicPower() >= 50 and RuneCount > 2 and
    Player:CanCast(BreathOfSindragosa)
    then
        Player:Cast(BreathOfSindragosa)
        return
    end
    if BreathOfSindragosaEnabled and BreathOfSindragosa:Cooldown() < 5 and RuneCount < 2 then
        return
    end
    if
    FrostStrike:Exists() and Player:RunicPower() >= 92 and HasT19_4Pc and not ShouldDeathStrike and
    Target:CanCast(FrostStrike)
    then
        Target:Cast(FrostStrike)
        return
    end
    if
    FrostStrike:Exists() and RemorselessWinter:Exists() and GatheringStorm:Exists() and
    (not BreathOfSindragosaEnabled or BreathOfSindragosa:Cooldown() > 15) and
    not Player:Buff(RemorselessWinter) and
    RemorselessWinter:Cooldown() < Player:GCD() * 3 and
    Player:RunicPower() >= 30 and
    not ShouldDeathStrike and
    Target:CanCast(FrostStrike)
    then
        Target:Cast(FrostStrike)
        return
    end
    if
    RemorselessWinter:Exists() and TargetDistance < 8 and IsOptionEnabled("冷酷严冬") and
    NumEnemies_8y >= GetOptionValue("冷酷严冬") and
    (Player:Buff(Rime) or not GatheringStorm:Exists()) and
    PerseveranceOfTheEbonMartyr:IsEquipped(1) and
    Player:CanCast(RemorselessWinter)
    then
        Player:Cast(RemorselessWinter)
        return
    end
    if
    RemorselessWinter:Exists() and TargetDistance < 8 and IsOptionEnabled("冷酷严冬") and
    (NumEnemies_8y >= GetSecondOptionValue("冷酷严冬") or
    (GatheringStorm:Exists() and NumEnemies_8y >= GetOptionValue("冷酷严冬"))) and
    Player:CanCast(RemorselessWinter)
    then
        Player:Cast(RemorselessWinter)
        return
    end
    if
    HowlingBlast:Exists() and Player:Buff(Rime) and
    (Target:Debuff(RemorselessWinter) or RemorselessWinter:Cooldown() > 1.5 or
    not PerseveranceOfTheEbonMartyr:IsEquipped(1)) and
    Target:CanCast(HowlingBlast)
    then
        Target:Cast(HowlingBlast)
        return
    end
    if FrostStrike:Exists() and Player:RunicPower() >= 70 and not ShouldDeathStrike and Target:CanCast(FrostStrike) then
        Target:Cast(FrostStrike)
        return
    end
    if Obliterate:Exists() and not Player:Buff(Rime) and Target:CanCast(Obliterate) then
        Target:Cast(Obliterate)
        return
    end
    if
    HornOfWinter:Exists() and (not BreathOfSindragosaEnabled or BreathOfSindragosa:Cooldown() > 15) and
    Player:RunicPower() <= 70 and
    Player:CanCast(HornOfWinter)
    then
        Player:Cast(HornOfWinter)
        return
    end
    if
    FrostStrike:Exists() and (not BreathOfSindragosaEnabled or BreathOfSindragosa:Cooldown() > 15) and
    not ShouldDeathStrike and
    Target:CanCast(FrostStrike)
    then
        Target:Cast(FrostStrike)
        return
    end
    if
    RemorselessWinter:Exists() and TargetDistance < 8 and IsOptionEnabled("冷酷严冬") and
    NumEnemies_8y >= GetOptionValue("冷酷严冬") and
    (not BreathOfSindragosaEnabled or BreathOfSindragosa:Cooldown() > 10) and
    Player:CanCast(RemorselessWinter)
    then
        Player:Cast(RemorselessWinter)
        return
    end
    if
    RemorselessWinter:Exists() and TargetDistance < 8 and IsOptionEnabled("单个目标使用冷酷严冬") and
    (not BreathOfSindragosaEnabled or BreathOfSindragosa:Cooldown() > 10) and
    Player:CanCast(RemorselessWinter)
    then
        Player:Cast(RemorselessWinter)
        return
    end
end
function Rotation:bos_ticking()
    if
    RuneCount < 3 and CDOptionEnabled("符文武器") and Player:RunicPower() <= GetOptionValue("符文武器施放条件") and
    RuneCount <= GetSecondOptionValue("符文武器施放条件")
    then
        if
        EmpowerRuneWeapon:Exists() and not HungeringRuneWeapon:Exists() and Player:RunicPower() < 30 and
        Player:CanCast(EmpowerRuneWeapon)
        then
            Player:Cast(EmpowerRuneWeapon)
            return
        end
        if
        HungeringRuneWeapon:Exists() and Player:RunicPower() < 40 and not Player:Buff(HungeringRuneWeapon) and
        Player:CanCast(HungeringRuneWeapon)
        then
            Player:Cast(HungeringRuneWeapon)
            return
        end
    end
    if
    RuneCount < 2 and HornOfWinter:Exists() and Player:RunicPower() < 70 and not Player:Buff(HungeringRuneWeapon) and
    Player:CanCast(HornOfWinter)
    then
        Player:Cast(HornOfWinter)
        return
    end
    if HowlingBlast:Exists() and not Target:Debuff(FrostFever) and Target:CanCast(HowlingBlast) then
        Target:Cast(HowlingBlast)
        return
    end
    if
    RemorselessWinter:Exists() and TargetDistance < 8 and IsOptionEnabled("冷酷严冬") and
    NumEnemies_8y >= GetOptionValue("冷酷严冬") and
    ((Player:RunicPower() >= 22 and HasT19_4Pc) or Player:RunicPower() >= 30) and
    (Player:Buff(Rime) or not GatheringStorm:Exists()) and
    not Player:Buff(HungeringRuneWeapon) and
    PerseveranceOfTheEbonMartyr:IsEquipped(1) and
    Player:CanCast(RemorselessWinter)
    then
        Player:Cast(RemorselessWinter)
        return
    end
    if
    RemorselessWinter:Exists() and TargetDistance < 8 and IsOptionEnabled("冷酷严冬") and
    (NumEnemies_8y >= GetSecondOptionValue("冷酷严冬") or
    (GatheringStorm:Exists() and NumEnemies_8y >= GetOptionValue("冷酷严冬"))) and
    Player:CanCast(RemorselessWinter)
    then
        Player:Cast(RemorselessWinter)
        return
    end
    if
    HowlingBlast:Exists() and ((Player:RunicPower() >= 22 and HasT19_4Pc) or Player:RunicPower() >= 30) and
    Player:Buff(Rime) and
    (not Player:Buff(HungeringRuneWeapon) or
    (IsOptionEnabled("白霜效果期间施放凛风冲击") and Player:RunicPower() >= GetOptionValue("白霜效果期间施放凛风冲击"))) and
    Target:CanCast(HowlingBlast)
    then
        Target:Cast(HowlingBlast)
        return
    end
    if
    FrostStrike:Exists() and Player:RunicPower() >= GetSecondOptionValue("冰龙吐息") and
    Player:Buff(HungeringRuneWeapon) and
    not ShouldDeathStrike and
    Target:CanCast(FrostStrike)
    then
        Target:Cast(FrostStrike)
        return
    end
    if Obliterate:Exists() and (Player:RunicPower() <= 70 or RuneCount > 3) and Target:CanCast(Obliterate) then
        Target:Cast(Obliterate)
        return
    end
    if
    RemorselessWinter:Exists() and TargetDistance < 8 and IsOptionEnabled("冷酷严冬") and
    NumEnemies_8y >= GetOptionValue("冷酷严冬") and
    Player:CanCast(RemorselessWinter)
    then
        Player:Cast(RemorselessWinter)
        return
    end
    if
    RemorselessWinter:Exists() and TargetDistance < 8 and IsOptionEnabled("单个目标使用冷酷严冬") and
    (not BreathOfSindragosaEnabled or BreathOfSindragosa:Cooldown() > 10) and
    Player:CanCast(RemorselessWinter)
    then
        Player:Cast(RemorselessWinter)
        return
    end
end
function Rotation:generic()
    if
    FrostStrike:Exists() and not ShatteringStrikes:Exists() and
    (IcyTalons:Exists() and Player:BuffRemains(IcyTalonsBuff) < 1.5) and
    not ShouldDeathStrike and
    Target:CanCast(FrostStrike)
    then
        Target:Cast(FrostStrike)
        return
    end
    if
    FrostStrike:Exists() and ShatteringStrikes:Exists() and Target:DebuffCount(Razorice) == 5 and
    not ShouldDeathStrike and
    Target:CanCast(FrostStrike)
    then
        Target:Cast(FrostStrike)
        return
    end
    if HowlingBlast:Exists() and not Target:Debuff(FrostFever) and Target:CanCast(HowlingBlast) then
        Target:Cast(HowlingBlast)
        return
    end
    if
    Obliterate:Exists() and RunicAttenuation:Exists() and KoltirasNewfoundWill:IsEquipped(6) and HasT19_2Pc and
    Target:CanCast(Obliterate)
    then
        Target:Cast(Obliterate)
        return
    end
    if
    RemorselessWinter:Exists() and TargetDistance < 8 and IsOptionEnabled("冷酷严冬") and
    NumEnemies_8y >= GetSecondOptionValue("冷酷严冬") and
    (Player:Buff(Rime) or not GatheringStorm:Exists()) and
    PerseveranceOfTheEbonMartyr:IsEquipped(1) and
    Player:CanCast(RemorselessWinter)
    then
        Player:Cast(RemorselessWinter)
        return
    end
    if
    RemorselessWinter:Exists() and TargetDistance < 8 and IsOptionEnabled("冷酷严冬") and
    (NumEnemies_8y >= GetSecondOptionValue("冷酷严冬") or
    (GatheringStorm:Exists() and NumEnemies_8y >= GetOptionValue("冷酷严冬"))) and
    Player:CanCast(RemorselessWinter)
    then
        Player:Cast(RemorselessWinter)
        return
    end
    if
    HowlingBlast:Exists() and Player:Buff(Rime) and not (Player:Buff(Obliteration) and NumTargetEnemies_8y < 2) and
    Target:CanCast(HowlingBlast)
    then
        Target:Cast(HowlingBlast)
        return
    end
    if
    FrostStrike:Exists() and Player:RunicPowerDeficit() <= 30 and not ShouldDeathStrike and
    Target:CanCast(FrostStrike)
    then
        Target:Cast(FrostStrike)
        return
    end
    if
    FrostStrike:Exists() and Player:Buff(Obliteration) and not Player:Buff(KillingMachine) and not ShouldDeathStrike and
    Target:CanCast(FrostStrike)
    then
        Target:Cast(FrostStrike)
        return
    end
    if
    RemorselessWinter:Exists() and TargetDistance < 8 and IsOptionEnabled("冷酷严冬") and
    NumEnemies_8y >= GetSecondOptionValue("冷酷严冬") and
    not (Frostscythe:Exists() and Player:Buff(KillingMachine) and FrostscytheUnits >= 2) and
    Player:CanCast(RemorselessWinter)
    then
        Player:Cast(RemorselessWinter)
        return
    end
    if
    Frostscythe:Exists() and IsOptionEnabled("冰霜之镰") and Player:Buff(KillingMachine) and
    FrostscytheUnits >= GetOptionValue("冰霜之镰") and
    Player:CanCast(Frostscythe)
    then
        Player:Cast(Frostscythe)
        return
    end
    if
    GlacialAdvance:Exists() and IsOptionEnabled("冰川突进") and GlacialAdvanceEnemies >= GetOptionValue("冰川突进") and
    Player:CanCast(GlacialAdvance)
    then
        Player:Cast(GlacialAdvance)
        return
    end
    if
    Frostscythe:Exists() and IsOptionEnabled("冰霜之镰") and FrostscytheUnits >= GetSecondOptionValue("冰霜之镰") and
    Player:CanCast(Frostscythe)
    then
        Player:Cast(Frostscythe)
        return
    end
    if Obliterate:Exists() and Player:Buff(KillingMachine) and Target:CanCast(Obliterate) then
        Target:Cast(Obliterate)
        return
    end
    if
    RemorselessWinter:Exists() and TargetDistance < 8 and IsOptionEnabled("单个目标使用冷酷严冬") and
    Player:CanCast(RemorselessWinter)
    then
        Player:Cast(RemorselessWinter)
        return
    end
    if Obliterate:Exists() and Target:CanCast(Obliterate) then
        Target:Cast(Obliterate)
        return
    end
    if HornOfWinter:Exists() and Player:CanCast(HornOfWinter) then
        Player:Cast(HornOfWinter)
        return
    end
    if FrostStrike:Exists() and not ShouldDeathStrike and Target:CanCast(FrostStrike) then
        Target:Cast(FrostStrike)
        return
    end
    if
    RemorselessWinter:Exists() and TargetDistance < 8 and IsOptionEnabled("冷酷严冬") and
    NumEnemies_8y >= GetOptionValue("冷酷严冬") and
    FrozenPulse:Exists() and
    Player:CanCast(RemorselessWinter)
    then
        Player:Cast(RemorselessWinter)
        return
    end
    if
    CDOptionEnabled("符文武器") and Player:RunicPower() <= GetOptionValue("符文武器施放条件") and
    RuneCount <= GetSecondOptionValue("符文武器施放条件")
    then
        if EmpowerRuneWeapon:Exists() and not HungeringRuneWeapon:Exists() and Player:CanCast(EmpowerRuneWeapon) then
            Player:Cast(EmpowerRuneWeapon)
            return
        end
        if HungeringRuneWeapon:Exists() and Player:CanCast(HungeringRuneWeapon) then
            Player:Cast(HungeringRuneWeapon)
            return
        end
    end
end
function Rotation:Combat()
    if
    RaiseAlly:Exists() and IsOptionEnabled("复活盟友") and Target:Exists() and Target:IsDeadOrGhost() and
    Target:IsPlayer() and
    Target:CanCast(RaiseAlly)
    then
        Target:Cast(RaiseAlly)
        return
    end
    RuneCount, NextRune = Player:Runes()
    if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        Player:StartAttack()
        BreathOfSindragosaEnabled = BreathOfSindragosa:Exists() and CDOptionEnabled("冰龙吐息")
        ShouldDeathStrike =         DeathStrike:Exists() and IsOptionEnabled("灵界打击") and
        (Player:HealthPercentage() <= GetOptionValue("灵界打击") or
        (Player:Buff(DarkSuccorBuff) and Player:HealthPercentage() <= GetSecondOptionValue("灵界打击")))
        if Player:IsWithinCastRange(Target, Obliterate) then
            if
            PillarOfFrost:Exists() and CDOptionEnabled("冰霜之柱") and
            (Player:Buff(BreathOfSindragosa) or BreathOfSindragosa:Cooldown() > 55 or
            not BreathOfSindragosaEnabled) and
            Player:CanCast(PillarOfFrost)
            then
                Player:Cast(PillarOfFrost)
                return
            end
            if CDOptionEnabled("进攻性种族技能") then
                if ArcaneTorrent:Exists() and Player:RunicPowerDeficit() > 20 and Player:CanCast(ArcaneTorrent) then
                    Player:Cast(ArcaneTorrent)
                    return
                end
                if BloodFury:Exists() and Player:Buff(PillarOfFrost) and Player:CanCast(BloodFury) then
                    Player:Cast(BloodFury)
                end
                if Berserking:Exists() and Player:CanCast(Berserking) then
                    Player:Cast(Berserking)
                end
            end
            Player:UseTrinkets()
            Player:UsePotions("力量药水")
            if
            SindragosasFury:Exists() and IsOptionEnabled("辛达苟萨之怒") and SindragosasFuryEnemies >= 1 and
            Player:Buff(PillarOfFrost) and
            Player:CanCast(SindragosasFury)
            then
                Player:Cast(SindragosasFury)
                return
            end
            if
            Obliteration:Exists() and CDOptionEnabled("湮灭") and
            (not FrozenPulse:Exists() or (RuneCount < 2 and Player:RunicPower() < 28)) and
            Player:CanCast(Obliteration)
            then
                Player:Cast(Obliteration)
            end
        end
        if ShouldDeathStrike and Target:CanCast(DeathStrike) then
            Target:Cast(DeathStrike)
            return
        end
        if
        ChainsOfIce:Exists() and IsOptionEnabled("冰冻之心") and Player:BuffCount(ChilledHeart) >= 10 and
        Target:CanCast(ChainsOfIce)
        then
            if
            (Player:BuffCount(ChilledHeart) >= 20 and Player:Buff(UnholyStrength) and PillarOfFrost:Cooldown() > 6) or
            (Player:Buff(PillarOfFrost) and Player:BuffRemains(PillarOfFrost) < Player:GCD() and
            (Player:BuffCount(ChilledHeart) >= 11 or (Player:BuffCount(ChilledHeart) >= 10 and HasT20_4Pc))) or
            (Player:Buff(UnholyStrength) and Player:BuffRemains(UnholyStrength) < Player:GCD() and
            Player:BuffCount(ChilledHeart) >= 16 and
            PillarOfFrost:Cooldown() > 6)
            then
                Target:Cast(ChainsOfIce)
                return
            end
        end
        bosExists = BreathOfSindragosa:Exists()
        if not bosExists then
            self:generic()
        end
        hasBreath = Player:Buff(BreathOfSindragosa)
        if bosExists and not hasBreath then
            self:bos()
        end
        if bosExists and hasBreath then
            self:bos_ticking()
        end
    end
end
function Rotation:OutOfCombat()
    if WraithWalk:Exists() and IsOptionEnabled("幽魂步") and Player:IsMoving() and Player:CanCast(WraithWalk) then
        Player:Cast(WraithWalk)
        return
    end
    if IsOptionEnabled("自动进入战斗") and Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        local EngageSpell = HowlingBlast
        if EngageSpell:Exists() and Target:CanCast(EngageSpell) then
            Target:Cast(EngageSpell)
            return
        end
    end
end
SetRotation(252, {})
local Rotation = Rotations[252]
function Rotation:Initialize()
    ArcaneTorrent = Spell(50613, false, false, true)
    Berserking = Spell(26297, false, false, true)
    BloodFury = Spell(20572, false, false, true)
    GiftOfTheNaaru = Spell(59545, false, false, true)
    Apocalypse = Spell(220143, false, true, true)
    AntiMagicShell = Spell(48707, false, false, true)
    ArmyOfTheDead = Spell(42650, false, false, true)
    BlightedRuneWeapon = Spell(194918, false, false, true)
    BurstingSores = Spell(207264)
    Castigator = Spell(207305)
    ChainsOfIce = Spell(45524, true, true, true)
    ChilledHeart = Spell(235599)
    ClawingShadows = Spell(207311, true, true, true)
    ControlUndead = Spell(111673, true, true, true)
    CorpseShield = Spell(207319, false, false, true)
    DarkArbiter = Spell(207349, true, true, true)
    DarkCommand = Spell(56222, true, true, true)
    DarkSuccor = Spell(178819)
    DarkSuccorBuff = Spell(101568)
    DarkTransformation = Spell(63560, false, false, true)
    DeathAndDecay = Spell(43265, false, true, true)
    DeathAndDecayBuff = Spell(188290)
    DeathCoil = Spell(47541, true, true, true)
    DeathStrike = Spell(49998, true, true, true)
    Defile = Spell(152280, false, true, true)
    Epidemic = Spell(207317, false, false, true)
    FesteringStrike = Spell(85948, true, true, true)
    FesteringWound = Spell(194310)
    IceboundFortitude = Spell(48792, false, false, true)
    InfectedClaws = Spell(207272)
    MindFreeze = Spell(47528, true, true, true)
    Necrosis = Spell(207346)
    NecrosisBuff = Spell(216974)
    Outbreak = Spell(77575, false, true, true)
    RaiseAlly = Spell(61999, false, false, true, true)
    RaiseDead = Spell(46584, false, false, true)
    ScourgeStrike = Spell(55090, true, true, true)
    ShadowInfusion = Spell(198943)
    SludgeBelcher = Spell(207313)
    SoulReaper = Spell(130736, true, true, true)
    SoulReaperBuff = Spell(215711)
    SuddenDoom = Spell(81340, true, true, true)
    SummonGargoyle = Spell(49206, false, true, true)
    UnholyStrength = Spell(53365)
    VirulentPlague = Spell(191587)
    WraithWalk = Spell(212552, false, false, true)
    Claw = Spell(47468, true, true, true)
    Huddle = Spell(47484, false, false, true)
    Gnaw = Spell(47481, true, true, true)
    Cleaver = Spell(212333, true, true, true)
    ProtectiveBile = Spell(212384, false, false, true)
    Smash = Spell(212336, true, true, true)
    Hook = Spell(212468, true, true, true)
    TaktheritrixsShoulderpads = Item(137075)
    TheInstructorsFourthLesson = Item(132448)
    AddPage("常规")
    AddPage("进攻")
    AddPage("防御")
    AddCommonOptions()
    AddPresetOption("常规")
    AddSection("常规", "辅助", "Yellow")
    AddNewOption("常规", "复活盟友", 210, true, nil, nil, "Use Raise Ally on dead target.")
    AddNewOption(
    "常规",
    "立即战复坦克",
    220,
    false,
    { 1, 0, 3, 0.1 },
    nil,
    "Enable to cast Raise Ally on a dead tank." .. C.TOOLTIP_VALUE .. "Set the delay before using it."
    )
    AddSection("常规", "移动", "Yellow")
    AddNewOption("常规", "幽魂步", 210, false, nil, nil, "Automatically use Wraith Walk while moving and Out of Combat.")
    AddPresetOption("进攻")
    AddSection("进攻", "大技能", "Yellow")
    AddPresetOption(
    "Cooldown",
    "天启",
    nil,
    { 7, 4, 8, 1 },
    "Minimum Festering Wounds count that we should apply to our current target before using Apocalypse." ..
    C.TOOLTIP_HINT(
    "The rotation will still attempt to apply at least 7 Wounds before Apocalypse. However, if Apocalypse is ready and the number of Wounds is greater than the second option value, Apocalypse will be used even if we got less than 7 Wounds up."
    )
    )
    AddPresetOption("Cooldown", "凋零符文武器")
    AddPresetOption(
    "Cooldown",
    "黑暗仲裁者",
    nil,
    { 80, 1, 100, 1 },
    "Amount of Runic Power we should pool before using Dark Arbiter."
    )
    AddPresetOption("Cooldown", "灵魂收割")
    AddPresetOption("Cooldown", "召唤石像鬼")
    AddSection("进攻", "能力", "Yellow")
    AddNewOption(
    "进攻",
    "冰冻之心",
    210,
    true,
    nil,
    nil,
    "Use Chain of Ice when we got 19 stacks of Chilled Heart while wearing the Chille Heart legendary chest."
    )
    AddNewOption(
    "进攻",
    "黑暗突变",
    232,
    true,
    { 1, "DT Before DND", "正常" },
    { 1, 1, 10, 1 },
    "Use Dark Transformation." ..
    C.TOOLTIP_VALUE_1 ..
    C.TOOLTIP_SUBVALUE("DT Before DND", true) ..
    "Use Death Coil and Dark Transformation before Death and Decay if you have the Shadow Infusion talent." ..
    C.TOOLTIP_SUBVALUE("正常") ..
    "Do not use Death Coil and Dark Transformation before Death and Decay." ..
    C.TOOLTIP_VALUE_2 ..
    "Amount of enemies that need to be in 8 yards radius around our target to use Dark Transformation."
    )
    AddNewOption("进攻", "仅对BOSS施放黑暗突变", 210, true, nil, nil, "Use Dark Transformation on Target if it's a boss.")
    AddNewOption(
    "进攻",
    "枯萎凋零",
    232,
    true,
    { 2, "目标", "Target Standing", "Centered", "Centered Standing", "Under Player", "Under Player Standing" },
    { 1, 1, 10, 1 },
    "Use Death and Decay." ..
    C.TOOLTIP_VALUE_1 ..
    "Choose preferred mode." ..
    C.TOOLTIP_SUBVALUE("目标") ..
    "Always use on the current target." ..
    C.TOOLTIP_SUBVALUE("Target Standing") ..
    "Always use on the current target. Target must be standing still." ..
    C.TOOLTIP_SUBVALUE("Centered") ..
    "Use centered on a cluster of enemies." ..
    C.TOOLTIP_SUBVALUE("Centered Standing") ..
    "Use centered on a cluster of enemies. Enemies must be standing still." ..
    C.TOOLTIP_VALUE_2 ..
    "Amount of enemies that must be in the spell effect to use."
    )
    AddNewOption(
    "进攻",
    "枯萎凋零 距离",
    220,
    true,
    { 3, 0, 5, 1 },
    nil,
    "Distance from Player we want to use Death and Decay for the Under Player options." ..
    C.TOOLTIP_VALUE .. "Distance in yards from Player."
    )
    AddNewOption(
    "进攻",
    "凋零缠绕(填充技能)",
    220,
    false,
    { 35, 35, 100, 1 },
    nil,
    "Use Death Coil as Filler when Dark Arbiter and Dark Transformation cooldowns are higher than 15 seconds." ..
    C.TOOLTIP_VALUE .. "Runic Power threshold to use Death Coil as Filler."
    )
    AddNewOption(
    "进攻",
    "传染",
    222,
    true,
    { 5, 1, 10, 1 },
    { 3, 1, 10, 1 },
    "Use Epidemic." ..
    C.TOOLTIP_VALUE_1 ..
    "Amount of enemies that must have Virulent Plague to use." ..
    C.TOOLTIP_VALUE_2 .. "Amount of enemies that must have Virulent Plague to use as low priority."
    )
    AddNewOption(
    "进攻",
    "超出范围使用传染",
    222,
    true,
    { 3, 1, 3, 1 },
    { 3, 0, 3, 0.1 },
    "Use Epidemic as Single Target while Out of Range when there is less than a specified time on specified stack recharge." ..
    C.TOOLTIP_VALUE_1 ..
    "Use Epidemic before we reach this amount of charges." ..
    C.TOOLTIP_VALUE_2 .. "Time (in second) before we reach the charges threshold."
    )
    AddNewOption(
    "进攻",
    "单个目标使用传染",
    222,
    true,
    { 3, 1, 3, 1 },
    { 1, 0, 3, 0.1 },
    "Use Epidemic as Single Target when there is less than a specified time on specified stack recharge." ..
    C.TOOLTIP_VALUE_1 ..
    "Use Epidemic before we reach this amount of charges." ..
    C.TOOLTIP_VALUE_2 .. "Time (in second) before we reach the charges threshold."
    )
    AddNewOption(
    "进攻",
    "爆发周期",
    220,
    true,
    { 2, 1, 10, 1 },
    nil,
    "Use Outbreak to apply Virulent Plague when at least x enemies dont have the debuffs. Disabling it will still make it be cast on the target." ..
    C.TOOLTIP_VALUE .. "Amount of enemies that must not have Virulent Plague to use."
    )
    AddNewOption(
    "进攻",
    "宠物输出处理",
    233,
    true,
    { 2, "Do Not Handle Assist", "Handle Assist" },
    { 3, "Do Not Handle Spells", "Enable Spells", "Handle Spells" },
    "Manage Pet Casts to use power as high priority only during Dark Transformation." ..
    C.TOOLTIP_VALUE_1 ..
    "Enable this to automatically change between assist and passive mode depending if you have a target or not." ..
    C.TOOLTIP_VALUE_2 ..
    "Enable this to automatically disable spells the profile should be handling so that they are handled by the rotation." ..
    C.TOOLTIP_HINT(
    "Spells handling applies to Ghoul Claw and Gnaw or Abomination Cleaver and Smash."
    )
    )
    AddPresetOption("防御")
    AddSection("防御", "能力", "Yellow")
    AddNewOption(
    "防御",
    "灵界打击",
    222,
    true,
    { 20, 1, 100, 1 },
    { 70, 1, 100, 1 },
    "Use Death Strike." ..
    C.TOOLTIP_VALUE_1 ..
    "Health threshold to use." .. C.TOOLTIP_VALUE_2 .. "Health threshold to use with Dark Succor buff."
    )
    AddSection("防御", "大技能", "Yellow")
    AddNewOption(
    "防御",
    "反魔法护罩",
    220,
    false,
    { 50, 1, 100, 1 },
    nil,
    "Use Anti-Magic Shell." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddNewOption(
    "防御",
    "血肉之盾",
    232,
    false,
    { 2, "Do Not Use Pet Shield", "Use Pet Shield" },
    { 25, 1, 100, 1 },
    "Use Corpse Shield." ..
    C.TOOLTIP_VALUE_1 ..
    "Set to Use Pet Shield to allow using the Pet Shield ability (Ghoul Huddle or Abomination Protective Bile)." ..
    C.TOOLTIP_VALUE_2 ..
    "Health threshold." ..
    C.TOOLTIP_HINT(
    "If first option is set to Use Pet Shield, the Pet will Shield itself whenever you use Corpse Shield. Even if used manually or if the option to use Corpse Shield is disabled. To prevent Pet from Shielding itself, you need to define it to Do Not Use Pet Shield."
    )
    )
    AddNewOption(
    "防御",
    "冰封之韧",
    220,
    true,
    { 20, 1, 100, 1 },
    nil,
    "Use Icebound Fortitude." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddOutput("|cffFF0000敌人数量|r // |cff00FF00感染数量|r:")
    SetOutput("|cffFF0000敌人数量|r // |cff00FF00感染数量|r:", "|cffFF00000|r // |cff00FF000|r")
end
function Rotation:Events()
end
function Rotation:Pulse()
    if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
        return
    end
    if Target:Exists() and BMPullTime() < 5 then
        self:Opening()
        return
    end
    if GetTime() < Rotation.SpamPrevention then
        return
    end
    Rotation.SpamPrevention = GetTime() + 0.05
    Target = Unit.Target
    local InCombat = Player:IsInCombat()
    if not InCombat then
        self:OutOfCombat()
        return
    end
    if InCombat then
        self:Defensives()
    end
    Target = Player:ReTarget(FesteringStrike, true) or Unit.Target
    if Target:Exists() then
        Rotations:RefreshUnitTables(Rotation.Identifier)
        self:Interrupts()
        if
        IsOptionEnabled("开怪技能") and
        (GetOptionValue("开怪技能") == "无条件使用" or (GetOptionValue("开怪技能") == "打BOSS使用" and Target:IsBoss()) or
        (GetOptionValue("开怪技能") == "CDs Only" and CooldownsAllowed())) and
        not OpenerEnded
        then
            self:Opener()
            return
        elseif CombatTime() > 10 then
            OpenerEnded = true
        end
        self:OffGCDAbilities()
        if Player:GlobalCooldown() == 0 then
            self:Combat()
        end
    end
end
function Rotation:Opening()
    Player:UsePotions("力量药水")
    if
    IsOptionEnabled("抢先施放(需DBM插件)") and
    (GetOptionValue("抢先施放(需DBM插件)") == "无条件使用" or
    (GetOptionValue("抢先施放(需DBM插件)") == "打BOSS使用" and Target:IsBoss()))
    then
        if ArmyOfTheDead:Exists() and BMPullTime() < 7 and Player:CanCast(ArmyOfTheDead) then
            Player:Cast(ArmyOfTheDead)
            return
        end
        if
        DarkTransformation:Exists() and BMPullTime() < GetSecondOptionValue("抢先施放(需DBM插件)") + Player:GCD() + 0.2 and
        Player:CanCast(DarkTransformation)
        then
            Player:Cast(DarkTransformation)
            return
        end
        if BMPullTime() < GetSecondOptionValue("抢先施放(需DBM插件)") then
            Player:StartAttack()
            if Hook:PetKnown() and Target:CanCast(Hook) then
                Target:Cast(Hook)
            end
            if SummonGargoyle:Exists() and not DarkArbiter:Exists() and Target:CanCast(SummonGargoyle) then
                Target:Cast(SummonGargoyle)
                return
            end
        end
    end
end
function Rotation:Opener()
    self.ChoosenOpener = nil
    if self.ChoosenOpener ~= nil then
        OpenerParser(self.ChoosenOpener)
    else
        Bug("Invalid Talents combination, Opener will not be used.")
        OpenerEnded = true
    end
end
function Rotation:Defensives()
    Player:UseHealingItem()
    if
    AntiMagicShell:Exists() and IsOptionEnabled("反魔法护罩") and Player:HealthPercentage() <= GetOptionValue("反魔法护罩") and
    Player:CanCast(AntiMagicShell)
    then
        Player:Cast(AntiMagicShell)
    end
    if
    IceboundFortitude:Exists() and IsOptionEnabled("冰封之韧") and Player:HealthPercentage() <= GetOptionValue("冰封之韧") and
    Player:CanCast(IceboundFortitude)
    then
        Player:Cast(IceboundFortitude)
    end
    if
    CorpseShield:Exists() and IsOptionEnabled("血肉之盾") and Player:HealthPercentage() <= GetSecondOptionValue("血肉之盾") and
    Player:CanCast(CorpseShield)
    then
        Player:Cast(CorpseShield)
    end
    if
    CorpseShield:Exists() and GetOptionValue("血肉之盾") == "Use Pet Shield" and PlayerPet:Power() > 10 and
    Player:Buff(CorpseShield)
    then
        if SludgeBelcher:Exists() and Player:PetCanCast(ProtectiveBile) and ProtectiveBile:TimeSinceCast() > 45 then
            Player:Cast(ProtectiveBile)
            ProtectiveBile.LastCastTime = GetTime()
        elseif Player:PetCanCast(Huddle) and Huddle:TimeSinceCast() > 45 then
            Player:Cast(Huddle)
            Huddle.LastCastTime = GetTime()
        end
    end
    if
    GiftOfTheNaaru:Exists() and IsOptionEnabled("纳鲁的赐福") and
    Player:SpecialHealthPercentage() <= GetOptionValue("纳鲁的赐福") and
    Player:CanCast(GiftOfTheNaaru)
    then
        Player:Cast(GiftOfTheNaaru)
    end
end
function Rotation:Interrupts()
    Player:UseInterrupt(MindFreeze, ArcaneTorrent)
end
function Rotation:PlayerPetHandling()
    if IsOptionEnabled("宠物输出处理") then
        if PlayerPet:Exists() then
            if GetSecondOptionValue("宠物输出处理") == "Handle Spells" and Target:Exists() and not Target:IsDeadOrGhost() then
                for i = 1, 10 do
                    self.PetActionName, _, _, _, _, _, self.IsPetActionActive, self.PetActionID = GetPetActionInfo(i)
                    if
                    self.PetActionID == 212333 or self.PetActionID == 212336 or self.PetActionID == 47468 or
                    self.PetActionID == 47481
                    then
                        if self.IsPetActionActive then
                            Bug("Disabling " .. self.PetActionName)
                            DisableSpellAutocast(self.PetActionName)
                        end
                    end
                end
                IsDarkTransformationEnabled = DarkTransformation:Exists() and IsOptionEnabled("黑暗突变") or false
                if SludgeBelcher:Exists() then
                    if PlayerPet:Buff(DarkTransformation) and Target:PetCanCast(Cleaver) then
                        Target:Cast(Cleaver)
                    elseif
                    (not IsDarkTransformationEnabled or DarkTransformation:Cooldown() > 10 or
                    PlayerPet:Power() >= 80) and
                    Target:PetCanCast(Cleaver)
                    then
                        Target:Cast(Cleaver)
                    end
                    if PlayerPet:Buff(DarkTransformation) and Target:PetCanCast(Smash) then
                        Target:Cast(Smash)
                    elseif
                    (not IsDarkTransformationEnabled or DarkTransformation:Cooldown() > 25) and
                    Target:PetCanCast(Smash)
                    then
                        Target:Cast(Smash)
                    end
                else
                    if PlayerPet:Buff(DarkTransformation) and Target:PetCanCast(Claw) then
                        Target:Cast(Claw)
                    elseif
                    (not IsDarkTransformationEnabled or DarkTransformation:Cooldown() > 10 or
                    PlayerPet:Power() >= 80) and
                    Target:PetCanCast(Claw)
                    then
                        Target:Cast(Claw)
                    end
                    if PlayerPet:Buff(DarkTransformation) and Target:PetCanCast(Gnaw) then
                        Target:Cast(Gnaw)
                    elseif
                    (not IsDarkTransformationEnabled or DarkTransformation:Cooldown() > 25) and
                    Target:PetCanCast(Gnaw)
                    then
                        Target:Cast(Gnaw)
                    end
                end
            elseif GetSecondOptionValue("宠物输出处理") == "Enable Spells" then
                for i = 1, 10 do
                    self.PetActionName, _, _, _, _, _, self.IsPetActionActive, self.PetActionID = GetPetActionInfo(i)
                    if
                    self.PetActionID == 212333 or self.PetActionID == 212336 or self.PetActionID == 47468 or
                    self.PetActionID == 47481
                    then
                        if not self.IsPetActionActive then
                            Bug("Enabling " .. self.PetActionName)
                            EnableSpellAutocast(self.PetActionName)
                        end
                    end
                end
            end
            if GetOptionValue("宠物输出处理") == "Handle Assist" then
                if Target:Exists() and not self.PetAssisting then
                    PetAssistMode()
                    self.PetAssisting = true
                elseif not Target:Exists() and self.PetAssisting then
                    PetPassiveMode()
                    self.PetAssisting = false
                end
            end
        end
    else
        if PlayerPet:Exists() then
            for i = 1, 10 do
                self.PetActionName, _, _, _, _, _, self.IsPetActionActive, self.PetActionID = GetPetActionInfo(i)
                if
                self.PetActionID == 212333 or self.PetActionID == 212336 or self.PetActionID == 47468 or
                self.PetActionID == 47481
                then
                    if not self.IsPetActionActive then
                        Bug("Enabling " .. self.PetActionName)
                        EnableSpellAutocast(self.PetActionName)
                    end
                end
            end
        end
    end
end
function Rotation:PetHandler()
    if (UnitExists("PlayerPet") == false or UnitIsDeadOrGhost("PlayerPet")) and Player:CanCast(RaiseDead) then
        Player:Cast(RaiseDead)
        return
    end
end
function Rotation:OffGCDAbilities()
    self:PlayerPetHandling()
end
function Rotation:UnitTables()
    Enemies_40y = UseAOE() and Player:EnemiesWithinDistance(40, false) or {}
    EpidemicUnitsCount =     UseAOE() and Epidemic:Exists() and #Player:FilterEnemiesByDebuff(Enemies_40y, VirulentPlague) or 0
    OutbreakUnit = UseAOE() and Target:BestClusterOfMobsToDot(VirulentPlague, 3, 8, false, 30, false) or nil
    TargetEnemies_8y = UseAOE() and Target:EnemiesWithinDistance(8, true) or {}
    OutbreakCount = UseAOE() and #Target:FilterEnemiesByDebuff(TargetEnemies_8y, VirulentPlague) or 0
    NumEnemies = #TargetEnemies_8y
end
function Rotation:Combat()
    if RaiseAlly:Exists() then
        if
        IsOptionEnabled("复活盟友") and Target:Exists() and Target:IsDeadOrGhost() and Target:IsPlayer() and
        Target:CanCast(RaiseAlly)
        then
            Target:Cast(RaiseAlly)
            return
        end
        if IsOptionEnabled("立即战复坦克") then
            MainTank, MainTankTarget, OffTank, OffTankTarget = Unit.GetMainTanks()
            if MainTank and MainTank:Exists() and not MainTank:IsDeadOrGhost() then
                MainTankResDelay = nil
            end
            if OffTank and OffTank:Exists() and not OffTank:IsDeadOrGhost() then
                OffTankResDelay = nil
            end
            if
            MainTank and MainTank:Exists() and MainTank:IsDeadOrGhost() and MainTank:IsPlayer() and
            MainTank:CanCast(RaiseAlly)
            then
                if not MainTankResDelay then
                    MainTankResDelay = GetTime()
                end
                if GetTime() - MainTankResDelay >= GetOptionValue("立即战复坦克") then
                    MainTankResDelay = nil
                    MainTank:Cast(RaiseAlly)
                    return
                end
            elseif
            OffTank and OffTank:Exists() and OffTank:IsDeadOrGhost() and OffTank:IsPlayer() and
            OffTank:CanCast(RaiseAlly)
            then
                if not OffTankResDelay then
                    OffTankResDelay = GetTime()
                end
                if GetTime() - OffTankResDelay >= GetOptionValue("立即战复坦克") then
                    OffTankResDelay = nil
                    OffTank:Cast(RaiseAlly)
                    return
                end
            end
        end
    end
    self:PetHandler()
    RuneCount, NextRune = Player:Runes()
    RunicPower, RunicPowerDeficit, DarkArbiterRunicPower =     Player:RunicPower(),
    Player:RunicPowerDeficit(),
    DarkArbiter:Exists() and DarkArbiter:Cooldown() < 10 and GetSecondOptionValue("黑暗仲裁者") or
    Player:RunicPowerMax() - 10
    if Target:Exists() and Player:CanAttack(Target) then
        Player:StartAttack()
        SetOutput(
        "|cffFF0000敌人数量|r // |cff00FF00感染数量|r:",
        "|cffFF0000" .. tostring(#Enemies_40y) .. "|r // |cff00FF00" .. tostring(EpidemicUnitsCount) .. "|r"
        )
        ApocalypseEnabled = CDOptionEnabled("天启")
        ApocalypseCooldown = ApocalypseEnabled and Apocalypse:Cooldown() or 100
        GargoyleEnabled, ArbiterEnabled =         not DarkArbiter:Exists() and SummonGargoyle:Exists() and CDOptionEnabled("召唤石像鬼") or false,
        DarkArbiter:Exists() and CDOptionEnabled("黑暗仲裁者") or false
        if Player:IsWithinCastRange(Target, FesteringStrike) then
            Player:UseTrinkets()
            if CDOptionEnabled("进攻性种族技能") then
                if BloodFury:Exists() and Player:CanCast(BloodFury) then
                    Player:Cast(BloodFury)
                end
                if not Apocalypse:Exists() and Berserking:Exists() and Player:CanCast(Berserking) then
                    Player:Cast(Berserking)
                end
                if ArcaneTorrent:Exists() and RunicPowerDeficit > 20 and Player:CanCast(ArcaneTorrent) then
                    Player:Cast(ArcaneTorrent)
                end
            end
            Player:UsePotions("力量药水")
        end
        if
        DeathStrike:Exists() and
        (Player:HealthPercentage() <= GetOptionValue("灵界打击") or
        (Player:Buff(DarkSuccorBuff) and Player:HealthPercentage() <= GetSecondOptionValue("灵界打击"))) and
        Target:CanCast(DeathStrike)
        then
            Target:Cast(DeathStrike)
            return
        end
        if Outbreak:Exists() and Outbreak:TimeSinceCast() > 6 then
            if
            Epidemic:Exists() and IsOptionEnabled("爆发周期") and
            #Enemies_40y - EpidemicUnitsCount >= GetOptionValue("爆发周期")
            then
                if OutbreakUnit and OutbreakUnit:CanCast(Outbreak) then
                    Outbreak.LastCastTime = GetTime()
                    OutbreakUnit:Cast(Outbreak)
                    return
                end
            end
            if not Target:Debuff(VirulentPlague) and Target:CanCast(Outbreak) then
                Outbreak.LastCastTime = GetTime()
                Target:Cast(Outbreak)
                return
            end
        end
        if
        DarkTransformation:Exists() and PlayerPet:Exists() and not PlayerPet:IsDeadOrGhost() and
        ((IsOptionEnabled("黑暗突变") and NumEnemies >= GetSecondOptionValue("黑暗突变")) or
        (IsOptionEnabled("仅对BOSS施放黑暗突变") and Target:IsBoss())) and
        Player:CanCast(DarkTransformation)
        then
            if DarkArbiter:Exists() then
                if TaktheritrixsShoulderpads:IsEquipped(3) and (not ArbiterEnabled or DarkArbiter:Cooldown() > 165) then
                    Player:Cast(DarkTransformation)
                    return
                end
                if
                TaktheritrixsShoulderpads:IsEquipped(3) and not ShadowInfusion:Exists() and
                (not ArbiterEnabled or DarkArbiter:Cooldown() > 55)
                then
                    Player:Cast(DarkTransformation)
                    return
                end
                if
                TaktheritrixsShoulderpads:IsEquipped(3) and ShadowInfusion:Exists() and
                (not ArbiterEnabled or DarkArbiter:Cooldown() > 35)
                then
                    Player:Cast(DarkTransformation)
                    return
                end
            else
                if TaktheritrixsShoulderpads:IsEquipped(3) and (not GargoyleEnabled or SummonGargoyle:Cooldown() > 160) then
                    Player:Cast(DarkTransformation)
                    return
                end
                if
                TaktheritrixsShoulderpads:IsEquipped(3) and not ShadowInfusion:Exists() and
                (not GargoyleEnabled or SummonGargoyle:Cooldown() > 55)
                then
                    Player:Cast(DarkTransformation)
                    return
                end
                if
                TaktheritrixsShoulderpads:IsEquipped(3) and ShadowInfusion:Exists() and
                (not GargoyleEnabled or SummonGargoyle:Cooldown() > 35)
                then
                    Player:Cast(DarkTransformation)
                    return
                end
            end
            if not TaktheritrixsShoulderpads:IsEquipped(3) and RuneCount <= 3 then
                Player:Cast(DarkTransformation)
                return
            end
        end
        if
        BlightedRuneWeapon:Exists() and CDOptionEnabled("凋零符文武器") and RuneCount <= 3 and
        Player:CanCast(BlightedRuneWeapon)
        then
            Player:Cast(BlightedRuneWeapon)
            return
        end
        if DarkArbiter:Exists() and GetTotemInfo(3) then
            if DeathCoil:Exists() and Target:CanCast(DeathCoil) then
                Target:Cast(DeathCoil)
                return
            end
            if
            Apocalypse:Exists() and ApocalypseEnabled and Target:DebuffCount(FesteringWound) >= 6 and
            Target:CanCast(Apocalypse)
            then
                Target:Cast(Apocalypse)
                return
            end
            if
            FesteringStrike:Exists() and ApocalypseEnabled and Target:DebuffCount(FesteringWound) < 6 and
            ApocalypseCooldown < 3 and
            Target:CanCast(FesteringStrike)
            then
                Target:Cast(FesteringStrike)
                return
            end
            if NumEnemies >= 2 then
                if
                not Defile:Exists() and DeathAndDecay:Exists() and IsOptionEnabled("枯萎凋零") and
                not DeathAndDecay:IsOnCooldown()
                then
                    if Target:CastGroundSpell(DeathAndDecay, "枯萎凋零", 10) then
                        return
                    end
                end
                if
                Epidemic:Exists() and IsOptionEnabled("传染") and EpidemicUnitsCount >= GetOptionValue("传染") and
                Player:CanCast(Epidemic)
                then
                    Player:Cast(Epidemic)
                    return
                end
                if
                ScourgeStrike:Exists() and not ClawingShadows:Exists() and Player:BuffAny(DeathAndDecayBuff) and
                Target:CanCast(ScourgeStrike)
                then
                    Target:Cast(ScourgeStrike)
                    return
                end
                if ClawingShadows:Exists() and Player:BuffAny(DeathAndDecayBuff) and Target:CanCast(ClawingShadows) then
                    Target:Cast(ClawingShadows)
                    return
                end
                if
                Epidemic:Exists() and IsOptionEnabled("传染") and EpidemicUnitsCount >= GetSecondOptionValue("传染") and
                Player:CanCast(Epidemic)
                then
                    Player:Cast(Epidemic)
                    return
                end
            end
            if FesteringStrike:Exists() and Target:DebuffCount(FesteringWound) <= 4 and Target:CanCast(FesteringStrike) then
                Target:Cast(FesteringStrike)
                return
            end
            if
            ScourgeStrike:Exists() and not ClawingShadows:Exists() and Target:Debuff(FesteringWound) and
            Target:CanCast(ScourgeStrike)
            then
                Target:Cast(ScourgeStrike)
                return
            end
            if ClawingShadows:Exists() and Target:Debuff(FesteringWound) and Target:CanCast(ClawingShadows) then
                Target:Cast(ClawingShadows)
                return
            end
            return
        end
        if
        DarkArbiter:Exists() and CDOptionEnabled("黑暗仲裁者") and not TaktheritrixsShoulderpads:IsEquipped(3) and
        RunicPower > DarkArbiterRunicPower and
        Target:CanCast(DarkArbiter)
        then
            Target:Cast(DarkArbiter)
            return
        end
        if
        DarkArbiter:Exists() and CDOptionEnabled("黑暗仲裁者") and TaktheritrixsShoulderpads:IsEquipped(3) and
        RunicPower > DarkArbiterRunicPower and
        DarkTransformation:Cooldown() < 2 and
        Target:CanCast(DarkArbiter)
        then
            Target:Cast(DarkArbiter)
            return
        end
        if
        not DarkArbiter:Exists() and SummonGargoyle:Exists() and CDOptionEnabled("召唤石像鬼") and
        not TaktheritrixsShoulderpads:IsEquipped(3) and
        RuneCount <= 3 and
        Target:CanCast(SummonGargoyle)
        then
            Target:Cast(SummonGargoyle)
            return
        end
        if
        ChainsOfIce:Exists() and IsOptionEnabled("冰冻之心") and Player:BuffCount(ChilledHeart) > 19 and
        Target:CanCast(ChainsOfIce)
        then
            Target:Cast(ChainsOfIce)
            return
        end
        if
        not DarkArbiter:Exists() and SummonGargoyle:Exists() and CDOptionEnabled("召唤石像鬼") and
        TaktheritrixsShoulderpads:IsEquipped(3) and
        DarkTransformation:Cooldown() < 10 and
        RuneCount <= 3 and
        Target:CanCast(SummonGargoyle)
        then
            Target:Cast(SummonGargoyle)
            return
        end
        SoulReaperCooldown = SoulReaper:Exists() and CDOptionEnabled("灵魂收割") and SoulReaper:Cooldown() or 100
        if
        SoulReaper:Exists() and CDOptionEnabled("灵魂收割") and Target:DebuffCount(FesteringWound) >= 6 and
        ApocalypseCooldown < 4 and
        Target:CanCast(SoulReaper)
        then
            Target:Cast(SoulReaper)
            return
        end
        if Apocalypse:Exists() and CDOptionEnabled("天启") and SoulReaperCooldown > 15 then
            if Target:DebuffCount(FesteringWound) >= GetSecondOptionValue("天启") and Target:CanCast(Apocalypse) then
                if CDOptionEnabled("进攻性种族技能") then
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        Player:Cast(Berserking)
                    end
                end
                Target:Cast(Apocalypse)
                return
            end
        end
        if Apocalypse:Exists() and CDOptionEnabled("天启") then
            if Target:DebuffCount(FesteringWound) < 7 or Target:DebuffCount(FesteringWound) < GetSecondOptionValue("天启") then
                if Target:CanCast(FesteringStrike) and Apocalypse:Cooldown() < 2 then
                    Target:Cast(FesteringStrike)
                    return
                end
            elseif Target:DebuffCount(FesteringWound) < 3 then
                if Target:CanCast(FesteringStrike) and Apocalypse:Cooldown() < 5 then
                    Target:Cast(FesteringStrike)
                    return
                end
            end
        end
        if DeathCoil:Exists() and RunicPower > DarkArbiterRunicPower and Target:CanCast(DeathCoil) then
            Target:Cast(DeathCoil)
            return
        end
        if
        DeathCoil:Exists() and not DarkArbiter:Exists() and Player:Buff(SuddenDoom) and
        not Player:Buff(NecrosisBuff) and
        RuneCount <= 3 and
        Target:CanCast(DeathCoil)
        then
            Target:Cast(DeathCoil)
            return
        end
        if
        DeathCoil:Exists() and DarkArbiter:Exists() and Player:Buff(SuddenDoom) and DarkArbiter:Cooldown() > 5 and
        RuneCount <= 3 and
        Target:CanCast(DeathCoil)
        then
            Target:Cast(DeathCoil)
            return
        end
        if
        FesteringStrike:Exists() and Apocalypse:Exists() and Target:DebuffCount(FesteringWound) < 6 and
        ApocalypseCooldown <= 6 and
        Target:CanCast(FesteringStrike)
        then
            Target:Cast(FesteringStrike)
            return
        end
        if
        SoulReaper:Exists() and CDOptionEnabled("灵魂收割") and
        (not Apocalypse:Exists() or Apocalypse:Cooldown() > 30 or not ApocalypseEnabled) and
        Target:DebuffCount(FesteringWound) >= 3 and
        SoulReaper:Cooldown() < Player:GCD() * 2
        then
            local WoundsRequired = Castigator:Exists() and 5 or 3
            if Target:DebuffCount(FesteringWound) >= WoundsRequired and RuneCount >= 3 and Target:CanCast(SoulReaper) then
                Target:Cast(SoulReaper)
                return
            elseif Target:DebuffCount(FesteringWound) < WoundsRequired and Target:CanCast(FesteringStrike) then
                Target:Cast(FesteringStrike)
                return
            elseif
            RunicPower >= 35 and
            (not ShadowInfusion:Exists() or not PlayerPet:Buff(DarkTransformation) or
            PlayerPet:BuffRemains(DarkTransformation) > 5) and
            Target:CanCast(DeathCoil)
            then
                Bug("Pooling runes for Soul Reaper 2 ")
                Target:Cast(DeathCoil)
                return
            else
                Bug("Pooling for Soul Reaper 2 ")
                return
            end
        end
        if
        FesteringStrike:Exists() and Target:Debuff(SoulReaper) and not Target:Debuff(FesteringWound) and
        Target:CanCast(FesteringStrike)
        then
            Target:Cast(FesteringStrike)
            return
        end
        if
        ScourgeStrike:Exists() and not ClawingShadows:Exists() and Target:Debuff(SoulReaper) and
        Player:BuffCount(SoulReaperBuff) < 3 and
        Target:DebuffCount(FesteringWound) >= 1 and
        Target:CanCast(ScourgeStrike)
        then
            Target:Cast(ScourgeStrike)
            return
        end
        if
        ClawingShadows:Exists() and Target:Debuff(SoulReaper) and Player:BuffCount(SoulReaperBuff) < 3 and
        Target:DebuffCount(FesteringWound) >= 1 and
        Target:CanCast(ClawingShadows)
        then
            Target:Cast(ClawingShadows)
            return
        end
        if Defile:Exists() and IsOptionEnabled("枯萎凋零") and Target:CanCast(Defile) then
            if Target:CastGroundSpell(Defile, "枯萎凋零", 10) then
                return "Cast"
            end
        end
        if NumEnemies >= 2 then
            if
            not Defile:Exists() and DeathAndDecay:Exists() and IsOptionEnabled("枯萎凋零") and
            not DeathAndDecay:IsOnCooldown()
            then
                if Target:CastGroundSpell(DeathAndDecay, "枯萎凋零", 10) then
                    return "Cast"
                end
            end
            if
            Epidemic:Exists() and IsOptionEnabled("传染") and EpidemicUnitsCount >= GetOptionValue("传染") and
            Player:CanCast(Epidemic)
            then
                Player:Cast(Epidemic)
                return "Cast"
            end
            if
            ScourgeStrike:Exists() and not ClawingShadows:Exists() and Player:BuffAny(DeathAndDecayBuff) and
            Target:CanCast(ScourgeStrike)
            then
                Target:Cast(ScourgeStrike)
                return "Cast"
            end
            if ClawingShadows:Exists() and Player:BuffAny(DeathAndDecayBuff) and Target:CanCast(ClawingShadows) then
                Target:Cast(ClawingShadows)
                return "Cast"
            end
            if
            Epidemic:Exists() and IsOptionEnabled("传染") and EpidemicUnitsCount >= GetSecondOptionValue("传染") and
            Player:CanCast(Epidemic)
            then
                Player:Cast(Epidemic)
                return "Cast"
            end
        end
        if TheInstructorsFourthLesson:IsEquipped(9) then
            if
            FesteringStrike:Exists() and Target:DebuffCount(FesteringWound) <= 2 and RunicPowerDeficit > 5 and
            Target:CanCast(FesteringStrike)
            then
                Target:Cast(FesteringStrike)
                return
            end
            if
            DeathCoil:Exists() and not Player:Buff(NecrosisBuff) and Necrosis:Exists() and RuneCount <= 3 and
            Target:CanCast(DeathCoil)
            then
                Target:Cast(DeathCoil)
                return
            end
            if
            ScourgeStrike:Exists() and not ClawingShadows:Exists() and Player:Buff(NecrosisBuff) and
            Target:DebuffCount(FesteringWound) >= 3 and
            RunicPowerDeficit > 9 and
            Target:CanCast(ScourgeStrike)
            then
                Target:Cast(ScourgeStrike)
                return
            end
            if
            ClawingShadows:Exists() and Player:Buff(NecrosisBuff) and Target:DebuffCount(FesteringWound) >= 3 and
            RunicPowerDeficit > 9 and
            Target:CanCast(ClawingShadows)
            then
                Target:Cast(ClawingShadows)
                return
            end
            if
            ScourgeStrike:Exists() and not ClawingShadows:Exists() and Player:Buff(UnholyStrength) and
            Target:DebuffCount(FesteringWound) >= 3 and
            RunicPowerDeficit > 9 and
            Target:CanCast(ScourgeStrike)
            then
                Target:Cast(ScourgeStrike)
                return
            end
            if
            ClawingShadows:Exists() and Player:Buff(UnholyStrength) and Target:DebuffCount(FesteringWound) >= 3 and
            RunicPowerDeficit > 9 and
            Target:CanCast(ClawingShadows)
            then
                Target:Cast(ClawingShadows)
                return
            end
            if
            ScourgeStrike:Exists() and not ClawingShadows:Exists() and RuneCount >= 2 and
            Target:DebuffCount(FesteringWound) >= 3 and
            RunicPowerDeficit > 9 and
            Target:CanCast(ScourgeStrike)
            then
                Target:Cast(ScourgeStrike)
                return
            end
            if
            ClawingShadows:Exists() and RuneCount >= 2 and Target:DebuffCount(FesteringWound) >= 3 and
            RunicPowerDeficit > 9 and
            Target:CanCast(ClawingShadows)
            then
                Target:Cast(ClawingShadows)
                return
            end
            if
            DeathCoil:Exists() and ShadowInfusion:Exists() and DarkArbiter:Exists() and
            not PlayerPet:Buff(DarkTransformation) and
            DarkArbiter:Cooldown() > 10 and
            Target:CanCast(DeathCoil)
            then
                Target:Cast(DeathCoil)
                return
            end
            if
            DeathCoil:Exists() and ShadowInfusion:Exists() and not DarkArbiter:Exists() and
            not PlayerPet:Buff(DarkTransformation) and
            Target:CanCast(DeathCoil)
            then
                Target:Cast(DeathCoil)
                return
            end
            if DeathCoil:Exists() and DarkArbiter:Exists() and DarkArbiter:Cooldown() > 10 and Target:CanCast(DeathCoil) then
                Target:Cast(DeathCoil)
                return
            end
            if
            DeathCoil:Exists() and not ShadowInfusion:Exists() and not DarkArbiter:Exists() and
            Target:CanCast(DeathCoil)
            then
                Target:Cast(DeathCoil)
                return
            end
        end
        if not Castigator:Exists() and not TheInstructorsFourthLesson:IsEquipped(9) then
            if
            FesteringStrike:Exists() and
            ((Target:DebuffCount(FesteringWound) <= 2 and Target:TimeToDie() > 6) or
            Target:DebuffCount(FesteringWound) < 1) and
            RunicPowerDeficit > 5 and
            Target:CanCast(FesteringStrike)
            then
                Target:Cast(FesteringStrike)
                return
            end
            if
            DeathCoil:Exists() and not Player:Buff(NecrosisBuff) and Necrosis:Exists() and RuneCount <= 3 and
            Target:CanCast(DeathCoil)
            then
                Target:Cast(DeathCoil)
                return
            end
            if
            ScourgeStrike:Exists() and not ClawingShadows:Exists() and Player:Buff(NecrosisBuff) and
            Target:Debuff(FesteringWound) and
            RunicPowerDeficit > 9 and
            Target:CanCast(ScourgeStrike)
            then
                Target:Cast(ScourgeStrike)
                return
            end
            if
            ClawingShadows:Exists() and Player:Buff(NecrosisBuff) and Target:Debuff(FesteringWound) and
            RunicPowerDeficit > 9 and
            Target:CanCast(ClawingShadows)
            then
                Target:Cast(ClawingShadows)
                return
            end
            if
            ScourgeStrike:Exists() and not ClawingShadows:Exists() and Player:Buff(UnholyStrength) and
            Target:Debuff(FesteringWound) and
            RunicPowerDeficit > 9 and
            Target:CanCast(ScourgeStrike)
            then
                Target:Cast(ScourgeStrike)
                return
            end
            if
            ClawingShadows:Exists() and Player:Buff(UnholyStrength) and Target:Debuff(FesteringWound) and
            RunicPowerDeficit > 9 and
            Target:CanCast(ClawingShadows)
            then
                Target:Cast(ClawingShadows)
                return
            end
            if
            ScourgeStrike:Exists() and not ClawingShadows:Exists() and RuneCount >= 2 and
            Target:Debuff(FesteringWound) and
            RunicPowerDeficit > 9 and
            Target:CanCast(ScourgeStrike)
            then
                Target:Cast(ScourgeStrike)
                return
            end
            if
            ClawingShadows:Exists() and RuneCount >= 2 and Target:Debuff(FesteringWound) and RunicPowerDeficit > 9 and
            Target:CanCast(ClawingShadows)
            then
                Target:Cast(ClawingShadows)
                return
            end
            if
            DeathCoil:Exists() and ShadowInfusion:Exists() and DarkArbiter:Exists() and
            not PlayerPet:Buff(DarkTransformation) and
            DarkArbiter:Cooldown() > 10 and
            Target:CanCast(DeathCoil)
            then
                Target:Cast(DeathCoil)
                return
            end
            if
            DeathCoil:Exists() and ShadowInfusion:Exists() and not DarkArbiter:Exists() and
            not PlayerPet:Buff(DarkTransformation) and
            Target:CanCast(DeathCoil)
            then
                Target:Cast(DeathCoil)
                return
            end
            if DeathCoil:Exists() and DarkArbiter:Exists() and DarkArbiter:Cooldown() > 10 and Target:CanCast(DeathCoil) then
                Target:Cast(DeathCoil)
                return
            end
            if
            DeathCoil:Exists() and not ShadowInfusion:Exists() and not DarkArbiter:Exists() and
            Target:CanCast(DeathCoil)
            then
                Target:Cast(DeathCoil)
                return
            end
        end
        if Castigator:Exists() and not TheInstructorsFourthLesson:IsEquipped(9) then
            if
            FesteringStrike:Exists() and
            ((Target:DebuffCount(FesteringWound) <= 4 and Target:TimeToDie() > 6) or
            Target:DebuffCount(FesteringWound) <= 2) and
            RunicPowerDeficit > 23 and
            Target:CanCast(FesteringStrike)
            then
                Target:Cast(FesteringStrike)
                return
            end
            if
            DeathCoil:Exists() and not Player:Buff(NecrosisBuff) and Necrosis:Exists() and RuneCount <= 3 and
            Target:CanCast(DeathCoil)
            then
                Target:Cast(DeathCoil)
                return
            end
            if
            Epidemic:Exists() and RuneCount >= 2 and IsOptionEnabled("单个目标使用传染") and
            (Epidemic:Charges() >= GetOptionValue("单个目标使用传染") or
            (Epidemic:Charges() >= GetOptionValue("单个目标使用传染") - 1 and
            Epidemic:Recharge() < GetSecondOptionValue("单个目标使用传染"))) and
            Player:CanCast(Epidemic)
            then
                Bug("单个目标使用传染")
                Player:Cast(Epidemic)
                return
            end
            if
            ScourgeStrike:Exists() and not ClawingShadows:Exists() and RuneCount >= 2 and Player:Buff(NecrosisBuff) and
            Target:DebuffCount(FesteringWound) >= 3 and
            RunicPowerDeficit > 23 and
            Target:CanCast(ScourgeStrike)
            then
                Target:Cast(ScourgeStrike)
                return
            end
            if
            ScourgeStrike:Exists() and not ClawingShadows:Exists() and RuneCount >= 2 and
            Player:Buff(UnholyStrength) and
            Target:DebuffCount(FesteringWound) >= 3 and
            RunicPowerDeficit > 23 and
            Target:CanCast(ScourgeStrike)
            then
                Target:Cast(ScourgeStrike)
                return
            end
            if
            ScourgeStrike:Exists() and not ClawingShadows:Exists() and RuneCount >= 2 and
            Target:DebuffCount(FesteringWound) >= 3 and
            RunicPowerDeficit > 23 and
            Target:CanCast(ScourgeStrike)
            then
                Target:Cast(ScourgeStrike)
                return
            end
            if
            DeathCoil:Exists() and ShadowInfusion:Exists() and DarkArbiter:Exists() and
            not PlayerPet:Buff(DarkTransformation) and
            DarkArbiter:Cooldown() > 15 and
            Target:CanCast(DeathCoil)
            then
                Target:Cast(DeathCoil)
                return
            end
            if
            DeathCoil:Exists() and ShadowInfusion:Exists() and not DarkArbiter:Exists() and
            not PlayerPet:Buff(DarkTransformation) and
            Target:CanCast(DeathCoil)
            then
                Target:Cast(DeathCoil)
                return
            end
            if DeathCoil:Exists() and DarkArbiter:Exists() and DarkArbiter:Cooldown() > 15 and Target:CanCast(DeathCoil) then
                Target:Cast(DeathCoil)
                return
            end
            if
            DeathCoil:Exists() and not ShadowInfusion:Exists() and not DarkArbiter:Exists() and
            Target:CanCast(DeathCoil)
            then
                Target:Cast(DeathCoil)
                return
            end
        end
        if
        DeathCoil:Exists() and IsOptionEnabled("凋零缠绕(填充技能)") and RunicPower >= GetOptionValue("凋零缠绕(填充技能)") and
        (not ShadowInfusion:Exists() or PlayerPet:BuffRemains(DarkTransformation) > 7) and
        (not DarkArbiter:Exists() or DarkArbiter:Cooldown() > 15) and
        Target:CanCast(DeathCoil)
        then
            Bug("凋零缠绕(填充技能)")
            Target:Cast(DeathCoil)
            return
        end
        if
        Epidemic:Exists() and RuneCount >= 2 and IsOptionEnabled("超出范围使用传染") and
        (Epidemic:Charges() >= GetOptionValue("超出范围使用传染") or
        (Epidemic:Charges() >= GetOptionValue("超出范围使用传染") - 1 and
        Epidemic:Recharge() < GetSecondOptionValue("超出范围使用传染"))) and
        Player:CanCast(Epidemic)
        then
            Bug("超出范围使用传染")
            Player:Cast(Epidemic)
            return
        end
    end
end
function Rotation:OutOfCombat()
    self:PetHandler()
    if WraithWalk:Exists() and IsOptionEnabled("幽魂步") and Player:IsMoving() and Player:CanCast(WraithWalk) then
        Player:Cast(WraithWalk)
        return
    end
    if IsOptionEnabled("自动进入战斗") and Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        local EngageSpell = Outbreak:Exists() and Outbreak or FesteringStrike
        if EngageSpell:Exists() and Target:CanCast(EngageSpell) then
            Target:Cast(EngageSpell)
            return
        end
    end
end
SetRotation(577, {})
local Rotation = Rotations[577]
function Rotation:Initialize()
    self.HasBetaRotation = true
    ArcaneTorrent = Spell(202719, false, false, true)
    Shadowmeld = Spell(58984, false, false, true)
    Annihilation = Spell(201427, true, true, true)
    BladeDance = Spell(188499, false, false, true)
    BlindFury = Spell(203550, false, false, true)
    Bloodlet = Spell(206473)
    Blur = Spell(198589, false, false, true)
    BlurBuff = Spell(212800, false, false, true)
    ChaosBlades = Spell(247938, false, false, true)
    ChaosCleave = Spell(206475)
    ChaosNova = Spell(179057, false, false, true)
    ChaosStrike = Spell(162794, true, true, true)
    ConsumeMagic = Spell(183752, true, true, true)
    DeathSweep = Spell(210152, false, false, true)
    Demonic = Spell(213410, false, false, true)
    DemonsBite = Spell(162243, true, true, true)
    DemonBlades = Spell(203555, true, true, true)
    DemonSpeed = Spell(201469)
    EyeBeam = Spell(198013, false, false, true)
    FelBarrage = Spell(211053, true, true, true)
    Felblade = Spell(232893, true, true, true)
    FelEruption = Spell(211881, true, true, true)
    FelMastery = Spell(192939)
    FelRush = Spell(195072, false, false, true)
    FirstBlood = Spell(206416, false, false, true)
    FuryOfTheIllidari = Spell(201467, false, false, true)
    MasterOfTheGlaive = Spell(203556)
    Metamorphosis = Spell(191427, false, false, true)
    MetamorphosisPVP = Spell(191427, false, true, true)
    MetamorphosisBuff = Spell(162264, false, false, true)
    Momentum = Spell(206476, false, false, true)
    MomentumBuff = Spell(208628)
    Nemesis = Spell(206491, true, true, true)
    Netherwalk = Spell(196555, false, false, true)
    Prepared = Spell(203551, false, false, true)
    ThrowGlaive = Spell(185123, true, true, true)
    VengefulRetreat = Spell(198793, false, false, true)
    Imprison = Spell(217832, true, false, false)
    GlaiveSnare = Spell(213405)
    FelCrazedRage = Spell(225141)
    WideEyes = Spell(238045)
    Beam = Spell(206645)
    AnguishOfTheDeceiver = Spell(201473)
    DraughtOfSouls = Item(140808)
    AddPage("常规")
    AddPage("进攻")
    AddPage("防御")
    if self.HasBetaRotation then
        AddNewOption(
        "常规",
        "测试版循环",
        210,
        true,
        nil,
        nil,
        "Use the lastest updated combat routine. May not be as optimized and can contain error regarding execution!"
        )
    end
    AddCommonOptions()
    AddPresetOption("常规", "Melee", nil, false)
    AddSection("常规", { "移动设置", "移动选项" }, "Yellow")
    AddNewOption(
    "常规",
    { "原地邪能冲撞", "邪能冲击取消动作" },
    210,
    false,
    nil,
    nil,
    {
        "Use Fel Rush with movement cancel to sync Momentum with high damage abilities or to prevent capping charges." ..
        C.TOOLTIP_HINT(
        "Requires Fel Mastery and/or Momentum talent. Can cause Disconnect if you move forward while jumping."
        ),
        "使用邪能冲击与动作取消同步动量与高伤害能力或防止封顶费用。" .. C.TOOLTIP_HINT("需要邪能精通和/或势如破竹天赋。 如果您跳跃时向前移动，可能导致断开连接。")
    }
    )
    AddNewOption(
    "常规",
    { "复仇回避 连招", "复仇回避组合" },
    230,
    false,
    { 1, { "邪能之刃", "邪能之刃" }, { "邪能冲撞", "邪能冲撞" }, { "邪能弹幕和冲撞", "邪能弹幕 & 邪能冲撞" } },
    nil,
    {
        "Use Vengeful Retreat + Felblade or Fel Rush to proc Momentum." ..
        C.TOOLTIP_VALUE ..
        C.TOOLTIP_SUBVALUE("自动") ..
        "Use Felblade or Fel Rush along Vengeful Retreat. Felblade will be favored but Fel Rush will be used if Felblade is not talented or ready." ..
        C.TOOLTIP_SUBVALUE("邪能之刃") ..
        "Use Felblade with Vengeful Retreat." ..
        C.TOOLTIP_SUBVALUE("邪能冲撞") ..
        "Use Fel Rush with Vengeful Retreat." ..
        C.TOOLTIP_HINT("You need Prepared and Momentum talents."),
        "使用复仇回避 + 邪能之刃要么邪能冲撞激活势如破竹。" ..
        C.TOOLTIP_VALUE ..
        C.TOOLTIP_SUBVALUE("自动") ..
        "使用邪能之刃要么邪能冲撞随着复仇回避。 邪能之刃将会受到青睐，但如能邪能刃没有天赋或准备就会被使用。" ..
        C.TOOLTIP_SUBVALUE("邪能之刃") ..
        "使用邪能之刃与复仇回避" ..
        C.TOOLTIP_SUBVALUE("邪能冲撞") .. "使用邪能冲击以及复仇回避" .. C.TOOLTIP_HINT("你需要准备和动力的人才。")
    }
    )
    AddPresetOption("进攻")
    AddSection("进攻", { "大技能", "酷唐斯" }, "Yellow")
    AddPresetOption("Cooldown", { "混乱之刃", "混乱之刃" })
    AddPresetOption("Cooldown", { "恶魔变形", "恶魔变形" })
    AddPresetOption("Cooldown", { "涅墨西斯", "涅墨西斯" })
    AddNewOption(
    "进攻",
    { "伊利达雷之怒", "伊利达雷之怒" },
    223,
    true,
    { 2, 1, 10, 1 },
    { 2, { "无条件使用", "总是" }, { "大技能用法", "仅限冷却时间" } },
    {
        "Use Fury of the Illidari." ..
        C.TOOLTIP_VALUE_1 ..
        "Amount of units that needs to be around player to use." ..
        C.TOOLTIP_VALUE_2 ..
        C.TOOLTIP_SUBVALUE("无条件使用", true) ..
        "Will use the ability even if CDs are disabled." ..
        C.TOOLTIP_SUBVALUE("大技能用法") .. "Will only use the ability if CDs are enabled.",
        "使用 伊利达雷之怒。" ..
        C.TOOLTIP_VALUE_1 ..
        "需要在玩家身边使用的单位数量。" ..
        C.TOOLTIP_VALUE_2 ..
        C.TOOLTIP_SUBVALUE("总是", true) ..
        "即使冷却时间被禁用，也会使用这种能力。" .. C.TOOLTIP_SUBVALUE("仅限冷却时间") .. "只有启用冷却时才会使用该功能。"
    }
    )
    AddNewOption(
    "进攻",
    { "伊利达雷之怒 BOSS", "伊利达雷之怒老板" },
    223,
    true,
    { 1, 1, 10, 1 },
    { 2, { "无条件使用", "总是" }, { "大技能用法", "仅限冷却时间" } },
    {
        "Use Fury of the Illidari when our target is a Boss." ..
        C.TOOLTIP_VALUE_1 ..
        "Amount of units that needs to be around player to use." ..
        C.TOOLTIP_VALUE_2 ..
        C.TOOLTIP_SUBVALUE("无条件使用", true) ..
        "Will use the ability even if CDs are disabled." ..
        C.TOOLTIP_SUBVALUE("大技能用法") .. "Will only use the ability if CDs are enabled.",
        "当我们的目标是老板时，使用伊利达雷之怒。" ..
        C.TOOLTIP_VALUE_1 ..
        "需要在玩家身边使用的单位数量。" ..
        C.TOOLTIP_VALUE_2 ..
        C.TOOLTIP_SUBVALUE("总是", true) ..
        "即使冷却时间被禁用，也会使用这种能力。" .. C.TOOLTIP_SUBVALUE("仅限冷却时间") .. "只有启用冷却时才会使用该功能。"
    }
    )
    AddPresetOption(
    "Cooldown",
    { "邪能弹幕", "邪能弹幕" },
    1,
    { 1, 1, 10, 1 },
    {
        "Amount of units that need to be in 8 yards around the target to use with 4 charges. It will still use it with 5 charges even on single target.",
        "需要在目标周围8码范围内使用4个费用的单位数量。 即使在单个目标上，它仍然会使用5个费用。"
    }
    )
    AddSection("进攻", { "能力", "能力" }, "Yellow")
    AddNewOption(
    "进攻",
    "魔化流循环",
    210,
    true,
    nil,
    nil,
    "ONLY BETA: Use a special APL when running Demonic talent. Best used with Blind Fury and Demonic Appetite Talent"
    )
    AddNewOption(
    "进攻",
    { "刃舞, 死亡横扫", "刃舞, 死亡横扫" },
    220,
    true,
    { 3, 1, 10, 1 },
    nil,
    {
        "Use Blade Dance." ..
        C.TOOLTIP_VALUE ..
        "Number of enemies in range to use Blade Dance. It will always use on 1 enemy if First Blood is talented. Automatically adjusts +3 units when Chaos Cleave is talented." ..
        C.TOOLTIP_HINT("This value should never be changed."),
        "使用刃舞。" ..
        C.TOOLTIP_VALUE ..
        "使用刀锋的范围内的敌人数量。 如果第一滴血是有天赋的，它将永远用于1个敌人。 自动调整+3单位混沌切割有天赋。" .. C.TOOLTIP_HINT("此值不应更改。")
    }
    )
    AddNewOption(
    "进攻",
    { "混乱顺劈保存怒气", "混乱顺劈池" },
    220,
    true,
    { 60, 0, 100, 5 },
    nil,
    {
        "Should we Pool Fury for incoming waves of adds while we only have one target in range for Chaos Strike." ..
        C.TOOLTIP_VALUE .. "Minimum Fury deficit before spending.",
        "我们应该为入侵的敌人节省能量，而我们只有一个目标在范围内为混沌打击。" .. C.TOOLTIP_VALUE .. "支出前最低限度的愤怒赤字。"
    }
    )
    AddPresetOption(
    "Cooldown",
    { "眼棱", "眼棱" },
    nil,
    { 2, 1, 10, 1 },
    { "Amount of units that needs to be in 10 yards in front of player to use.", "在玩家面前10码的单位数量。" }
    )
    AddPresetOption(
    "Cooldown",
    { "眼棱和魔化", "眼棱与魔化人才" },
    nil,
    { 1, 1, 10, 1 },
    { "Amount of units that needs to be in 10 yards in front of player to use.", "在玩家面前10码的单位数量。" }
    )
    AddNewOption(
    "进攻",
    { "眼棱和势如破竹", "眼棱与势如破竹" },
    210,
    false,
    nil,
    nil,
    {
        "Only use Eye Beam during Momentum." ..
        C.TOOLTIP_HINT(
        "WARNING: Eye Beam will not be used until you have the Momentum buff. This mean that if Fel Rush Cancel Movement option is disabled, you need to manage Momentum manually. This only applies if the Momentum talent is choosen."
        ),
        "在动量时只使用眼镜。" ..
        C.TOOLTIP_HINT("警告：眼棱将不会被使用，直到你有势如破竹魔法增益。 这意味着如果“邪能冲击取消动作”选项被禁用，则需要手动管理势如破竹。 这只适用于如果选择如破竹人才。")
    }
    )
    AddNewOption("进攻", { "邪能爆发", "邪能爆发" }, 210, true, nil, nil, { "Use Fel Eruption.", "使用邪能爆发。" })
    AddNewOption(
    "进攻",
    { "邪能之刃", "邪能之刃" },
    230,
    true,
    { 1, { "无条件使用", "总是" }, { "Melee Range", "近战范围" } },
    nil,
    {
        "Use Felblade to generate Fury." ..
        C.TOOLTIP_VALUE ..
        "Choose when you want to use Felblade." ..
        C.TOOLTIP_SUBVALUE("无条件使用") ..
        "Use in and out of melee range." ..
        C.TOOLTIP_SUBVALUE("Melee Range") .. "Only use in melee range.",
        "使用邪能之刃来产生愤怒。" ..
        C.TOOLTIP_VALUE ..
        "选择何时使用邪能之刃。" ..
        C.TOOLTIP_SUBVALUE("总是") .. "使用进出近战范围。" .. C.TOOLTIP_SUBVALUE("近战范围") .. "仅在近战范围内使用。"
    }
    )
    AddNewOption(
    "进攻",
    { "投掷利刃", "投掷利刃" },
    230,
    true,
    { 1, { "无条件使用", "总是" }, { "在战斗中", "在战斗中" }, { "脱离战斗后", "在战斗中" } },
    nil,
    {
        "Use Throw Glaive as a filler in the rotation even without Bloodlet." ..
        C.TOOLTIP_VALUE ..
        "Choose when you want to use Throw Glaive." ..
        C.TOOLTIP_SUBVALUE("无条件使用") ..
        "Use Throw Glaive In and Out of Combat." ..
        C.TOOLTIP_SUBVALUE("在战斗中") ..
        "Only use Throw Glaive In Combat." ..
        C.TOOLTIP_SUBVALUE("脱离战斗后") .. "Only use Throw Glaive Out of Combat.",
        "在没有血滴子的情况下使用投掷利刃作为填充物。" ..
        C.TOOLTIP_VALUE ..
        "选择何时使用投掷利刃。" ..
        C.TOOLTIP_SUBVALUE("总是") ..
        "使用投掷利刃进出战斗。" ..
        C.TOOLTIP_SUBVALUE("在战斗中") ..
        "在战斗中只使用投掷利刃。" .. C.TOOLTIP_SUBVALUE("在战斗中") .. "只用投掷利刃出战斗。"
    }
    )
    AddPresetOption("防御")
    AddSection("防御", { "大技能", "酷唐斯" }, "Yellow")
    AddNewOption("防御", { "疾影", "疾影" }, 220, true, { 25, 1, 100, 1 }, nil, { "Health Percentage to use Blur.", "健康百分比使用疾影。" })
    AddNewOption(
    "防御",
    { "虚空行走", "虚空行走" },
    220,
    true,
    { 25, 1, 100, 1 },
    nil,
    { "Health Percentage to use Netherwalk.", "健康百分比使用虚空行走。" }
    )
    AddNewOption(
    "防御",
    { "魔化天赋下低血量使用眼棱", "眼棱恶魔变形低健康" },
    220,
    false,
    { 50, 1, 100, 1 },
    nil,
    {
        "Health Percentage to use Eye Beam to trigger Metamorphosis to heal ourself when using the Demonic talent.",
        "健康百分比使用眼球触发变态使用恶魔天赋治愈自己。"
    }
    )
    local PathFrame = CreateFrame("FRAME", "PathFrameFrame")
    PathFrame:RegisterEvent("UI_ERROR_MESSAGE")
    local function PathCheck(Self, Event, Message)
        if Message == _G["SPELL_FAILED_NOPATH"] or Message == 50 then
            NoPathFromEvent = true
            NoPathFromEventPositionX, NoPathFromEventPositionY, NoPathFromEventPositionZ = Player.X, Player.Y, Player.Z
        end
    end
    PathFrame:SetScript("OnEvent", PathCheck)
    local Frame = CreateFrame("Frame")
    local function RushForward(self, ...)
        if VengefulRetreating ~= nil then
            Option1 = GetOptionValue("复仇回避 连招")
            if
            not Target:Exists() or Target:IsDeadOrGhost() or not Player:IsInCombat() or
            (Option1 == "邪能之刃" and not Felblade:Exists())
            then
                VengefulRetreating = nil
            end
            if
            (Option1 == "邪能之刃" or Option1 == "自动") and Felblade:Exists() and Target:CanCast(Felblade) and
            VengefulRetreating < GetTime()
            then
                Target:Cast(Felblade)
                return
            end
            if
            (Option1 == "邪能冲撞" or Option1 == "自动" or Option1 == "邪能弹幕和冲撞") and Player:GlobalCooldown() == 0 and
            VengefulRetreating < GetTime()
            then
                Player:Cast(FelRush)
                FelRush.LastCastTime = GetTime()
                return
            end
        end
    end
    Frame:SetScript("OnUpdate", RushForward)
    RegisterCommand(
    "felrush",
    function()
        if FelRush:Exists() then
            if ShouldFelRush == true then
                ShouldFelRush = false
                Bug("Fel Rush Queue Canceled")
            else
                if FelRush:Cooldown() < 1.5 then
                    ShouldFelRush = true
                    Bug("Fel Rush Queued")
                else
                    Bug("Fel Rush is on cooldown.")
                end
            end
        else
            Bug("You do not have Fel Rush.")
        end
    end
    )
    RegisterCommand(
    "chaos",
    function()
        if Player:IsInCombat() then
            if ChaosNova:Exists() then
                if ShouldChaosNova == true then
                    ShouldChaosNova = false
                    Bug("Chaos Nova Queue Canceled")
                elseif ChaosNova:Cooldown() < 5 then
                    ShouldChaosNova = true
                    Bug("Chaos Nova Queued")
                end
            else
                Bug("You do not have Chaos Nova.")
            end
        end
    end
    )
    RegisterCommand(
    "eyebeam",
    function()
        if Player:IsInCombat() then
            if EyeBeam:Exists() then
                if ShouldEyeBeamMacro == true then
                    ShouldEyeBeamMacro = false
                    Bug("Eye Beam Queue Canceled")
                elseif EyeBeam:Cooldown() < 5 then
                    ShouldEyeBeamMacro = true
                    Bug("Eye Beam Queued")
                end
            else
                Bug("You do not have Eye Beam.")
            end
        end
    end
    )
end
function Rotation:UseBetaRotation()
    return self.HasBetaRotation and IsOptionEnabled("测试版循环")
end
function Rotation:Events()
    EventFrame:RegisterForSelfCombatEvent(
    function(...)
        if select(12, ...) == 232893 then
            VengefulRetreating = nil
        end
    end,
    "SPELL_CAST_SUCCESS"
    )
    EventFrame:RegisterForEvent(
    function(...)
        if select(1, ...) == "player" and select(5, ...) == 195072 then
            if FelRushCancel then
                _G["AscendStop"]()
                _G["MoveBackwardStop"]()
                FelRushCancel = false
            end
            VengefulRetreating = nil
        end
    end,
    "UNIT_SPELLCAST_SUCCEEDED"
    )
end
function Rotation:Pulse()
    if ShouldJumpAndRush then
        if GetSpellCooldown(GetSpellInfo(195072)) == 0 then
            self:FelRushJump()
        elseif GetSpellCooldown(GetSpellInfo(195072)) > Player:GCD() then
            ShouldJumpAndRush = false
        end
        return
    end
    if
    not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() or
    VengefulRetreating ~= nil or
    Player:Channeling(EyeBeam) or
    FelRush:TimeSinceCast() < 0.75 or
    Player:Buff(FelCrazedRage) or
    Player:Buff(Netherwalk)
    then
        return
    end
    if Target:Exists() and BMPullTime() < 5 then
        self:Opening()
        return
    end
    if GetTime() < Rotation.SpamPrevention then
        return
    end
    Rotation.SpamPrevention = GetTime() + 0.05
    Target = Unit.Target
    local InCombat = Player:IsInCombat()
    if not InCombat then
        self:OutOfCombat()
        return
    end
    if InCombat then
        self:Defensives()
    end
    if Target:Exists() and BMPullTime() < 5 then
        self:Opening()
        return
    end
    Target = Player:ReTarget(DemonsBite, false) or Unit.Target
    if Target:Exists() then
        Rotations:RefreshUnitTables(Rotation.Identifier)
        self:OffGCDAbilities()
        if Player:GlobalCooldown() == 0 then
            if self:UseBetaRotation() then
                self:CombatBeta()
            else
                self:Combat()
            end
        end
    end
end
function Rotation:Opening()
    Player:UsePotions("Agility")
    if
    IsOptionEnabled("抢先施放(需DBM插件)") and
    (GetOptionValue("抢先施放(需DBM插件)") == "无条件使用" or
    (GetOptionValue("抢先施放(需DBM插件)") == "打BOSS使用" and Target:IsBoss()))
    then
        if
        Metamorphosis:Exists() and BMPullTime() < GetSecondOptionValue("抢先施放(需DBM插件)") and
        Player:DistanceTo(Target) < 40 and
        Player:CanCast(Metamorphosis)
        then
            Player:StartAttack()
            Player:ForceCastGroundTowardUnit(Target, Metamorphosis, Player:DistanceTo(Target, true) - 3, 0.5)
            return
        end
    end
end
function Rotation:Defensives()
    Player:UseHealingItem()
    if IsOptionEnabled("疾影") and Player:HealthPercentage() <= GetOptionValue("疾影") then
        if Blur:Exists() and not Netherwalk:Exists() and not Player:Buff(BlurBuff) and Player:CanCast(Blur) then
            Player:Cast(Blur)
        end
    end
    if IsOptionEnabled("虚空行走") and Player:HealthPercentage() <= GetOptionValue("虚空行走") then
        if Netherwalk:Exists() and not Player:Buff(Netherwalk) and Player:CanCast(Netherwalk) then
            Player:Cast(Netherwalk)
        end
    end
    if
    Target:Exists() and Player:IsWithinCastRange(Target, ChaosCleave) and EyeBeam:Exists() and Demonic:Exists() and
    IsOptionEnabled("魔化天赋下低血量使用眼棱") and
    Player:Power() >= 50 and
    Player:HealthPercentage() <= GetOptionValue("魔化天赋下低血量使用眼棱") and
    Player:CanCast(EyeBeam)
    then
        Bug("Eye Beam with Demonic to Heal ourself.")
        Player:Cast(EyeBeam)
        return
    end
end
function Rotation:OffGCDAbilities()
    Player:UseInterrupt(ConsumeMagic, ArcaneTorrent)
end
function Rotation:FelRushMacro()
    if Player:CanCast(FelRush) then
        ShouldFelRush = false
        if not _G["IsSwimming"]() and not _G["IsFalling"]() then
            ShouldJumpAndRush = true
            _G["MoveBackwardStart"]()
            return
        end
    end
end
function Rotation:FelRushJump()
    if ShouldJumpAndRush then
        _G["JumpOrAscendStart"]()
        ShouldJumpAndRush = false
        FelRushCancel = true
        Player:Cast(FelRush)
        _G["AscendStop"]()
        _G["MoveBackwardStop"]()
        return
    end
end
function Rotation:UnitTables()
    EyeBeamUnits =     UseAOE() and EyeBeam:Exists() and (IsOptionEnabled("眼棱") or (Demonic:Exists() and IsOptionEnabled("眼棱和魔化"))) and
    #Player:UnitsInFrontRectangle(15, 5) or
    0
    EyeBeamUnitsMax =     UseAOE() and EyeBeam:Exists() and (IsOptionEnabled("眼棱") or (Demonic:Exists() and IsOptionEnabled("眼棱和魔化"))) and
    #Player:UnitsInFrontRectangle(15 + Player:DistanceTo(Target), 5) or
    0
    GlaiveUnits = UseAOE() and #Target:EnemiesWithinDistance(10, true) or 0
    Enemies_40y = UseAOE() and Player:EnemiesWithinDistance(40, true, false) or {}
    Enemies_8y = UseAOE() and Player:EnemiesWithinDistance(8, true, false) or {}
    AddsIncoming = #Enemies_40y > #Enemies_8y and true or false
    NumEnemies = #Enemies_8y
    BladeDanceUnits = NumEnemies
end
function Rotation:Combat()
    if Target:DebuffAny(Imprison) then
        return
    end
    Fury, FuryDeficit, GCDMax = Player:Power(), Player:PowerDeficit(), Player:GCD()
    if ShouldFelRush then
        self:FelRushMacro()
        return
    end
    if ShouldChaosNova then
        if Fury < 30 and Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
            if Target:CanCast(DemonsBite) then
                Target:Cast(DemonsBite)
                return
            end
        elseif Fury >= 30 then
            if Player:CanCast(ChaosNova) then
                Player:Cast(ChaosNova)
                ShouldChaosNova = false
                return
            end
        end
    end
    if ShouldEyeBeamMacro then
        FuryRequirement = 50 - (WideEyes:ArtifactRank() * 5)
        if Fury < FuryRequirement and Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
            if Target:CanCast(DemonsBite) then
                Target:Cast(DemonsBite)
                return
            end
        elseif Fury >= FuryRequirement then
            if Player:CanCast(EyeBeam) then
                Player:Cast(EyeBeam)
                ShouldEyeBeamMacro = false
                return
            end
        end
    end
    if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        Player:StartAttack()
        if NoPathFromEvent then
            local X, Y, Z = Player:Position():Expand()
            if NoPathFromEventPositionX ~= X or NoPathFromEventPositionY ~= Y or NoPathFromEventPositionZ ~= Z then
                NoPathFromEvent = false
                NoPathFromEventPositionX, NoPathFromEventPositionY, NoPathFromEventPositionZ = nil, nil, nil
            end
        end
        ShouldEyeBeam =         EyeBeam:Exists() and
        ((Demonic:Exists() and CDOptionEnabled("眼棱和魔化")) or (not Demonic:Exists() and CDOptionEnabled("眼棱"))) and
        (not IsOptionEnabled("眼棱和势如破竹") or not Momentum:Exists() or Player:Buff(MomentumBuff))
        ShouldFuryOfTheIllidari =         FuryOfTheIllidari:Exists() and
        ((IsOptionEnabled("伊利达雷之怒") and (CooldownsAllowed() or GetSecondOptionValue("伊利达雷之怒") == "无条件使用") and
        #Enemies_8y >= GetOptionValue("伊利达雷之怒")) or
        (IsOptionEnabled("伊利达雷之怒 BOSS") and
        (CooldownsAllowed() or GetSecondOptionValue("伊利达雷之怒 BOSS") == "无条件使用") and
        Target:IsBoss() and
        #Enemies_8y >= GetOptionValue("伊利达雷之怒 BOSS"))) and
        not Target:IsMoving() and
        Player:IsWithinCastRange(Target, ChaosStrike)
        NemesisEnabled = Nemesis:Exists() and CDOptionEnabled("涅墨西斯")
        ChaosBladesEnabled = ChaosBlades:Exists() and CDOptionEnabled("混乱之刃")
        MetamorphosisEnabled = Metamorphosis:Exists() and CDOptionEnabled("恶魔变形") and not Player:Buff(MetamorphosisBuff)
        WaitingForNemesis =         NemesisEnabled and not (not Nemesis:Exists() or not Nemesis:IsOnCooldown() or Nemesis:Cooldown() > 60)
        WaitingForChaosBlades =         ChaosBladesEnabled and
        not (not ChaosBlades:Exists() or not ChaosBlades:IsOnCooldown() or ChaosBlades:Cooldown() > 60)
        PoolingForMeta =         MetamorphosisEnabled and Metamorphosis:Cooldown() < 6 and not NoPathFromEvent and FuryDeficit > 30 and
        not Demonic:Exists() and
        (not WaitingForNemesis or Nemesis:Cooldown() < 10) and
        (not WaitingForChaosBlades or ChaosBlades:Cooldown() < 6)
        BladeDanceVariable =         BladeDance:Exists() and UseAOE() and IsOptionEnabled("刃舞, 死亡横扫") and
        ((GetOptionValue("刃舞, 死亡横扫") == 1 and Player:IsWithinCastRange(Target, ChaosStrike)) or
        (FirstBlood:Exists() and BladeDanceUnits >= 1) or
        BladeDanceUnits >= GetOptionValue("刃舞, 死亡横扫") + (ChaosCleave:Exists() and 3 or 0))
        PoolingForBladeDance =         BladeDanceVariable and Fury - 40 < 35 - (FirstBlood:Exists() and 20 or 0) and
        BladeDanceUnits >= GetOptionValue("刃舞, 死亡横扫") + (ChaosCleave:Exists() and 3 or 0)
        PoolingForChaosStrike =         ChaosCleave:Exists() and IsOptionEnabled("混乱顺劈保存怒气") and FuryDeficit > GetOptionValue("混乱顺劈保存怒气") and
        UseAOE() and
        NumEnemies < 2 and
        AddsIncoming
        if
        IsOptionEnabled("复仇回避 连招") and (Momentum:Exists() or Prepared:Exists()) and not Player:Buff(MomentumBuff) and
        not Player:Buff(Prepared) and
        Player:IsWithinCastRange(Target, ChaosStrike)
        then
            Option1 = GetOptionValue("复仇回避 连招")
            if
            ((Option1 ~= "邪能冲撞" and Felblade:Exists() and not Felblade:IsOnCooldown()) or
            (Option1 ~= "邪能之刃" and FelRush:Exists() and not FelRush:IsOnCooldown())) and
            Player:CanCast(VengefulRetreat)
            then
                if Felblade:Exists() and Option1 == "邪能之刃" and not Felblade:IsOnCooldown() then
                    Player:Cast(VengefulRetreat)
                    VengefulRetreating = GetTime() + 0.7
                    Bug("Vengeful Retreat + Felblade")
                    return
                elseif Option1 == "邪能冲撞" and Target:CanCast(ChaosStrike) then
                    Player:Cast(VengefulRetreat)
                    Target:Cast(ChaosStrike)
                    VengefulRetreating = GetTime()
                    Bug("Vengeful Retreat + Fel Rush")
                    return
                elseif Option1 == "邪能弹幕和冲撞" and FelBarrage:Exists() and Target:CanCast(ChaosStrike) then
                    Player:Cast(VengefulRetreat)
                    if Target:CanCast(FelBarrage) then
                        Target:Cast(FelBarrage)
                    else
                        Target:Cast(ChaosStrike)
                    end
                    VengefulRetreating = GetTime()
                    Bug("Vengeful Retreat + Fel Barrage + Fel Rush")
                    return
                end
            end
        end
        if Player:IsWithinCastRange(Target, ChaosStrike) then
            if
            MetamorphosisEnabled and NoPathTime < GetTime() and
            not (PoolingForMeta or WaitingForNemesis or WaitingForChaosBlades)
            then
                if Target:IsPlayer() then
                    if Player:IsWithinCastRange(Target, Felblade) and Target:CanCast(MetamorphosisPVP) then
                        Player:ForceCastGroundTowardUnit(Target, Metamorphosis, Player:DistanceTo(Target, true) - 1, 4)
                        return
                    end
                elseif Player:CanCast(Metamorphosis) then
                    Player:CastGround(Metamorphosis)
                    return
                end
            end
            if
            ArcaneTorrent:Exists() and IsOptionEnabled("进攻性种族技能") and
            (CooldownsAllowed() or GetOptionValue("进攻性种族技能") == "无条件使用") and
            FuryDeficit > 30 and
            Player:CanCast(ArcaneTorrent)
            then
                Player:Cast(ArcaneTorrent)
                return
            end
            if NemesisEnabled and Target:CanCast(Nemesis) then
                if
                Player:Buff(ChaosBlades) or Player:Buff(MetamorphosisBuff) or Metamorphosis:Cooldown() < 20 or
                not CDOptionEnabled("恶魔变形")
                then
                    Target:Cast(Nemesis)
                    return
                end
            end
            if
            ChaosBladesEnabled and
            (Player:Buff(MetamorphosisBuff) or Metamorphosis:Cooldown() > 60 or not CDOptionEnabled("恶魔变形")) and
            Player:CanCast(ChaosBlades)
            then
                Player:Cast(ChaosBlades)
                return
            end
            if
            DraughtOfSouls:IsEquipped(13, 14) and not DraughtOfSouls:IsOnCooldown() and
            not Player:Buff(MetamorphosisBuff) and
            (not FirstBlood:Exists() or not BladeDanceVariable or BladeDance:Cooldown() > 3) and
            (not Nemesis:Exists() or Nemesis:Cooldown() > 30)
            then
                DraughtOfSouls:Use()
            end
            if
            (Player:Buff(ChaosBlades) or not ChaosBlades:Exists()) and
            (not DraughtOfSouls:IsEquipped(13, 14) or DraughtOfSouls:IsOnCooldown())
            then
                Player:UseTrinkets()
            end
            Player:UsePotions("Agility")
        end
        FelRushEnabled =         FelRush:Exists() and IsOptionEnabled("原地邪能冲撞") and Player:IsFacing(Target) and
        Player:IsWithinCastRange(Target, ChaosStrike) or
        false
        if
        FelRushEnabled and not Target:Debuff(Beam) and not Target:Buff(Beam) and
        (Momentum:Exists() or FelMastery:Exists()) and
        (not Momentum:Exists() or
        (FelRush:Charges() == 2 or VengefulRetreat:Cooldown() > 4 or
        (BladeDanceVariable and BladeDance:Cooldown() < 2) or
        (ShouldEyeBeam and EyeBeam:Cooldown() < 2) or
        (ShouldFuryOfTheIllidari and FuryOfTheIllidari:Cooldown() < 2) or
        (Player:BuffRemains(MetamorphosisBuff) > 4 and Fury >= 40)) and
        not Player:Buff(MomentumBuff)) and
        (not FelMastery:Exists() or FuryDeficit >= 25) and
        Player:CanCast(FelRush)
        then
            self:FelRushMacro()
            return
        end
        if
        FelBarrage:Exists() and CDOptionEnabled("邪能弹幕") and (Player:Buff(MomentumBuff) or not Momentum:Exists()) and
        (GlaiveUnits >= GetSecondOptionValue("邪能弹幕")) and
        Target:CanCast(FelBarrage)
        then
            Target:Cast(FelBarrage)
            return
        end
        if
        ThrowGlaive:Exists() and Bloodlet:Exists() and (not Momentum:Exists() or Player:Buff(MomentumBuff)) and
        ThrowGlaive:Charges() == 2 and
        (not Target:IsPlayer() or CooldownsAllowed()) and
        Target:CanCast(ThrowGlaive)
        then
            Target:Cast(ThrowGlaive, true)
            return
        end
        if
        Felblade:Exists() and IsOptionEnabled("邪能之刃") and
        (GetOptionValue("邪能之刃") == "无条件使用" or Player:IsWithinCastRange(Target, ChaosStrike)) and
        not Target:Debuff(Beam) and
        not Target:Buff(Beam) and
        Fury < 15 and
        BladeDanceVariable and
        BladeDance:Cooldown() < 2 * GCDMax and
        Target:CanCast(Felblade)
        then
            Target:Cast(Felblade)
            return
        end
        if
        Player:Buff(MetamorphosisBuff) and BladeDanceVariable and Player:IsWithinCastRange(Target, ChaosStrike) and
        Player:CanCast(BladeDance)
        then
            Player:Cast(BladeDance)
            return
        end
        if
        FelRushEnabled and not Target:Debuff(Beam) and not Target:Buff(Beam) and FelRush:Charges() == 2 and
        not Momentum:Exists() and
        not FelMastery:Exists() and
        Player:CanCast(FelRush)
        then
            self:FelRushMacro()
            return
        end
        if IsOptionEnabled("邪能爆发") and FelEruption:Exists() and Target:CanCast(FelEruption) then
            Target:Cast(FelEruption)
            return
        end
        if
        ShouldFuryOfTheIllidari and (not Momentum:Exists() or Player:Buff(MomentumBuff)) and
        (not ChaosBladesEnabled or Player:Buff(ChaosBlades) or ChaosBlades:Cooldown() > 30) and
        Player:CanCast(FuryOfTheIllidari)
        then
            Player:Cast(FuryOfTheIllidari)
            return
        end
        if
        ShouldEyeBeam and not Target:Debuff(Beam) and not Target:Buff(Beam) and
        Player:IsWithinCastRange(Target, Felblade) and
        Demonic:Exists() and
        (DemonBlades:Exists() or (BlindFury:Exists() and FuryDeficit >= 35) or
        (not BlindFury:Exists() and FuryDeficit < 30)) and
        EyeBeamUnits >= GetSecondOptionValue("眼棱和魔化") and
        Player:CanCast(EyeBeam)
        then
            Player:Cast(EyeBeam)
            return
        end
        if
        BladeDanceVariable and Player:IsWithinCastRange(Target, ChaosStrike) and Player:CanCast(BladeDance) and
        (not Demonic:Exists() or not ShouldEyeBeam or EyeBeam:Cooldown() > 5) and
        (not MetamorphosisEnabled or Metamorphosis:IsOnCooldown())
        then
            Player:Cast(BladeDance)
            return
        end
        if
        ThrowGlaive:Exists() and Bloodlet:Exists() and GlaiveUnits >= 2 and
        (not MasterOfTheGlaive:Exists() or not Momentum:Exists() or Player:Buff(MomentumBuff)) and
        Target:TimeToDie() > 7 and
        (not Target:IsPlayer() or CooldownsAllowed()) and
        Target:CanCast(ThrowGlaive)
        then
            Target:Cast(ThrowGlaive, true)
            return
        end
        PreparedValue = Player:Buff(Prepared) and 1 or 0
        if
        Felblade:Exists() and IsOptionEnabled("邪能之刃") and
        (GetOptionValue("邪能之刃") == "无条件使用" or Player:IsWithinCastRange(Target, ChaosStrike)) and
        not Target:Debuff(Beam) and
        not Target:Buff(Beam) and
        FuryDeficit >= 30 + PreparedValue * 8 and
        Target:CanCast(Felblade)
        then
            Target:Cast(Felblade)
            return
        end
        if
        ShouldEyeBeam and not Target:Debuff(Beam) and not Target:Buff(Beam) and
        Player:IsWithinCastRange(Target, Felblade) and
        BlindFury:Exists() and
        ((Demonic:Exists() and EyeBeamUnits >= GetSecondOptionValue("眼棱和魔化")) or
        (not Demonic:Exists() and EyeBeamUnits >= GetSecondOptionValue("眼棱"))) and
        Player:CanCast(EyeBeam)
        then
            Player:Cast(EyeBeam)
            return
        end
        if
        ChaosStrike:Exists() and Player:Buff(MetamorphosisBuff) and
        (DemonBlades:Exists() or not Momentum:Exists() or Player:Buff(MomentumBuff) or
        FuryDeficit <= 30 + PreparedValue * 8 or
        Player:BuffRemains(MetamorphosisBuff) < 5) and
        not PoolingForBladeDance and
        Target:CanCast(ChaosStrike)
        then
            Bug("Annihilation")
            Target:Cast(ChaosStrike)
            return
        end
        if
        ThrowGlaive:Exists() and Bloodlet:Exists() and
        (not MasterOfTheGlaive:Exists() or not Momentum:Exists() or Player:Buff(MomentumBuff)) and
        Target:TimeToDie() > 7 and
        (not Target:IsPlayer() or CooldownsAllowed()) and
        Target:CanCast(ThrowGlaive)
        then
            Target:Cast(ThrowGlaive, true)
            return
        end
        if
        ShouldEyeBeam and not Target:BuffAny(Beam) and Player:IsWithinCastRange(Target, Felblade) and
        not Demonic:Exists() and
        not BlindFury:Exists() and
        EyeBeamUnits >= GetSecondOptionValue("眼棱") and
        Player:CanCast(EyeBeam)
        then
            Player:Cast(EyeBeam)
            return
        end
        if
        not DemonBlades:Exists() and Demonic:Exists() and not BlindFury:Exists() and
        not Player:Buff(MetamorphosisBuff) and
        EyeBeam:Cooldown() < GCDMax and
        FuryDeficit >= 20 and
        Target:CanCast(DemonsBite)
        then
            Bug(
            "Demon's Bite (4) - " ..
            tostring(math.floor(BladeDance:Cooldown() / 100) * 100) ..
            "s on Eye Beam's Cooldown and " .. tostring(Fury) .. " Fury."
            )
            Target:Cast(DemonsBite)
            return
        end
        if
        not DemonBlades:Exists() and Demonic:Exists() and not BlindFury:Exists() and
        not Player:Buff(MetamorphosisBuff) and
        EyeBeam:Cooldown() < 2 * GCDMax and
        FuryDeficit >= 45 and
        Target:CanCast(DemonsBite)
        then
            Bug(
            "Demon's Bite (5) - " ..
            tostring(math.floor(BladeDance:Cooldown() / 100) * 100) ..
            "s on Eye Beam's Cooldown and " .. tostring(Fury) .. " Fury."
            )
            Target:Cast(DemonsBite)
            return
        end
        if
        ThrowGlaive:Exists() and IsOptionEnabled("投掷利刃") and GetOptionValue("投掷利刃") ~= "脱离战斗后" and
        not Player:Buff(MetamorphosisBuff) and
        GlaiveUnits >= 2 and
        (not Target:IsPlayer() or CooldownsAllowed()) and
        Target:CanCast(ThrowGlaive)
        then
            Target:Cast(ThrowGlaive, true)
            return
        end
        if
        ChaosStrike:Exists() and
        (DemonBlades:Exists() or not Momentum:Exists() or Player:Buff(MomentumBuff) or
        FuryDeficit <= 30 + PreparedValue * 8) and
        not PoolingForChaosStrike and
        not PoolingForMeta and
        not PoolingForBladeDance and
        (not Demonic:Exists() or (not CDOptionEnabled("眼棱和魔化") and FuryDeficit < 35) or EyeBeam:IsOnCooldown() or
        (BlindFury:Exists() and FuryDeficit < 35)) and
        Target:CanCast(ChaosStrike)
        then
            Target:Cast(ChaosStrike)
            return
        end
        if
        FelBarrage:Exists() and CDOptionEnabled("邪能弹幕") and not Player:Buff(MetamorphosisBuff) and
        (not Momentum:Exists() or Player:Buff(MomentumBuff)) and
        NumEnemies > GetSecondOptionValue("邪能弹幕") and
        Target:CanCast(FelBarrage)
        then
            Target:Cast(FelBarrage)
            return
        end
        if not DemonBlades:Exists() and Target:CanCast(DemonsBite) then
            Bug("Demon's Bite (6) - Filler")
            Target:Cast(DemonsBite)
            return
        end
        if
        ThrowGlaive:Exists() and IsOptionEnabled("投掷利刃") and GetOptionValue("投掷利刃") ~= "脱离战斗后" and
        MasterOfTheGlaive:Exists() and
        Target:IsPlayer() and
        Target:DebuffRemains(GlaiveSnare) < 1 and
        Target:CanCast(ThrowGlaive)
        then
            Target:Cast(ThrowGlaive, true)
            return
        end
        if
        ThrowGlaive:Exists() and IsOptionEnabled("投掷利刃") and GetOptionValue("投掷利刃") ~= "脱离战斗后" and
        not Bloodlet:Exists() and
        not Target:IsPlayer() and
        Target:CanCast(ThrowGlaive)
        then
            Target:Cast(ThrowGlaive, true)
            return
        end
    end
end
function Rotation:CombatBeta()
    if Target:DebuffAny(Imprison) then
        return
    end
    Fury, FuryDeficit, GCDMax = Player:Power(), Player:PowerDeficit(), Player:GCD()
    if ShouldFelRush then
        self:FelRushMacro()
        return
    end
    if ShouldChaosNova then
        if Fury < 30 and Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
            if Target:CanCast(DemonsBite) then
                Target:Cast(DemonsBite)
                return
            end
        elseif Fury >= 30 then
            if Player:CanCast(ChaosNova) then
                Player:Cast(ChaosNova)
                ShouldChaosNova = false
                return
            end
        end
    end
    if ShouldEyeBeamMacro then
        FuryRequirement = 50 - (WideEyes:ArtifactRank() * 5)
        if Fury < FuryRequirement and Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
            if Target:CanCast(DemonsBite) then
                Target:Cast(DemonsBite)
                return
            end
        elseif Fury >= FuryRequirement then
            if Player:CanCast(EyeBeam) then
                Player:Cast(EyeBeam)
                ShouldEyeBeamMacro = false
                return
            end
        end
    end
    if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        Player:StartAttack()
        if NoPathFromEvent then
            local X, Y, Z = Player:Position():Expand()
            if NoPathFromEventPositionX ~= X or NoPathFromEventPositionY ~= Y or NoPathFromEventPositionZ ~= Z then
                NoPathFromEvent = false
                NoPathFromEventPositionX, NoPathFromEventPositionY, NoPathFromEventPositionZ = nil, nil, nil
            end
        end
        ShouldEyeBeam =         EyeBeam:Exists() and
        ((Demonic:Exists() and CDOptionEnabled("眼棱和魔化")) or (not Demonic:Exists() and CDOptionEnabled("眼棱"))) and
        (not IsOptionEnabled("眼棱和势如破竹") or not Momentum:Exists() or Player:Buff(MomentumBuff))
        ShouldFuryOfTheIllidari =         FuryOfTheIllidari:Exists() and
        ((IsOptionEnabled("伊利达雷之怒") and (CooldownsAllowed() or GetSecondOptionValue("伊利达雷之怒") == "无条件使用") and
        #Enemies_8y >= GetOptionValue("伊利达雷之怒")) or
        (IsOptionEnabled("伊利达雷之怒 BOSS") and
        (CooldownsAllowed() or GetSecondOptionValue("伊利达雷之怒 BOSS") == "无条件使用") and
        Target:IsBoss() and
        #Enemies_8y >= GetOptionValue("伊利达雷之怒 BOSS"))) and
        not Target:IsMoving() and
        Player:IsWithinCastRange(Target, ChaosStrike)
        NemesisEnabled = Nemesis:Exists() and CDOptionEnabled("涅墨西斯")
        ChaosBladesEnabled = ChaosBlades:Exists() and CDOptionEnabled("混乱之刃")
        MetamorphosisEnabled = Metamorphosis:Exists() and CDOptionEnabled("恶魔变形") and not Player:Buff(MetamorphosisBuff)
        WaitingForNemesis =         NemesisEnabled and not (not Nemesis:Exists() or not Nemesis:IsOnCooldown() or Nemesis:Cooldown() > 60)
        WaitingForChaosBlades =         ChaosBladesEnabled and
        not (not ChaosBlades:Exists() or not ChaosBlades:IsOnCooldown() or ChaosBlades:Cooldown() > 60)
        PoolingForMeta =         MetamorphosisEnabled and not Demonic:Exists() and Metamorphosis:Cooldown() < 6 and not NoPathFromEvent and
        FuryDeficit > 30 and
        (not WaitingForNemesis or Nemesis:Cooldown() < 10) and
        (not WaitingForChaosBlades or ChaosBlades:Cooldown() < 6)
        BladeDanceVariable =         BladeDance:Exists() and UseAOE() and IsOptionEnabled("刃舞, 死亡横扫") and
        ((GetOptionValue("刃舞, 死亡横扫") == 1 and Player:IsWithinCastRange(Target, ChaosStrike)) or
        (FirstBlood:Exists() and BladeDanceUnits >= 1) or
        HasT20_4Pc or
        BladeDanceUnits >= GetOptionValue("刃舞, 死亡横扫") + (ChaosCleave:Exists() and 3 or 0))
        PoolingForBladeDance = BladeDanceVariable and Fury < 75 - (FirstBlood:Exists() and 20 or 0)
        PoolingForChaosStrike =         ChaosCleave:Exists() and IsOptionEnabled("混乱顺劈保存怒气") and FuryDeficit > GetOptionValue("混乱顺劈保存怒气") and
        UseAOE() and
        NumEnemies < 2 and
        AddsIncoming
        if
        IsOptionEnabled("复仇回避 连招") and (Momentum:Exists() or Prepared:Exists()) and not Player:Buff(MomentumBuff) and
        not Player:Buff(Prepared) and
        Player:IsWithinCastRange(Target, ChaosStrike)
        then
            Option1 = GetOptionValue("复仇回避 连招")
            if
            ((Option1 ~= "邪能冲撞" and Felblade:Exists() and not Felblade:IsOnCooldown()) or
            (Option1 ~= "邪能之刃" and FelRush:Exists() and not FelRush:IsOnCooldown())) and
            Player:CanCast(VengefulRetreat)
            then
                if Felblade:Exists() and Option1 == "邪能之刃" and not Felblade:IsOnCooldown() then
                    Player:Cast(VengefulRetreat)
                    VengefulRetreating = GetTime() + 0.7
                    Bug("Vengeful Retreat + Felblade")
                    return
                elseif Option1 == "邪能冲撞" and Target:CanCast(ChaosStrike) then
                    Player:Cast(VengefulRetreat)
                    Target:Cast(ChaosStrike)
                    VengefulRetreating = GetTime()
                    Bug("Vengeful Retreat + Fel Rush")
                    return
                elseif Option1 == "邪能弹幕和冲撞" and FelBarrage:Exists() and Target:CanCast(ChaosStrike) then
                    Player:Cast(VengefulRetreat)
                    if Target:CanCast(FelBarrage) then
                        Target:Cast(FelBarrage)
                    else
                        Target:Cast(ChaosStrike)
                    end
                    VengefulRetreating = GetTime()
                    Bug("Vengeful Retreat + Fel Barrage + Fel Rush")
                    return
                end
            end
        end
        if Player:IsWithinCastRange(Target, ChaosStrike) then
            if
            MetamorphosisEnabled and NoPathTime < GetTime() and
            (not (PoolingForMeta or WaitingForNemesis or WaitingForChaosBlades))
            then
                if Target:IsPlayer() then
                    if Player:IsWithinCastRange(Target, Felblade) and Target:CanCast(MetamorphosisPVP) then
                        Player:ForceCastGroundTowardUnit(Target, Metamorphosis, Player:DistanceTo(Target, true) - 1, 4)
                        return
                    end
                elseif Player:CanCast(Metamorphosis) then
                    Player:CastGround(Metamorphosis)
                    return
                end
            end
            if
            ArcaneTorrent:Exists() and IsOptionEnabled("进攻性种族技能") and
            (CooldownsAllowed() or GetOptionValue("进攻性种族技能") == "无条件使用") and
            FuryDeficit > 30 and
            Player:CanCast(ArcaneTorrent)
            then
                Player:Cast(ArcaneTorrent)
                return
            end
            if NemesisEnabled and Target:CanCast(Nemesis) then
                if
                Player:Buff(ChaosBlades) or Player:Buff(MetamorphosisBuff) or Metamorphosis:Cooldown() < 20 or
                not CDOptionEnabled("恶魔变形")
                then
                    Target:Cast(Nemesis)
                    return
                end
            end
            if
            ChaosBladesEnabled and
            (Player:Buff(MetamorphosisBuff) or Metamorphosis:Cooldown() > 60 or not CDOptionEnabled("恶魔变形")) and
            Player:CanCast(ChaosBlades)
            then
                Player:Cast(ChaosBlades)
                return
            end
            if
            DraughtOfSouls:IsEquipped(13, 14) and not DraughtOfSouls:IsOnCooldown() and
            not Player:Buff(MetamorphosisBuff) and
            (not FirstBlood:Exists() or not BladeDanceVariable or BladeDance:Cooldown() > 3) and
            (not Nemesis:Exists() or Nemesis:Cooldown() > 30)
            then
                DraughtOfSouls:Use()
            end
            if
            (Player:Buff(ChaosBlades) or not ChaosBlades:Exists()) and
            (not DraughtOfSouls:IsEquipped(13, 14) or DraughtOfSouls:IsOnCooldown())
            then
                Player:UseTrinkets()
            end
            Player:UsePotions("Agility")
        end
        FelRushEnabled =         FelRush:Exists() and IsOptionEnabled("原地邪能冲撞") and Player:IsFacing(Target) and
        Player:IsWithinCastRange(Target, ChaosStrike) or
        false
        PreparedValue = Player:Buff(Prepared) and 1 or 0
        if Demonic:Exists() and IsOptionEnabled("魔化流循环") then
            if
            FelRushEnabled and not Target:Debuff(Beam) and not Target:Buff(Beam) and
            (Momentum:Exists() or FelMastery:Exists()) and
            (not Momentum:Exists() or
            (FelRush:Charges() == 2 or VengefulRetreat:Cooldown() > 4 or
            (BladeDanceVariable and BladeDance:Cooldown() < 2) or
            (ShouldEyeBeam and EyeBeam:Cooldown() < 2) or
            (ShouldFuryOfTheIllidari and FuryOfTheIllidari:Cooldown() < 2) or
            (Player:BuffRemains(MetamorphosisBuff) > 4 and Fury >= 40)) and
            not Player:Buff(MomentumBuff)) and
            Player:CanCast(FelRush)
            then
                self:FelRushMacro()
                return
            end
            if
            ThrowGlaive:Exists() and Bloodlet:Exists() and (not Momentum:Exists() or Player:Buff(MomentumBuff)) and
            ThrowGlaive:Charges() == 2 and
            (not Target:IsPlayer() or CooldownsAllowed()) and
            Target:CanCast(ThrowGlaive)
            then
                Target:Cast(ThrowGlaive, true)
                return
            end
            if
            Player:Buff(MetamorphosisBuff) and BladeDanceVariable and Player:IsWithinCastRange(Target, ChaosStrike) and
            Player:CanCast(BladeDance)
            then
                Player:Cast(BladeDance)
                return
            end
            if IsOptionEnabled("邪能爆发") and FelEruption:Exists() and Target:CanCast(FelEruption) then
                Target:Cast(FelEruption)
                return
            end
            if
            ShouldFuryOfTheIllidari and (not Momentum:Exists() or Player:Buff(MomentumBuff)) and
            Player:CanCast(FuryOfTheIllidari)
            then
                Player:Cast(FuryOfTheIllidari)
                return
            end
            if
            BladeDanceVariable and Player:IsWithinCastRange(Target, ChaosStrike) and Player:CanCast(BladeDance) and
            (not ShouldEyeBeam or EyeBeam:Cooldown() > 5) and
            (not MetamorphosisEnabled or Metamorphosis:IsOnCooldown())
            then
                Player:Cast(BladeDance)
                return
            end
            if
            ThrowGlaive:Exists() and Bloodlet:Exists() and GlaiveUnits >= 2 and
            (not MasterOfTheGlaive:Exists() or not Momentum:Exists() or Player:Buff(MomentumBuff)) and
            Target:TimeToDie() > 7 and
            (not Target:IsPlayer() or CooldownsAllowed()) and
            Target:CanCast(ThrowGlaive)
            then
                Target:Cast(ThrowGlaive, true)
                return
            end
            if
            Felblade:Exists() and IsOptionEnabled("邪能之刃") and
            (GetOptionValue("邪能之刃") == "无条件使用" or Player:IsWithinCastRange(Target, ChaosStrike)) and
            not Target:Debuff(Beam) and
            not Target:Buff(Beam) and
            FuryDeficit >= 30 and
            Target:CanCast(Felblade)
            then
                Target:Cast(Felblade)
                return
            end
            if
            ShouldEyeBeam and not Target:Debuff(Beam) and not Target:Buff(Beam) and
            Player:IsWithinCastRange(Target, Felblade) and
            EyeBeamUnits >= GetSecondOptionValue("眼棱和魔化") and
            Player:CanCast(EyeBeam)
            then
                Player:Cast(EyeBeam)
                return
            end
            if
            ChaosStrike:Exists() and Player:Buff(MetamorphosisBuff) and
            (not Momentum:Exists() or Player:Buff(MomentumBuff) or FuryDeficit < 30 + PreparedValue * 8 or
            Player:BuffRemains(MetamorphosisBuff) < 5) and
            not PoolingForBladeDance and
            Target:CanCast(ChaosStrike)
            then
                Bug("Annihilation")
                Target:Cast(ChaosStrike)
                return
            end
            if
            ThrowGlaive:Exists() and Bloodlet:Exists() and
            (not MasterOfTheGlaive:Exists() or not Momentum:Exists() or Player:Buff(MomentumBuff)) and
            Target:TimeToDie() > 7 and
            (not Target:IsPlayer() or CooldownsAllowed()) and
            Target:CanCast(ThrowGlaive)
            then
                Target:Cast(ThrowGlaive, true)
                return
            end
            if
            ChaosStrike:Exists() and
            (not Momentum:Exists() or Player:Buff(MomentumBuff) or FuryDeficit <= 30 + PreparedValue * 8) and
            not PoolingForChaosStrike and
            not PoolingForMeta and
            not PoolingForBladeDance and
            Target:CanCast(ChaosStrike)
            then
                Target:Cast(ChaosStrike)
                return
            end
            if
            FelRushEnabled and not Target:Debuff(Beam) and not Target:Buff(Beam) and not Momentum:Exists() and
            (not Player:Buff(MetamorphosisBuff) or DemonBlades:Exists()) and
            FelRush:Charges() == 2 and
            Player:CanCast(FelRush)
            then
                self:FelRushMacro()
                return
            end
            if not DemonBlades:Exists() and Target:CanCast(DemonsBite) then
                Bug("Demon's Bite - Demonic")
                Target:Cast(DemonsBite)
                return
            end
            if
            ThrowGlaive:Exists() and IsOptionEnabled("投掷利刃") and GetOptionValue("投掷利刃") ~= "脱离战斗后" and
            not Bloodlet:Exists() and
            not Target:IsPlayer() and
            Target:CanCast(ThrowGlaive)
            then
                Target:Cast(ThrowGlaive, true)
                return
            end
            return
        end
        if
        FelRushEnabled and not Target:Debuff(Beam) and not Target:Buff(Beam) and
        (Momentum:Exists() or FelMastery:Exists()) and
        (not Momentum:Exists() or
        (FelRush:Charges() == 2 or VengefulRetreat:Cooldown() > 4 or
        (BladeDanceVariable and BladeDance:Cooldown() < 2) or
        (ShouldEyeBeam and EyeBeam:Cooldown() < 2) or
        (ShouldFuryOfTheIllidari and FuryOfTheIllidari:Cooldown() < 2) or
        (Player:BuffRemains(MetamorphosisBuff) > 4 and Fury >= 40)) and
        not Player:Buff(MomentumBuff)) and
        (not FelMastery:Exists() or FuryDeficit >= 25) and
        Player:CanCast(FelRush)
        then
            self:FelRushMacro()
            return
        end
        if
        FelBarrage:Exists() and CDOptionEnabled("邪能弹幕") and (Player:Buff(MomentumBuff) or not Momentum:Exists()) and
        (GlaiveUnits >= GetSecondOptionValue("邪能弹幕")) and
        Target:CanCast(FelBarrage)
        then
            Target:Cast(FelBarrage)
            return
        end
        if
        ThrowGlaive:Exists() and Bloodlet:Exists() and (not Momentum:Exists() or Player:Buff(MomentumBuff)) and
        ThrowGlaive:Charges() == 2 and
        (not Target:IsPlayer() or CooldownsAllowed()) and
        Target:CanCast(ThrowGlaive)
        then
            Target:Cast(ThrowGlaive, true)
            return
        end
        if
        Felblade:Exists() and IsOptionEnabled("邪能之刃") and
        (GetOptionValue("邪能之刃") == "无条件使用" or Player:IsWithinCastRange(Target, ChaosStrike)) and
        not Target:Debuff(Beam) and
        not Target:Buff(Beam) and
        Fury < 15 and
        BladeDanceVariable and
        BladeDance:Cooldown() < 2 * GCDMax and
        Target:CanCast(Felblade)
        then
            Target:Cast(Felblade)
            return
        end
        if
        Player:Buff(MetamorphosisBuff) and BladeDanceVariable and Player:IsWithinCastRange(Target, ChaosStrike) and
        Player:CanCast(BladeDance)
        then
            Player:Cast(BladeDance)
            return
        end
        if
        FelRushEnabled and not Target:Debuff(Beam) and not Target:Buff(Beam) and FelRush:Charges() == 2 and
        not Momentum:Exists() and
        not FelMastery:Exists() and
        Player:CanCast(FelRush)
        then
            self:FelRushMacro()
            return
        end
        if IsOptionEnabled("邪能爆发") and FelEruption:Exists() and Target:CanCast(FelEruption) then
            Target:Cast(FelEruption)
            return
        end
        if
        ShouldFuryOfTheIllidari and (not Momentum:Exists() or Player:Buff(MomentumBuff)) and
        (not ChaosBladesEnabled or Player:Buff(ChaosBlades) or ChaosBlades:Cooldown() > 30) and
        Player:CanCast(FuryOfTheIllidari)
        then
            Player:Cast(FuryOfTheIllidari)
            return
        end
        if
        BladeDanceVariable and Player:IsWithinCastRange(Target, ChaosStrike) and Player:CanCast(BladeDance) and
        (not MetamorphosisEnabled or Metamorphosis:IsOnCooldown())
        then
            Player:Cast(BladeDance)
            return
        end
        if
        ThrowGlaive:Exists() and Bloodlet:Exists() and GlaiveUnits >= 2 and
        (not MasterOfTheGlaive:Exists() or not Momentum:Exists() or Player:Buff(MomentumBuff)) and
        Target:TimeToDie() > 7 and
        (not Target:IsPlayer() or CooldownsAllowed()) and
        Target:CanCast(ThrowGlaive)
        then
            Target:Cast(ThrowGlaive, true)
            return
        end
        if
        Felblade:Exists() and IsOptionEnabled("邪能之刃") and
        (GetOptionValue("邪能之刃") == "无条件使用" or Player:IsWithinCastRange(Target, ChaosStrike)) and
        not Target:Debuff(Beam) and
        not Target:Buff(Beam) and
        FuryDeficit >= 30 + PreparedValue * 8 and
        Target:CanCast(Felblade)
        then
            Target:Cast(Felblade)
            return
        end
        if
        ShouldEyeBeam and not Target:Debuff(Beam) and not Target:Buff(Beam) and
        Player:IsWithinCastRange(Target, Felblade) and
        (EyeBeamUnits >= GetSecondOptionValue("眼棱")) and
        Player:CanCast(EyeBeam)
        then
            Player:Cast(EyeBeam)
            return
        end
        if
        ChaosStrike:Exists() and Player:Buff(MetamorphosisBuff) and
        (DemonBlades:Exists() or not Momentum:Exists() or Player:Buff(MomentumBuff) or
        FuryDeficit <= 30 + PreparedValue * 8 or
        Player:BuffRemains(MetamorphosisBuff) < 5) and
        not PoolingForBladeDance and
        Target:CanCast(ChaosStrike)
        then
            Bug("Annihilation")
            Target:Cast(ChaosStrike)
            return
        end
        if
        ThrowGlaive:Exists() and Bloodlet:Exists() and
        (not MasterOfTheGlaive:Exists() or not Momentum:Exists() or Player:Buff(MomentumBuff)) and
        Target:TimeToDie() > 7 and
        (not Target:IsPlayer() or CooldownsAllowed()) and
        Target:CanCast(ThrowGlaive)
        then
            Target:Cast(ThrowGlaive, true)
            return
        end
        if
        ThrowGlaive:Exists() and IsOptionEnabled("投掷利刃") and GetOptionValue("投掷利刃") ~= "脱离战斗后" and
        not Bloodlet:Exists() and
        not Player:Buff(MetamorphosisBuff) and
        GlaiveUnits >= 3 and
        (not Target:IsPlayer() or CooldownsAllowed()) and
        Target:CanCast(ThrowGlaive)
        then
            Target:Cast(ThrowGlaive, true)
            return
        end
        if
        ChaosStrike:Exists() and
        (DemonBlades:Exists() or not Momentum:Exists() or Player:Buff(MomentumBuff) or
        FuryDeficit < 30 + PreparedValue * 8) and
        not PoolingForChaosStrike and
        not PoolingForMeta and
        not PoolingForBladeDance and
        Target:CanCast(ChaosStrike)
        then
            Target:Cast(ChaosStrike)
            return
        end
        if
        FelRushEnabled and not Target:Debuff(Beam) and not Target:Buff(Beam) and not Momentum:Exists() and
        (not Player:Buff(MetamorphosisBuff) or DemonBlades:Exists()) and
        FelRush:FractionalCharges() >= 1.8 and
        Player:CanCast(FelRush)
        then
            self:FelRushMacro()
            return
        end
        if not DemonBlades:Exists() and Target:CanCast(DemonsBite) then
            Bug("Demon's Bite - Normal")
            Target:Cast(DemonsBite)
            return
        end
        if
        ThrowGlaive:Exists() and IsOptionEnabled("投掷利刃") and GetOptionValue("投掷利刃") ~= "脱离战斗后" and
        MasterOfTheGlaive:Exists() and
        Target:IsPlayer() and
        Target:DebuffRemains(GlaiveSnare) < 1 and
        Target:CanCast(ThrowGlaive)
        then
            Target:Cast(ThrowGlaive, true)
            return
        end
        if
        ThrowGlaive:Exists() and IsOptionEnabled("投掷利刃") and GetOptionValue("投掷利刃") ~= "脱离战斗后" and
        not Bloodlet:Exists() and
        not Target:IsPlayer() and
        Target:CanCast(ThrowGlaive)
        then
            Target:Cast(ThrowGlaive, true)
            return
        end
    end
end
function Rotation:OutOfCombat()
    ShouldChaosNova = false
    if ShouldFelRush then
        self:FelRushMacro()
    end
    if IsOptionEnabled("自动进入战斗") and Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        if Annihilation:Exists() and Player:Buff(MetamorphosisBuff) and Target:CanCast(Annihilation) then
            Target:Cast(Annihilation)
            return
        end
        if ChaosStrike:Exists() and not Player:Buff(MetamorphosisBuff) and Target:CanCast(ChaosStrike) then
            Target:Cast(ChaosStrike)
            return
        end
        if Felblade:Exists() and IsOptionEnabled("邪能之刃") and not NoPathFromEvent and Target:CanCast(Felblade) then
            Target:Cast(Felblade)
            return
        end
        if DemonsBite:Exists() and Target:CanCast(DemonsBite) then
            Target:Cast(DemonsBite)
            return
        end
        if
        ThrowGlaive:Exists() and IsOptionEnabled("投掷利刃") and GetOptionValue("投掷利刃") ~= "在战斗中" and
        Target:CanCast(ThrowGlaive)
        then
            Target:Cast(ThrowGlaive, true)
            return
        end
    end
end
SetRotation(581, {})
local Rotation = Rotations[581]
function Rotation:Initialize()
    ArcaneTorrent = Spell(202719, false, false, true)
    Shadowmeld = Spell(58984, false, false, true)
    ConcentratedSigils = Spell(207666)
    ConsumeMagic = Spell(183752, true, true, true)
    DemonicInfusion = Spell(236189, false, false, true)
    DemonSpikes = Spell(203720, false, false, true)
    DemonSpikesBuff = Spell(203819, false, false, true)
    EmpowerWards = Spell(218256, false, false, true)
    FelBlade = Spell(232893, true, true, true)
    FelDevastation = Spell(212084, false, false, true)
    FelEruption = Spell(211881, true, true, true)
    FieryBrand = Spell(204021, true, true, true)
    FieryBrandDebuff = Spell(207744)
    FlameCrash = Spell(227322)
    Fracture = Spell(209795, true, true, true)
    ImmolationAura = Spell(178740, false, false, true)
    InfernalStrike = Spell(189110, false, true, true)
    InfernalStrikePlayer = Spell(189110, false, false, true)
    Metamorphosis = Spell(187827, false, false, true)
    RazorSpikes = Spell(209400, false, false, true)
    Shear = Spell(203782, true, true, true)
    SigilOfFlame = Spell(204596, false, true, true)
    SigilOfFlamePlayer = Spell(204596, false, false, true)
    SigilOfFlameDebuff = Spell(204598)
    SpiritBomb = Spell(247454, false, true, true)
    SpiritBombDebuff = Spell(247456, false, false, true)
    SoulBarrier = Spell(227225, false, false, true)
    SoulCarver = Spell(207407, true, true, true)
    SoulCleave = Spell(228477, true, true, true)
    SoulFragments = Spell(203981, false, true, true)
    ThrowGlaive = Spell(204157, true, true, true)
    Torment = Spell(185245, false, true, true)
    AddPage("常规")
    AddPage("进攻")
    AddPage("防御")
    AddCommonOptions()
    AddPresetOption("常规", "Melee", nil, false)
    AddPresetOption("TankingFeatures", { "折磨", "折磨" })
    AddPresetOption("进攻")
    AddSection("进攻", { "能力", "能力" }, "Yellow")
    AddPresetOption("Cooldown", { "灵魂切削", "灵魂切削" })
    AddPresetOption("Cooldown", { "恶魔灌注CD", "恶魔灌注" })
    AddPresetOption("Cooldown", { "烈火烙印", "炽天使" }, nil, { 90, 1, 100, 1 }, { "Health threshold.", "健康阈值。" })
    AddPresetOption("Cooldown", { "邪能毁灭", "邪能毁灭" })
    AddNewOption(
    "进攻",
    { "邪能毁灭CD", "邪能毁灭" },
    122,
    true,
    { 1, 1, 5, 1 },
    { 100, 1, 100, 1 },
    {
        "Use Fel Devastation." ..
        C.TOOLTIP_VALUE_1 ..
        "Number of enemies required in front of you." ..
        C.TOOLTIP_VALUE_2 .. "Minimum Health Percentage required to use it.",
        "使用邪能毁灭" .. C.TOOLTIP_VALUE_1 .. "在你面前需要的敌人数量" .. C.TOOLTIP_VALUE_2 .. "最低健康使用所需的百分比。"
    }
    )
    AddNewOption(
    "进攻",
    { "烈火烙印时灵魂切削", "灵魂切削同步" },
    210,
    true,
    nil,
    nil,
    { "Try to use Soul Carver only when Fiery Brand debuff is present.", "使用灵魂切削只用烈火烙印。" }
    )
    AddSection("进攻", { "能力", "能力" }, "Yellow")
    AddNewOption(
    "进攻",
    { "烈焰咒符", "烈焰咒符" },
    232,
    true,
    { 2, { "目标", "目标" }, { "Target Standing", "目标站立" }, { "Centered", "中心" }, { "Centered Standing", "中心站立" } },
    { 1, 1, 10, 1 },
    {
        "Use Sigil Of Flame." ..
        C.TOOLTIP_VALUE_1 ..
        "Choose preferred mode." ..
        C.TOOLTIP_SUBVALUE("目标") ..
        "Always use on the current target." ..
        C.TOOLTIP_SUBVALUE("Target Standing") ..
        "Always use on the current target. Target must be standing still." ..
        C.TOOLTIP_SUBVALUE("Centered") ..
        "Use centered on a cluster of enemies." ..
        C.TOOLTIP_SUBVALUE("Centered Standing") ..
        "Use centered on a cluster of enemies. Enemies must be standing still." ..
        C.TOOLTIP_VALUE_2 ..
        "Amount of enemies that must be in the spell effect to use.",
        "使用烈焰咒符。" ..
        C.TOOLTIP_VALUE_1 ..
        "选择首选模式。" ..
        C.TOOLTIP_SUBVALUE("目标") ..
        "始终使用当前目标。" ..
        C.TOOLTIP_SUBVALUE("目标站立") ..
        "始终使用当前目标。 目标必须站稳" ..
        C.TOOLTIP_SUBVALUE("中心") ..
        "以一群敌人为中心。" ..
        C.TOOLTIP_SUBVALUE("中心站立") ..
        "以一群敌人为中心。 敌人必须站稳" .. C.TOOLTIP_VALUE_2 .. "必须使用法术效果的敌人的数量。"
    }
    )
    AddNewOption("进攻", { "邪能爆发", "邪能爆发" }, 210, true, nil, nil, { "Use Fel Eruption.", "使用邪能爆发。" })
    AddNewOption("进攻", { "邪能之刃", "邪能之刃" }, 210, true, nil, nil, { "Use Felblade.", "使用邪能之刃。" })
    AddNewOption("进攻", { "献祭光环", "献祭光环" }, 220, true, { 1, 1, 10, 1 }, nil, { "Use Immolation Aura.", "使用献祭光环。" })
    AddNewOption("进攻", { "投掷利刃", "投掷利刃" }, 210, true, nil, nil, { "Use Throw Glaive.", "使用投掷利刃。" })
    AddNewOption(
    "进攻",
    { "地狱火撞击", "地狱火撞击" },
    222,
    false,
    { 1, 0, 3, 1 },
    { 0.5, 0.5, 10, 0.5 },
    {
        "Use Infernal Strike on your position." ..
        C.TOOLTIP_VALUE_1 ..
        "How many charges should be left untouched." ..
        C.TOOLTIP_VALUE_2 .. "How many seconds you have to stand still until Infernal Strike is used.",
        "使用地狱火撞击在你的位置" .. C.TOOLTIP_VALUE_1 .. "应该多少费用不受影响" .. C.TOOLTIP_VALUE_2 .. "在使用Infernal Strike之前，您必须静置多少秒。"
    }
    )
    AddNewOption("进攻", { "幽魂炸弹", "幽魂炸弹" }, 210, true, nil, nil, { "Use Spirit Bomb to keep up Frailty.", "使用幽魂炸弹保持脆弱。" })
    AddNewOption(
    "进攻",
    { "幽魂炸弹倾卸", "幽魂炸弹转储" },
    220,
    true,
    { 4, 1, 5, 1 },
    nil,
    { "Use Spirit Bomb with a set amount of Fragments over Soul Cleave.", "使用灵魂炸弹与5碎片在灵魂切割。" }
    )
    AddNewOption(
    "进攻",
    { "破裂倾卸", "破裂转储" },
    222,
    false,
    { 95, 0, 100, 1 },
    { 20, 0, 100, 1 },
    {
        "When Razor Spikes and Fracture are talented, we pool resources and then dump them into Fracture or Soul Cleave, depending on number of enemies." ..
        C.TOOLTIP_VALUE_1 ..
        "Pain threshold to start dumping (using Demon Spikes)." ..
        C.TOOLTIP_VALUE_2 .. "Pain threshold to stop dumping. If you don't want to dump all Pain.",
        "当剃刀尖峰和骨折有天赋时，我们将资源进行汇总，然后根据敌人的数量将其转储到骨折或灵魂切割中。" ..
        C.TOOLTIP_VALUE_1 .. "疼痛阈值开始倾倒（使用恶魔峰值）。" .. C.TOOLTIP_VALUE_2 .. "疼痛阈值停止倾倒。 如果你不想倾倒所有的痛苦。"
    }
    )
    AddPresetOption("防御")
    AddSection("防御", { "能力", "能力" }, "Yellow")
    AddNewOption(
    "防御",
    { "破裂", "破裂" },
    220,
    true,
    { 4, 0, 20, 1 },
    nil,
    {
        "Use Fracture when we want to have more fragments available." ..
        C.TOOLTIP_VALUE_1 ..
        "Soul Fragments threshold." ..
        C.TOOLTIP_HINT(
        "Only used when Pain is higher than Soul Cleave second value. Setting this value to 0 will make it always be used as filler regardless how many Soul Fragments are in available."
        ),
        "使用破裂当我们想要有更多的碎片可用。" ..
        C.TOOLTIP_VALUE_1 .. "灵魂碎片门槛。" .. C.TOOLTIP_HINT("只有当疼痛高于灵魂切割第二个值时才使用。 将此值设置为0将使其始终用作填充，而不管有多少个灵魂片段可用。")
    }
    )
    AddNewOption(
    "防御",
    { "破裂敌人", "破裂的敌人" },
    220,
    true,
    { 2, 0, 20, 1 },
    nil,
    {
        "Only use Fracture when there are less than given amount of enemies in Soul Cleave range." ..
        C.TOOLTIP_VALUE_1 .. "Soul Cleave Enemies.",
        "在灵魂裂劈范围内，只有使用少量的敌人才能使用破裂。" .. C.TOOLTIP_VALUE_1 .. "灵魂裂劈敌敌。"
    }
    )
    AddNewOption(
    "防御",
    { "灵魂裂劈", "灵魂裂劈" },
    222,
    true,
    { 75, 1, 100, 1 },
    { 80, 1, 101, 1 },
    {
        "Use Soul Cleave when our Health is Low or our Pain is high." ..
        C.TOOLTIP_VALUE_1 ..
        "Health threshold." ..
        C.TOOLTIP_VALUE_2 ..
        "Pain threshold." ..
        C.TOOLTIP_HINT(
        "If our health is higher than the first value or our Pain is higher than the second value. If Fracture is talented and our Soul Fragments count is lower than Fracture value we will use it, otherwise Soul Cleave will be used."
        ),
        "当我们的健康很低或我们的痛苦很高时，使用灵魂切割。" ..
        C.TOOLTIP_VALUE_1 ..
        "健康阈值。" ..
        C.TOOLTIP_VALUE_2 ..
        "疼痛阈值。" .. C.TOOLTIP_HINT("如果我们的健康高于第一个值，而我们的疼痛高于第二个值，如果骨折有天赋，我们的灵魂碎片计数低于骨折值，我们将使用灵魂切割。")
    }
    )
    AddNewOption(
    "Hidden",
    "Soul Cleave Enemy Detection",
    122,
    true,
    { 20, 1, 100, 1 },
    { 8, 1, 100, 1 },
    "Soul Cleave enemy detection with specified arc and range." ..
    C.TOOLTIP_VALUE_1 .. "Arc" .. C.TOOLTIP_VALUE_2 .. "范围"
    )
    AddSection("防御", { "减伤", "减轻" }, "Yellow")
    AddNewOption(
    "防御",
    "恶魔尖刺Buff左",
    120,
    true,
    { 6, 0, 18, 0.5 },
    nil,
    "How much time left on Demon Spikes buff to use another charge."
    )
    AddNewOption(
    "防御",
    { "恶魔尖刺第一层充能", "恶魔尖刺第一收费1" },
    222,
    true,
    { 45, 1, 100, 1 },
    { 15, 0, 100, 1 },
    {
        "Use Demon Spikes with one charge when our health fall under Value 1 health and we lost more than Value 2 health in the last 5 seconds via Physical damage." ..
        C.TOOLTIP_VALUE_1 ..
        "Health threshold." ..
        C.TOOLTIP_VALUE_2 .. "Health percentage lost in the last 5 seconds via Physical damage.",
        "当我们的健康处于1级健康状态下时，使用恶魔峰值1次，而在过去5秒内，物理伤害损失超过2级健康。" ..
        C.TOOLTIP_VALUE_1 .. "健康阈值。" .. C.TOOLTIP_VALUE_2 .. "身体伤害在过去5秒内的健康百分比损失。"
    }
    )
    AddNewOption(
    "防御",
    { "恶魔尖刺第二层充能", "恶魔尖刺第二收费2" },
    222,
    true,
    { 85, 1, 100, 1 },
    { 15, 0, 100, 1 },
    {
        "Use Demon Spikes with two charges when our health fall under Value 1 health and we lost more than Value 2 health in the last 5 seconds via Physical damage." ..
        C.TOOLTIP_VALUE_1 ..
        "Health threshold." ..
        C.TOOLTIP_VALUE_2 .. "Health percentage lost in the last 5 seconds via Physical damage.",
        "当我们的健康处于“值2”健康状态时，使用恶魔峰值，一旦发生身体伤害，我们在过去5秒钟内就会损失超过“2”值的健康状况。" ..
        C.TOOLTIP_VALUE_1 .. "健康阈值。" .. C.TOOLTIP_VALUE_2 .. "身体伤害在过去5秒内的健康百分比损失。"
    }
    )
    AddNewOption(
    "防御",
    { "恶魔尖刺第三层充能", "恶魔尖刺第二收费3" },
    222,
    true,
    { 85, 1, 100, 1 },
    { 15, 0, 100, 1 },
    {
        "Use Demon Spikes with three charges when our health fall under Value 1 health and we lost more than Value 2 health in the last 5 seconds via Physical damage." ..
        C.TOOLTIP_VALUE_1 ..
        "Health threshold." ..
        C.TOOLTIP_VALUE_2 .. "Health percentage lost in the last 5 seconds via Physical damage.",
        "当我们的健康处于“值3”健康状态时，使用恶魔峰值，一旦发生身体伤害，我们在过去5秒钟内就会损失超过“2”值的健康状况。" ..
        C.TOOLTIP_VALUE_1 .. "健康阈值。" .. C.TOOLTIP_VALUE_2 .. "身体伤害在过去5秒内的健康百分比损失。"
    }
    )
    AddNewOption(
    "防御",
    { "恶魔灌注", "恶魔灌注" },
    222,
    true,
    { 60, 1, 100, 1 },
    { 15, 0, 100, 1 },
    {
        "Use Demonic Infusion when our health fall under Value 1 health and we lost more than Value 2 health in the last 5 seconds via Physical damage." ..
        C.TOOLTIP_VALUE_1 ..
        "Health threshold." ..
        C.TOOLTIP_VALUE_2 .. "Health percentage lost in the last 5 seconds via Physical damage.",
        "当我们的健康处于1级健康状态下时，使用恶魔输液，在过去5秒内，身体受到损害，我们的身体损失超过2倍。" ..
        C.TOOLTIP_VALUE_1 .. "健康阈值。" .. C.TOOLTIP_VALUE_2 .. "身体伤害在过去5秒内的健康百分比损失。"
    }
    )
    AddNewOption(
    "防御",
    { "恶魔灌注痛苦", "恶魔灌注疼痛" },
    120,
    true,
    { 30, 0, 100, 1 },
    nil,
    {
        "Pain threshold to use Demonic Infusion." ..
        C.TOOLTIP_VALUE_1 ..
        "Pain threshold. Will use Demonic Infusion only if your current Pain is at or below threshold.",
        "疼痛阈值使用恶魔灌注。" .. C.TOOLTIP_VALUE_1 .. "疼痛阈值。 只有当目前的疼痛达到或低于阈值时，才会使用恶魔灌注。"
    }
    )
    AddNewOption(
    "防御",
    { "强化结界 1", "强化结界1" },
    222,
    true,
    { 90, 1, 100, 1 },
    { 5, 0, 100, 1 },
    {
        "Use Empower Wards with 1 Charge when our health fall under Value 1 health and we lost more than Value 2 health in the last 5 seconds via Spell damage." ..
        C.TOOLTIP_VALUE_1 ..
        "Health threshold." ..
        C.TOOLTIP_VALUE_2 .. "Health percentage lost in the last 5 seconds via Spell damage.",
        "当我们的健康属于“值1”健康状态时，使用强化结界，在过去5秒内，通过法术伤害，我们输给了超过“2”值的健康。" ..
        C.TOOLTIP_VALUE_1 .. "健康阈值。" .. C.TOOLTIP_VALUE_2 .. "通过法术伤害在过去5秒内的健康百分比损失。"
    }
    )
    AddNewOption(
    "防御",
    { "强化结界 2", "强化结界2" },
    222,
    true,
    { 90, 1, 100, 1 },
    { 5, 0, 100, 1 },
    {
        "Use Empower Wards with 2 Charges when our health fall under Value 1 health and we lost more than Value 2 health in the last 5 seconds via Spell damage." ..
        C.TOOLTIP_VALUE_1 ..
        "Health threshold." ..
        C.TOOLTIP_VALUE_2 .. "Health percentage lost in the last 5 seconds via Spell damage.",
        "当我们的健康属于“值1”健康状态时，使用强化结界，在过去5秒内，通过法术伤害，我们输给了超过“2”值的健康。" ..
        C.TOOLTIP_VALUE_1 .. "健康阈值。" .. C.TOOLTIP_VALUE_2 .. "通过法术伤害在过去5秒内的健康百分比损失。"
    }
    )
    AddSection("防御", { "能力", "能力" }, "Yellow")
    AddNewOption(
    "防御",
    { "恶魔变形", "恶魔变形" },
    223,
    true,
    { 30, 1, 100, 1 },
    { 2, { "无条件使用", "总是" }, { "大技能用法", "冷却时间" } },
    {
        "Use Metamorphosis." ..
        C.TOOLTIP_VALUE ..
        C.TOOLTIP_SUBVALUE("无条件使用", true) ..
        "Will use the ability even if CDs are disabled." ..
        C.TOOLTIP_SUBVALUE("大技能用法") .. "Will only use the ability if CDs are enabled.",
        "使用恶魔变形" ..
        C.TOOLTIP_VALUE ..
        C.TOOLTIP_SUBVALUE("总是", true) ..
        "即使冷却时间被禁用，也会使用这种能力。" .. C.TOOLTIP_SUBVALUE("冷却时间") .. "只有启用冷却时才会使用该功能。"
    }
    )
    AddNewOption(
    "防御",
    { "灵魂壁障", "灵魂壁障" },
    220,
    true,
    { 60, 1, 100, 1 },
    nil,
    { "Use Soul Barrier." .. C.TOOLTIP_VALUE .. "Health threshold.", "使用灵魂壁障" .. C.TOOLTIP_VALUE .. "健康阈值。" }
    )
    Enemies_8y = {}
end
function Rotation:Events()
    EventFrame:RegisterForEvent(
    function(...)
        if select(1, ...) == "player" and select(5, ...) == 189111 then
            InfernalStrikeCasted = GetTime() + 4
        end
    end,
    "UNIT_SPELLCAST_SUCCEEDED"
    )
end
function Rotation:Pulse()
    if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
        return
    end
    if Target:Exists() and BMPullTime() < 5 then
        self:Opening()
        return
    end
    if GetTime() < Rotation.SpamPrevention then
        return
    end
    Rotation.SpamPrevention = GetTime() + 0.05
    Target = Unit.Target
    local InCombat = Player:IsInCombat()
    if not InCombat then
        self:OutOfCombat()
        return
    end
    if InCombat then
        self:Defensives()
    end
    Target = Player:ReTarget(Shear, false) or Unit.Target
    if Target:Exists() then
        Rotations:RefreshUnitTables(Rotation.Identifier)
        self:OffGCDAbilities()
        if Player:GlobalCooldown() == 0 then
            self:Combat()
        end
    end
end
function Rotation:Opening()
    Player:UsePotions("Agility")
    if
    IsOptionEnabled("抢先施放(需DBM插件)") and
    (GetOptionValue("抢先施放(需DBM插件)") == "无条件使用" or
    (GetOptionValue("抢先施放(需DBM插件)") == "打BOSS使用" and Target:IsBoss()))
    then
        if
        InfernalStrike:Exists() and BMPullTime() < GetSecondOptionValue("抢先施放(需DBM插件)") and
        Player:DistanceTo(Target) < 40 and
        Target:CanCast(InfernalStrike)
        then
            Player:StartAttack()
            Player:ForceCastGroundTowardUnit(Target, InfernalStrike, Player:DistanceTo(Target, true) - 3, 0.5)
            return
        end
    end
end
function Rotation:Defensives()
    if Player:IsWithinCastRange(Target, Shear) then
        Player:UseHealingItem()
        if
        FieryBrand:Exists() and CDOptionEnabled("烈火烙印") and
        Player:HealthPercentage() <= GetSecondOptionValue("烈火烙印") and
        Target:CanCast(FieryBrand)
        then
            Target:Cast(FieryBrand)
        end
        if
        SoulBarrier:Exists() and IsOptionEnabled("灵魂壁障") and Player:HealthPercentage() <= GetOptionValue("灵魂壁障") and
        Player:CanCast(SoulBarrier)
        then
            Player:Cast(SoulBarrier)
        end
        if
        Metamorphosis:Exists() and IsOptionEnabled("恶魔变形") and
        (CooldownsAllowed() or GetSecondOptionValue("恶魔变形") == "无条件使用") and
        Player:HealthPercentage() < GetOptionValue("恶魔变形") and
        not Player:Buff(Metamorphosis) and
        Player:CanCast(Metamorphosis)
        then
            Player:Cast(Metamorphosis)
            return
        end
    end
    RandomOffGCD = RandomOffGCD or math.random(35, 115) * 0.01
    if SoulCleave:Cooldown() < RandomOffGCD then
        if DemonicInfusion:Exists() and CDOptionEnabled("恶魔灌注CD") and Player:Pain() <= GetOptionValue("恶魔灌注痛苦") then
            if IsOptionEnabled("恶魔灌注") then
                if
                Player:HealthPercentage() <= GetOptionValue("恶魔灌注") and
                Player:RecentDamageTakenPercent(5, "Physical") >= GetSecondOptionValue("恶魔灌注") and
                Player:CanCast(DemonicInfusion)
                then
                    Bug("Mitigation via Demonic Infusion")
                    Player:Cast(DemonicInfusion)
                    return
                end
            end
        end
        if DemonSpikes:Exists() and IsOptionEnabled("破裂倾卸") and RazorSpikes:Exists() and Fracture:Exists() then
            if
            Player:Pain() >= GetOptionValue("破裂倾卸") and Player:IsWithinCastRange(Target, Shear) and
            Player:BuffRemains(DemonSpikesBuff) < 0.5 and
            Player:CanCast(DemonSpikes)
            then
                Bug("Demon Spikes for Damage Dump")
                Player:Cast(DemonSpikes)
                DemonSpikes.LastCastTime = GetTime()
                return
            end
        elseif
        DemonSpikes:Exists() and Player:Pain() >= 20 and
        Player:BuffRemains(DemonSpikesBuff) < GetOptionValue("恶魔尖刺Buff左") and
        DemonSpikes:TimeSinceCast() > 0.5 and
        (Player:IsWithinCastRange(Target, Shear) or #Enemies_8y > 0)
        then
            local PhysicalDamageTakenLast5 = Player:RecentDamageTakenPercent(5, "Physical")
            if
            (IsOptionEnabled("恶魔尖刺第三层充能") and
            (DemonSpikes:FractionalCharges() <= 3 and DemonSpikes:FractionalCharges() >= 2.75) and
            Player:HealthPercentage() <= GetOptionValue("恶魔尖刺第三层充能") and
            PhysicalDamageTakenLast5 >= GetSecondOptionValue("恶魔尖刺第三层充能")) or
            (IsOptionEnabled("恶魔尖刺第二层充能") and
            (DemonSpikes:FractionalCharges() < 3 and DemonSpikes:FractionalCharges() >= 1.75) and
            Player:HealthPercentage() <= GetOptionValue("恶魔尖刺第二层充能") and
            PhysicalDamageTakenLast5 >= GetSecondOptionValue("恶魔尖刺第二层充能")) or
            (IsOptionEnabled("恶魔尖刺第一层充能") and DemonSpikes:Charges() == 1 and
            Player:HealthPercentage() <= GetOptionValue("恶魔尖刺第一层充能") and
            PhysicalDamageTakenLast5 >= GetSecondOptionValue("恶魔尖刺第一层充能"))
            then
                Bug("Mitigation via Demon Spikes. Charges: " .. DemonSpikes:FractionalCharges())
                DemonSpikes.LastCastTime = GetTime()
                Player:Cast(DemonSpikes)
                return
            end
        end
        if EmpowerWards:Exists() and not Player:Buff(EmpowerWards) and EmpowerWards:TimeSinceCast() > 0.5 then
            if
            (IsOptionEnabled("强化结界 2") and
            (EmpowerWards:FractionalCharges() <= 2 and EmpowerWards:FractionalCharges() >= 1.75) and
            Player:HealthPercentage() <= GetOptionValue("强化结界 2") and
            Player:RecentDamageTakenPercent(5, "Spell") >= GetSecondOptionValue("强化结界 2") and
            Player:CanCast(EmpowerWards)) or
            (IsOptionEnabled("强化结界 1") and EmpowerWards:Charges() == 1 and
            Player:HealthPercentage() <= GetOptionValue("强化结界 1") and
            Player:RecentDamageTakenPercent(5, "Spell") >= GetSecondOptionValue("强化结界 1") and
            Player:CanCast(EmpowerWards))
            then
                Bug("Mitigation via Empower Wards")
                EmpowerWards.LastCastTime = GetTime()
                Player:Cast(EmpowerWards)
                return
            end
        end
    end
end
function Rotation:OffGCDAbilities()
    if Torment:Exists() and Player:TauntManager(Torment, "折磨", Target, TauntEnemies) then
        return
    end
    Player:UseInterrupt(ConsumeMagic, ArcaneTorrent)
    if
    InfernalStrike:Exists() and IsOptionEnabled("地狱火撞击") and GetOptionValue("地狱火撞击") < InfernalStrike:Charges() and
    Player:Standing() >= GetSecondOptionValue("地狱火撞击") and
    InfernalStrikeEnemies > 0 and
    InfernalStrike:TimeSinceCast() > 0.5 and
    Player:CanCast(InfernalStrikePlayer)
    then
        InfernalStrike.LastCastTime = GetTime()
        Player:Cast(InfernalStrikePlayer)
        return
    end
end
function Rotation:UnitTables()
    TauntEnemies = Player:EnemiesWithinDistance(30, false)
    TargetEnemies_8y = UseAOE() and Target:EnemiesWithinDistance(8, false) or {}
    Enemies_8y = UseAOE() and Player:EnemiesWithinDistance(8, true) or {}
    InfernalStrikeEnemies = UseAOE() and #Player:EnemiesWithinDistance(6, true) or 0
    NumEnemies = #TargetEnemies_8y
    FelDevastationNumEnemies =     UseAOE() and FelDevastation:Exists() and CDOptionEnabled("邪能毁灭") and #Player:UnitsInFrontRectangle(20, 5) or 0
    SoulCleaveNumEnemies =     UseAOE() and IsOptionEnabled("灵魂裂劈") and
    #Player:UnitsInFrontRectangle(
    GetSecondOptionValue("Soul Cleave Enemy Detection"),
    GetOptionValue("Soul Cleave Enemy Detection")
    ) or
    0
end
function Rotation:Combat()
    Pain, PainDeficit, GCDMax, Fragments =     Player:Power(),
    Player:PowerDeficit(),
    Player:GCD(),
    Player:Buff(SoulFragments) and Player:BuffCount(SoulFragments) or 0
    if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        Player:StartAttack()
        if Player:IsWithinCastRange(Target, Shear) then
            Player:UsePotions(GetSecondOptionValue("使用药水"))
            Player:UseTrinkets()
            if
            ArcaneTorrent:Exists() and IsOptionEnabled("进攻性种族技能") and
            (CooldownsAllowed() or GetOptionValue("进攻性种族技能") == "无条件使用") and
            Pain < 80 and
            Player:CanCast(ArcaneTorrent)
            then
                Player:Cast(ArcaneTorrent)
                return
            end
            if SoulCarver:Exists() and CDOptionEnabled("灵魂切削") and Target:CanCast(SoulCarver) then
                if IsOptionEnabled("烈火烙印时灵魂切削") then
                    if Target:Debuff(FieryBrandDebuff) or FieryBrand:Cooldown() > 35 then
                        Target:Cast(SoulCarver)
                        return
                    end
                else
                    Target:Cast(SoulCarver)
                    return
                end
            end
        end
        if
        SpiritBomb:Exists() and
        ((IsOptionEnabled("幽魂炸弹") and Target:DebuffRemains(SpiritBombDebuff) < 2 and Fragments >= 1) or
        (IsOptionEnabled("幽魂炸弹倾卸") and Fragments >= GetOptionValue("幽魂炸弹倾卸"))) and
        (Player:DistanceTo(Target) < 8 or NumEnemies > 0) and
        Target:CanCast(SpiritBomb)
        then
            Target:Cast(SpiritBomb)
            return
        end
        if
        IsOptionEnabled("破裂倾卸") and RazorSpikes:Exists() and Fracture:Exists() and Player:Buff(DemonSpikesBuff) and
        Pain > GetSecondOptionValue("破裂倾卸")
        then
            if
            (not IsOptionEnabled("破裂敌人") or SoulCleaveNumEnemies < GetOptionValue("破裂敌人")) and
            Target:CanCast(Fracture)
            then
                Bug("Fracture - Damage Dump")
                Target:Cast(Fracture)
                return
            elseif SoulCleaveNumEnemies >= GetOptionValue("破裂敌人") and Target:CanCast(SoulCleave) then
                Bug("Soul Cleave - Damage Dump")
                Target:Cast(SoulCleave)
                return
            end
        end
        if
        FelDevastation:Exists() and CDOptionEnabled("邪能毁灭") and
        Player:HealthPercentage() <= GetSecondOptionValue("邪能毁灭CD") and
        (GetOptionValue("邪能毁灭CD") == 1 or (GetOptionValue("邪能毁灭CD") > 1 and UseAOE())) and
        FelDevastationNumEnemies >= GetOptionValue("邪能毁灭CD") and
        not Player:IsMoving() and
        Player:CanCast(FelDevastation)
        then
            Player:Cast(FelDevastation)
            return
        end
        if
        SoulCleave:Exists() and IsOptionEnabled("灵魂裂劈") and Pain >= 50 and
        Player:HealthPercentage() <= GetOptionValue("灵魂裂劈") and
        Target:CanCast(SoulCleave)
        then
            Bug("Soul Cleave - Healing")
            Target:Cast(SoulCleave)
            return
        end
        if
        Fracture:Exists() and not (IsOptionEnabled("破裂倾卸") and RazorSpikes:Exists() and Fracture:Exists()) and
        IsOptionEnabled("破裂") and
        Pain >= GetSecondOptionValue("灵魂裂劈") and
        (not IsOptionEnabled("破裂敌人") or SoulCleaveNumEnemies < GetOptionValue("破裂敌人")) and
        (GetOptionValue("破裂") == 0 or Fragments < GetOptionValue("破裂")) and
        Target:CanCast(Fracture)
        then
            Bug("Fracture - Dump")
            Target:Cast(Fracture)
            return
        end
        if
        SoulCleave:Exists() and not (IsOptionEnabled("破裂倾卸") and RazorSpikes:Exists() and Fracture:Exists()) and
        IsOptionEnabled("灵魂裂劈") and
        Pain >= GetSecondOptionValue("灵魂裂劈") and
        Target:CanCast(SoulCleave)
        then
            Bug("Soul Cleave - Dump")
            Target:Cast(SoulCleave)
            return
        end
        if
        ImmolationAura:Exists() and IsOptionEnabled("献祭光环") and Player:IsWithinCastRange(Target, Shear) and
        #Enemies_8y >= GetOptionValue("献祭光环") and
        Player:CanCast(ImmolationAura)
        then
            Player:Cast(ImmolationAura)
            return
        end
        if
        FelEruption:Exists() and IsOptionEnabled("邪能爆发") and
        (not RazorSpikes:Exists() or Player:Buff(DemonSpikesBuff)) and
        Target:CanCast(FelEruption)
        then
            Target:Cast(FelEruption)
            return
        end
        if
        SigilOfFlame:Exists() and IsOptionEnabled("烈焰咒符") and not Target:Debuff(SigilOfFlameDebuff) and
        not Target:IsDeadOrGhost() and
        Target:TimeToDie() >= 5 and
        (not FlameCrash:Exists() or not InfernalStrikeCasted or InfernalStrikeCasted < GetTime())
        then
            if ConcentratedSigils:Exists() then
                if
                Player:IsWithinCastRange(Target, Shear) and NumEnemies >= GetSecondOptionValue("烈焰咒符") and
                Player:CanCast(SigilOfFlamePlayer)
                then
                    Player:Cast(SigilOfFlamePlayer)
                    return
                end
            else
                if Target:CanCast(SigilOfFlame) then
                    if Target:CastGroundSpell(SigilOfFlame, "烈焰咒符", 8, 1.2) then
                        return
                    end
                end
            end
        end
        if
        FelBlade:Exists() and IsOptionEnabled("邪能之刃") and Player:IsWithinCastRange(Target, Shear) and
        Target:CanCast(FelBlade)
        then
            Target:Cast(FelBlade)
            return
        end
        if Shear:Exists() and Target:CanCast(Shear) then
            Target:Cast(Shear)
            return
        end
        if ThrowGlaive:Exists() and IsOptionEnabled("投掷利刃") and Target:CanCast(ThrowGlaive) then
            Target:Cast(ThrowGlaive)
            return
        end
    end
end
function Rotation:OutOfCombat()
    if IsOptionEnabled("自动进入战斗") and Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        if IsOptionEnabled("邪能之刃") and FelBlade:Exists() and Target:CanCast(FelBlade) then
            Target:Cast(FelBlade)
            return
        end
        if Target:CanCast(Shear) then
            Target:Cast(Shear)
            return
        end
        if IsOptionEnabled("投掷利刃") and Target:CanCast(ThrowGlaive) then
            Target:Cast(ThrowGlaive)
            return
        end
    end
end
SetRotation(102, {})
local Rotation = Rotations[102]
StarfallAstralPower, NewMoonIcon, HalfMoonIcon, FullMoonIcon = 60, 1392545, 1392543, 1392542
function Rotation:Initialize()
    self.HasBetaRotation = true
    Berserking = Spell(26297, false, false, true)
    AstralAcceleration = Spell(242232)
    AstralCommunion = Spell(202359, false, false, true)
    Barkskin = Spell(22812, false, false, true)
    BearForm = Spell(5487, false, false, true)
    BlessingOfAnshe = Spell(202739)
    BlessingOfElune = Spell(202737)
    BlessingOfTheAncients = Spell(202360, false, false, true)
    CatForm = Spell(768, false, false, true)
    CelestialAlignment = Spell(194223, false, false, true)
    DisplacerBeast = Spell(137452, false, false, true)
    ForceOfNature = Spell(205636, false, true, true)
    FullMoon = Spell(202771, true, true, false)
    FuryOfElune = Spell(202770, true, true, true)
    HalfMoon = Spell(202768, true, true, false)
    HealingTouch = Spell(5185, false, false, false)
    Incarnation = Spell(102560, false, false, true)
    LunarEmpowerment = Spell(164547)
    LunarStrike = Spell(194153, true, true, false)
    LunarStrikeInstant = Spell(194153, true, true, true)
    Moonfire = Spell(8921, false, true, true)
    MoonfireDebuff = Spell(164812)
    MoonkinForm = Spell(24858, false, false, true)
    NaturesBalance = Spell(202430)
    NewMoon = Spell(202767, true, true, false)
    OwlkinFrenzy = Spell(157228)
    Rebirth = Spell(20484, false, false, false, true)
    Renewal = Spell(108238, false, false, true)
    SolarBeam = Spell(78675, true, true, true)
    SolarEmpowerment = Spell(164545)
    SoulOfTheForest = Spell(114107)
    Starfall = Spell(191034, false, true, true)
    StarfallBuff = Spell(184989)
    Starsurge = Spell(78674, true, true, true)
    StellarDrift = Spell(202354)
    StellarFlare = Spell(202347, true, true, false)
    Sunfire = Spell(93402, false, true, true)
    SunfireDebuff = Spell(164815)
    TravelForm = Spell(783, false, false, true)
    SolarWrath = Spell(190984, true, true, false)
    WarriorOfElune = Spell(202425, false, false, true)
    FeralAffinity = Spell(202157)
    FerociousBite = Spell(22568, true, true, true)
    Rip = Spell(1079, true, true, true)
    Shred = Spell(5221, true, true, true)
    Swipe = Spell(106785, false, false, true)
    GuardianAffinity = Spell(197491)
    FrenziedRegeneration = Spell(22842, false, false, true)
    Ironfur = Spell(192081, false, false, true)
    Mangle = Spell(33917, true, true, true)
    Thrash = Spell(77758, false, false, true)
    ThrashDebuff = Spell(192090)
    RestorationAffinity = Spell(197492)
    Regrowth = Spell(8936, false, false, false)
    Rejuvenation = Spell(774, false, false, true)
    Swiftmend = Spell(18562, false, false, true)
    EmeraldDreamcatcher = Item(137062)
    EmeraldDreamcatcherBuff = Spell(224706)
    OnethsOverconfidenceStarfall = Spell(209407)
    OnethsOverconfidenceStarsurge = Spell(209406)
    AddPage("常规")
    AddPage("进攻")
    AddPage("防御")
    AddPage("亲和")
    if self.HasBetaRotation then
        AddNewOption(
        "常规",
        "测试版循环",
        210,
        true,
        nil,
        nil,
        "Use the lastest updated combat routine. May not be as optimized and can contain error regarding execution!"
        )
    end
    AddCommonOptions()
    AddPresetOption("常规", "Caster", nil, true)
    AddSection("常规", "辅助", "Yellow")
    AddNewOption(
    "常规",
    "远古祝福",
    230,
    true,
    { 1, "安瑟的祝福", "艾露恩的祝福" },
    nil,
    "Maintain choosed Blessing buffed." .. C.TOOLTIP_VALUE .. "Choose which blessing you would like to keep buffed."
    )
    AddNewOption("常规", "枭兽形态", 210, true, nil, nil, "Use Moonkin Form.")
    AddNewOption(
    "常规",
    "复生",
    210,
    true,
    nil,
    nil,
    "Enable to automatically resurrect targeted dead player targets in combat."
    )
    AddNewOption(
    "常规",
    "立即战服坦克",
    220,
    true,
    { 2, 0, 3, 0.1 },
    nil,
    "Enable to use Rebirth to resurrect a dead Tank." .. C.TOOLTIP_VALUE .. "Set the delay before using it."
    )
    AddPresetOption("进攻")
    AddSection("进攻", "大技能", "Yellow")
    AddPresetOption("Cooldown", "沟通星界")
    AddPresetOption("Cooldown", "超凡之盟")
    AddPresetOption("Cooldown", "自然之力", 1)
    AddPresetOption("Cooldown", "艾露恩之怒")
    AddPresetOption("Cooldown", "化身")
    AddPresetOption("Cooldown", "艾露恩的战士", 1)
    AddSection("进攻", "能力", "Yellow")
    AddNewOption(
    "进攻",
    "满月",
    120,
    true,
    { 2, 1, 10, 1 },
    nil,
    "Full Moon with artifact." ..
    C.TOOLTIP_VALUE .. "Amount of units needed within 5 yards of target to use Full Moon."
    )
    AddNewOption(
    "进攻",
    "多目标 月火术",
    222,
    false,
    { 5, 1, 20, 1 },
    { 3, 0, 25, 0.1 },
    "Multi-Dot Moonfire Cycle." ..
    C.TOOLTIP_VALUE_1 ..
    "Number of dots to apply." .. C.TOOLTIP_VALUE_2 .. "Minimum health (in million) to apply."
    )
    AddNewOption(
    "进攻",
    "多目标 星辰耀斑",
    222,
    false,
    { 10, 1, 20, 1 },
    { 3, 0, 25, 0.1 },
    "Multi-Dot Stellar Flare Cycle." ..
    C.TOOLTIP_VALUE_1 ..
    "Number of dots to apply." .. C.TOOLTIP_VALUE_2 .. "Minimum health (in million) to apply."
    )
    AddNewOption(
    "进攻",
    "多目标 阳炎术",
    222,
    false,
    { 10, 1, 20, 1 },
    { 3, 0, 25, 0.1 },
    "Multi-Dot Sunfire Cycle." ..
    C.TOOLTIP_VALUE_1 ..
    "Number of dots to apply." .. C.TOOLTIP_VALUE_2 .. "Minimum health (in million) to apply."
    )
    AddNewOption(
    "进攻",
    "移动时填充技能",
    223,
    true,
    { 0.7, 0, 4, 0.1 },
    { 2, "月火术", "阳炎术" },
    "Use Moonfire or Sunfire as filler while moving and we cannot cast anything else." ..
    C.TOOLTIP_VALUE_1 ..
    "Time to wait in seconds before using Moonfire/Sunfire filler while moving." ..
    C.TOOLTIP_VALUE_2 .. "Preferred spell to use."
    )
    AddNewOption(
    "进攻",
    "星辰坠落",
    232,
    true,
    { 2, "目标", "Target Standing", "Centered", "Centered Standing" },
    { 2, 1, 25, 1 },
    "Use Starfall." ..
    C.TOOLTIP_VALUE_1 ..
    "Choose preferred mode." ..
    C.TOOLTIP_SUBVALUE("目标") ..
    "Always use on the current target." ..
    C.TOOLTIP_SUBVALUE("Target Standing") ..
    "Always use on the current target. Target must be standing still." ..
    C.TOOLTIP_SUBVALUE("Centered") ..
    "Use centered on a cluster of enemies." ..
    C.TOOLTIP_SUBVALUE("Centered Standing") ..
    "Use centered on a cluster of enemies. Enemies must be standing still." ..
    C.TOOLTIP_VALUE_2 ..
    "Amount of enemies that must be in the spell effect to use."
    )
    AddNewOption(
    "进攻",
    "高优先级 星辰坠落",
    232,
    true,
    { 2, "目标", "Target Standing", "Centered", "Centered Standing" },
    { 3, 1, 25, 1 },
    "Use Starfall as high priority, before DoTs and New Moon." ..
    C.TOOLTIP_VALUE_1 ..
    "Choose preferred mode." ..
    C.TOOLTIP_SUBVALUE("目标") ..
    "Always use on the current target." ..
    C.TOOLTIP_SUBVALUE("Target Standing") ..
    "Always use on the current target. Target must be standing still." ..
    C.TOOLTIP_SUBVALUE("Centered") ..
    "Use centered on a cluster of enemies." ..
    C.TOOLTIP_SUBVALUE("Centered Standing") ..
    "Use centered on a cluster of enemies. Enemies must be standing still." ..
    C.TOOLTIP_VALUE_2 ..
    "Amount of enemies that must be in the spell effect to use."
    )
    AddNewOption(
    "进攻",
    "星辰坠落 欧奈斯的直觉",
    210,
    false,
    nil,
    nil,
    "Use Starfall on Single Target with Oneth Legendary Buff, which makes Starfall free to use." ..
    C.TOOLTIP_HINT("Still tries to use it on best enemy cluster.")
    )
    AddNewOption(
    "进攻",
    "星涌术",
    220,
    true,
    { 60, 40, 130, 1 },
    nil,
    "Use Starsurge when we get enough Astral Power." ..
    C.TOOLTIP_VALUE ..
    "Astral Power threshold to use." ..
    C.TOOLTIP_HINT(
    "It is highly recommanded to do not go higher than 80 as this could lead to bleeding Astral Power. It should also be kept above 60 so that Starfall can be used when needed."
    )
    )
    AddNewOption(
    "进攻",
    "翡翠捕梦者",
    222,
    true,
    { 2, 1, 10, 1 },
    { 0, 0, 1, 0.05 },
    "Enables support specific rotation with Emerald Dreamcatcher Legendary." ..
    C.TOOLTIP_VALUE_1 ..
    "Until which amount of enemies you still want to use Dreamcatcher rotation. Normally at 3 you start using normal one. But some times you may want more priority damage." ..
    C.TOOLTIP_VALUE_2 ..
    "Buff duration tolerance for lags and high ping. For calculations the buffs remaining duration is calculated shorter with the given amount. So buff does not drop shortly after a cast due to being calcuated to tight."
    )
    AddPresetOption("防御")
    AddSection("防御", "能力", "Yellow")
    AddNewOption(
    "防御",
    "树皮术",
    220,
    true,
    { 40, 1, 100, 1 },
    nil,
    "Use Barkskin." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddNewOption(
    "防御",
    "治疗之触 自己",
    222,
    true,
    { 30, 1, 100, 1 },
    { 80, 1, 100, 1 },
    "Use Healing Touch on ourself." ..
    C.TOOLTIP_VALUE_1 ..
    "Health threshold while In Combat." .. C.TOOLTIP_VALUE_2 .. "Health threshold while Out of Combat."
    )
    AddNewOption(
    "防御",
    "愈合 自己",
    222,
    true,
    { 30, 1, 100, 1 },
    { 80, 1, 100, 1 },
    "Use Regrowth on ourself." ..
    C.TOOLTIP_VALUE_1 ..
    "Health threshold while In Combat." .. C.TOOLTIP_VALUE_2 .. "Health threshold while Out of Combat."
    )
    AddNewOption(
    "防御",
    "新生",
    220,
    true,
    { 30, 1, 100, 1 },
    nil,
    "Use Renewal on ourself." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddSection("亲和", "恢复亲和", "Yellow")
    AddNewOption("亲和", "恢复亲和", 210, false, nil, nil, "Enable Restoration Affinity Healing.")
    AddNewOption(
    "亲和",
    "治疗之触",
    222,
    true,
    { 75, 0, 100, 1 },
    { 65, 0, 100, 1 },
    "Use Healing Touch." ..
    C.TOOLTIP_VALUE_1 ..
    "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid."
    )
    AddNewOption(
    "亲和",
    "愈合",
    222,
    true,
    { 45, 0, 100, 1 },
    { 35, 0, 100, 1 },
    "Use Regrowth." ..
    C.TOOLTIP_VALUE_1 ..
    "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid."
    )
    AddNewOption(
    "亲和",
    "回春术",
    222,
    true,
    { 80, 0, 100, 1 },
    { 70, 0, 100, 1 },
    "Use Rejuvenation." ..
    C.TOOLTIP_VALUE_1 ..
    "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid."
    )
    AddNewOption(
    "亲和",
    "回春术 自己",
    220,
    true,
    { 30, 1, 100, 1 },
    nil,
    "Use Rejuvenation on ourself." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddNewOption(
    "亲和",
    "迅捷治愈",
    222,
    true,
    { 25, 0, 100, 1 },
    { 15, 0, 100, 1 },
    "Use Swiftmend." ..
    C.TOOLTIP_VALUE_1 ..
    "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid."
    )
    AddSection("亲和", "守护亲和", "Yellow")
    AddNewOption("亲和", "守护亲和", 210, false, nil, nil, "Enable Guardian Affinity Tanking.")
    AddNewOption(
    "亲和",
    "狂暴回复",
    220,
    true,
    { 35, 1, 100, 1 },
    nil,
    "Use Frenzied Regeneration." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddNewOption("亲和", "铁鬃", 220, true, { 90, 1, 100, 1 }, nil, "Use Ironfur." .. C.TOOLTIP_VALUE .. "Health threshold.")
    AddSection("亲和", "野性亲和", "Yellow")
    AddNewOption("亲和", "野性亲和", 210, false, nil, nil, "Enable Feral Affinity DPS.")
    AddNewOption("亲和", "割裂", 210, true, nil, nil, "Use Rip.")
    AddNewOption(
    "亲和",
    "横扫",
    220,
    true,
    { 3, 1, 10, 1 },
    nil,
    "Use Swipe." .. C.TOOLTIP_VALUE .. "Amount of units needed within 10 yards of player to use Swipe."
    )
    AddOutput("|cFF9A2EFE主T:")
    AddOutput("|cFF9A2EFE副T:")
    ISCL = {
        [HalfMoon:ID()] = "Half Moon",
        [HealingTouch:ID()] = "治疗之触",
        [LunarStrike:ID()] = "Lunar Strike",
        [NewMoon:ID()] = "New Moon",
        [Regrowth:ID()] = "愈合",
        [SolarWrath:ID()] = "阳炎之怒",
        [StellarFlare:ID()] = "Stellar Flare"
    }
end
function Rotation:UseBetaRotation()
    return self.HasBetaRotation and IsOptionEnabled("测试版循环")
end
function Rotation:Events()
end
function Rotation:Pulse()
    if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
        return
    end
    if Target:Exists() and BMPullTime() < 5 then
        self:Opening()
        return
    end
    if GetTime() < Rotation.SpamPrevention then
        return
    end
    Rotation.SpamPrevention = GetTime() + 0.05
    Target = Unit.Target
    local InCombat = Player:IsInCombat()
    if not InCombat then
        self:OutOfCombat()
        return
    end
    if InCombat then
        self:Defensives()
    end
    Target = Player:ReTarget(Moonfire, true) or Unit.Target
    Rotations:RefreshUnitTables(Rotation.Identifier)
    self:Interrupts()
    if
    IsOptionEnabled("开怪技能") and
    (GetOptionValue("开怪技能") == "无条件使用" or (GetOptionValue("开怪技能") == "打BOSS使用" and Target:IsBoss()) or
    (GetOptionValue("开怪技能") == "CDs Only" and CooldownsAllowed())) and
    not OpenerEnded
    then
        self:Opener()
        return
    elseif CombatTime() > 10 then
        OpenerEnded = true
    end
    self:OffGCDAbilities()
    if Player:GlobalCooldown() == 0 then
        if self:UseBetaRotation() then
            self:CombatBeta()
        else
            self:Combat()
        end
    end
end
function Rotation:Opening()
    Player:UsePotions("智力药水")
    if
    IsOptionEnabled("抢先施放(需DBM插件)") and
    (GetOptionValue("抢先施放(需DBM插件)") == "无条件使用" or
    (GetOptionValue("抢先施放(需DBM插件)") == "打BOSS使用" and Target:IsBoss()))
    then
        if SolarWrath:Exists() and BMPullTime() < GetSecondOptionValue("抢先施放(需DBM插件)") and Target:CanCast(SolarWrath) then
            Target:Cast(SolarWrath)
            return
        end
    end
end
function Rotation:Opener()
    self.ChoosenOpener = nil
    if not EmeraldDreamcatcher:IsEquipped(1) then
        self.ChoosenOpener = {
            [1] = { NewMoon, Target, Player:Buff(MoonkinForm) ~= nil and NewMoon:Exists() },
            [2] = { Moonfire, Target, Player:Buff(MoonkinForm) ~= nil },
            [3] = { Sunfire, Target, Player:Buff(MoonkinForm) ~= nil },
            [4] = { Incarnation, Player, Player:Buff(MoonkinForm) ~= nil and Incarnation:Exists() },
            [5] = { CelestialAlignment, Player, Player:Buff(MoonkinForm) ~= nil and not Incarnation:Exists() },
            [6] = { Berserking, Player, Player:Buff(MoonkinForm) ~= nil and Berserking:Exists() },
            [7] = { "Trinkets", Player, Player:Buff(MoonkinForm) ~= nil },
            [8] = { NewMoon, Target, Player:Buff(MoonkinForm) ~= nil and NewMoon:Exists() },
            [9] = { NewMoon, Target, Player:Buff(MoonkinForm) ~= nil and NewMoon:Exists() },
            [10] = { Starsurge, Target, Player:Buff(MoonkinForm) ~= nil and Player:AstralPower() >= 40 },
            [11] = { SolarWrath, Target, Player:Buff(MoonkinForm) ~= nil and Player:Buff(SolarEmpowerment) ~= nil },
            [12] = {
                LunarStrike,
                Target,
                Player:Buff(MoonkinForm) ~= nil and Player:HasHero() and Player:Buff(LunarEmpowerment) ~= nil
            },
            [13] = { Starsurge, Target, Player:Buff(MoonkinForm) ~= nil and Player:AstralPower() >= 40 },
            [14] = {
                SolarWrath,
                Target,
                Player:Buff(MoonkinForm) ~= nil and Player:HasHero() and Player:Buff(SolarEmpowerment) ~= nil
            },
            [15] = { LunarStrike, Target, Player:Buff(MoonkinForm) ~= nil and Player:Buff(LunarEmpowerment) ~= nil },
            [16] = { Starsurge, Target, Player:Buff(MoonkinForm) ~= nil and Player:AstralPower() >= 40 },
            [17] = {
                SolarWrath,
                Target,
                Player:Buff(MoonkinForm) ~= nil and Player:HasHero() and Player:Buff(SolarEmpowerment) ~= nil
            },
            [18] = {
                SolarWrath,
                Target,
                Player:Buff(MoonkinForm) ~= nil and Player:HasHero() and Player:Buff(SolarEmpowerment) ~= nil
            },
            [19] = { Starsurge, Target, Player:Buff(MoonkinForm) ~= nil and Player:AstralPower() >= 40 },
            [20] = { Starsurge, Target, Player:Buff(MoonkinForm) ~= nil and Player:AstralPower() >= 40 },
            [21] = { Starsurge, Target, Player:Buff(MoonkinForm) ~= nil and Player:AstralPower() >= 40 },
            [22] = "Normal Opener"
        }
    else
        if Player:HasHero() then
            self.ChoosenOpener = {
                [1] = { NewMoon, Target, Player:Buff(MoonkinForm) ~= nil and NewMoon:Exists() },
                [2] = { Moonfire, Target, Player:Buff(MoonkinForm) ~= nil },
                [3] = { Sunfire, Target, Player:Buff(MoonkinForm) ~= nil },
                [4] = { Incarnation, Player, Player:Buff(MoonkinForm) ~= nil and Incarnation:Exists() },
                [5] = { CelestialAlignment, Player, Player:Buff(MoonkinForm) ~= nil and not Incarnation:Exists() },
                [6] = { Berserking, Player, Player:Buff(MoonkinForm) ~= nil and Berserking:Exists() },
                [7] = { "Trinkets", Player, Player:Buff(MoonkinForm) ~= nil },
                [8] = { NewMoon, Target, Player:Buff(MoonkinForm) ~= nil and NewMoon:Exists() },
                [9] = { NewMoon, Target, Player:Buff(MoonkinForm) ~= nil and NewMoon:Exists() },
                [10] = { Starsurge, Target, Player:Buff(MoonkinForm) ~= nil and Player:AstralPower() >= 40 },
                [11] = { SolarWrath, Target, Player:Buff(MoonkinForm) ~= nil and Player:Buff(SolarEmpowerment) ~= nil },
                [12] = { LunarStrike, Target, Player:Buff(MoonkinForm) ~= nil and Player:Buff(LunarEmpowerment) ~= nil },
                [13] = { Starsurge, Target, Player:Buff(MoonkinForm) ~= nil and Player:AstralPower() >= 40 },
                [14] = { SolarWrath, Target, Player:Buff(MoonkinForm) ~= nil and Player:Buff(SolarEmpowerment) ~= nil },
                [15] = { LunarStrike, Target, Player:Buff(MoonkinForm) ~= nil and Player:Buff(LunarEmpowerment) ~= nil },
                [16] = { Starsurge, Target, Player:Buff(MoonkinForm) ~= nil and Player:AstralPower() >= 40 },
                [17] = { Starsurge, Target, Player:Buff(MoonkinForm) ~= nil and Player:AstralPower() >= 40 },
                [18] = { Starsurge, Target, Player:Buff(MoonkinForm) ~= nil and Player:AstralPower() >= 40 },
                [19] = { Starsurge, Target, Player:Buff(MoonkinForm) ~= nil and Player:AstralPower() >= 40 },
                [20] = { SolarWrath, Target, Player:Buff(MoonkinForm) ~= nil and Player:Buff(SolarEmpowerment) ~= nil },
                [21] = { SolarWrath, Target, Player:Buff(MoonkinForm) ~= nil and Player:Buff(SolarEmpowerment) ~= nil },
                [22] = { LunarStrike, Target, Player:Buff(MoonkinForm) ~= nil and Player:Buff(LunarEmpowerment) ~= nil },
                [23] = { LunarStrike, Target, Player:Buff(MoonkinForm) ~= nil and Player:Buff(LunarEmpowerment) ~= nil },
                [24] = "Emerald Dreamcatcher Heroism Opener"
            }
        else
            self.ChoosenOpener = {
                [1] = { NewMoon, Target, Player:Buff(MoonkinForm) ~= nil and NewMoon:Exists() },
                [2] = { Moonfire, Target, Player:Buff(MoonkinForm) ~= nil },
                [3] = { Sunfire, Target, Player:Buff(MoonkinForm) ~= nil },
                [4] = { Incarnation, Player, Player:Buff(MoonkinForm) ~= nil and Incarnation:Exists() },
                [5] = { CelestialAlignment, Player, Player:Buff(MoonkinForm) ~= nil and not Incarnation:Exists() },
                [6] = { Berserking, Player, Player:Buff(MoonkinForm) ~= nil and Berserking:Exists() },
                [7] = { "Trinkets", Player, Player:Buff(MoonkinForm) ~= nil },
                [8] = { NewMoon, Target, Player:Buff(MoonkinForm) ~= nil and NewMoon:Exists() },
                [9] = { NewMoon, Target, Player:Buff(MoonkinForm) ~= nil and NewMoon:Exists() },
                [10] = { Starsurge, Target, Player:Buff(MoonkinForm) ~= nil and Player:AstralPower() >= 40 },
                [11] = { SolarWrath, Target, Player:Buff(MoonkinForm) ~= nil and Player:Buff(SolarEmpowerment) ~= nil },
                [12] = { Starsurge, Target, Player:Buff(MoonkinForm) ~= nil and Player:AstralPower() >= 40 },
                [13] = { LunarStrike, Target, Player:Buff(MoonkinForm) ~= nil and Player:Buff(LunarEmpowerment) ~= nil },
                [14] = { Starsurge, Target, Player:Buff(MoonkinForm) ~= nil and Player:AstralPower() >= 40 },
                [15] = { SolarWrath, Target, Player:Buff(MoonkinForm) ~= nil and Player:Buff(SolarEmpowerment) ~= nil },
                [16] = { SolarWrath, Target, Player:Buff(MoonkinForm) ~= nil and Player:Buff(SolarEmpowerment) ~= nil },
                [17] = { Starsurge, Target, Player:Buff(MoonkinForm) ~= nil and Player:AstralPower() >= 40 },
                [18] = { Starsurge, Target, Player:Buff(MoonkinForm) ~= nil and Player:AstralPower() >= 40 },
                [19] = { Starsurge, Target, Player:Buff(MoonkinForm) ~= nil and Player:AstralPower() >= 40 },
                [20] = { SolarWrath, Target, Player:Buff(MoonkinForm) ~= nil and Player:Buff(SolarEmpowerment) ~= nil },
                [21] = { SolarWrath, Target, Player:Buff(MoonkinForm) ~= nil and Player:Buff(SolarEmpowerment) ~= nil },
                [22] = { LunarStrike, Target, Player:Buff(MoonkinForm) ~= nil and Player:Buff(LunarEmpowerment) ~= nil },
                [23] = { LunarStrike, Target, Player:Buff(MoonkinForm) ~= nil and Player:Buff(LunarEmpowerment) ~= nil },
                [24] = "Emerald Dreamcatcher Opener"
            }
        end
    end
    if self.ChoosenOpener ~= nil then
        OpenerParser(self.ChoosenOpener)
    else
        Bug("Invalid Talents combination, Opener will not be used.")
        OpenerEnded = true
    end
end
function Rotation:Interrupts()
    Player:UseInterrupt(SolarBeam)
end
function Rotation:Defensives()
    Player:UseHealingItem()
    if IsOptionEnabled("树皮术") and Player:HealthPercentage() <= GetOptionValue("树皮术") and Player:CanCast(Barkskin) then
        Player:Cast(Barkskin)
    end
end
function Rotation:OffGCDAbilities()
    if GuardianAffinity:Exists() and IsOptionEnabled("守护亲和") and Player:Buff(BearForm) then
        if IsOptionEnabled("铁鬃") and Player:CanCast(Ironfur) then
            if
            Player:Rage() >= 85 or
            (Player:HealthPercentage() <= GetOptionValue("铁鬃") and Player:Rage() >= 40 and
            not Player:Buff(Ironfur))
            then
                Player:Cast(Ironfur)
                return
            end
        end
        if IsOptionEnabled("狂暴回复") and Player:CanCast(FrenziedRegeneration) and not Player:Buff(FrenziedRegeneration) then
            if Player:HealthPercentage() <= GetOptionValue("狂暴回复") and Player:Rage() >= 10 then
                Player:Cast(FrenziedRegeneration)
                return
            end
        end
    end
    if
    Player:Buff(MoonkinForm) and AstralCommunion:Exists() and CDOptionEnabled("沟通星界") and Player:AstralPower() < 15 and
    (not FuryOfElune:Exists() or FuryOfElune:TimeSinceCast() < 15) and
    Player:CanCast(AstralCommunion)
    then
        Player:Cast(AstralCommunion)
        return
    end
end
function Rotation:AstralDump(Energy, Delay)
    if not Player:Buff(FuryOfElune) then
        if
        Starsurge:Exists() and IsOptionEnabled("星涌术") and Player:Buff(OnethsOverconfidenceStarsurge) and
        Target:CanCast(Starsurge)
        then
            Target:Cast(Starsurge)
            return
        end
        if
        UseAOE() and Starfall:Exists() and IsOptionEnabled("星辰坠落") and
        (AstralPower >= StarfallAstralPower or Player:Buff(OnethsOverconfidenceStarfall)) and
        Target:CanCast(Starfall)
        then
            if Target:CastGroundSpell(Starfall, "星辰坠落", StarfallRadius) then
                return
            end
        end
        if
        Starsurge:Exists() and IsOptionEnabled("星涌术") and AstralPower >= GetOptionValue("星涌术") and
        Target:CanCast(Starsurge)
        then
            Target:Cast(Starsurge)
            return
        end
    end
end
function Rotation:HealCycle(Spell, SpellOption, SpellBuff)
    if Spell:Exists() and IsOptionEnabled(SpellOption) then
        if
        MainTank and MainTank:SpecialHealthPercentage() <= GetOptionValue(SpellOption) and
        (not SpellBuff or MainTank:BuffRemains(SpellBuff) < 3) and
        MainTank:CanCast(Spell)
        then
            self:RemoveForm()
            MainTank:Cast(Spell)
            return
        end
        if
        OffTank and OffTank:SpecialHealthPercentage() <= GetOptionValue(SpellOption) and
        (not SpellBuff or OffTank:BuffRemains(SpellBuff) < 3) and
        OffTank:CanCast(Spell)
        then
            self:RemoveForm()
            OffTank:Cast(Spell)
            return
        end
        if
        Lowest and Lowest:SpecialHealthPercentage() <= GetSecondOptionValue(SpellOption) and
        (not SpellBuff or Lowest:BuffRemains(SpellBuff) < 3) and
        Lowest:CanCast(Spell)
        then
            self:RemoveForm()
            Lowest:Cast(Spell)
            return
        end
        if SpellBuff then
            local ThisUnit
            for i = 1, #HealUnits do
                ThisUnit = HealUnits[i]
                if
                ThisUnit:CanCast(Spell) and ThisUnit:BuffRemains(Spell) < 3 and
                ThisUnit:SpecialHealthPercentage() <= GetSecondOptionValue(SpellOption)
                then
                    self:RemoveForm()
                    ThisUnit:Cast(Spell)
                    return
                end
            end
        end
    end
end
function Rotation:MultiDotsCycles()
    if IsOptionEnabled("多目标 阳炎术") and SunfireUnit and SunfireUnit:CanCast(Sunfire) then
        SunfireUnit:Cast(Sunfire)
        return
    end
    if IsOptionEnabled("多目标 月火术") and MoonfireUnit and MoonfireUnit:CanCast(Moonfire) then
        MoonfireUnit:Cast(Moonfire)
        return
    end
    if IsOptionEnabled("多目标 星辰耀斑") and StellarFlareUnit and StellarFlareUnit:CanCast(StellarFlare) then
        StellarFlareUnit:Cast(StellarFlare)
        return
    end
end
function Rotation:BlessingOfTheAncientsBuff()
    if BlessingOfTheAncients:Exists() and IsOptionEnabled("远古祝福") then
        if GetOptionValue("远古祝福") == "艾露恩的祝福" then
            if not Player:Buff(BlessingOfElune) and Player:CanCast(BlessingOfTheAncients) then
                Player:Cast(BlessingOfTheAncients)
                return
            end
        else
            if not Player:Buff(BlessingOfAnshe) and Player:CanCast(BlessingOfTheAncients) then
                Player:Cast(BlessingOfTheAncients)
                return
            end
        end
    end
end
function Rotation:RemoveForm()
    if Player:Buff(MoonkinForm) then
        RunMacroText("/cancelaura " .. MoonkinForm:Name())
    elseif Player:Buff(CatForm) then
        RunMacroText("/cancelaura " .. CatForm:Name())
    elseif Player:Buff(BearForm) then
        RunMacroText("/cancelaura " .. BearForm:Name())
    end
end
function Rotation:UnitTables()
    Enemies = UseAOE() and Player:EnemiesWithinDistance(40) or {}
    StarfallRadius = 20
    MoonfireUnit = UseAOE() and Unit.DotCycle(Enemies, Moonfire, MoonfireDebuff, 22, "多目标 月火术") or nil
    SunfireUnit = UseAOE() and Unit.DotCycle(Enemies, Sunfire, SunfireDebuff, 18, "多目标 阳炎术") or nil
    StellarFlareUnit = UseAOE() and Unit.DotCycle(Enemies, StellarFlare, StellarFlare, 24, "多目标 星辰耀斑") or nil
    StarfallAstralPower = SoulOfTheForest:Exists() and 40 or 60
    TargetEnemies_20y = UseAOE() and Target:Exists() and Target:EnemiesWithinDistance(StarfallRadius, true) or {}
    if self:UseBetaRotation() then
        StarfallRadius = StellarDrift:Exists() and 19.5 or 15
        TargetEnemies_20y = UseAOE() and Target:Exists() and Target:EnemiesWithinDistance(StarfallRadius, true) or {}
    end
    TargetEnemies_5y = UseAOE() and Target:Exists() and Target:FilterEnemiesByDistance(TargetEnemies_20y, 5, true) or {}
    PlayerEnemies_10y =     UseAOE() and FeralAffinity:Exists() and IsOptionEnabled("野性亲和") and IsOptionEnabled("横扫") and
    Player:EnemiesWithinDistance(10, true) or
    {}
    NumEnemies = #TargetEnemies_5y
    if RestorationAffinity:Exists() and IsOptionEnabled("恢复亲和") then
        HealUnits = Player:HealUnitsAround(100, 40)
        Lowest = Unit.Lowest(HealUnits, MainTank, OffTank)
    else
        HealUnits, Lowest = {}, nil
    end
end
function Rotation:Combat()
    self:BlessingOfTheAncientsBuff()
    GCDMax, AstralPower = Player:GCD(), Player:AstralPower()
    if
    RestorationAffinity:Exists() and Rejuvenation:Exists() and IsOptionEnabled("回春术 自己") and
    Player:HealthPercentage() <= GetOptionValue("回春术 自己") and
    Player:CanCast(Rejuvenation) and
    not Player:Buff(Rejuvenation)
    then
        self:RemoveForm()
        Player:Cast(Rejuvenation)
        return
    end
    if
    HealingTouch:Exists() and IsOptionEnabled("治疗之触 自己") and Player:HealthPercentage() <= GetOptionValue("治疗之触 自己") and
    Player:CanCast(HealingTouch)
    then
        self:RemoveForm()
        Player:Cast(HealingTouch)
        return
    end
    if
    Regrowth:Exists() and Player:Standing() > 1.5 and IsOptionEnabled("愈合 自己") and
    Player:HealthPercentage() <= GetOptionValue("愈合 自己") and
    Player:CanCast(Regrowth)
    then
        if Player:Buff(CatForm) or Player:Buff(BearForm) then
            self:RemoveForm()
        end
        Player:Cast(Regrowth)
        return
    end
    if
    Renewal:Exists() and IsOptionEnabled("新生") and Player:HealthPercentage() <= GetOptionValue("新生") and
    Player:CanCast(Renewal)
    then
        Player:Cast(Renewal)
        return
    end
    MainTank, MainTankTarget, OffTank, OffTankTarget = Unit.GetMainTanks()
    if MainTank and MainTank:Exists() and not MainTank:IsDeadOrGhost() then
        MainTankResDelay = nil
    end
    if OffTank and OffTank:Exists() and not OffTank:IsDeadOrGhost() then
        OffTankResDelay = nil
    end
    if IsOptionEnabled("立即战服坦克") then
        if
        MainTank and MainTank:Exists() and MainTank:IsDeadOrGhost() and MainTank:IsPlayer() and
        MainTank:CanCast(Rebirth)
        then
            if not MainTankResDelay then
                MainTankResDelay = GetTime()
            end
            if GetTime() - MainTankResDelay >= GetOptionValue("立即战服坦克") then
                MainTankResDelay = nil
                MainTank:Cast(Rebirth)
                return
            end
        elseif
        OffTank and OffTank:Exists() and OffTank:IsDeadOrGhost() and OffTank:IsPlayer() and OffTank:CanCast(Rebirth)
        then
            if not OffTankResDelay then
                OffTankResDelay = GetTime()
            end
            if GetTime() - OffTankResDelay >= GetOptionValue("立即战服坦克") then
                OffTankResDelay = nil
                OffTank:Cast(Rebirth)
                return
            end
        end
    end
    if
    Rebirth:Exists() and IsOptionEnabled("复生") and Target:Exists() and Target:IsDeadOrGhost() and
    not Player:IsMoving() and
    Target:IsPlayer() and
    Target:CanCast(Rebirth)
    then
        Target:Cast(Rebirth)
        return
    end
    if RestorationAffinity:Exists() and IsOptionEnabled("恢复亲和") then
        if Swiftmend:Exists() and IsOptionEnabled("迅捷治愈") and not Swiftmend:IsOnCooldown() then
            if
            MainTank and MainTank:SpecialHealthPercentage() <= GetOptionValue("迅捷治愈") and
            (MainTank:Buff(Rejuvenation) or MainTank:Buff(Regrowth)) and
            MainTank:CanCast(Swiftmend)
            then
                self:RemoveForm()
                MainTank:Cast(Swiftmend)
                return
            end
            if
            OffTank and OffTank:SpecialHealthPercentage() <= GetOptionValue("迅捷治愈") and
            (OffTank:Buff(Rejuvenation) or OffTank:Buff(Regrowth)) and
            OffTank:CanCast(Swiftmend)
            then
                self:RemoveForm()
                OffTank:Cast(Swiftmend)
                return
            end
            if
            Lowest and Lowest:SpecialHealthPercentage() <= GetSecondOptionValue("迅捷治愈") and
            (Lowest:Buff(Rejuvenation) or Lowest:Buff(Regrowth)) and
            Lowest:CanCast(Swiftmend)
            then
                self:RemoveForm()
                Lowest:Cast(Swiftmend)
                return
            end
        end
        self:HealCycle(Regrowth, "愈合", Regrowth)
        self:HealCycle(Rejuvenation, "回春术", Rejuvenation)
        self:HealCycle(HealingTouch, "治疗之触", nil)
    end
    if Target:Exists() and Player:CanAttack(Target) then
        if GuardianAffinity:Exists() and IsOptionEnabled("守护亲和") then
            if not Player:Buff(BearForm) and Player:CanCast(BearForm) then
                Player:Cast(BearForm)
                return
            end
            if Player:IsWithinCastRange(Target, Mangle) then
                if not Target:Debuff(ThrashDebuff) and Player:CanCast(Thrash) then
                    Player:Cast(Thrash)
                    return
                end
                if Target:CanCast(Mangle) then
                    Target:Cast(Mangle)
                    return
                end
                if Player:CanCast(Thrash) then
                    Player:Cast(Thrash)
                    return
                end
            end
            if Moonfire:Exists() then
                if Target:DebuffRemains(MoonfireDebuff) < 6 and Target:CanCast(Moonfire) then
                    Target:Cast(Moonfire)
                    return
                end
                if IsOptionEnabled("多目标 月火术") and MoonfireUnit and MoonfireUnit:CanCast(Moonfire) then
                    MoonfireUnit:Cast(Moonfire)
                    return
                end
            end
            return
        end
        if FeralAffinity:Exists() and IsOptionEnabled("野性亲和") then
            if not Player:Buff(CatForm) and Player:CanCast(CatForm) then
                Player:Cast(CatForm)
                return
            end
            if Rip:Exists() and IsOptionEnabled("割裂") and Player:ComboPoints() >= 5 and Target:DebuffRemains(Rip) < 6 then
                Target:Cast(Rip)
                return
            end
            if
            FerociousBite:Exists() and
            (Player:ComboPoints() >= 5 or (Player:ComboPoints() >= 2 and Target:TimeToDie() < 5))
            then
                Target:Cast(FerociousBite)
                return
            end
            if IsOptionEnabled("横扫") and #PlayerEnemies_10y >= GetOptionValue("横扫") then
                if Player:CanCast(Swipe) then
                    Player:Cast(Swipe)
                    return
                end
            else
                if Target:CanCast(Shred) then
                    Target:Cast(Shred)
                    return
                end
            end
            return
        end
        if
        MoonkinForm:Exists() and IsOptionEnabled("枭兽形态") and not Player:Buff(MoonkinForm) and
        Player:CanCast(MoonkinForm) and
        (not Player:Buff(CatForm) or Player:Buff(DisplacerBeast)) and
        not Player:Buff(BearForm) and
        not Player:Buff(TravelForm)
        then
            Player:Cast(MoonkinForm)
            return
        end
        if not Player:Buff(MoonkinForm) then
            return
        end
        if Player:IsWithinCastRange(Target, SolarWrath) then
            Player:UsePotions("智力药水")
            Player:UseTrinkets()
            if CDOptionEnabled("进攻性种族技能") then
                if Berserking:Exists() and Player:CanCast(Berserking) then
                    Player:Cast(Berserking)
                end
            end
            if ForceOfNature:Exists() and CDOptionEnabled("自然之力") and Target:CanCast(ForceOfNature) then
                Target:Cast(ForceOfNature)
                return
            end
        end
        EmeraldDreamcatcherEquipped = EmeraldDreamcatcher:IsEquipped(1)
        WarriorOfEluneEnabled = CDOptionEnabled("艾露恩的战士")
        IncarnationEnabled = CDOptionEnabled("化身")
        CelestialAlignmentEnabled = CDOptionEnabled("超凡之盟")
        FuryOfEluneEnabled = CDOptionEnabled("艾露恩之怒")
        if WarriorOfElune:Exists() and WarriorOfEluneEnabled and Player:CanCast(WarriorOfElune) then
            Player:Cast(WarriorOfElune)
            return
        end
        if FuryOfElune:Exists() and FuryOfElune:Cooldown() < Target:TimeToDie() then
            if
            Incarnation:Exists() and IncarnationEnabled and AstralPower >= 95 and FuryOfElune:Cooldown() < GCDMax and
            Player:CanCast(Incarnation)
            then
                Player:Cast(Incarnation)
                return
            end
            if AstralPower >= 95 and FuryOfEluneEnabled and Target:CanCast(FuryOfElune) then
                Target:Cast(FuryOfElune)
                return
            end
            if NewMoon:Exists() and NewMoon:Icon() == NewMoonIcon and Target:CanCast(NewMoon) then
                if
                ((NewMoon:Charges() == 2 and NewMoon:Recharge() < 5) or NewMoon:Charges() == 3) and
                (Player:Buff(FuryOfElune) or (FuryOfElune:Cooldown() > GCDMax * 3 and AstralPower <= 90))
                then
                    Bug("New Moon")
                    Target:Cast(NewMoon)
                    return
                end
            end
            if NewMoon:Exists() and NewMoon:Icon() == HalfMoonIcon and Target:CanCast(NewMoon) then
                if
                ((NewMoon:Charges() == 2 and NewMoon:Recharge() < 5) or NewMoon:Charges() == 3) and
                (Player:Buff(FuryOfElune) or (FuryOfElune:Cooldown() > GCDMax * 3 and AstralPower <= 80))
                then
                    Bug("Half Moon")
                    Target:Cast(NewMoon)
                    return
                end
            end
            if NewMoon:Exists() and NewMoon:Icon() == FullMoonIcon and Target:CanCast(NewMoon) then
                if
                ((NewMoon:Charges() == 2 and NewMoon:Recharge() < 5) or NewMoon:Charges() == 3) and
                (Player:Buff(FuryOfElune) or (FuryOfElune:Cooldown() > GCDMax * 3 and AstralPower <= 60))
                then
                    Bug("满月")
                    Target:Cast(NewMoon)
                    return
                end
            end
            if
            AstralCommunion:Exists() and CDOptionEnabled("沟通星界") and Player:Buff(FuryOfElune) and AstralPower <= 25 and
            Player:CanCast(AstralCommunion)
            then
                Player:Cast(AstralCommunion)
                return
            end
            if
            LunarStrike:Exists() and Player:Buff(WarriorOfElune) and
            (AstralPower <= 90 or (AstralPower <= 85 and Player:Buff(Incarnation))) and
            Target:CanCast(LunarStrike)
            then
                Target:Cast(LunarStrike)
                return
            end
            if NewMoon:Exists() and NewMoon:Icon() == NewMoonIcon and Target:CanCast(NewMoon) then
                if AstralPower <= 90 and Player:Buff(FuryOfElune) then
                    Bug("New Moon")
                    Target:Cast(NewMoon)
                    return
                end
            end
            if NewMoon:Exists() and NewMoon:Icon() == HalfMoonIcon and Target:CanCast(NewMoon) then
                if AstralPower <= 80 and Player:Buff(FuryOfElune) and AstralPower > NewMoon:CastTime() * 12 then
                    Bug("Half Moon")
                    Target:Cast(NewMoon)
                    return
                end
            end
            if NewMoon:Exists() and NewMoon:Icon() == FullMoonIcon and Target:CanCast(NewMoon) then
                if AstralPower <= 60 and Player:Buff(FuryOfElune) and AstralPower > NewMoon:CastTime() * 12 then
                    Bug("满月")
                    Target:Cast(NewMoon)
                    return
                end
            end
            if
            Moonfire:Exists() and not Player:Buff(FuryOfElune) and Target:DebuffRemains(MoonfireDebuff) <= 6.6 and
            Target:CanCast(Moonfire)
            then
                Target:Cast(Moonfire)
                return
            end
            if
            Sunfire:Exists() and not Player:Buff(FuryOfElune) and Target:DebuffRemains(SunfireDebuff) <= 5.4 and
            Target:CanCast(Sunfire)
            then
                Target:Cast(Sunfire)
                return
            end
            if StellarFlare:Exists() and Target:DebuffRemains(StellarFlare) <= 7.2 and Target:CanCast(StellarFlare) then
                Target:Cast(StellarFlare)
                return
            end
            if
            not Player:Buff(FuryOfElune) and (NumEnemies <= 2 and FuryOfElune:Cooldown() > 7) or
            ((NumEnemies >= 2 and StellarFlare:Exists() or NumEnemies >= 3) and FuryOfElune:Cooldown() > 10)
            then
                self:AstralDump()
            end
            if
            not Player:Buff(FuryOfElune) and
            ((AstralPower >= 92 and FuryOfElune:Cooldown() > GCDMax * 3) or
            (WarriorOfElune:Cooldown() <= 5 and FuryOfElune:Cooldown() >= 35 and
            Player:BuffCount(LunarEmpowerment) < 2))
            then
                self:AstralDump()
            end
            if SolarWrath:Exists() and NumEnemies < 3 and Player:Buff(SolarEmpowerment) and Target:CanCast(SolarWrath) then
                Target:Cast(SolarWrath)
                return
            end
            if
            LunarStrike:Exists() and
            (Player:BuffCount(LunarEmpowerment) >= 3 or
            (Player:BuffRemains(LunarEmpowerment) < 5 and Player:Buff(LunarEmpowerment))) and
            Target:CanCast(LunarStrike)
            then
                Target:Cast(LunarStrike)
                return
            end
            self:MultiDotsCycles()
            if LunarStrike:Exists() and NumEnemies >= 3 and Target:CanCast(LunarStrike) then
                Target:Cast(LunarStrike)
                return
            end
            if SolarWrath:Exists() and NumEnemies < 3 and Target:CanCast(SolarWrath) then
                Target:Cast(SolarWrath)
                return
            end
        end
        if IsOptionEnabled("翡翠捕梦者") and EmeraldDreamcatcherEquipped and #TargetEnemies_20y <= GetOptionValue("翡翠捕梦者") then
            EmeraldDreamcatcherRemains = Player:BuffRemains(EmeraldDreamcatcherBuff) - GetSecondOptionValue("翡翠捕梦者")
            if
            AstralCommunion:Exists() and CDOptionEnabled("沟通星界") and Player:Buff(EmeraldDreamcatcherBuff) and
            Player:AstralPowerDeficit() >= 75 and
            Player:CanCast(AstralCommunion)
            then
                Player:Cast(AstralCommunion)
                return
            end
            if
            Incarnation:Exists() and IncarnationEnabled and AstralPower >= 85 and
            not Player:Buff(EmeraldDreamcatcherBuff) and
            Player:CanCast(Incarnation)
            then
                Player:Cast(Incarnation)
                return
            end
            if
            CelestialAlignment:Exists() and CelestialAlignmentEnabled and not Incarnation:Exists() and
            AstralPower >= 85 and
            not Player:Buff(EmeraldDreamcatcherBuff) and
            Player:CanCast(CelestialAlignment)
            then
                Player:Cast(CelestialAlignment)
                return
            end
            if
            Starsurge:Exists() and IsOptionEnabled("星涌术") and
            ((Player:Buff(CelestialAlignment) and Player:BuffRemains(CelestialAlignment) < 10) or
            (Player:Buff(Incarnation) and Player:BuffRemains(Incarnation) < 3 * GCDMax and AstralPower > 78) or
            (Player:Buff(CelestialAlignment) and Player:BuffRemains(CelestialAlignment) < 2 * GCDMax and
            AstralPower > 52) or
            (Player:Buff(Incarnation) and Player:BuffRemains(Incarnation) < GCDMax and AstralPower > 26)) and
            Target:CanCast(Starsurge)
            then
                Target:Cast(Starsurge)
                return
            end
            if
            StellarFlare:Exists() and Target:DebuffRemains(StellarFlare) < 7.2 and AstralPower >= 15 and
            Target:CanCast(StellarFlare)
            then
                Target:Cast(StellarFlare)
                return
            end
            if
            Moonfire:Exists() and
            ((NaturesBalance:Exists() and Target:DebuffRemains(MoonfireDebuff) < 3) or
            (Target:DebuffRemains(MoonfireDebuff) < 6.6 and not NaturesBalance:Exists())) and
            (EmeraldDreamcatcherRemains > GCDMax or not Player:Buff(EmeraldDreamcatcherBuff)) and
            Target:CanCast(Moonfire)
            then
                Target:Cast(Moonfire)
                return
            end
            if
            Sunfire:Exists() and
            ((NaturesBalance:Exists() and Target:DebuffRemains(SunfireDebuff) < 3) or
            (Target:DebuffRemains(SunfireDebuff) < 5.4 and not NaturesBalance:Exists())) and
            (EmeraldDreamcatcherRemains > GCDMax or not Player:Buff(EmeraldDreamcatcherBuff)) and
            Target:CanCast(Sunfire)
            then
                Target:Cast(Sunfire)
                return
            end
            if
            Starfall:Exists() and IsOptionEnabled("星辰坠落 欧奈斯的直觉") and Player:Buff(OnethsOverconfidenceStarfall) and
            EmeraldDreamcatcherRemains > GCDMax and
            Player:BuffRemains(StarfallBuff) < 2 and
            Target:CanCast(Starfall)
            then
                if Target:CastGround(Starfall, 1, 20, 40, false) then
                    return
                end
            end
            if NewMoon:Exists() and NewMoon:Icon() == HalfMoonIcon and Target:CanCast(NewMoon) then
                if AstralPower <= 80 and EmeraldDreamcatcherRemains > NewMoon:CastTime() and AstralPower >= 6 then
                    Target:Cast(NewMoon)
                    return
                end
            end
            if NewMoon:Exists() and NewMoon:Icon() == FullMoonIcon and Target:CanCast(NewMoon) then
                if AstralPower <= 60 and EmeraldDreamcatcherRemains > NewMoon:CastTime() then
                    Target:Cast(NewMoon)
                    return
                end
            end
            if
            SolarWrath:Exists() and Player:BuffCount(SolarEmpowerment) > 1 and
            EmeraldDreamcatcherRemains > 2 * SolarWrath:CastTime() and
            AstralPower >= 6 and
            (Target:DebuffRemains(MoonfireDebuff) > 5 or
            (Target:DebuffRemains(SunfireDebuff) < 5.4 and Target:DebuffRemains(MoonfireDebuff) > 6.6)) and
            (not (Player:Buff(CelestialAlignment) or Player:Buff(Incarnation)) and AstralPower <= 90 or
            (Player:Buff(CelestialAlignment) or Player:Buff(Incarnation)) and AstralPower <= 85) and
            Target:CanCast(SolarWrath)
            then
                Target:Cast(SolarWrath)
                return
            end
            if
            LunarStrike:Exists() and Player:Buff(LunarEmpowerment) and
            EmeraldDreamcatcherRemains > LunarStrike:CastTime() and
            AstralPower >= 11 and
            (not (Player:Buff(CelestialAlignment) or Player:Buff(Incarnation)) and AstralPower <= 85 or
            (Player:Buff(CelestialAlignment) or Player:Buff(Incarnation)) and AstralPower <= 77.5) and
            Target:CanCast(LunarStrike)
            then
                Bug(
                "EC: Lunar Strike Cast Time vs. ED Buff: " ..
                LunarStrike:CastTime() .. " < " .. EmeraldDreamcatcherRemains
                )
                Target:Cast(LunarStrike)
                return
            end
            if
            SolarWrath:Exists() and Player:Buff(SolarEmpowerment) and
            EmeraldDreamcatcherRemains > SolarWrath:CastTime() and
            AstralPower >= 16 and
            (not (Player:Buff(CelestialAlignment) or Player:Buff(Incarnation)) and AstralPower <= 90 or
            (Player:Buff(CelestialAlignment) or Player:Buff(Incarnation)) and AstralPower <= 85) and
            Target:CanCast(SolarWrath)
            then
                Target:Cast(SolarWrath)
                return
            end
            if
            Starsurge:Exists() and IsOptionEnabled("星涌术") and
            ((Player:Buff(EmeraldDreamcatcherBuff) and EmeraldDreamcatcherRemains < GCDMax) or AstralPower > 90 or
            ((Player:Buff(CelestialAlignment) or Player:Buff(Incarnation)) and AstralPower >= 85) or
            (Player:Buff(EmeraldDreamcatcherBuff) and AstralPower >= 77.5 and
            (Player:Buff(CelestialAlignment) or Player:Buff(Incarnation)))) and
            Target:CanCast(Starsurge)
            then
                Target:Cast(Starsurge)
                return
            end
            if
            Starfall:Exists() and IsOptionEnabled("星辰坠落 欧奈斯的直觉") and Player:Buff(OnethsOverconfidenceStarfall) and
            Player:BuffRemains(StarfallBuff) < 2 and
            Target:CanCast(Starfall)
            then
                if Target:CastGround(Starfall, 1, 20, 40, false) then
                    return
                end
            end
            if NewMoon:Exists() and NewMoon:Icon() == NewMoonIcon and Target:CanCast(NewMoon) then
                if AstralPower <= 90 then
                    Target:Cast(NewMoon)
                    return
                end
            end
            if NewMoon:Exists() and NewMoon:Icon() == HalfMoonIcon and Target:CanCast(NewMoon) then
                if AstralPower <= 80 then
                    Target:Cast(NewMoon)
                    return
                end
            end
            if NewMoon:Exists() and NewMoon:Icon() == FullMoonIcon and Target:CanCast(NewMoon) then
                if
                AstralPower <= 60 and
                ((CelestialAlignment:Exists() and CelestialAlignmentEnabled and not Incarnation:Exists() and
                ((CelestialAlignment:Cooldown() > 65 and NewMoon:Charges() > 0) or
                (CelestialAlignment:Cooldown() > 50 and NewMoon:Charges() > 1) or
                (CelestialAlignment:Cooldown() > 25 and NewMoon:Charges() > 2))) or
                (Incarnation:Exists() and IncarnationEnabled and
                (Incarnation:Cooldown() > 65 and NewMoon:Charges() > 0) or
                (Incarnation:Cooldown() > 50 and NewMoon:Charges() > 1) or
                (Incarnation:Cooldown() > 25 and NewMoon:Charges() > 2)) or
                (CelestialAlignment:Exists() and not Incarnation:Exists() and not CelestialAlignmentEnabled) or
                (Incarnation:Exists() and not IncarnationEnabled))
                then
                    Target:Cast(NewMoon)
                    return
                end
            end
            self:MultiDotsCycles()
            if SolarWrath:Exists() and Player:Buff(SolarEmpowerment) and Target:CanCast(SolarWrath) then
                Target:Cast(SolarWrath)
                return
            end
            if LunarStrike:Exists() and Player:Buff(LunarEmpowerment) and Target:CanCast(LunarStrike) then
                Target:Cast(LunarStrike)
                return
            end
            if SolarWrath:Exists() and Target:CanCast(SolarWrath) then
                Target:Cast(SolarWrath)
                return
            end
            return
        end
        if
        Starsurge:Exists() and IsOptionEnabled("星涌术") and IsOptionEnabled("高优先级 星辰坠落") and
        Player:Buff(OnethsOverconfidenceStarsurge) and
        not Player:Buff(FuryOfElune) and
        Target:CanCast(Starsurge)
        then
            Bug("Starsurge Onet's Overconfidence High Prio")
            Target:Cast(Starsurge)
            return
        end
        if
        UseAOE() and Starfall:Exists() and IsOptionEnabled("高优先级 星辰坠落") and
        (AstralPower >= StarfallAstralPower or Player:Buff(OnethsOverconfidenceStarfall)) and
        not Player:Buff(FuryOfElune) and
        Target:CanCast(Starfall)
        then
            if Target:CastGroundSpell(Starfall, "高优先级 星辰坠落", 20) then
                Bug("高优先级 星辰坠落")
                return
            end
        end
        if NewMoon:Exists() and NewMoon:Icon() == NewMoonIcon and Target:CanCast(NewMoon) then
            if ((NewMoon:Charges() == 2 and NewMoon:Recharge() < 5) or NewMoon:Charges() == 3) then
                Bug("New Moon")
                Target:Cast(NewMoon)
                return
            end
        end
        if NewMoon:Exists() and NewMoon:Icon() == HalfMoonIcon and Target:CanCast(NewMoon) then
            if
            ((NewMoon:Charges() == 2 and NewMoon:Recharge() < 5) or NewMoon:Charges() == 3) or
            (Target:TimeToDie() < 15 and NewMoon:Charges() == 2)
            then
                Bug("Half Moon")
                Target:Cast(NewMoon)
                return
            end
        end
        if NewMoon:Exists() and NewMoon:Icon() == FullMoonIcon and Target:CanCast(NewMoon) then
            if
            ((NewMoon:Charges() == 2 and NewMoon:Recharge() < 5) or NewMoon:Charges() == 3) or
            Target:TimeToDie() < 15
            then
                Bug("满月")
                Target:Cast(NewMoon)
                return
            end
        end
        if StellarFlare:Exists() and Target:DebuffRemains(StellarFlare) <= 7.2 and Target:CanCast(StellarFlare) then
            Target:Cast(StellarFlare)
            return
        end
        if
        Moonfire:Exists() and
        ((NaturesBalance:Exists() and Target:DebuffRemains(MoonfireDebuff) < 3) or
        (Target:DebuffRemains(MoonfireDebuff) < 6.6 and not NaturesBalance:Exists())) and
        Target:CanCast(Moonfire)
        then
            Target:Cast(Moonfire)
            return
        end
        if
        Sunfire:Exists() and
        ((NaturesBalance:Exists() and Target:DebuffRemains(SunfireDebuff) < 3) or
        (Target:DebuffRemains(SunfireDebuff) < 6.5 and not NaturesBalance:Exists())) and
        Target:CanCast(Sunfire)
        then
            Target:Cast(Sunfire)
            return
        end
        if
        AstralCommunion:Exists() and CDOptionEnabled("沟通星界") and Player:AstralPowerDeficit() >= 75 and
        Player:CanCast(AstralCommunion)
        then
            Player:Cast(AstralCommunion)
            return
        end
        if Incarnation:Exists() and IncarnationEnabled and AstralPower >= 40 and Player:CanCast(Incarnation) then
            Player:Cast(Incarnation)
            return
        end
        if
        CelestialAlignment:Exists() and CelestialAlignmentEnabled and not Incarnation:Exists() and AstralPower >= 40 and
        Player:CanCast(CelestialAlignment)
        then
            Player:Cast(CelestialAlignment)
            return
        end
        if
        Starfall:Exists() and IsOptionEnabled("星辰坠落 欧奈斯的直觉") and Player:Buff(OnethsOverconfidenceStarfall) and
        Target:CanCast(Starfall)
        then
            if Target:CastGround(Starfall, 1, 20, 40, false) then
                return
            end
        end
        if
        SolarWrath:Exists() and NumEnemies < 3 and Player:BuffCount(SolarEmpowerment) == 3 and
        Target:CanCast(SolarWrath)
        then
            Target:Cast(SolarWrath)
            return
        end
        if LunarStrike:Exists() and Player:BuffCount(LunarEmpowerment) == 3 and Target:CanCast(LunarStrike) then
            Target:Cast(LunarStrike)
            return
        end
        if Player:Buff(CelestialAlignment) or Player:Buff(Incarnation) then
            self:AstralDump()
            if LunarStrike:Exists() and Player:Buff(WarriorOfElune) and Target:CanCast(LunarStrike) then
                Target:Cast(LunarStrike)
                return
            end
            if SolarWrath:Exists() and NumEnemies < 3 and Player:Buff(SolarEmpowerment) and Target:CanCast(SolarWrath) then
                Target:Cast(SolarWrath)
                return
            end
            if LunarStrike:Exists() and Player:Buff(LunarEmpowerment) and Target:CanCast(LunarStrike) then
                Target:Cast(LunarStrike)
                return
            end
            if
            SolarWrath:Exists() and NumEnemies < 3 and NaturesBalance:Exists() and
            Target:DebuffRemains(SunfireDebuff) < 5 and
            SolarWrath:CastTime() < Target:DebuffRemains(SunfireDebuff) and
            Target:CanCast(SolarWrath)
            then
                Target:Cast(SolarWrath)
                return
            end
            if
            LunarStrike:Exists() and NaturesBalance:Exists() and Target:DebuffRemains(MoonfireDebuff) < 5 and
            LunarStrike:CastTime() < Target:DebuffRemains(MoonfireDebuff) and
            Target:CanCast(LunarStrike)
            then
                Target:Cast(LunarStrike)
                return
            end
            self:MultiDotsCycles()
            if LunarStrike:Exists() and NumEnemies >= 3 and Target:CanCast(LunarStrike) then
                Target:Cast(LunarStrike)
                return
            end
            if SolarWrath:Exists() and NumEnemies < 3 and Target:CanCast(SolarWrath) then
                Target:Cast(SolarWrath)
                return
            end
        end
        if NewMoon:Exists() and NewMoon:Icon() == NewMoonIcon and Target:CanCast(NewMoon) then
            if AstralPower <= 90 then
                Bug("New Moon")
                Target:Cast(NewMoon)
                return
            end
        end
        if NewMoon:Exists() and NewMoon:Icon() == HalfMoonIcon and Target:CanCast(NewMoon) then
            if AstralPower <= 80 then
                Bug("Half Moon")
                Target:Cast(NewMoon)
                return
            end
        end
        if NewMoon:Exists() and NewMoon:Icon() == FullMoonIcon and Target:CanCast(NewMoon) then
            if AstralPower <= 60 then
                Bug("满月")
                Target:Cast(NewMoon)
                return
            end
        end
        self:AstralDump()
        if LunarStrike:Exists() and Player:Buff(WarriorOfElune) and Target:CanCast(LunarStrike) then
            Target:Cast(LunarStrike)
            return
        end
        if SolarWrath:Exists() and NumEnemies < 3 and Player:Buff(SolarEmpowerment) and Target:CanCast(SolarWrath) then
            Target:Cast(SolarWrath)
            return
        end
        if LunarStrike:Exists() and Player:Buff(LunarEmpowerment) and Target:CanCast(LunarStrike) then
            Target:Cast(LunarStrike)
            return
        end
        if
        SolarWrath:Exists() and NumEnemies < 3 and NaturesBalance:Exists() and
        Target:DebuffRemains(SunfireDebuff) < 5 and
        SolarWrath:CastTime() < Target:DebuffRemains(SunfireDebuff) and
        Target:CanCast(SolarWrath)
        then
            Target:Cast(SolarWrath)
            return
        end
        if
        LunarStrike:Exists() and NaturesBalance:Exists() and Target:DebuffRemains(MoonfireDebuff) < 5 and
        LunarStrike:CastTime() < Target:DebuffRemains(MoonfireDebuff) and
        Target:CanCast(LunarStrike)
        then
            Target:Cast(LunarStrike)
            return
        end
        self:MultiDotsCycles()
        if LunarStrike:Exists() and (NumEnemies >= 3 or Player:Buff(OwlkinFrenzy)) and Target:CanCast(LunarStrike) then
            Target:Cast(LunarStrike)
            return
        end
        if SolarWrath:Exists() and NumEnemies < 3 and Target:CanCast(SolarWrath) then
            Target:Cast(SolarWrath)
            return
        end
        if IsOptionEnabled("移动时填充技能") and Player:Moving() >= GetOptionValue("移动时填充技能") then
            if LunarStrikeInstant:Exists() and Player:Buff(OwlkinFrenzy) and Target:CanCast(LunarStrikeInstant) then
                Target:Cast(LunarStrikeInstant)
                return
            end
            if GetSecondOptionValue("移动时填充技能") == "阳炎术" then
                if Sunfire:Exists() and Target:CanCast(Sunfire) then
                    Target:Cast(Sunfire)
                    return
                end
            else
                if Moonfire:Exists() and Target:CanCast(Moonfire) then
                    Target:Cast(Moonfire)
                    return
                end
            end
        end
    end
end
function Rotation:CombatBeta()
    self:BlessingOfTheAncientsBuff()
    GCDMax, AstralPower, AstralPowerDeficit = Player:GCD(), Player:AstralPower(), Player:AstralPowerDeficit()
    if
    RestorationAffinity:Exists() and Rejuvenation:Exists() and IsOptionEnabled("回春术 自己") and
    Player:HealthPercentage() <= GetOptionValue("回春术 自己") and
    Player:CanCast(Rejuvenation) and
    not Player:Buff(Rejuvenation)
    then
        self:RemoveForm()
        Player:Cast(Rejuvenation)
        return
    end
    if
    HealingTouch:Exists() and IsOptionEnabled("治疗之触 自己") and Player:HealthPercentage() <= GetOptionValue("治疗之触 自己") and
    Player:CanCast(HealingTouch)
    then
        self:RemoveForm()
        Player:Cast(HealingTouch)
        return
    end
    if
    Regrowth:Exists() and Player:Standing() > 1.5 and IsOptionEnabled("愈合 自己") and
    Player:HealthPercentage() <= GetOptionValue("愈合 自己") and
    Player:CanCast(Regrowth)
    then
        if Player:Buff(CatForm) or Player:Buff(BearForm) then
            self:RemoveForm()
        end
        Player:Cast(Regrowth)
        return
    end
    if
    Renewal:Exists() and IsOptionEnabled("新生") and Player:HealthPercentage() <= GetOptionValue("新生") and
    Player:CanCast(Renewal)
    then
        Player:Cast(Renewal)
        return
    end
    MainTank, MainTankTarget, OffTank, OffTankTarget = Unit.GetMainTanks()
    if MainTank and MainTank:Exists() and not MainTank:IsDeadOrGhost() then
        MainTankResDelay = nil
    end
    if OffTank and OffTank:Exists() and not OffTank:IsDeadOrGhost() then
        OffTankResDelay = nil
    end
    if IsOptionEnabled("立即战服坦克") then
        if
        MainTank and MainTank:Exists() and MainTank:IsDeadOrGhost() and MainTank:IsPlayer() and
        MainTank:CanCast(Rebirth)
        then
            if not MainTankResDelay then
                MainTankResDelay = GetTime()
            end
            if GetTime() - MainTankResDelay >= GetOptionValue("立即战服坦克") then
                MainTankResDelay = nil
                MainTank:Cast(Rebirth)
                return
            end
        elseif
        OffTank and OffTank:Exists() and OffTank:IsDeadOrGhost() and OffTank:IsPlayer() and OffTank:CanCast(Rebirth)
        then
            if not OffTankResDelay then
                OffTankResDelay = GetTime()
            end
            if GetTime() - OffTankResDelay >= GetOptionValue("立即战服坦克") then
                OffTankResDelay = nil
                OffTank:Cast(Rebirth)
                return
            end
        end
    end
    if
    Rebirth:Exists() and IsOptionEnabled("复生") and Target:Exists() and Target:IsDeadOrGhost() and
    not Player:IsMoving() and
    Target:IsPlayer() and
    Target:CanCast(Rebirth)
    then
        Target:Cast(Rebirth)
        return
    end
    if RestorationAffinity:Exists() and IsOptionEnabled("恢复亲和") then
        if Swiftmend:Exists() and IsOptionEnabled("迅捷治愈") and not Swiftmend:IsOnCooldown() then
            if
            MainTank and MainTank:SpecialHealthPercentage() <= GetOptionValue("迅捷治愈") and
            (MainTank:Buff(Rejuvenation) or MainTank:Buff(Regrowth)) and
            MainTank:CanCast(Swiftmend)
            then
                self:RemoveForm()
                MainTank:Cast(Swiftmend)
                return
            end
            if
            OffTank and OffTank:SpecialHealthPercentage() <= GetOptionValue("迅捷治愈") and
            (OffTank:Buff(Rejuvenation) or OffTank:Buff(Regrowth)) and
            OffTank:CanCast(Swiftmend)
            then
                self:RemoveForm()
                OffTank:Cast(Swiftmend)
                return
            end
            if
            Lowest and Lowest:SpecialHealthPercentage() <= GetSecondOptionValue("迅捷治愈") and
            (Lowest:Buff(Rejuvenation) or Lowest:Buff(Regrowth)) and
            Lowest:CanCast(Swiftmend)
            then
                self:RemoveForm()
                Lowest:Cast(Swiftmend)
                return
            end
        end
        self:HealCycle(Regrowth, "愈合", Regrowth)
        self:HealCycle(Rejuvenation, "回春术", Rejuvenation)
        self:HealCycle(HealingTouch, "治疗之触", nil)
    end
    if Target:Exists() and Player:CanAttack(Target) then
        if GuardianAffinity:Exists() and IsOptionEnabled("守护亲和") then
            if not Player:Buff(BearForm) and Player:CanCast(BearForm) then
                Player:Cast(BearForm)
                return
            end
            if Player:IsWithinCastRange(Target, Mangle) then
                if not Target:Debuff(ThrashDebuff) and Player:CanCast(Thrash) then
                    Player:Cast(Thrash)
                    return
                end
                if Target:CanCast(Mangle) then
                    Target:Cast(Mangle)
                    return
                end
                if Player:CanCast(Thrash) then
                    Player:Cast(Thrash)
                    return
                end
            end
            if Moonfire:Exists() then
                if Target:DebuffRemains(MoonfireDebuff) < 6 and Target:CanCast(Moonfire) then
                    Target:Cast(Moonfire)
                    return
                end
                if IsOptionEnabled("多目标 月火术") and MoonfireUnit and MoonfireUnit:CanCast(Moonfire) then
                    MoonfireUnit:Cast(Moonfire)
                    return
                end
            end
            return
        end
        if FeralAffinity:Exists() and IsOptionEnabled("野性亲和") then
            if not Player:Buff(CatForm) and Player:CanCast(CatForm) then
                Player:Cast(CatForm)
                return
            end
            if Rip:Exists() and IsOptionEnabled("割裂") and Player:ComboPoints() >= 5 and Target:DebuffRemains(Rip) < 6 then
                Target:Cast(Rip)
                return
            end
            if
            FerociousBite:Exists() and
            (Player:ComboPoints() >= 5 or (Player:ComboPoints() >= 2 and Target:TimeToDie() < 5))
            then
                Target:Cast(FerociousBite)
                return
            end
            if IsOptionEnabled("横扫") and #PlayerEnemies_10y >= GetOptionValue("横扫") then
                if Player:CanCast(Swipe) then
                    Player:Cast(Swipe)
                    return
                end
            else
                if Target:CanCast(Shred) then
                    Target:Cast(Shred)
                    return
                end
            end
            return
        end
        if
        MoonkinForm:Exists() and IsOptionEnabled("枭兽形态") and not Player:Buff(MoonkinForm) and
        Player:CanCast(MoonkinForm) and
        (not Player:Buff(CatForm) or Player:Buff(DisplacerBeast)) and
        not Player:Buff(BearForm) and
        not Player:Buff(TravelForm)
        then
            Player:Cast(MoonkinForm)
            return
        end
        if not Player:Buff(MoonkinForm) then
            return
        end
        if Player:IsWithinCastRange(Target, SolarWrath) then
            Player:UsePotions("智力药水")
            Player:UseTrinkets()
            if CDOptionEnabled("进攻性种族技能") then
                if Berserking:Exists() and Player:CanCast(Berserking) then
                    Player:Cast(Berserking)
                end
            end
            if ForceOfNature:Exists() and CDOptionEnabled("自然之力") and Target:CanCast(ForceOfNature) then
                Target:Cast(ForceOfNature)
                return
            end
        end
        EmeraldDreamcatcherEquipped = EmeraldDreamcatcher:IsEquipped(1)
        WarriorOfEluneEnabled = CDOptionEnabled("艾露恩的战士")
        IncarnationEnabled = CDOptionEnabled("化身")
        CelestialAlignmentEnabled = CDOptionEnabled("超凡之盟")
        FuryOfEluneEnabled = CDOptionEnabled("艾露恩之怒")
        if FuryOfElune:Exists() and FuryOfElune:Cooldown() < Target:TimeToDie() then
            if
            Incarnation:Exists() and IncarnationEnabled and AstralPower >= 95 and FuryOfElune:Cooldown() < GCDMax and
            Player:CanCast(Incarnation)
            then
                Player:Cast(Incarnation)
                return
            end
            if AstralPower >= 95 and FuryOfEluneEnabled and Target:CanCast(FuryOfElune) then
                Target:Cast(FuryOfElune)
                return
            end
            if NewMoon:Exists() and NewMoon:Icon() == NewMoonIcon and Target:CanCast(NewMoon) then
                if
                ((NewMoon:Charges() == 2 and NewMoon:Recharge() < 5) or NewMoon:Charges() == 3) and
                (Player:Buff(FuryOfElune) or (FuryOfElune:Cooldown() > GCDMax * 3 and AstralPower <= 90))
                then
                    Bug("New Moon")
                    Target:Cast(NewMoon)
                    return
                end
            end
            if NewMoon:Exists() and NewMoon:Icon() == HalfMoonIcon and Target:CanCast(NewMoon) then
                if
                ((NewMoon:Charges() == 2 and NewMoon:Recharge() < 5) or NewMoon:Charges() == 3) and
                (Player:Buff(FuryOfElune) or (FuryOfElune:Cooldown() > GCDMax * 3 and AstralPower <= 80))
                then
                    Bug("Half Moon")
                    Target:Cast(NewMoon)
                    return
                end
            end
            if NewMoon:Exists() and NewMoon:Icon() == FullMoonIcon and Target:CanCast(NewMoon) then
                if
                ((NewMoon:Charges() == 2 and NewMoon:Recharge() < 5) or NewMoon:Charges() == 3) and
                (Player:Buff(FuryOfElune) or (FuryOfElune:Cooldown() > GCDMax * 3 and AstralPower <= 60))
                then
                    Bug("满月")
                    Target:Cast(NewMoon)
                    return
                end
            end
            if
            AstralCommunion:Exists() and CDOptionEnabled("沟通星界") and Player:Buff(FuryOfElune) and AstralPower <= 25 and
            Player:CanCast(AstralCommunion)
            then
                Player:Cast(AstralCommunion)
                return
            end
            if
            WarriorOfElune:Exists() and WarriorOfEluneEnabled and
            (Player:Buff(FuryOfElune) or (FuryOfElune:Cooldown() >= 35 and Player:Buff(LunarEmpowerment))) and
            Player:CanCast(WarriorOfElune)
            then
                Player:Cast(WarriorOfElune)
                return
            end
            if
            LunarStrike:Exists() and Player:Buff(WarriorOfElune) and
            (AstralPower <= 90 or (AstralPower <= 85 and Player:Buff(Incarnation))) and
            Target:CanCast(LunarStrike)
            then
                Target:Cast(LunarStrike)
                return
            end
            if NewMoon:Exists() and NewMoon:Icon() == NewMoonIcon and Target:CanCast(NewMoon) then
                if AstralPower <= 90 and Player:Buff(FuryOfElune) then
                    Bug("New Moon")
                    Target:Cast(NewMoon)
                    return
                end
            end
            if NewMoon:Exists() and NewMoon:Icon() == HalfMoonIcon and Target:CanCast(NewMoon) then
                if AstralPower <= 80 and Player:Buff(FuryOfElune) and AstralPower > NewMoon:CastTime() * 12 then
                    Bug("Half Moon")
                    Target:Cast(NewMoon)
                    return
                end
            end
            if NewMoon:Exists() and NewMoon:Icon() == FullMoonIcon and Target:CanCast(NewMoon) then
                if AstralPower <= 60 and Player:Buff(FuryOfElune) and AstralPower > NewMoon:CastTime() * 12 then
                    Bug("满月")
                    Target:Cast(NewMoon)
                    return
                end
            end
            if
            Moonfire:Exists() and not Player:Buff(FuryOfElune) and Target:DebuffRemains(MoonfireDebuff) <= 6.6 and
            Target:CanCast(Moonfire)
            then
                Target:Cast(Moonfire)
                return
            end
            if
            Sunfire:Exists() and not Player:Buff(FuryOfElune) and Target:DebuffRemains(SunfireDebuff) <= 5.4 and
            Target:CanCast(Sunfire)
            then
                Target:Cast(Sunfire)
                return
            end
            if StellarFlare:Exists() and Target:DebuffRemains(StellarFlare) <= 7.2 and Target:CanCast(StellarFlare) then
                Target:Cast(StellarFlare)
                return
            end
            if
            not Player:Buff(FuryOfElune) and (NumEnemies <= 2 and FuryOfElune:Cooldown() > 7) or
            ((NumEnemies >= 2 and StellarFlare:Exists() or NumEnemies >= 3) and FuryOfElune:Cooldown() > 10)
            then
                self:AstralDump()
            end
            if
            not Player:Buff(FuryOfElune) and
            ((AstralPower >= 92 and FuryOfElune:Cooldown() > GCDMax * 3) or
            (WarriorOfElune:Cooldown() <= 5 and FuryOfElune:Cooldown() >= 35 and
            Player:BuffCount(LunarEmpowerment) < 2))
            then
                self:AstralDump()
            end
            if SolarWrath:Exists() and NumEnemies < 3 and Player:Buff(SolarEmpowerment) and Target:CanCast(SolarWrath) then
                Target:Cast(SolarWrath)
                return
            end
            if
            LunarStrike:Exists() and
            ((Player:BuffCount(LunarEmpowerment) >= 3 or
            (Player:BuffRemains(LunarEmpowerment) < 5 and Player:Buff(LunarEmpowerment))) or
            NumEnemies >= 2) and
            Target:CanCast(LunarStrike)
            then
                Target:Cast(LunarStrike)
                return
            end
            self:MultiDotsCycles()
            if SolarWrath:Exists() and NumEnemies < 3 and Target:CanCast(SolarWrath) then
                Target:Cast(SolarWrath)
                return
            end
        end
        if IsOptionEnabled("翡翠捕梦者") and EmeraldDreamcatcherEquipped and #TargetEnemies_20y <= GetOptionValue("翡翠捕梦者") then
            EmeraldDreamcatcherRemains = Player:BuffRemains(EmeraldDreamcatcherBuff) - GetSecondOptionValue("翡翠捕梦者")
            if
            AstralCommunion:Exists() and CDOptionEnabled("沟通星界") and Player:Buff(EmeraldDreamcatcherBuff) and
            AstralPowerDeficit >= 75 and
            Player:CanCast(AstralCommunion)
            then
                Player:Cast(AstralCommunion)
                return
            end
            if
            Incarnation:Exists() and IncarnationEnabled and (AstralPower >= 60 or Player:HasHero()) and
            Player:CanCast(Incarnation)
            then
                Player:Cast(Incarnation)
                return
            end
            if
            CelestialAlignment:Exists() and CelestialAlignmentEnabled and not Incarnation:Exists() and
            AstralPower >= 60 and
            not Player:Buff(EmeraldDreamcatcherBuff) and
            Player:CanCast(CelestialAlignment)
            then
                Player:Cast(CelestialAlignment)
                return
            end
            if
            Starsurge:Exists() and IsOptionEnabled("星涌术") and (GCDMax * AstralPower / 26) > Target:TimeToDie() and
            Target:CanCast(Starsurge)
            then
                Target:Cast(Starsurge)
                return
            end
            if StellarFlare:Exists() and Target:DebuffRemains(StellarFlare) < 7.2 and Target:CanCast(StellarFlare) then
                Target:Cast(StellarFlare)
                return
            end
            if
            Moonfire:Exists() and
            ((NaturesBalance:Exists() and Target:DebuffRemains(MoonfireDebuff) < 3) or
            (Target:DebuffRemains(MoonfireDebuff) < 6.6 and not NaturesBalance:Exists())) and
            (EmeraldDreamcatcherRemains > GCDMax or not Player:Buff(EmeraldDreamcatcherBuff)) and
            Target:CanCast(Moonfire)
            then
                Target:Cast(Moonfire)
                return
            end
            if
            Sunfire:Exists() and
            ((NaturesBalance:Exists() and Target:DebuffRemains(SunfireDebuff) < 3) or
            (Target:DebuffRemains(SunfireDebuff) < 5.4 and not NaturesBalance:Exists())) and
            (EmeraldDreamcatcherRemains > GCDMax or not Player:Buff(EmeraldDreamcatcherBuff)) and
            Target:CanCast(Sunfire)
            then
                Target:Cast(Sunfire)
                return
            end
            if
            Starfall:Exists() and IsOptionEnabled("星辰坠落 欧奈斯的直觉") and Player:Buff(OnethsOverconfidenceStarfall) and
            EmeraldDreamcatcherRemains > GCDMax and
            Target:CanCast(Starfall)
            then
                if Target:CastGround(Starfall, 1, StarfallRadius, 40, false) then
                    return
                end
            end
            if NewMoon:Exists() and NewMoon:Icon() == HalfMoonIcon and Target:CanCast(NewMoon) then
                if AstralPowerDeficit >= 10 and EmeraldDreamcatcherRemains > NewMoon:CastTime() and AstralPower >= 16 then
                    Target:Cast(NewMoon)
                    return
                end
            end
            if NewMoon:Exists() and NewMoon:Icon() == HalfMoonIcon and Target:CanCast(NewMoon) then
                if AstralPowerDeficit >= 20 and EmeraldDreamcatcherRemains > NewMoon:CastTime() and AstralPower >= 6 then
                    Target:Cast(NewMoon)
                    return
                end
            end
            if NewMoon:Exists() and NewMoon:Icon() == FullMoonIcon and Target:CanCast(NewMoon) then
                if AstralPowerDeficit >= 40 and EmeraldDreamcatcherRemains > NewMoon:CastTime() then
                    Target:Cast(NewMoon)
                    return
                end
            end
            if
            LunarStrike:Exists() and
            (Player:Buff(LunarEmpowerment) and EmeraldDreamcatcherRemains > LunarStrike:CastTime() and
            (not (Player:Buff(CelestialAlignment) or Player:Buff(Incarnation)) and AstralPowerDeficit >= 15 or
            (Player:Buff(CelestialAlignment) or Player:Buff(Incarnation)) and AstralPowerDeficit >= 22.5)) and
            Player:SpellHaste() < 0.4 and
            Target:CanCast(LunarStrike)
            then
                Bug(
                "EC: Lunar Strike Cast Time vs. ED Buff: " ..
                LunarStrike:CastTime() .. " < " .. EmeraldDreamcatcherRemains
                )
                Target:Cast(LunarStrike)
                return
            end
            if
            SolarWrath:Exists() and Player:BuffCount(SolarEmpowerment) > 1 and
            EmeraldDreamcatcherRemains > 2 * SolarWrath:CastTime() and
            AstralPower >= 6 and
            (Target:DebuffRemains(MoonfireDebuff) > 5 or
            (Target:DebuffRemains(SunfireDebuff) < 5.4 and Target:DebuffRemains(MoonfireDebuff) > 6.6)) and
            (not (Player:Buff(CelestialAlignment) or Player:Buff(Incarnation)) and AstralPowerDeficit >= 10 or
            (Player:Buff(CelestialAlignment) or Player:Buff(Incarnation)) and AstralPowerDeficit >= 15) and
            Target:CanCast(SolarWrath)
            then
                Target:Cast(SolarWrath)
                return
            end
            if
            LunarStrike:Exists() and Player:Buff(LunarEmpowerment) and
            EmeraldDreamcatcherRemains > LunarStrike:CastTime() and
            AstralPower >= 11 and
            (not (Player:Buff(CelestialAlignment) or Player:Buff(Incarnation)) and AstralPowerDeficit >= 15 or
            (Player:Buff(CelestialAlignment) or Player:Buff(Incarnation)) and AstralPowerDeficit >= 22.5) and
            Target:CanCast(LunarStrike)
            then
                Bug(
                "EC: Lunar Strike Cast Time vs. ED Buff: " ..
                LunarStrike:CastTime() .. " < " .. EmeraldDreamcatcherRemains
                )
                Target:Cast(LunarStrike)
                return
            end
            if
            SolarWrath:Exists() and Player:Buff(SolarEmpowerment) and
            EmeraldDreamcatcherRemains > SolarWrath:CastTime() and
            AstralPower >= 16 and
            (not (Player:Buff(CelestialAlignment) or Player:Buff(Incarnation)) and AstralPowerDeficit >= 10 or
            (Player:Buff(CelestialAlignment) or Player:Buff(Incarnation)) and AstralPowerDeficit >= 15) and
            Target:CanCast(SolarWrath)
            then
                Target:Cast(SolarWrath)
                return
            end
            if
            Starsurge:Exists() and IsOptionEnabled("星涌术") and
            ((Player:Buff(EmeraldDreamcatcherBuff) and EmeraldDreamcatcherRemains < GCDMax) or AstralPower > 85 or
            ((Player:Buff(CelestialAlignment) or Player:Buff(Incarnation)) and AstralPower > 30)) and
            Target:CanCast(Starsurge)
            then
                Target:Cast(Starsurge)
                return
            end
            if
            Starfall:Exists() and IsOptionEnabled("星辰坠落 欧奈斯的直觉") and Player:Buff(OnethsOverconfidenceStarfall) and
            Target:CanCast(Starfall)
            then
                if Target:CastGround(Starfall, 1, StarfallRadius, 40, false) then
                    return
                end
            end
            if NewMoon:Exists() and NewMoon:Icon() == NewMoonIcon and Target:CanCast(NewMoon) then
                if AstralPowerDeficit >= 10 then
                    Target:Cast(NewMoon)
                    return
                end
            end
            if NewMoon:Exists() and NewMoon:Icon() == HalfMoonIcon and Target:CanCast(NewMoon) then
                if AstralPowerDeficit >= 20 then
                    Target:Cast(NewMoon)
                    return
                end
            end
            if NewMoon:Exists() and NewMoon:Icon() == FullMoonIcon and Target:CanCast(NewMoon) then
                if AstralPowerDeficit >= 40 then
                    Target:Cast(NewMoon)
                    return
                end
            end
            self:MultiDotsCycles()
            if SolarWrath:Exists() and Player:Buff(SolarEmpowerment) and Target:CanCast(SolarWrath) then
                Target:Cast(SolarWrath)
                return
            end
            if LunarStrike:Exists() and Player:Buff(LunarEmpowerment) and Target:CanCast(LunarStrike) then
                Target:Cast(LunarStrike)
                return
            end
            if SolarWrath:Exists() and Target:CanCast(SolarWrath) then
                Target:Cast(SolarWrath)
                return
            end
            return
        end
        if
        Starsurge:Exists() and IsOptionEnabled("星涌术") and IsOptionEnabled("高优先级 星辰坠落") and
        Player:Buff(OnethsOverconfidenceStarsurge) and
        not Player:Buff(FuryOfElune) and
        Target:CanCast(Starsurge)
        then
            Bug("Starsurge Onet's Overconfidence High Prio")
            Target:Cast(Starsurge)
            return
        end
        if
        UseAOE() and Starfall:Exists() and IsOptionEnabled("高优先级 星辰坠落") and
        (AstralPower >= StarfallAstralPower or Player:Buff(OnethsOverconfidenceStarfall)) and
        not Player:Buff(FuryOfElune) and
        Target:CanCast(Starfall)
        then
            if Target:CastGroundSpell(Starfall, "高优先级 星辰坠落", StarfallRadius) then
                Bug("高优先级 星辰坠落")
                return
            end
        end
        if NewMoon:Exists() and NewMoon:Icon() == NewMoonIcon and Target:CanCast(NewMoon) then
            if
            ((NewMoon:Charges() == 2 and NewMoon:Recharge() < 5) or NewMoon:Charges() == 3) and
            AstralPowerDeficit > 14
            then
                Bug("New Moon")
                Target:Cast(NewMoon)
                return
            end
        end
        if NewMoon:Exists() and NewMoon:Icon() == HalfMoonIcon and Target:CanCast(NewMoon) then
            if
            (((NewMoon:Charges() == 2 and NewMoon:Recharge() < 5) or NewMoon:Charges() == 3) or
            (Target:TimeToDie() < 15 and NewMoon:Charges() == 2)) and
            AstralPowerDeficit > 24
            then
                Bug("Half Moon")
                Target:Cast(NewMoon)
                return
            end
        end
        if NewMoon:Exists() and NewMoon:Icon() == FullMoonIcon and Target:CanCast(NewMoon) then
            if
            (((NewMoon:Charges() == 2 and NewMoon:Recharge() < 5) or NewMoon:Charges() == 3) or
            Target:TimeToDie() < 15) and
            AstralPowerDeficit > 44
            then
                Bug("满月")
                Target:Cast(NewMoon)
                return
            end
        end
        if StellarFlare:Exists() and Target:DebuffRemains(StellarFlare) <= 7.2 and Target:CanCast(StellarFlare) then
            Target:Cast(StellarFlare)
            return
        end
        if
        Moonfire:Exists() and
        ((NaturesBalance:Exists() and Target:DebuffRemains(MoonfireDebuff) < 3) or
        (Target:DebuffRemains(MoonfireDebuff) < 6.6 and not NaturesBalance:Exists())) and
        AstralPowerDeficit > 7 and
        Target:CanCast(Moonfire)
        then
            Target:Cast(Moonfire)
            return
        end
        if
        Sunfire:Exists() and
        ((NaturesBalance:Exists() and Target:DebuffRemains(SunfireDebuff) < 3) or
        (Target:DebuffRemains(SunfireDebuff) < 6.5 and not NaturesBalance:Exists())) and
        AstralPowerDeficit > 7 and
        Target:CanCast(Sunfire)
        then
            Target:Cast(Sunfire)
            return
        end
        if
        AstralCommunion:Exists() and CDOptionEnabled("沟通星界") and Player:AstralPowerDeficit() >= 71 and
        Player:CanCast(AstralCommunion)
        then
            Player:Cast(AstralCommunion)
            return
        end
        if Incarnation:Exists() and IncarnationEnabled and AstralPower >= 40 and Player:CanCast(Incarnation) then
            Player:Cast(Incarnation)
            return
        end
        if
        CelestialAlignment:Exists() and CelestialAlignmentEnabled and not Incarnation:Exists() and AstralPower >= 40 and
        Player:CanCast(CelestialAlignment)
        then
            Player:Cast(CelestialAlignment)
            return
        end
        if
        Starfall:Exists() and IsOptionEnabled("星辰坠落 欧奈斯的直觉") and Player:Buff(OnethsOverconfidenceStarfall) and
        Target:CanCast(Starfall)
        then
            if Target:CastGround(Starfall, 1, StarfallRadius, 40, false) then
                return
            end
        end
        if
        SolarWrath:Exists() and NumEnemies < 3 and Player:BuffCount(SolarEmpowerment) == 3 and
        Target:CanCast(SolarWrath)
        then
            Target:Cast(SolarWrath)
            return
        end
        if LunarStrike:Exists() and Player:BuffCount(LunarEmpowerment) == 3 and Target:CanCast(LunarStrike) then
            Target:Cast(LunarStrike)
            return
        end
        if
        Starsurge:Exists() and IsOptionEnabled("星涌术") and Player:Buff(OnethsOverconfidenceStarsurge) and
        Target:CanCast(Starsurge)
        then
            Target:Cast(Starsurge)
            return
        end
        self:MultiDotsCycles()
        if (#TargetEnemies_20y >= 2 and StellarDrift:Exists()) or #TargetEnemies_20y >= 3 then
            if
            Player:BuffRemains(Starfall) < GCDMax * 2 or AstralPowerDeficit < 22.5 or
            (Player:BuffRemains(CelestialAlignment) > 8 or Player:BuffRemains(Incarnation) > 8) or
            Target:TimeToDie() < 8
            then
                self:AstralDump()
            end
            if
            NewMoon:Exists() and NewMoon:Icon() == NewMoonIcon and AstralPowerDeficit > 14 and
            Target:CanCast(NewMoon)
            then
                Bug("New Moon")
                Target:Cast(NewMoon)
                return
            end
            if
            NewMoon:Exists() and NewMoon:Icon() == HalfMoonIcon and AstralPowerDeficit > 24 and
            Target:CanCast(NewMoon)
            then
                Bug("New Moon")
                Target:Cast(NewMoon)
                return
            end
            if
            NewMoon:Exists() and NewMoon:Icon() == FullMoonIcon and AstralPowerDeficit > 44 and
            Target:CanCast(NewMoon)
            then
                Bug("New Moon")
                Target:Cast(NewMoon)
                return
            end
            if WarriorOfElune:Exists() and WarriorOfEluneEnabled and Player:CanCast(WarriorOfElune) then
                Player:Cast(WarriorOfElune)
                return
            end
            if LunarStrike:Exists() and Player:Buff(WarriorOfElune) and Target:CanCast(LunarStrike) then
                Target:Cast(LunarStrike)
                return
            end
            self:MultiDotsCycles()
            if SolarWrath:Exists() and Player:Buff(SolarEmpowerment) and Target:CanCast(SolarWrath) then
                Target:Cast(SolarWrath)
                return
            end
            if LunarStrike:Exists() and Player:Buff(LunarEmpowerment) and Target:CanCast(LunarStrike) then
                Target:Cast(LunarStrike)
                return
            end
            if LunarStrike:Exists() and (NumEnemies >= 4 or Player:SpellHaste() < 0.45) and Target:CanCast(LunarStrike) then
                Target:Cast(LunarStrike)
                return
            end
            if SolarWrath:Exists() and Target:CanCast(SolarWrath) then
                Target:Cast(SolarWrath)
                return
            end
        end
        if
        AstralPowerDeficit < 44 or
        (Player:Buff(CelestialAlignment) or Player:Buff(Incarnation) or Player:Buff(AstralAcceleration)) or
        (GCDMax * (AstralPower / 40)) > Target:TimeToDie()
        then
            self:AstralDump()
        end
        if NewMoon:Exists() and NewMoon:Icon() == NewMoonIcon and Target:CanCast(NewMoon) then
            if AstralPowerDeficit > 14 and not (Player:Buff(CelestialAlignment) or Player:Buff(Incarnation)) then
                Bug("New Moon")
                Target:Cast(NewMoon)
                return
            end
        end
        if NewMoon:Exists() and NewMoon:Icon() == HalfMoonIcon and Target:CanCast(NewMoon) then
            if AstralPowerDeficit > 24 and not (Player:Buff(CelestialAlignment) or Player:Buff(Incarnation)) then
                Bug("New Moon")
                Target:Cast(NewMoon)
                return
            end
        end
        if NewMoon:Exists() and NewMoon:Icon() == FullMoonIcon and Target:CanCast(NewMoon) then
            if AstralPowerDeficit > 44 then
                Bug("New Moon")
                Target:Cast(NewMoon)
                return
            end
        end
        if WarriorOfElune:Exists() and WarriorOfEluneEnabled and Player:CanCast(WarriorOfElune) then
            Player:Cast(WarriorOfElune)
            return
        end
        if LunarStrike:Exists() and Player:Buff(WarriorOfElune) and Target:CanCast(LunarStrike) then
            Target:Cast(LunarStrike)
            return
        end
        self:MultiDotsCycles()
        if SolarWrath:Exists() and Player:Buff(SolarEmpowerment) and Target:CanCast(SolarWrath) then
            Target:Cast(SolarWrath)
            return
        end
        if LunarStrike:Exists() and Player:Buff(LunarEmpowerment) and Target:CanCast(LunarStrike) then
            Target:Cast(LunarStrike)
            return
        end
        if SolarWrath:Exists() and Target:CanCast(SolarWrath) then
            Target:Cast(SolarWrath)
            return
        end
        if IsOptionEnabled("移动时填充技能") and Player:Moving() >= GetOptionValue("移动时填充技能") then
            if LunarStrikeInstant:Exists() and Player:Buff(OwlkinFrenzy) and Target:CanCast(LunarStrikeInstant) then
                Target:Cast(LunarStrikeInstant)
                return
            end
            if GetSecondOptionValue("移动时填充技能") == "阳炎术" then
                if Sunfire:Exists() and Target:CanCast(Sunfire) then
                    Target:Cast(Sunfire)
                    return
                end
            else
                if Moonfire:Exists() and Target:CanCast(Moonfire) then
                    Target:Cast(Moonfire)
                    return
                end
            end
        end
    end
end
function Rotation:OutOfCombat()
    self:BlessingOfTheAncientsBuff()
    if
    RestorationAffinity:Exists() and Rejuvenation:Exists() and IsOptionEnabled("回春术 自己") and
    Player:HealthPercentage() <= GetOptionValue("回春术 自己") and
    Player:CanCast(Rejuvenation) and
    not Player:Buff(Rejuvenation)
    then
        self:RemoveForm()
        Player:Cast(Rejuvenation)
        return
    end
    if
    HealingTouch:Exists() and Player:Standing() > 1.5 and IsOptionEnabled("治疗之触 自己") and
    Player:HealthPercentage() <= GetSecondOptionValue("治疗之触 自己") and
    Player:CanCast(HealingTouch)
    then
        self:RemoveForm()
        Player:Cast(HealingTouch)
        return
    end
    if
    Regrowth:Exists() and Player:Standing() > 1.5 and IsOptionEnabled("愈合 自己") and
    Player:HealthPercentage() <= GetSecondOptionValue("愈合 自己") and
    Player:CanCast(Regrowth)
    then
        Player:Cast(Regrowth)
        return
    end
    if not Player:Buff(CatForm) and not Player:Buff(BearForm) and not Player:Buff(TravelForm) then
        if GuardianAffinity:Exists() and IsOptionEnabled("守护亲和") then
            if not Player:Buff(BearForm) and Player:CanCast(BearForm) then
                Player:Cast(BearForm)
                return
            end
        elseif FeralAffinity:Exists() and IsOptionEnabled("野性亲和") then
            if not Player:Buff(CatForm) and Player:CanCast(CatForm) then
                Player:Cast(CatForm)
                return
            end
        elseif IsOptionEnabled("枭兽形态") then
            if not Player:Buff(MoonkinForm) and Player:CanCast(MoonkinForm) then
                Player:Cast(MoonkinForm)
                return
            end
        end
    end
    if IsOptionEnabled("自动进入战斗") and Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        if SolarWrath:Exists() and Target:CanCast(SolarWrath) then
            Target:Cast(SolarWrath)
            return
        end
    end
end
SetRotation(103, {})
local Rotation = Rotations[103]
FBValue = 50
function Rotation:Initialize()
    Berserking = Spell(26297, false, false, true)
    Shadowmeld = Spell(58984, false, false, true)
    AshamanesRip = Spell(210705, false, true, true)
    Bloodtalons = Spell(155672, false, false, false)
    BloodtalonsBuff = Spell(145152, false, false, false)
    BrutalSlash = Spell(202028, false, false, true)
    Clearcasting = Spell(135700, false, false, false)
    FerociousBite = Spell(22568, true, true, true)
    JaggedWounds = Spell(202032, false, false, false)
    LunarInspiration = Spell(155580, false, false, false)
    Maim = Spell(22570, true, true, true)
    MomentOfClarity = Spell(236068, false, false, false)
    Moonfire = Spell(8921, false, true, true)
    MoonfireDebuff = Spell(164812, false, false, false)
    Predator = Spell(202021)
    PredatorySwiftness = Spell(69369, false, false, false)
    Prowl = Spell(5215, false, false, true)
    Rake = Spell(1822, true, true, true)
    RakeDebuff = Spell(155722, false, false, false)
    Rip = Spell(1079, true, true, true)
    Sabertooth = Spell(202031, false, false, false)
    SavageRoar = Spell(52610, false, false, true)
    SoulOfTheForest = Spell(158476)
    Shred = Spell(5221, true, true, true)
    Swipe = Spell(213764, false, false, true)
    SwipeCheckID = Spell(106785, false, false, true)
    Thrash = Spell(106830, false, false, true)
    ThrashDebuff = Spell(106830, false, false, false)
    AshamanesFrenzy = Spell(210722, true, true, true)
    AshamanesFrenzyDebuff = Spell(210723)
    Berserk = Spell(106951, false, false, true)
    ElunesGuidance = Spell(202060, false, false, true)
    Incarnation = Spell(102543, false, false, true)
    TigersFury = Spell(5217, false, false, true)
    HealingTouch = Spell(5185, false, false, false)
    Rebirth = Spell(20484, false, false, false, true)
    RebirthInstant = Spell(20484, false, false, true, true)
    Regrowth = Spell(8936, false, false, false)
    RegrowthInstant = Spell(8936, false, false, false)
    Revive = Spell(50769, false, false, false, true)
    Renewal = Spell(108238, false, false, true)
    SurvivalInstincts = Spell(61336, false, false, true)
    Dash = Spell(1850, false, false, true)
    SkullBash = Spell(106839, true, true, true)
    BearForm = Spell(5487, false, false, true)
    CatForm = Spell(768, false, false, true)
    MoonkinForm = Spell(197625, false, false, true)
    BalanceAffinity = Spell(197488, false, false, false)
    LunarEmpowerment = Spell(164547, false, false, false)
    LunarStrike = Spell(197628, true, true, false)
    SolarEmpowerment = Spell(164545, false, false, false)
    SolarWrath = Spell(197629, true, true, false)
    Starsurge = Spell(197626, true, true, false)
    Sunfire = Spell(197630, true, true, false)
    SunfireDebuff = Spell(164815, false, false, false)
    GuardianAffinity = Spell(217615, false, false, false)
    Mangle = Spell(33917, true, true, true)
    Ironfur = Spell(192081, false, false, true)
    FrenziedRegeneration = Spell(22842, false, false, true)
    Rejuvenation = Spell(774, false, false, true)
    RestorationAffinity = Spell(197492, false, false, false)
    Swiftmend = Spell(18562, false, false, false)
    AiluroPouncers = Item(137024)
    ChatoyantSignet = Item(137040)
    DraughtOfSouls = Item(140808)
    EkowraithCreatorOfWorlds = Item(137075)
    LuffaWrappings = Item(137056)
    TheWildshapersClutch = Item(137094)
    FireyRedMaimers = Item(144354)
    FireyRedMaimersBuff = Spell(236757)
    AddPage("常规")
    AddPage("进攻")
    AddPage("防御")
    AddCommonOptions()
    AddNewOption("常规", "测试版循环", 210, false, nil, nil, "Enable this to use the lastest revision of the Feral Rotation.")
    AddPresetOption("常规", "Melee", { 1, "Rake", "月火术" }, true)
    AddSection("常规", "起手设置", "Yellow")
    AddNewOption(
    "常规",
    "猎豹之步",
    220,
    false,
    { 11, 9, 13, 0.1 },
    nil,
    "Automatically un-equip Ailuro Pouncers and re-equip during Boss Mods countdown to make sure we have the Predatory Swiftness buff ready for the first Rip." ..
    C.TOOLTIP_VALUE ..
    "Time on the Boss Mods countdown at which we should perform the swap." ..
    C.TOOLTIP_HINT("The swap should be performed ideally roughly 10 seconds before the pull.")
    )
    AddNewOption(
    "常规",
    "处理 血腥爪击",
    220,
    false,
    { 12, 5, 13, 0.1 },
    nil,
    "Proc Bloodtalons Buff during Boss Mods Countdown." ..
    C.TOOLTIP_VALUE .. "Time on the Boss Mods countdown at which we should apply Bloodtalons Buff."
    )
    AddSection("常规", "变形", "Yellow")
    AddNewOption(
    "常规",
    "自动潜行",
    220,
    true,
    { 15, 1, 40, 1 },
    nil,
    "Enable to auto put in Cat Form or use Prowl." ..
    C.TOOLTIP_VALUE ..
    "Distance away from the target." .. C.TOOLTIP_HINT("The distance is checked only while out of combat.")
    )
    AddNewOption(
    "常规",
    "自动亲和",
    210,
    true,
    nil,
    nil,
    "Enable to automatically performs Affinity rotation." ..
    C.TOOLTIP_HINT(
    "Balance and Guardian will start once you're in the appropriate form, Restoration when you're not shapeshifted."
    )
    )
    AddSection("常规", "复生", "Yellow")
    AddNewOption(
    "常规",
    "立即战服坦克",
    220,
    false,
    { 0, 0, 3, 0.1 },
    nil,
    "Enable to use the Predatory Swiftness buff on rebirth to resuscitate a dead tank" ..
    C.TOOLTIP_VALUE .. "Set the delay before using it."
    )
    AddNewOption(
    "常规",
    "复生",
    210,
    true,
    nil,
    nil,
    "Enable to automatically resurrect targeted dead player targets in combat."
    )
    AddPresetOption("进攻")
    if Shadowmeld:Exists() then
        AddPresetOption("Cooldown", "进攻性种族技能")
    end
    AddSection("进攻", "大技能", "Yellow")
    AddPresetOption("Cooldown", "阿莎曼的狂乱")
    AddPresetOption("Cooldown", "狂暴")
    AddPresetOption("Cooldown", "月神的守护")
    AddPresetOption("Cooldown", "猛虎之怒")
    AddNewOption("进攻", "饰品和猛虎之怒", 210, true, nil, nil, "If enabled, we will pair our trinkets with Tiger's Fury.")
    AddSection("进攻", "能力", "Yellow")
    AddNewOption(
    "进攻",
    "野蛮挥砍",
    223,
    true,
    { 5, 1, 10, 1 },
    { 2, "禁用", "防止上限" },
    "Use Brutal Slash." ..
    C.TOOLTIP_VALUE_1 ..
    "Amount of units needed to use Brutal Slash as high priority." ..
    C.TOOLTIP_VALUE_2 ..
    "Select Prevent Capping if you want to use Brutal Slash as filler when the charges are about to cap."
    )
    AddNewOption(
    "进攻",
    "野蛮挥砍储存能量",
    210,
    true,
    nil,
    nil,
    "Pool Energy and keep Combos to 3 while we have Brutal Slash charges so that we can instantly use the charges when waves of adds occur."
    )
    AddNewOption(
    "进攻",
    "割裂",
    220,
    false,
    { 1, 1, 3, 1 },
    nil,
    "Enable to use Maim with the Fiery Red Maimers Legendary." ..
    C.TOOLTIP_VALUE .. "Amount of units that need to be within 5 yards around the target to use."
    )
    AddNewOption(
    "进攻",
    "月火术",
    233,
    true,
    { 2, "无条件使用", "Lunar Inspiration" },
    { 1, "Everything", "在战斗中" },
    "Enable for the automatic usage of Moonfire while in Human Form or with Lunar Inspiration talent." ..
    C.TOOLTIP_VALUE_1 ..
    C.TOOLTIP_SUBVALUE("无条件使用", true) ..
    "Will use the ability both while in Human Form and with Lunar Inspiration talent." ..
    C.TOOLTIP_SUBVALUE("Lunar Inspiration") ..
    "Will only use the ability with Lunar Inspiration talent." ..
    C.TOOLTIP_VALUE_2 ..
    C.TOOLTIP_SUBVALUE("Everything", true) ..
    "Will use the ability on every units available." ..
    C.TOOLTIP_SUBVALUE("在战斗中") ..
    "Will only use the ability on unit already in combat."
    )
    AddNewOption(
    "进攻",
    "根据目标血量上斜掠",
    222,
    false,
    { 25, 0, 100, 1 },
    { 25, 0, 100, 1 },
    "Set the Health threshold in order to apply Rake (and Moonfire if talented into Lunar Inspiration)." ..
    C.TOOLTIP_VALUE_1 ..
    "Set Minimum Health for target." ..
    C.TOOLTIP_VALUE_2 ..
    "Set Minimum Health for Adds (Multi-DoT)." .. C.TOOLTIP_HINT("Overrides TTD when enabled.")
    )
    AddNewOption(
    "进攻",
    "根据致死时间上斜掠",
    122,
    true,
    { 6, 0, 25, 1 },
    { 9, 0, 25, 1 },
    "Set the TimeToDie threshold in order to apply Rake (and Moonfire if talented into Lunar Inspiration)." ..
    C.TOOLTIP_VALUE_1 ..
    "Set Minimum Time To Die for target." ..
    C.TOOLTIP_VALUE_2 .. "Set Minimum Time To Die for Adds (Multi-DoT)."
    )
    AddNewOption(
    "进攻",
    "根据目标血量上割裂",
    222,
    false,
    { 25, 0, 100, 1 },
    { 25, 0, 100, 1 },
    "Minimum Health threshold to apply Rip." ..
    C.TOOLTIP_VALUE_1 ..
    "Set Minimum Health for target." ..
    C.TOOLTIP_VALUE_2 ..
    "Set Minimum Health for Adds (Multi-DoT)." .. C.TOOLTIP_HINT("Overrides TTD when enabled.")
    )
    AddNewOption(
    "进攻",
    "根据致死时间上割裂",
    122,
    true,
    { 12, 0, 25, 1 },
    { 16, 0, 25, 1 },
    "Minimum Time To Die threshold to apply Rip." ..
    C.TOOLTIP_VALUE_1 ..
    "Set Minimum Time To Die for target." ..
    C.TOOLTIP_VALUE_2 .. "Set Minimum Time To Die for Adds (Multi-DoT)."
    )
    AddNewOption("进攻", "横扫", 210, true, nil, nil, "Use Swipe.")
    AddNewOption(
    "进攻",
    "痛击",
    220,
    true,
    { 2, 1, 5, 1 },
    nil,
    "Enable to use Thrash for AoE." ..
    C.TOOLTIP_VALUE ..
    "Set the min. number of enemies to refresh Trash if it has been applied recently (during AoE)."
    )
    AddPresetOption("防御")
    AddSection("防御", "能力", "Yellow")
    AddNewOption("防御", "高优先级 愈合", 220, false, { 90, 1, 100, 1 }, nil, "Health Percentage to use Survival Instincts.")
    AddSection("防御", "大技能", "Yellow")
    AddNewOption("防御", "生存本能", 220, true, { 45, 1, 100, 1 }, nil, "Health Percentage to use Survival Instincts.")
    ISCL = {
        [197628] = "Lunar Strike",
        [197629] = "阳炎之怒",
        [HealingTouch:ID()] = "治疗之触",
        [Regrowth:ID()] = "愈合",
        [Revive:ID()] = "Revive"
    }
    function Unit:RakeDamage()
        return BleedTable.Rake[self:GUID()] or 0
    end
    function Unit:RipDamage()
        return BleedTable.Rip[self:GUID()] or 0
    end
    function Unit:ThrashDamage()
        return BleedTable.Thrash[self:GUID()] or 0
    end
    AddOutput("横扫敌人数量: ")
    SetOutput("横扫敌人数量: ", "0")
    AddOutput("斜掠伤害:")
    SetOutput("斜掠伤害:", "0  0")
    AddOutput("割裂伤害:")
    SetOutput("割裂伤害:", "0  0")
    self.RakeDamageOutput = 0
    self.RipDamageOutput = 0
end
function Rotation:Events()
    BleedTable = {
        Rake = {},
        Rip = {},
        Thrash = {},
        LastRakeDmg = 1,
        LastRakeTime = 0,
        LastRipDmg = 1,
        LastRipTime = 0,
        LastThrashDmg = 1,
        LastThrashTime = 0
    }
    local DamageMultiplier, RakeMultiplier
    function BleedDamage(SpellName)
        if Player:Buff(BloodtalonsBuff) then
            DamageMultiplier = 1
            if Player:Buff(BloodtalonsBuff) then
                DamageMultiplier = DamageMultiplier * 1.5
            end
            if Player:Buff(TigersFury) then
                DamageMultiplier = DamageMultiplier * 1.15
            end
            if Player:Buff(SavageRoar) then
                DamageMultiplier = DamageMultiplier * 1.25
            end
            if Player:IsStealthed(true, true) then
                RakeMultiplier = 2
            else
                RakeMultiplier = 1
            end
            if SpellName == "Rake" then
                return RakeMultiplier * DamageMultiplier
            elseif SpellName == "割裂" then
                return DamageMultiplier
            elseif SpellName == "痛击" then
                return DamageMultiplier
            end
        else
            return 1
        end
    end
    EventFrame:RegisterForSelfCombatEvent(
    function(...)
        SpellID = select(12, ...)
        if SpellID == 1822 then
            self.RakeDamageOutput = BleedDamage("Rake")
            BleedTable.LastRakeDmg = self.RakeDamageOutput
            BleedTable.LastRakeTime = GetTime() + 0.3
        elseif SpellID == 1079 then
            self.RipDamageOutput = BleedDamage("割裂")
            BleedTable.LastRipDmg = self.RipDamageOutput
            BleedTable.LastRipTime = GetTime() + 0.3
        elseif SpellID == 106830 then
            BleedTable.LastThrashDmg = BleedDamage("痛击")
            BleedTable.LastThrashTime = GetTime() + 0.3
        end
    end,
    "SPELL_CAST_SUCCESS"
    )
    EventFrame:RegisterForSelfCombatEvent(
    function(...)
        DestGUID, _, _, _, SpellID = select(8, ...)
        if SpellID == 155722 then
            BleedTable.Rake[DestGUID] =             GetTime() < BleedTable.LastRakeTime and BleedTable.LastRakeDmg or BleedDamage("Rake")
        elseif SpellID == 1079 then
            BleedTable.Rip[DestGUID] =             GetTime() < BleedTable.LastRipTime and BleedTable.LastRipDmg or BleedDamage("割裂")
        elseif SpellID == 106830 then
            BleedTable.Thrash[DestGUID] =             GetTime() < BleedTable.LastThrashTime and BleedTable.LastThrashDmg or BleedDamage("痛击")
        end
    end,
    "SPELL_AURA_APPLIED",
    "SPELL_AURA_REFRESH"
    )
    EventFrame:RegisterForCombatEvent(
    function(...)
        DestGUID = select(8, ...)
        if BleedTable.Rake[DestGUID] then
            BleedTable.Rake[DestGUID] = nil
        end
        if BleedTable.Rip[DestGUID] then
            BleedTable.Rip[DestGUID] = nil
        end
        if BleedTable.Thrash[DestGUID] then
            BleedTable.Thrash[DestGUID] = nil
        end
    end,
    "UNIT_DIED",
    "UNIT_DESTROYED"
    )
    EventFrame:RegisterForEvent(
    function()
        OpenerRaked, OpenerEnded, ShredTo5 = false, false, false
        self.AiluroSwapReady = true
    end,
    "PLAYER_REGEN_ENABLED"
    )
end
local function TigersFurySync()
    if CDOptionEnabled("狂暴") and not Incarnation:Exists() and Player:CanCast(Berserk) then
        Player:Cast(Berserk)
        Bug("TF Synced Berserk - Tiger Fury Sync")
    end
    if Berserking:Exists() and CDOptionEnabled("进攻性种族技能") and Player:CanCast(Berserking) then
        CastSpellByID(26297, "player")
        Bug("TF Synced Berserking - Tiger Fury Sync")
    end
    if IsOptionEnabled("饰品和猛虎之怒") then
        Player:UseTrinkets()
        Bug("TF Synced Trinkets - Tiger Fury Sync")
    end
end
function Rotation:Pulse()
    if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
        return
    end
    Regrowth = Player:Buff(PredatorySwiftness) and Spell(8936, false, false, true) or Spell(8936, false, false, false)
    if Incarnation:Exists() then
        Berserk = Spell(102543, false, false, true)
        Prowl = Player:Buff(Incarnation) and Spell(102547, false, false, true) or Spell(5215, false, false, true)
    else
        Berserk = Spell(106951, false, false, true)
        Prowl = Spell(5215, false, false, true)
    end
    if LunarInspiration:Exists() and Player:Buff(CatForm) then
        Moonfire = Spell(155625, false, true, true)
        MoonfireDebuff = Spell(155625, false, false, false)
    else
        Moonfire = Spell(8921, false, true, true)
        MoonfireDebuff = Spell(164812, false, false, false)
    end
    if Player:Buff(CatForm) then
        Swipe = Spell(213764, false, false, true)
        Thrash = Spell(106830, false, false, true)
        ThrashDebuff = Spell(106830, false, false, false)
    elseif Player:Buff(BearForm) then
        Swipe = Spell(213771, false, false, true)
        Thrash = Spell(77758, false, false, true)
        ThrashDebuff = Spell(192090, false, false, false)
    else
        Swipe = Spell(213764, false, false, true)
        Thrash = Spell(106832, false, false, true)
        ThrashDebuff = Spell(106832, false, false, false)
    end
    if Target:Exists() and BMPullTime() < 15 and not Player:IsInCombat() then
        self:Opening()
        return
    end
    if GetTime() < Rotation.SpamPrevention then
        return
    end
    Rotation.SpamPrevention = GetTime() + 0.05
    Target = Unit.Target
    local InCombat = Player:IsInCombat()
    if not InCombat then
        self:OutOfCombat()
        return
    end
    if InCombat then
        self:Defensives()
    end
    Target = Player:ReTarget(Shred, true) or Unit.Target
    Rotations:RefreshUnitTables(Rotation.Identifier)
    self:Interrupts()
    self:OffGCDAbilities()
    if
    IsOptionEnabled("开怪技能") and
    (GetOptionValue("开怪技能") == "无条件使用" or (GetOptionValue("开怪技能") == "打BOSS使用" and Target:IsBoss()) or
    (GetOptionValue("开怪技能") == "CDs Only" and CooldownsAllowed())) and
    not Target:Debuff(Rip) and
    CombatTime() < 15 and
    SavageRoar:Exists() and
    JaggedWounds:Exists() and
    Bloodtalons:Exists() and
    NumEnemies <= 1 and
    not OpenerEnded
    then
        self:Opener()
        return
    elseif Target:Debuff(Rip) ~= nil or CombatTime() > 15 then
        OpenerEnded = true
    end
    if Player:GlobalCooldown() == 0 then
        if IsOptionEnabled("测试版循环") then
            self:CombatBeta()
        else
            self:Combat()
        end
    end
end
function Rotation:Opening()
    if
    Bloodtalons:Exists() and IsOptionEnabled("处理 血腥爪击") and BMPullTime() < GetOptionValue("处理 血腥爪击") and
    not Player:Buff(BloodtalonsBuff) and
    (Player:Buff(PredatorySwiftness) or not Player:Buff(CatForm)) and
    Player:CanCast(Regrowth)
    then
        Player:Cast(Regrowth)
        return
    end
    if
    IsOptionEnabled("猎豹之步") and BMPullTime() < GetOptionValue("猎豹之步") and BMPullTime() > 8 and
    not Player:IsCasting() and
    not Player:IsChanneling()
    then
        if AiluroPouncers:IsEquipped(8) and not Player:IsInCombat() and not self.Switched then
            self.EmptySlotsTable = {}
            for i = 0, NUM_BAG_SLOTS do
                GetContainerFreeSlots(i, self.EmptySlotsTable)
                if #self.EmptySlotsTable > 0 then
                    self.ValidContainer = i
                    break
                end
            end
            if self.ValidContainer then
                PickupInventoryItem(8)
                if self.ValidContainer == 0 then
                    PutItemInBackpack()
                else
                    PutItemInBag(ContainerIDToInventoryID(self.ValidContainer))
                end
                self.Switched = GetTime() + 0.1
                self.AiluroSwapReady = false
            else
                Print("Could not unequip Ailuro Pouncers as your bags are full.")
            end
        end
        if self.Switched ~= nil and self.Switched < GetTime() then
            if AiluroPouncers:IsEquipped() then
                self.Switched = nil
            else
                PickupContainerItem(self.ValidContainer, self.EmptySlotsTable[1])
                EquipCursorItem(8)
            end
        end
    end
    Player:UsePotions("Agility")
    if IsOptionEnabled("自动潜行") and BMPullTime() < 2 then
        if not Player:IsStealthed(true, true) and Player:CanCast(Prowl) then
            Bug("Prowl - Auto Cat Form and Prowl")
            Player:Cast(Prowl)
            return
        end
        if not Player:Buff(CatForm) and Player:CanCast(CatForm) then
            Bug("Cat Form - Auto Cat Form and Prowl")
            Player:Cast(CatForm)
            return
        end
    end
end
function Rotation:Opener()
    if
    Player:Buff(CatForm) and
    (Player:IsStealthed(true, true) or (not Player:Buff(SavageRoar) and Player:ComboPoints() <= 0)) and
    Target:CanCast(Rake, true, true, false, false, true)
    then
        Rake.LastCastTime = GetTime()
        Bug("Opener - Rake")
        Target:Cast(Rake)
        return
    end
    if not Player:Buff(CatForm) and Player:CanCast(CatForm) then
        Bug("Opener - Cat Form")
        Player:Cast(CatForm)
        return
    end
    if not Player:IsStealthed() then
        Player:StartAttack()
        if SavageRoar:Exists() and not Player:Buff(SavageRoar) and Player:CanCast(SavageRoar) then
            Bug("Opener - Savage Roar")
            Player:Cast(SavageRoar)
            return
        end
        if DraughtOfSouls:IsEquipped(13, 14) then
            OpenerEnded = true
            return
        end
        if Berserk:Exists() and Player:Buff(SavageRoar) and Player:CanCast(Berserk) then
            Bug("Opener - Berserk")
            Player:Cast(Berserk)
            return
        end
        if
        Player:Buff(TigersFury) and Player:EnergyTimeToMax() > 3 and
        (not SavageRoar:Exists() or Player:Buff(SavageRoar))
        then
            Player:UseTrinkets()
        end
        if TigersFury:Exists() and Player:Buff(Berserk) and Player:CanCast(TigersFury) then
            Bug("Opener - Tiger's Fury")
            Player:Cast(TigersFury)
            return
        end
        if
        AshamanesFrenzy:Exists() and Player:Buff(BloodtalonsBuff) and
        Target:CanCast(AshamanesFrenzy, true, true, false, false, true)
        then
            Bug("Opener - Ashmane's Frenzy")
            Target:Cast(AshamanesFrenzy)
            return
        end
        if
        Regrowth:Exists() and Player:ComboPoints() >= 5 and not Player:Buff(BloodtalonsBuff) and
        Player:Buff(PredatorySwiftness) and
        Player:CanCast(RegrowthInstant)
        then
            Bug("Opener - Regrowth")
            Player:Cast(RegrowthInstant)
            return
        end
        if
        Rip:Exists() and Player:ComboPoints() >= 5 and
        (Player:Buff(BloodtalonsBuff) or not Player:Buff(PredatorySwiftness)) and
        Target:CanCast(Rip, true, true, false, false, true)
        then
            Bug("Opener - Rip")
            Target:Cast(Rip)
            return
        end
        if
        HasT19_4Pc and Player:ComboPoints() < 5 and not Target:Debuff(ThrashDebuff) and
        Player:IsWithinCastRange(Target, Shred, true) and
        Player:CanCast(Thrash, nil, true)
        then
            Bug("Opener - Thrash")
            Player:Cast(Thrash)
            return
        end
        if
        Shred:Exists() and Player:ComboPoints() < 5 and Player:Buff(SavageRoar) and
        Target:CanCast(Shred, true, true, false, false, true)
        then
            Bug("Opener - Shred")
            Target:Cast(Shred)
            return
        end
    end
end
function Rotation:Defensives()
    Player:UseHealingItem()
    if
    IsOptionEnabled("生存本能") and Player:HealthPercentage() <= GetOptionValue("生存本能") and
    not Player:Buff(SurvivalInstincts) and
    SurvivalInstincts:TimeSinceCast() > 0.5 and
    Player:CanCast(SurvivalInstincts)
    then
        Player:Cast(SurvivalInstincts)
        SurvivalInstincts.LastCastTime = GetTime()
    end
end
function Rotation:Interrupts()
    Player:UseInterrupt(SkullBash)
end
function Rotation:OffGCDAbilities()
end
function Rotation:CastHealCycle()
    if Focus:Exists() and Focus:CanCast(Regrowth) then
        Focus:Cast(Regrowth)
        return true
    end
    if Lowest and Lowest:CanCast(Regrowth) then
        Lowest:Cast(Regrowth)
        return true
    end
    if Player:CanCast(Regrowth) then
        Player:Cast(Regrowth)
        return true
    end
    return false
end
function Rotation:UnitTables()
    HealUnits = Player:HealUnitsAround(100, 40)
    Lowest = Unit.Lowest(HealUnits)
    Enemies_45y = Player:EnemiesWithinDistance(45, false)
    MaimEnemies =     UseAOE() and FireyRedMaimers:IsEquipped(7) and Player:Buff(FireyRedMaimersBuff) and Target:Exists() and
    #Target:EnemiesWithinDistance(5, false) or
    0
    self.MeleeRange =     5 + (BalanceAffinity:Exists() and (5 * (EkowraithCreatorOfWorlds:IsEquipped(5) and 1.75 or 1)) or 0)
    self.SwipeRange =     8 + (BalanceAffinity:Exists() and (5 * (EkowraithCreatorOfWorlds:IsEquipped(5) and 1.75 or 1)) or 0)
    self.ThrashRange =     (8 + (BalanceAffinity:Exists() and (5 * (EkowraithCreatorOfWorlds:IsEquipped(5) and 1.75 or 1)) or 0)) *
    (LuffaWrappings:IsEquipped(9) and 1.25 or 1)
    Enemies_5y = UseAOE() and Player:EnemiesWithinDistance(self.MeleeRange, false) or {}
    SwipeEnemies = UseAOE() and Player:EnemiesWithinDistance(self.SwipeRange, true) or {}
    ThrashEnemies = UseAOE() and Player:EnemiesWithinDistance(self.ThrashRange, true) or {}
    NumEnemies = #SwipeEnemies
    SetOutput("横扫敌人数量: ", tostring(NumEnemies))
end
function Rotation:CombatBeta()
    local RakeRefresh = 7
    RakeRefresh = (AiluroPouncers:IsEquipped(8) or SoulOfTheForest:Exists()) and 3 or RakeRefresh
    local Pooling = 3
    Pooling = ChatoyantSignet:IsEquipped(11, 12) and 10 or Pooling
    Pooling = TheWildshapersClutch:IsEquipped(10) and not ChatoyantSignet:IsEquipped(11, 12) and 3 or Pooling
    local RipTargetTTD, RipCycleTTD, RakeTargetTTD, RakeCycleTTD = 0, 0, 0, 0
    local RipTargetHP, RipCycleHP, RakeTargetHP, RakeCycleHP = 0, 0, 0, 0
    local RakeTickTime, MoonfireTickTime, RipTickTime, ThrashTickTime = 3, 2, 2, JaggedWounds:Exists() and 1.9 or 2.5
    local RakePandemic, RipPandemic, ThrashPandemic, ThrashSmartDuration, MoonfirePandemic = 4.5, 7.2, 4.5, 10, 4.2
    if IsOptionEnabled("立即战服坦克") then
        MainTank, MainTankTarget, OffTank, OffTankTarget = Unit.GetMainTanks()
        if MainTank and MainTank:Exists() and MainTank:IsPlayer() then
            if not MainTank:IsDeadOrGhost() then
                MainTankResDelay = nil
            else
                if not MainTankResDelay then
                    MainTankResDelay = GetTime() + GetOptionValue("立即战服坦克")
                end
                if
                GetTime() >= MainTankResDelay and Player:Buff(PredatorySwiftness) and
                MainTank:CanCast(RebirthInstant)
                then
                    MainTankResDelay = nil
                    Bug("Rebirth on MainTank")
                    MainTank:Cast(RebirthInstant)
                    return
                end
            end
        end
        if OffTank and OffTank:Exists() and OffTank:IsPlayer() then
            if not OffTank:IsDeadOrGhost() then
                OffTankResDelay = nil
            else
                if not OffTankResDelay then
                    OffTankResDelay = GetTime() + GetOptionValue("立即战服坦克")
                end
                if GetTime() >= OffTankResDelay and Player:Buff(PredatorySwiftness) and OffTank:CanCast(RebirthInstant) then
                    OffTankResDelay = nil
                    Bug("Rebirth on OffTank")
                    OffTank:Cast(RebirthInstant)
                    return
                end
            end
        end
    end
    if
    IsOptionEnabled("复生") and Target:Exists() and Target:IsDeadOrGhost() and Target:IsPlayer() and
    (not Player:IsMoving() or Player:Buff(PredatorySwiftness)) and
    Target:CanCast(Rebirth)
    then
        Bug("Rebirth on Target")
        Target:Cast(Rebirth)
        return
    end
    if IsOptionEnabled("自动亲和") then
        if RestorationAffinity:Exists() and not Player:Buff(CatForm) then
            self:RestorationAffinity()
        end
    end
    if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        Player:StartAttack()
        if Player:Buff(Berserk) and Player:Buff(Clearcasting) then
            FBValue = 12.5
        elseif Player:Buff(Berserk) or Player:Buff(Clearcasting) then
            FBValue = 25
        else
            FBValue = 50
        end
        RipTargetTTD = GetOptionValue("根据致死时间上割裂")
        RipCycleTTD = GetSecondOptionValue("根据致死时间上割裂")
        RakeTargetTTD = GetOptionValue("根据致死时间上斜掠")
        RakeCycleTTD = GetSecondOptionValue("根据致死时间上斜掠")
        RipTargetHP = GetOptionValue("根据目标血量上割裂") * 1000000
        RipCycleHP = GetSecondOptionValue("根据目标血量上割裂") * 1000000
        RakeTargetHP = GetOptionValue("根据目标血量上斜掠") * 1000000
        RakeCycleHP = GetSecondOptionValue("根据目标血量上斜掠") * 1000000
        if JaggedWounds:Exists() then
            RakePandemic = 3.015
            RipPandemic = 4.824
            ThrashPandemic = 3.015
            ThrashSmartDuration = 6.7
        else
            RakePandemic = 4.5
            RipPandemic = 7.2
            ThrashPandemic = 4.5
            ThrashSmartDuration = 10
        end
        SetOutput(
        "斜掠伤害:",
        (Target:Exists() and Target:DebuffRemains(RakeDebuff) > RakePandemic and "|cffFF0000" or "|cff00FF00") ..
        tostring(Target:Exists() and math.floor(Target:DebuffRemains(RakeDebuff)) or 0) ..
        "  " .. tostring(self.RakeDamageOutput)
        )
        SetOutput(
        "割裂伤害:",
        (Target:Exists() and Target:DebuffRemains(Rip) > RipPandemic and "|cffFF0000" or "|cff00FF00") ..
        tostring(Target:Exists() and math.floor(Target:DebuffRemains(Rip)) or 0) ..
        "  " .. tostring(self.RipDamageOutput)
        )
        if IsOptionEnabled("自动亲和") then
            if Player:Buff(MoonkinForm) then
                self:BalanceAffinity()
                return
            end
            if Player:Buff(BearForm) then
                self:GuardianAffinity()
                return
            end
        end
        if
        IsOptionEnabled("自动潜行") and Player:DistanceTo(Target) <= GetOptionValue("自动潜行") and not Player:Buff(CatForm) and
        Player:CanCast(CatForm)
        then
            Bug("Cat Form")
            Player:Cast(CatForm)
            return
        end
        if Player:Buff(CatForm) then
            if
            Rake:TimeSinceCast() > 0.5 and Player:IsStealthed(true, true) and
            Target:CanCast(Rake, true, true, false, false, true)
            then
                Rake.LastCastTime = GetTime()
                Bug("Rake")
                Target:Cast(Rake)
                return
            end
            if Player:IsStealthed(true, true) then
                Bug("Pooling for Rake")
                return
            end
            if
            IsOptionEnabled("高优先级 愈合") and Lowest and Player:Buff(PredatorySwiftness) and
            not Player:IsStealthed(true, true) and
            Lowest:HealthPercentage() <= GetOptionValue("高优先级 愈合") and
            Lowest:CanCast(Regrowth)
            then
                Bug("Regrowth (High Priority)")
                Lowest:Cast(Regrowth)
                return
            end
            if Target:Debuff(Rip) or CombatTime() > 15 then
                if Player:IsWithinCastRange(Target, Shred, true) then
                    if
                    Berserk:Exists() and CDOptionEnabled("狂暴") and Player:Energy() <= 30 and
                    (TigersFury:Cooldown() > 5 or Player:Buff(TigersFury)) and
                    not Incarnation:Exists() and
                    Player:CanCast(Berserk)
                    then
                        Bug("狂暴")
                        Player:Cast(Berserk)
                        return
                    end
                    if
                    TigersFury:Exists() and CDOptionEnabled("猛虎之怒") and Player:EnergyDeficit() >= 60 and
                    Player:CanCast(TigersFury)
                    then
                        TigersFurySync()
                        Bug("猛虎之怒")
                        Player:Cast(TigersFury)
                        return
                    end
                    if
                    ElunesGuidance:Exists() and CDOptionEnabled("月神的守护") and Player:ComboPoints() == 0 and
                    Player:Energy() >= 50 and
                    Player:CanCast(ElunesGuidance)
                    then
                        Bug("猛虎之怒")
                        Player:Cast(ElunesGuidance)
                        return
                    end
                    if
                    Incarnation:Exists() and CDOptionEnabled("狂暴") and Player:Energy() >= 30 and
                    (TigersFury:Cooldown() > 15 or Player:Buff(TigersFury)) and
                    Player:CanCast(Incarnation)
                    then
                        Bug("化身")
                        Player:Cast(Incarnation)
                        return
                    end
                    if
                    CDOptionEnabled("使用药水") and Target:IsBoss() and
                    ((Player:BuffRemains(Berserk) > 10 or Player:BuffRemains(Incarnation) > 20) and
                    Target:TimeToDie() <= 180)
                    then
                        Player:UsePotions("Agility")
                    end
                    if
                    AshamanesFrenzy:Exists() and CDOptionEnabled("阿莎曼的狂乱") and Player:ComboPoints() < 4 and
                    Player:ComboPoints() >= 2 and
                    (not Bloodtalons:Exists() or Player:Buff(BloodtalonsBuff)) and
                    Target:CanCast(AshamanesFrenzy, true, true, false, false, true)
                    then
                        Bug("Ashamane's Frenzy - Generator")
                        Target:Cast(AshamanesFrenzy)
                        return
                    end
                    if
                    Shadowmeld:Exists() and CDOptionEnabled("进攻性种族技能") and Player:Standing() >= 0.7 and
                    Player:ComboPoints() < 5 and
                    Player:Energy() >= 35 and
                    Target:BleedDamage(Rake) < 2.1 and
                    Player:Buff(TigersFury) and
                    (Player:Buff(Bloodtalons) or not Bloodtalons:Exists()) and
                    (not Incarnation:Exists() or Incarnation:Cooldown() > 18) and
                    not Player:Buff(Incarnation) and
                    Player:CanCast(Shadowmeld)
                    then
                        Bug("Shadowmeld - Generator")
                        Player:Cast(Shadowmeld)
                        return
                    end
                    if not IsOptionEnabled("饰品和猛虎之怒") or Player:Buff(TigersFury) or Player:BuffRemains(Incarnation) > 20 then
                        Player:UseTrinkets()
                    end
                end
                if
                Bloodtalons:Exists() and Player:Buff(PredatorySwiftness) and Player:ComboPoints() == 5 and
                Bloodtalons:Exists() and
                not Player:Buff(Bloodtalons) and
                (not Player:Buff(Incarnation) or Target:DebuffRemains(Rip) < 8 or Target:DebuffRemains(Rake) < 5)
                then
                    if self:CastHealCycle() then
                        Bug("Regrowth (Bloodtalons)")
                        return
                    end
                end
                if Player:ComboPoints() > 4 then
                    if SavageRoar:Exists() and not Player:Buff(SavageRoar) and Player:CanCast(SavageRoar, nil, true) then
                        if Player:CanCast(SavageRoar) then
                            Bug("Savage Roar - Finisher")
                            Player:Cast(SavageRoar)
                            return
                        else
                            Bug("Pooling for Savage Roar - Finisher")
                            return
                        end
                    end
                    RipTickTime = JaggedWounds:Exists() and 2 * (1 - 0.33) * 4 or 2 * 4
                    if
                    ((IsOptionEnabled("根据目标血量上割裂") and Target:Health() >= RipTargetHP) or
                    (not IsOptionEnabled("根据目标血量上割裂") and Target:TimeToDie() >= RipTargetTTD)) and
                    (not Target:Debuff(Rip) or Target:DebuffRemains(Rip) <= 5.6) and
                    ((Target:HealthPercentage() > 25 and not Sabertooth:Exists()) or
                    (Target:DebuffRemains(Rip) <= 15 and BleedDamage("割裂") > Target:RipDamage())) and
                    Target:CanCast(Rip, true, true, false, false, true)
                    then
                        Bug("Rip - Finisher")
                        Target:Cast(Rip)
                        return
                    end
                    if UseAOE() then
                        local ThisUnit
                        for i = 1, #Enemies_5y do
                            ThisUnit = Enemies_5y[i]
                            if
                            not ThisUnit:IsCrowdControlled() and
                            ((IsOptionEnabled("根据目标血量上割裂") and ThisUnit:Health() > RipCycleHP) or
                            (not IsOptionEnabled("根据目标血量上割裂") and ThisUnit:TimeToDie() > RipCycleTTD)) and
                            (not ThisUnit:Debuff(Rip) or ThisUnit:DebuffRemains(Rip) <= 5.6) and
                            ((ThisUnit:HealthPercentage() > 25 and not Sabertooth:Exists()) or
                            (ThisUnit:DebuffRemains(Rip) <= 15 and BleedDamage("割裂") > ThisUnit:RipDamage())) and
                            ThisUnit:CanCast(Rip, true, true, false, false, true)
                            then
                                Bug("Rip AoE - Finisher")
                                ThisUnit:Cast(Rip)
                                return
                            end
                        end
                    end
                    if
                    SavageRoar:Exists() and Player:BuffRemains(SavageRoar) < 12 and
                    Player:CanCast(SavageRoar, nil, true)
                    then
                        if Player:CanCast(SavageRoar) then
                            Bug("Savage Roar - Finisher")
                            Player:Cast(SavageRoar)
                            return
                        else
                            Bug("Pooling for Savage Roar - Finisher")
                            return
                        end
                    end
                    if
                    Maim:Exists() and IsOptionEnabled("割裂") and MaimEnemies >= GetOptionValue("割裂") and
                    FireyRedMaimers:IsEquipped(7) and
                    Player:Buff(FireyRedMaimersBuff) and
                    Target:CanCast(Maim, true, true, false, false, true)
                    then
                        Target:Cast(Maim)
                        return
                    end
                    if FerociousBite:Exists() and Player:EnergyTimeToMax() < 2 then
                        if
                        Target:Debuff(Rip) and Target:DebuffRemains(Rip) < 5.6 and Target:TimeToDie() > 3 and
                        (Sabertooth:Exists() or Target:HealthPercentage() < 25) and
                        Target:CanCast(FerociousBite, true, true, false, false, true)
                        then
                            Bug("Ferocious Bite")
                            Target:Cast(FerociousBite)
                            return
                        end
                        if UseAOE() then
                            local ThisUnit
                            for i = 1, #Enemies_5y do
                                ThisUnit = Enemies_5y[i]
                                if
                                not ThisUnit:IsCrowdControlled() and ThisUnit:Debuff(Rip) and
                                ThisUnit:DebuffRemains(Rip) < 5.6 and
                                ThisUnit:TimeToDie() > 3 and
                                (Sabertooth:Exists() or ThisUnit:HealthPercentage() < 25) and
                                ThisUnit:CanCast(FerociousBite, true, true, false, false, true)
                                then
                                    Bug("Ferocious Bite AoE")
                                    ThisUnit:Cast(FerociousBite)
                                    return
                                end
                            end
                        end
                        if Target:CanCast(FerociousBite, true, true, false, false, true) then
                            Bug("Ferocious Bite Filler")
                            Target:Cast(FerociousBite)
                            return
                        end
                    end
                    return
                end
                if
                AshamanesFrenzy:Exists() and Bloodtalons:Exists() and Player:Buff(PredatorySwiftness) and
                not Player:Buff(BloodtalonsBuff) and
                Player:ComboPoints() >= 2 and
                AshamanesFrenzy:Cooldown() < Player:GCD()
                then
                    if self:CastHealCycle() then
                        Bug("Ashamane's Frenzy Regrowth")
                        return
                    end
                end
                if
                Bloodtalons:Exists() and Player:Buff(PredatorySwiftness) and not Player:Buff(BloodtalonsBuff) and
                Player:ComboPoints() >= 4 and
                Target:DebuffRemains(Rake) < 4
                then
                    if self:CastHealCycle() then
                        Bug("Rake Regrowth")
                        return
                    end
                end
                if
                AiluroPouncers:IsEquipped(8) and Bloodtalons:Exists() and
                (Player:BuffCount(PredatorySwiftness) > 2 or
                (Player:BuffCount(PredatorySwiftness) > 1 and Target:DebuffRemains(RakeDebuff) < 3)) and
                not Player:Buff(BloodtalonsBuff)
                then
                    if self:CastHealCycle() then
                        Bug("Ailuro Pouncers Regrowth")
                        return
                    end
                end
                if
                BrutalSlash:Exists() and IsOptionEnabled("野蛮挥砍") and NumEnemies >= GetOptionValue("野蛮挥砍") and
                Player:CanCast(BrutalSlash)
                then
                    Bug("Brutal Slash - Generator")
                    Player:Cast(BrutalSlash)
                    return
                end
                if UseAOE() and IsOptionEnabled("痛击") and NumEnemies > 2 then
                    local Count = 0
                    local ThisUnit
                    for i = 1, #ThrashEnemies do
                        ThisUnit = ThrashEnemies[i]
                        if ThisUnit:DebuffRemains(ThrashDebuff) > ThrashSmartDuration then
                            Count = Count + 1
                        end
                    end
                    if NumEnemies - Count >= GetOptionValue("痛击") then
                        for i = 1, #ThrashEnemies do
                            ThisUnit = ThrashEnemies[i]
                            if ThisUnit:DebuffRefreshable(Thrash, ThrashPandemic) then
                                if Player:CanCast(Thrash) then
                                    Bug("Thrash - Generator")
                                    Player:Cast(Thrash)
                                    return
                                elseif Player:Energy() < 50 - (Player:Buff(Berserk) and 25 or 0) then
                                    Bug("Pooling for Thrash - Generator")
                                    return
                                end
                            end
                        end
                    end
                end
                if Rake:Exists() then
                    RakeTickTime = JaggedWounds:Exists() and 3 * (1 - 0.33) or 3
                    if
                    ((IsOptionEnabled("根据目标血量上斜掠") and Target:Health() > RakeTargetHP) or
                    (not IsOptionEnabled("根据目标血量上斜掠") and Target:TimeToDie() > RakeTargetTTD)) and
                    Target:TimeToDie() - Target:DebuffRemains(RakeDebuff) > RakeTickTime and
                    (not Target:Debuff(RakeDebuff) or
                    (not Bloodtalons:Exists() and Target:DebuffRefreshable(RakeDebuff, RakePandemic)) or
                    (Bloodtalons:Exists() and Player:Buff(BloodtalonsBuff) and
                    (Target:DebuffRemains(RakeDebuff) <= RakeRefresh) and
                    BleedDamage("Rake") >= Target:RakeDamage() * 0.8)) and
                    Target:TimeToDie() > Target:DebuffRemains(RakeDebuff) + RakeTickTime and
                    Target:CanCast(Rake, true, true, false, false, true)
                    then
                        if Target:CanCast(Rake, true, true, false, false, true) then
                            Bug("Rake - Generator")
                            Target:Cast(Rake)
                            return
                        else
                            Bug("Pooling for Rake - Generator")
                            return
                        end
                    end
                    if UseAOE() then
                        local ThisUnit
                        for i = 1, #Enemies_5y do
                            ThisUnit = Enemies_5y[i]
                            if
                            not ThisUnit:IsCrowdControlled() and
                            ((IsOptionEnabled("根据目标血量上斜掠") and ThisUnit:Health() > RakeCycleHP) or
                            (not IsOptionEnabled("根据目标血量上斜掠") and ThisUnit:TimeToDie() > RakeCycleTTD)) and
                            ThisUnit:TimeToDie() - ThisUnit:DebuffRemains(RakeDebuff) > RakeTickTime and
                            (not ThisUnit:Debuff(RakeDebuff) or
                            (not Bloodtalons:Exists() and
                            ThisUnit:DebuffRefreshable(RakeDebuff, RakePandemic)) or
                            (Bloodtalons:Exists() and Player:Buff(BloodtalonsBuff) and
                            (ThisUnit:DebuffRemains(RakeDebuff) <= RakeRefresh) and
                            BleedDamage("Rake") >= ThisUnit:RakeDamage() * 0.8)) and
                            ThisUnit:TimeToDie() > ThisUnit:DebuffRemains(RakeDebuff) + RakeTickTime and
                            ThisUnit:CanCast(Rake, true, true, false, false, true)
                            then
                                if ThisUnit:CanCast(Rake, true, true, false, false, true) then
                                    Bug("Rake AoE - Generator")
                                    ThisUnit:Cast(Rake)
                                    return
                                else
                                    Bug("Pooling for Rake AoE - Generator")
                                    return
                                end
                            end
                        end
                    end
                end
                if
                BrutalSlash:Exists() and IsOptionEnabled("野蛮挥砍") and UseAOE() and Player:DistanceTo(Target) < 8 and
                Player:Buff(TigersFury) and
                Player:CanCast(BrutalSlash)
                then
                    Bug("Brutal Slash - Generator")
                    Player:Cast(BrutalSlash)
                    return
                end
                if IsOptionEnabled("月火术") and LunarInspiration:Exists() then
                    MoonfireTickTime = (20 / (1 + UnitSpellHaste("player") / 100) / 10) * 2
                    if
                    Target:DebuffRefreshable(MoonfireDebuff, MoonfirePandemic) and
                    ((IsOptionEnabled("根据目标血量上斜掠") and Target:Health() > RakeTargetHP) or
                    (not IsOptionEnabled("根据目标血量上斜掠") and Target:TimeToDie() > RakeTargetTTD)) and
                    Target:DebuffRemains(MoonfireDebuff) < 4.2 and
                    Target:CanCast(Moonfire)
                    then
                        Bug("Moonfire - Generator")
                        Target:Cast(Moonfire)
                        return
                    end
                    if UseAOE() then
                        local ThisUnit
                        for i = 1, #Enemies_45y do
                            ThisUnit = Enemies_45y[i]
                            if
                            not ThisUnit:IsCrowdControlled() and
                            (GetSecondOptionValue("月火术") == "Everything" or ThisUnit:IsInCombat()) and
                            ThisUnit:DebuffRefreshable(MoonfireDebuff, MoonfirePandemic) and
                            ((IsOptionEnabled("根据目标血量上斜掠") and ThisUnit:Health() > RakeCycleHP) or
                            (not IsOptionEnabled("根据目标血量上斜掠") and ThisUnit:TimeToDie() > RakeCycleTTD)) and
                            ThisUnit:DebuffRemains(MoonfireDebuff) < 4.2 and
                            ThisUnit:CanCast(Moonfire)
                            then
                                Bug("Moonfire AoE - Generator")
                                ThisUnit:Cast(Moonfire)
                                return
                            end
                        end
                    end
                end
                if
                Thrash:Exists() and IsOptionEnabled("痛击") and Target:DebuffRefreshable(Thrash, ThrashPandemic) and
                (ThrashEnemies > 1 or (LuffaWrappings:IsEquipped(9) and Player:Buff(Clearcasting)))
                then
                    if Player:CanCast(Thrash) then
                        Bug("Thrash - Generator")
                        Player:Cast(Thrash)
                        return
                    elseif Player:Energy() < 50 - (Player:Buff(Berserk) and 25 or 0) then
                        Bug("Pooling for Thrash - Generator")
                        return
                    end
                end
                if
                UseAOE() and IsOptionEnabled("横扫") and not BrutalSlash:Exists() and NumEnemies > 1 and
                Player:CanCast(Swipe, nil, true)
                then
                    if Player:CanCast(SwipeCheckID) then
                        Bug("Swipe - Generator")
                        Player:Cast(Swipe)
                        return
                    else
                        Bug("Pooling for Swipe - Generator")
                        return
                    end
                end
                if
                Shred:Exists() and (BrutalSlash:Exists() or NumEnemies < 2 or not IsOptionEnabled("横扫")) and
                Target:CanCast(Shred, true, true, false, false, true)
                then
                    Bug("Shred - Generator")
                    Target:Cast(Shred)
                    return
                end
                return
            end
            if Rake:Exists() and not Target:Debuff(RakeDebuff) and Target:CanCast(Rake) then
                Bug("Moonfire - Opener")
                Target:Cast(Rake)
                return
            end
            if
            Moonfire:Exists() and LunarInspiration:Exists() and not Target:Debuff(Moonfire) and
            Target:CanCast(MoonfireDebuff)
            then
                Bug("Moonfire - Opener")
                Target:Cast(Moonfire)
                return
            end
            if SavageRoar:Exists() and not Player:Buff(SavageRoar) and Player:CanCast(SavageRoar) then
                Bug("Savage Roar - Opener")
                Player:Cast(SavageRoar)
                return
            end
            if Berserk:Exists() and not Incarnation:Exists() and CDOptionEnabled("狂暴") and Player:CanCast(Berserk) then
                Bug("Berserk - Opener")
                Player:Cast(Berserk)
                return
            end
            if Incarnation:Exists() and CDOptionEnabled("狂暴") and Player:CanCast(Incarnation) then
                Bug("Incarnation - Opener")
                Player:Cast(Incarnation)
                return
            end
            if TigersFury:Exists() and CDOptionEnabled("猛虎之怒") and Player:CanCast(TigersFury) then
                Bug("Tiger's Fury - Opener")
                Player:Cast(TigersFury)
                return
            end
            if AshamanesFrenzy:Exists() and CDOptionEnabled("阿莎曼的狂乱") and Target:CanCast(AshamanesFrenzy) then
                Bug("Ashamane's Frenzy - Opener")
                Target:Cast(AshamanesFrenzy)
                return
            end
            if
            Regrowth:Exists() and Player:Buff(PredatorySwiftness) and Bloodtalons:Exists() and
            not Player:Buff(BloodtalonsBuff) and
            Player:ComboPoints() == 5
            then
                if self:CastHealCycle() then
                    Bug("Regrowth - Opener")
                    return
                end
            end
            if Rip:Exists() and Player:ComboPoints() >= 5 and Target:CanCast(Rip) then
                Bug("Rip - Opener")
                Target:Cast(Rip)
                return
            end
            if
            Thrash:Exists() and not Target:Debuff(ThrashDebuff) and LuffaWrappings:IsEquipped(9) and
            Player:CanCast(Thrash)
            then
                Player:Cast(Thrash)
                return
            end
            if Shred:Exists() and Target:CanCast(Shred) then
                Bug("Shred - Opener")
                Target:Cast(Shred)
                return
            end
        end
    end
end
function Rotation:Combat()
    local RakeRefresh = 7
    RakeRefresh = (AiluroPouncers:IsEquipped(8) or SoulOfTheForest:Exists()) and 3 or RakeRefresh
    local Pooling = 3
    Pooling = ChatoyantSignet:IsEquipped(11, 12) and 10 or Pooling
    Pooling = TheWildshapersClutch:IsEquipped(10) and not ChatoyantSignet:IsEquipped(11, 12) and 3 or Pooling
    local RipTargetTTD, RipCycleTTD, RakeTargetTTD, RakeCycleTTD = 0, 0, 0, 0
    local RipTargetHP, RipCycleHP, RakeTargetHP, RakeCycleHP = 0, 0, 0, 0
    local RakeTickTime, MoonfireTickTime, RipTickTime, ThrashTickTime = 3, 2, 2, JaggedWounds:Exists() and 1.9 or 2.5
    local RakePandemic, RipPandemic, ThrashPandemic, ThrashSmartDuration, MoonfirePandemic = 4.5, 7.2, 4.5, 10, 4.2
    if IsOptionEnabled("立即战服坦克") then
        MainTank, MainTankTarget, OffTank, OffTankTarget = Unit.GetMainTanks()
        if MainTank and MainTank:Exists() and MainTank:IsPlayer() then
            if not MainTank:IsDeadOrGhost() then
                MainTankResDelay = nil
            else
                if not MainTankResDelay then
                    MainTankResDelay = GetTime() + GetOptionValue("立即战服坦克")
                end
                if
                GetTime() >= MainTankResDelay and Player:Buff(PredatorySwiftness) and
                MainTank:CanCast(RebirthInstant)
                then
                    MainTankResDelay = nil
                    Bug("Rebirth on MainTank")
                    MainTank:Cast(RebirthInstant)
                    return
                end
            end
        end
        if OffTank and OffTank:Exists() and OffTank:IsPlayer() then
            if not OffTank:IsDeadOrGhost() then
                OffTankResDelay = nil
            else
                if not OffTankResDelay then
                    OffTankResDelay = GetTime() + GetOptionValue("立即战服坦克")
                end
                if GetTime() >= OffTankResDelay and Player:Buff(PredatorySwiftness) and OffTank:CanCast(RebirthInstant) then
                    OffTankResDelay = nil
                    Bug("Rebirth on OffTank")
                    OffTank:Cast(RebirthInstant)
                    return
                end
            end
        end
    end
    if
    IsOptionEnabled("复生") and Target:Exists() and Target:IsDeadOrGhost() and Target:IsPlayer() and
    (not Player:IsMoving() or Player:Buff(PredatorySwiftness)) and
    Target:CanCast(Rebirth)
    then
        Bug("Rebirth on Target")
        Target:Cast(Rebirth)
        return
    end
    if IsOptionEnabled("自动亲和") then
        if RestorationAffinity:Exists() and not Player:Buff(CatForm) then
            self:RestorationAffinity()
        end
    end
    if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        Player:StartAttack()
        if Player:Buff(Berserk) and Player:Buff(Clearcasting) then
            FBValue = 12.5
        elseif Player:Buff(Berserk) or Player:Buff(Clearcasting) then
            FBValue = 25
        else
            FBValue = 50
        end
        RipTargetTTD = GetOptionValue("根据致死时间上割裂")
        RipCycleTTD = GetSecondOptionValue("根据致死时间上割裂")
        RakeTargetTTD = GetOptionValue("根据致死时间上斜掠")
        RakeCycleTTD = GetSecondOptionValue("根据致死时间上斜掠")
        RipTargetHP = GetOptionValue("根据目标血量上割裂") * 1000000
        RipCycleHP = GetSecondOptionValue("根据目标血量上割裂") * 1000000
        RakeTargetHP = GetOptionValue("根据目标血量上斜掠") * 1000000
        RakeCycleHP = GetSecondOptionValue("根据目标血量上斜掠") * 1000000
        if JaggedWounds:Exists() then
            RakePandemic = 3.015
            RipPandemic = 4.824
            ThrashPandemic = 3.015
            ThrashSmartDuration = 6.7
        else
            RakePandemic = 4.5
            RipPandemic = 7.2
            ThrashPandemic = 4.5
            ThrashSmartDuration = 10
        end
        SetOutput(
        "斜掠伤害:",
        (Target:Exists() and Target:DebuffRemains(RakeDebuff) > RakePandemic and "|cffFF0000" or "|cff00FF00") ..
        tostring(Target:Exists() and math.floor(Target:DebuffRemains(RakeDebuff)) or 0) ..
        "  " .. tostring(self.RakeDamageOutput)
        )
        SetOutput(
        "割裂伤害:",
        (Target:Exists() and Target:DebuffRemains(Rip) > RipPandemic and "|cffFF0000" or "|cff00FF00") ..
        tostring(Target:Exists() and math.floor(Target:DebuffRemains(Rip)) or 0) ..
        "  " .. tostring(self.RipDamageOutput)
        )
        if IsOptionEnabled("自动亲和") then
            if Player:Buff(MoonkinForm) then
                self:BalanceAffinity()
                return
            end
            if Player:Buff(BearForm) then
                self:GuardianAffinity()
                return
            end
        end
        if
        IsOptionEnabled("自动潜行") and Player:DistanceTo(Target) <= GetOptionValue("自动潜行") and not Player:Buff(CatForm) and
        Player:CanCast(CatForm)
        then
            Bug("Cat Form")
            Player:Cast(CatForm)
            return
        end
        if Player:Buff(CatForm) then
            if
            Rake:TimeSinceCast() > 0.5 and Player:IsStealthed(true, true) and
            Target:CanCast(Rake, true, true, false, false, true)
            then
                Rake.LastCastTime = GetTime()
                Bug("Rake")
                Target:Cast(Rake)
                return
            end
            if Player:IsStealthed(true, true) then
                Bug("Pooling for Rake")
                return
            end
            if
            IsOptionEnabled("高优先级 愈合") and Lowest and Player:Buff(PredatorySwiftness) and
            not Player:IsStealthed(true, true) and
            Lowest:HealthPercentage() <= GetOptionValue("高优先级 愈合") and
            Lowest:CanCast(Regrowth)
            then
                Bug("Regrowth (High Priority)")
                Lowest:Cast(Regrowth)
                return
            end
            if Player:IsWithinCastRange(Target, Shred, true) then
                if
                CDOptionEnabled("狂暴") and Player:Buff(TigersFury) and Player:EnergyTimeToMax() > Player:GCD() and
                not Incarnation:Exists() and
                Player:CanCast(Berserk)
                then
                    Bug("狂暴")
                    Player:Cast(Berserk)
                    return
                end
                if
                CDOptionEnabled("狂暴") and Incarnation:Exists() and not SavageRoar:Exists() and
                not SoulOfTheForest:Exists() and
                TigersFury:Cooldown() < Player:GCD() and
                Player:CanCast(Incarnation)
                then
                    Bug("化身")
                    Player:Cast(Incarnation)
                    return
                end
                if not IsOptionEnabled("饰品和猛虎之怒") or Player:Buff(TigersFury) or Player:BuffRemains(Incarnation) > 20 then
                    Player:UseTrinkets()
                end
                if
                CDOptionEnabled("使用药水") and
                (Player:BuffRemains(Berserk) > 10 or Player:BuffRemains(Incarnation) > 20) and
                Target:TimeToDie() <= 180
                then
                    Player:UsePotions("Agility")
                end
                if CDOptionEnabled("猛虎之怒") then
                    if
                    ((not Player:Buff(Clearcasting) and Player:EnergyDeficit() >= 60) or
                    Player:EnergyDeficit() >= 80) and
                    Player:CanCast(TigersFury)
                    then
                        TigersFurySync()
                        Bug("猛虎之怒")
                        Player:Cast(TigersFury)
                        return
                    end
                end
                if
                CDOptionEnabled("狂暴") and Incarnation:Exists() and not Player:Buff(Berserk) and
                (Player:EnergyTimeToMax() > 1 or TheWildshapersClutch:IsEquipped(10)) and
                Player:Energy() >= 35 and
                Player:CanCast(Berserk)
                then
                    Bug("化身")
                    Player:Cast(Berserk)
                    return
                end
            end
            if
            Target:Debuff(Rip) and Target:DebuffRemains(Rip) < 3 and Target:TimeToDie() > 3 and
            (Sabertooth:Exists() or Target:HealthPercentage() < 25) and
            Target:CanCast(FerociousBite, true, true, false, false, true)
            then
                Bug("Ferocious Bite")
                Target:Cast(FerociousBite)
                return
            end
            if UseAOE() then
                local ThisUnit
                for i = 1, #Enemies_5y do
                    ThisUnit = Enemies_5y[i]
                    if
                    not ThisUnit:IsCrowdControlled() and ThisUnit:Debuff(Rip) and ThisUnit:DebuffRemains(Rip) < 3 and
                    ThisUnit:TimeToDie() > 3 and
                    (Sabertooth:Exists() or ThisUnit:HealthPercentage() < 25) and
                    ThisUnit:CanCast(FerociousBite, true, true, false, false, true)
                    then
                        Bug("Ferocious Bite AoE")
                        ThisUnit:Cast(FerociousBite)
                        return
                    end
                end
            end
            if
            (Bloodtalons:Exists() and Player:BuffRemains(PredatorySwiftness) > 0 and
            not Player:Buff(BloodtalonsBuff) and
            (Player:ComboPoints() >= 5 or Player:BuffRemains(PredatorySwiftness) < 1.5 or
            (Player:ComboPoints() == 2 and AshamanesFrenzy:Exists() and
            AshamanesFrenzy:Cooldown() < Player:GCD()) or
            (ElunesGuidance:Exists() and
            ((ElunesGuidance:Cooldown() < Player:GCD() and Player:ComboPoints() == 0) or
            (Player:Buff(ElunesGuidance) and Player:ComboPoints() >= 4)))))
            then
                if self:CastHealCycle() then
                    Bug("Regrowth (Bloodtalons)")
                    return
                end
            end
            if CombatTime() < 20 and Sabertooth:Exists() and Player:ComboPoints() == 5 and not Target:Debuff(Rip) then
                if Bloodtalons:Exists() and not Player:Buff(BloodtalonsBuff) then
                    if self:CastHealCycle() then
                        Bug("Bloodtalons - sbt_opener")
                        return
                    end
                end
                if Player:CanCast(TigersFury) then
                    Bug("Tiger's Fury - sbt_opener")
                    Player:Cast(TigersFury)
                    return
                end
            end
            if
            AiluroPouncers:IsEquipped(8) and Bloodtalons:Exists() and
            (Player:BuffCount(PredatorySwiftness) > 2 or
            (Player:BuffCount(PredatorySwiftness) > 1 and Target:DebuffRemains(RakeDebuff) < 3)) and
            not Player:Buff(BloodtalonsBuff)
            then
                if self:CastHealCycle() then
                    Bug("Ailuro Pouncers Regrowth")
                    return
                end
            end
            if
            AiluroPouncers:IsEquipped(8) and Bloodtalons:Exists() and Player:Buff(PredatorySwiftness) and
            Player:BuffRemains(PredatorySwiftness) < 1.5 and
            not Player:Buff(BloodtalonsBuff) and
            not BrutalSlash:Exists() and
            not MomentOfClarity:Exists()
            then
                if self:CastHealCycle() then
                    Bug("Ailuro Pouncers Regrowth 2")
                    return
                end
            end
            if
            SavageRoar:Exists() and not Player:Buff(SavageRoar) and
            (Player:ComboPoints() == 5 or
            (BrutalSlash:Exists() and NumEnemies >= GetOptionValue("野蛮挥砍") and BrutalSlash:Charges() > 0 and
            Player:ComboPoints() >= 1)) and
            Player:CanCast(SavageRoar, nil, true)
            then
                if Player:CanCast(SavageRoar) then
                    Bug("Savage Roar - Finisher")
                    Player:Cast(SavageRoar)
                    return
                else
                    Bug("Pooling for Savage Roar - Finisher")
                    return
                end
            end
            if UseAOE() and IsOptionEnabled("痛击") and NumEnemies >= 5 then
                local Count = 0
                local ThisUnit
                for i = 1, #ThrashEnemies do
                    ThisUnit = ThrashEnemies[i]
                    if ThisUnit:DebuffRemains(ThrashDebuff) > ThrashSmartDuration then
                        Count = Count + 1
                    end
                end
                if NumEnemies - Count >= GetOptionValue("痛击") then
                    for i = 1, #ThrashEnemies do
                        ThisUnit = ThrashEnemies[i]
                        if ThisUnit:DebuffRefreshable(Thrash, ThrashPandemic) then
                            if Player:CanCast(Thrash) then
                                Bug("Thrash - Finisher")
                                Player:Cast(Thrash)
                                return
                            elseif Player:Energy() < 50 - (Player:Buff(Berserk) and 25 or 0) then
                                Bug("Pooling for Thrash - Finisher")
                                return
                            end
                        end
                    end
                end
            end
            if
            UseAOE() and IsOptionEnabled("横扫") and not BrutalSlash:Exists() and NumEnemies >= 8 and
            Player:CanCast(Swipe, nil, true)
            then
                if Player:CanCast(SwipeCheckID) then
                    Bug("Swipe - Finisher")
                    Player:Cast(Swipe)
                    return
                else
                    Bug("Pooling for Swipe - Finisher")
                    return
                end
            end
            if Player:ComboPoints() == 5 then
                RipTickTime = JaggedWounds:Exists() and 2 * (1 - 0.33) * 4 or 2 * 4
                if
                ((IsOptionEnabled("根据目标血量上割裂") and Target:Health() >= RipTargetHP) or
                (not IsOptionEnabled("根据目标血量上割裂") and Target:TimeToDie() >= RipTargetTTD)) and
                (not Target:Debuff(Rip) or
                (Target:DebuffRemains(Rip) < 8 and Target:HealthPercentage() > 25 and
                not Sabertooth:Exists()) or
                BleedDamage("割裂") > Target:RipDamage()) and
                Target:TimeToDie() - Target:DebuffRemains(Rip) > RipTickTime and
                Player:ComboPoints() == 5 and
                (Player:EnergyTimeToMax() < Pooling or Player:Buff(Berserk) or Player:Buff(Incarnation) or
                Player:Buff(ElunesGuidance) or
                TigersFury:Cooldown() < 3 or
                HasT18_4Pc or
                (Player:Buff(Clearcasting) and Player:Energy() > 65) or
                SoulOfTheForest:Exists() or
                not Target:Debuff(Rip) or
                (Target:DebuffRemains(RakeDebuff) < 1.5 and NumEnemies < 6)) and
                Target:CanCast(Rip, true, true, false, false, true)
                then
                    Bug("Rip - Finisher")
                    Target:Cast(Rip)
                    return
                end
                if UseAOE() then
                    local ThisUnit
                    for i = 1, #Enemies_5y do
                        ThisUnit = Enemies_5y[i]
                        if
                        not ThisUnit:IsCrowdControlled() and
                        ((IsOptionEnabled("根据目标血量上割裂") and ThisUnit:Health() > RipCycleHP) or
                        (not IsOptionEnabled("根据目标血量上割裂") and ThisUnit:TimeToDie() > RipCycleTTD)) and
                        (not ThisUnit:Debuff(Rip) or
                        (ThisUnit:DebuffRemains(Rip) < 8 and ThisUnit:HealthPercentage() > 25 and
                        not Sabertooth:Exists()) or
                        BleedDamage("割裂") > ThisUnit:RipDamage()) and
                        ThisUnit:TimeToDie() - ThisUnit:DebuffRemains(Rip) > RipTickTime and
                        Player:ComboPoints() == 5 and
                        (Player:EnergyTimeToMax() < Pooling or Player:Buff(Berserk) or Player:Buff(Incarnation) or
                        Player:Buff(ElunesGuidance) or
                        TigersFury:Cooldown() < 3 or
                        HasT18_4Pc or
                        (Player:Buff(Clearcasting) and Player:Energy() > 65) or
                        SoulOfTheForest:Exists() or
                        not ThisUnit:Debuff(Rip) or
                        (ThisUnit:DebuffRemains(RakeDebuff) < 1.5 and NumEnemies < 6)) and
                        ThisUnit:CanCast(Rip, true, true, false, false, true)
                        then
                            Bug("Rip AoE - Finisher")
                            ThisUnit:Cast(Rip)
                            return
                        end
                    end
                end
                if
                ((Player:BuffRemains(SavageRoar) <= 10.5 and Bloodtalons:Exists()) or
                (Player:BuffRemains(SavageRoar) <= 7.2)) and
                Player:ComboPoints() == 5 and
                (Player:EnergyTimeToMax() < Pooling or Player:Buff(Berserk) or Player:Buff(Incarnation) or
                Player:Buff(ElunesGuidance) or
                TigersFury:Cooldown() < 3 or
                (Player:Buff(Clearcasting) and Player:Energy() > 65) or
                SoulOfTheForest:Exists() or
                not Target:Debuff(Rip) or
                (Target:DebuffRemains(RakeDebuff) < 1.5 and NumEnemies < 6)) and
                SavageRoar:Exists()
                then
                    Bug("Savage Roar 2 - Finisher")
                    Player:Cast(SavageRoar)
                    return
                end
                if
                Swipe:Exists() and not BrutalSlash:Exists() and Player:ComboPoints() == 5 and
                (NumEnemies >= 6 or (NumEnemies >= 3 and not Bloodtalons:Exists())) and
                Player:ComboPoints() == 5 and
                (Player:EnergyTimeToMax() < Pooling or Player:Buff(Berserk) or Player:Buff(Incarnation) or
                Player:Buff(ElunesGuidance) or
                TigersFury:Cooldown() < 3 or
                (MomentOfClarity:Exists() and Player:Buff(Clearcasting))) and
                Player:CanCast(SwipeCheckID)
                then
                    Bug("Swipe 2 - Finisher")
                    Player:Cast(Swipe)
                    return
                end
                if
                Maim:Exists() and IsOptionEnabled("割裂") and MaimEnemies >= GetOptionValue("割裂") and
                FireyRedMaimers:IsEquipped(7) and
                Player:Buff(FireyRedMaimersBuff) and
                (Player:EnergyTimeToMax() < Pooling or Player:Buff(Berserk) or Player:Buff(Incarnation) or
                Player:Buff(ElunesGuidance) or
                TigersFury:Cooldown() < 3) and
                Target:CanCast(Maim, true, true, false, false, true)
                then
                    Target:Cast(Maim)
                    return
                end
                if
                Player:Energy() >= 50 and Player:ComboPoints() == 5 and
                (Player:EnergyTimeToMax() < Pooling or Player:Buff(Berserk) or Player:Buff(Incarnation) or
                Player:Buff(ElunesGuidance) or
                TigersFury:Cooldown() < 3) and
                Target:CanCast(FerociousBite, true, true, false, false, true)
                then
                    if Player:Energy() >= FBValue then
                        Bug("Ferocious Bite - Finisher")
                        Target:Cast(FerociousBite)
                        return
                    else
                        Bug("Pooling for Ferocious Bite - Finisher")
                        return
                    end
                end
                if UseAOE() then
                    local ThisUnit
                    local StaticCondition =                     Player:Energy() >= 50 and Player:ComboPoints() == 5 and
                    (Player:EnergyTimeToMax() < Pooling or Player:Buff(Berserk) or Player:Buff(Incarnation) or
                    Player:Buff(ElunesGuidance) or
                    TigersFury:Cooldown() < 3)
                    for i = 1, #Enemies_5y do
                        ThisUnit = Enemies_5y[i]
                        if
                        not ThisUnit:IsCrowdControlled() and StaticCondition and
                        ThisUnit:CanCast(FerociousBite, true, true, false, false, true)
                        then
                            if Player:Energy() >= FBValue then
                                Bug("Ferocious Bite AoE - Finisher")
                                ThisUnit:Cast(FerociousBite)
                                return
                            else
                                Bug("Pooling for Ferocious Bite AoE - Finisher")
                                return
                            end
                        end
                    end
                end
            end
            if
            BrutalSlash:Exists() and IsOptionEnabled("野蛮挥砍") and Player:ComboPoints() < 5 and
            NumEnemies >= GetOptionValue("野蛮挥砍") and
            Player:CanCast(BrutalSlash)
            then
                Bug("Brutal Slash - Generator")
                Player:Cast(BrutalSlash)
                return
            end
            if
            CDOptionEnabled("阿莎曼的狂乱") and AshamanesFrenzy:Exists() and Player:ComboPoints() <= 2 and
            not Player:Buff(ElunesGuidance) and
            (not Bloodtalons:Exists() or Player:Buff(BloodtalonsBuff)) and
            (not SavageRoar:Exists() or Player:Buff(SavageRoar)) and
            Target:CanCast(AshamanesFrenzy, true, true, false, false, true)
            then
                Bug("Ashamane's Frenzy - Generator")
                Target:Cast(AshamanesFrenzy)
                return
            end
            if
            ElunesGuidance:Exists() and CDOptionEnabled("月神的守护") and Player:ComboPoints() == 0 and
            Player:CanCast(ElunesGuidance)
            then
                if Player:Energy() >= FBValue then
                    Bug("Elune's Guidance - Generator")
                    Player:Cast(ElunesGuidance)
                    return
                else
                    Bug("Pooling for Elune's Guidance - Generator")
                    return
                end
            end
            if
            UseAOE() and IsOptionEnabled("痛击") and BrutalSlash:Exists() and NumEnemies >= 9 and
            Player:CanCast(Thrash, nil, true)
            then
                if Player:CanCast(Thrash) then
                    Bug("Thrash - Generator")
                    Player:Cast(Thrash)
                    return
                elseif Player:Energy() < 50 - (Player:Buff(Berserk) and 25 or 0) then
                    Bug("Pooling for Thrash - Generator")
                    return
                end
            end
            if
            UseAOE() and IsOptionEnabled("横扫") and not BrutalSlash:Exists() and NumEnemies >= 6 and
            Player:CanCast(Swipe, nil, true)
            then
                if Player:CanCast(SwipeCheckID) then
                    Bug("Swipe - Generator")
                    Player:Cast(Swipe)
                    return
                else
                    Bug("Pooling for Swipe - Generator")
                    return
                end
            end
            if
            Shadowmeld:Exists() and CDOptionEnabled("进攻性种族技能") and Player:Standing() >= 0.7 and
            Player:ComboPoints() < 5 and
            (Player:Buff(Clearcasting) or Player:Energy() >= 35 - (Player:Buff(Berserk) and 17.5 or 0)) and
            Target:RakeDamage() < 2.1 and
            Player:Buff(TigersFury) and
            (not Bloodtalons:Exists() or Player:Buff(BloodtalonsBuff)) and
            (not Incarnation:Exists() or (not Player:Buff(Incarnation) and Incarnation:Cooldown() > 18)) and
            Player:CanCast(Shadowmeld)
            then
                Bug("Shadowmeld - Generator")
                Player:Cast(Shadowmeld)
                return
            end
            if IsOptionEnabled("野蛮挥砍储存能量") then
                ShouldCombo =                 (TheWildshapersClutch:IsEquipped(10) and
                ((Player:ComboPoints() < 5 and
                ((not ChatoyantSignet:IsEquipped(11, 12) and Player:EnergyTimeToMax() < Player:GCD()) or
                (ChatoyantSignet:IsEquipped(11, 12) and Player:EnergyTimeToX(100) <= Player:GCD()))) or
                Player:ComboPoints() < 3)) or
                (BrutalSlash:Exists() and NumEnemies < GetOptionValue("野蛮挥砍") and
                ((Player:ComboPoints() < 5 and
                (Player:EnergyTimeToMax() <= Player:GCD() or BrutalSlash:Charges() < 1)) or
                Player:ComboPoints() < 3)) or
                (not BrutalSlash:Exists() and not TheWildshapersClutch:IsEquipped(10) and Player:ComboPoints() < 5)
            else
                ShouldCombo =                 (not TheWildshapersClutch:IsEquipped(10) and Player:ComboPoints() < 5) or
                (TheWildshapersClutch:IsEquipped(10) and
                ((Player:ComboPoints() < 5 and
                ((not ChatoyantSignet:IsEquipped(11, 12) and Player:EnergyTimeToMax() < Player:GCD()) or
                (ChatoyantSignet:IsEquipped(11, 12) and Player:EnergyTimeToX(100) <= Player:GCD()))) or
                Player:ComboPoints() < 3))
            end
            if
            UseAOE() and IsOptionEnabled("痛击") and LuffaWrappings:IsEquipped(9) and AiluroPouncers:IsEquipped(8) and
            HasT19_4Pc and
            Target:DebuffRemains(ThrashDebuff) <= ThrashPandemic and
            (NumEnemies >= 3 and (Player:Buff(Bloodtalons) or Player:Buff(Clearcasting))) and
            Player:DistanceTo(Target) <= self.ThrashRange and
            Player:CanCast(Thrash)
            then
                Bug("Pooling for Thrash - Custom Thrash")
                Player:Cast(Thrash)
                return
            end
            if Player:ComboPoints() < 5 then
                RakeTickTime = JaggedWounds:Exists() and 3 * (1 - 0.33) or 3
                if
                ((IsOptionEnabled("根据目标血量上斜掠") and Target:Health() > RakeTargetHP) or
                (not IsOptionEnabled("根据目标血量上斜掠") and Target:TimeToDie() > RakeTargetTTD)) and
                Target:TimeToDie() - Target:DebuffRemains(RakeDebuff) > RakeTickTime and
                (not Target:Debuff(RakeDebuff) or
                (not Bloodtalons:Exists() and Target:DebuffRefreshable(RakeDebuff, RakePandemic)) or
                (Bloodtalons:Exists() and Player:Buff(BloodtalonsBuff) and
                (Target:DebuffRemains(RakeDebuff) <= RakeRefresh) and
                BleedDamage("Rake") >= Target:RakeDamage() * 0.8)) and
                Target:TimeToDie() > Target:DebuffRemains(RakeDebuff) + RakeTickTime and
                Target:CanCast(Rake, true, true, false, false, true)
                then
                    if Target:CanCast(Rake, true, true, false, false, true) then
                        Bug("Rake - Generator")
                        Target:Cast(Rake)
                        return
                    else
                        Bug("Pooling for Rake - Generator")
                        return
                    end
                end
                if UseAOE() then
                    local ThisUnit
                    for i = 1, #Enemies_5y do
                        ThisUnit = Enemies_5y[i]
                        if
                        not ThisUnit:IsCrowdControlled() and
                        ((IsOptionEnabled("根据目标血量上斜掠") and ThisUnit:Health() > RakeCycleHP) or
                        (not IsOptionEnabled("根据目标血量上斜掠") and ThisUnit:TimeToDie() > RakeCycleTTD)) and
                        ThisUnit:TimeToDie() - ThisUnit:DebuffRemains(RakeDebuff) > RakeTickTime and
                        (not ThisUnit:Debuff(RakeDebuff) or
                        (not Bloodtalons:Exists() and ThisUnit:DebuffRefreshable(RakeDebuff, RakePandemic)) or
                        (Bloodtalons:Exists() and Player:Buff(BloodtalonsBuff) and
                        (ThisUnit:DebuffRemains(RakeDebuff) <= RakeRefresh) and
                        BleedDamage("Rake") >= ThisUnit:RakeDamage() * 0.8)) and
                        ThisUnit:TimeToDie() > ThisUnit:DebuffRemains(RakeDebuff) + RakeTickTime and
                        ThisUnit:CanCast(Rake, true, true, false, false, true)
                        then
                            if ThisUnit:CanCast(Rake, true, true, false, false, true) then
                                Bug("Rake AoE - Generator")
                                ThisUnit:Cast(Rake)
                                return
                            else
                                Bug("Pooling for Rake AoE - Generator")
                                return
                            end
                        end
                    end
                end
            end
            if IsOptionEnabled("月火术") and LunarInspiration:Exists() and Player:ComboPoints() < 5 then
                MoonfireTickTime = (20 / (1 + UnitSpellHaste("player") / 100) / 10) * 2
                if
                Target:DebuffRefreshable(MoonfireDebuff, MoonfirePandemic) and
                ((IsOptionEnabled("根据目标血量上斜掠") and Target:Health() > RakeTargetHP) or
                (not IsOptionEnabled("根据目标血量上斜掠") and Target:TimeToDie() > RakeTargetTTD)) and
                Target:TimeToDie() - Target:DebuffRemains(MoonfireDebuff) > MoonfireTickTime and
                Target:CanCast(Moonfire)
                then
                    Bug("Moonfire - Generator")
                    Target:Cast(Moonfire)
                    return
                end
                if UseAOE() then
                    local ThisUnit
                    for i = 1, #Enemies_45y do
                        ThisUnit = Enemies_45y[i]
                        if
                        not ThisUnit:IsCrowdControlled() and
                        (GetSecondOptionValue("月火术") == "Everything" or ThisUnit:IsInCombat()) and
                        ThisUnit:DebuffRefreshable(MoonfireDebuff, MoonfirePandemic) and
                        ((IsOptionEnabled("根据目标血量上斜掠") and ThisUnit:Health() > RakeCycleHP) or
                        (not IsOptionEnabled("根据目标血量上斜掠") and ThisUnit:TimeToDie() > RakeCycleTTD)) and
                        ThisUnit:TimeToDie() - ThisUnit:DebuffRemains(MoonfireDebuff) > MoonfireTickTime and
                        ThisUnit:CanCast(Moonfire)
                        then
                            Bug("Moonfire AoE - Generator")
                            ThisUnit:Cast(Moonfire)
                            return
                        end
                    end
                end
            end
            if
            IsOptionEnabled("痛击") and HasT19_4Pc and Target:DebuffRemains(ThrashDebuff) <= ThrashPandemic and
            Player:ComboPoints() < 5 and
            (NumEnemies >= 2 or
            ((LuffaWrappings:IsEquipped(9) or Player:Buff(Clearcasting)) and
            (AiluroPouncers:IsEquipped(8) or not Player:Buff(Bloodtalons)))) and
            Player:DistanceTo(Target) <= self.ThrashRange and
            Player:CanCast(Thrash)
            then
                Bug("Thrash - With Clearcast 1")
                Player:Cast(Thrash)
                return
            end
            if
            IsOptionEnabled("痛击") and not HasT19_4Pc and Target:DebuffRemains(ThrashDebuff) <= ThrashPandemic and
            (NumEnemies >= 2 or
            (Player:Buff(Clearcasting) and LuffaWrappings:IsEquipped(9) and
            (AiluroPouncers:IsEquipped(8) or not Player:Buff(BloodtalonsBuff)))) and
            Player:DistanceTo(Target) <= self.ThrashRange and
            Player:CanCast(Thrash)
            then
                Bug("Thrash - With Clearcast 2")
                Player:Cast(Thrash)
                return
            end
            if ShouldCombo then
                if
                BrutalSlash:Exists() and IsOptionEnabled("野蛮挥砍") and GetSecondOptionValue("野蛮挥砍") == "防止上限" and
                BrutalSlash:FractionalCharges() > 2.6 and
                Player:DistanceTo(Target, false, true) <= 8 + (BalanceAffinity:Exists() and 5 or 0) and
                NumEnemies >= 1 and
                Player:CanCast(BrutalSlash)
                then
                    Bug("Brutal Slash 2 - Generator")
                    Player:Cast(BrutalSlash)
                    return
                end
                if
                UseAOE() and Swipe:Exists() and not BrutalSlash:Exists() and IsOptionEnabled("横扫") and
                NumEnemies >= 3 and
                Player:CanCast(SwipeCheckID)
                then
                    Bug("Swipe 2 - Generator")
                    Player:Cast(Swipe)
                    return
                end
                if
                (BrutalSlash:Exists() or NumEnemies < 3 or not IsOptionEnabled("横扫")) and
                Target:CanCast(Shred, true, true, false, false, true)
                then
                    Bug("Shred - Generator")
                    Target:Cast(Shred)
                    return
                end
            end
            if Lowest and not Bloodtalons:Exists() and Player:Buff(PredatorySwiftness) then
                if Regrowth:Exists() and Lowest:CanCast(Regrowth) then
                    Bug("Regrowth Filler")
                    Lowest:Cast(Regrowth)
                    return
                end
            end
        elseif IsOptionEnabled("月火术") and GetOptionValue("月火术") == "无条件使用" then
            if UseAOE() then
                local ThisUnit
                for i = 1, #Enemies_45y do
                    ThisUnit = Enemies_45y[i]
                    if
                    not ThisUnit:IsCrowdControlled() and
                    (GetSecondOptionValue("月火术") == "Everything" or ThisUnit:IsInCombat()) and
                    ThisUnit:DebuffRefreshable(MoonfireDebuff, MoonfirePandemic) and
                    ThisUnit:TimeToDie() > RakeCycleTTD and
                    ThisUnit:CanCast(Moonfire)
                    then
                        Bug("Moonfire AoE")
                        ThisUnit:Cast(Moonfire)
                        return
                    end
                end
            end
            if Target:CanCast(Moonfire) then
                Bug("Moonfire Out of Range")
                Target:Cast(Moonfire)
                return
            end
        end
        return
    end
    return
end
function Rotation:OutOfCombat()
    SetOutput("斜掠伤害:", "0  0")
    SetOutput("割裂伤害:", "0  0")
    self.AiluroSwapReady = true
    if
    Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) and not Player:Buff(MoonkinForm) and
    not Player:Buff(BearForm)
    then
        if IsOptionEnabled("自动潜行") and Player:DistanceTo(Target) <= GetOptionValue("自动潜行") then
            Player:UsePotions("Agility")
            if not Player:IsStealthed(true, true) and Player:CanCast(Prowl) then
                Bug("Prowl - Auto Cat Form and Prowl")
                Player:Cast(Prowl)
                return
            end
            if not Player:Buff(CatForm) and Player:CanCast(CatForm) then
                Bug("Cat Form - Auto Cat Form and Prowl")
                Player:Cast(CatForm)
                return
            end
        end
        if IsOptionEnabled("自动进入战斗") then
            if GetOptionValue("自动进入战斗") == "Rake" then
                if Player:IsStealthed(true, true) and Target:CanCast(Rake, true, true, false, false, true) then
                    Bug("Rake - Auto Engage")
                    Target:Cast(Rake)
                    return
                end
            elseif GetOptionValue("自动进入战斗") == "月火术" then
                if Target:CanCast(Moonfire) then
                    Bug("Moonfire - Auto Engage")
                    Target:Cast(Moonfire)
                    return
                end
            end
        end
    end
    return
end
function Rotation:GuardianAffinity()
    if GuardianAffinity:Exists() then
        if Player:HealthPercentage() <= 60 and Player:Rage() >= 10 and Player:CanCast(FrenziedRegeneration) then
            Bug("Frenzied Regeneration - Guardian")
            Player:Cast(FrenziedRegeneration)
        end
        if Player:Rage() >= 45 and Player:CanCast(Ironfur) then
            Bug("Iron Fur - Guardian")
            Player:Cast(Ironfur)
            return
        end
    end
    if Player:DistanceTo(Target, false, true) <= 8 + (BalanceAffinity:Exists() and 5 or 0) and Player:CanCast(Thrash) then
        Bug("Thrash - Guardian")
        Player:Cast(Thrash)
        return
    end
    if GuardianAffinity:Exists() and Target:CanCast(Mangle) then
        Bug("Mangle - Guardian")
        Target:Cast(Mangle)
        return
    end
    if
    Target:TimeToDie() > GetOptionValue("根据致死时间上斜掠") and Target:DebuffRemains(MoonfireDebuff) <= 4 and
    Target:CanCast(Moonfire)
    then
        Bug("Moonfire - Guardian")
        Target:Cast(Moonfire)
        return
    end
    if
    not BrutalSlash:Exists() and Player:DistanceTo(Target, false, true) <= 8 + (BalanceAffinity:Exists() and 5 or 0) and
    Player:CanCast(Swipe)
    then
        Bug("Swipe - Guardian")
        Player:Cast(Swipe)
        return
    end
    if UseAOE() then
        local ThisUnit
        for i = 1, #Enemies_45y do
            ThisUnit = Enemies_45y[i]
            if
            not ThisUnit:IsCrowdControlled() and ThisUnit:TimeToDie() > GetSecondOptionValue("根据致死时间上斜掠") and
            ThisUnit:DebuffRemains(MoonfireDebuff) <= 4 and
            ThisUnit:CanCast(Moonfire)
            then
                Bug("Moonfire AoE - Guardian")
                ThisUnit:Cast(Moonfire)
                return
            end
        end
    end
    if Target:CanCast(Moonfire) then
        Bug("Moonfire Out of Range - Guardian")
        Target:Cast(Moonfire)
        return
    end
end
function Rotation:BalanceAffinity()
    if Target:CanCast(Starsurge) then
        Bug("Starsurge - Moonkin")
        Target:Cast(Starsurge)
        return
    end
    if Target:TimeToDie() > GetOptionValue("根据致死时间上斜掠") then
        if Target:DebuffRemains(SunfireDebuff) <= 4 and Target:CanCast(Sunfire) then
            Bug("Sunfire - Moonkin")
            CastSpellByID(Sunfire.Identifier)
            return
        end
        if Target:DebuffRemains(MoonfireDebuff) <= 4 and Target:CanCast(Moonfire) then
            Bug("Moonfire - Moonkin")
            Target:Cast(Moonfire)
            return
        end
    end
    if UseAOE() then
        local ThisUnit
        for i = 1, #Enemies_45y do
            ThisUnit = Enemies_45y[i]
            if not ThisUnit:IsCrowdControlled() and ThisUnit:TimeToDie() > GetSecondOptionValue("根据致死时间上斜掠") then
                if ThisUnit:DebuffRemains(SunfireDebuff) <= 4 and ThisUnit:CanCast(Sunfire) then
                    Bug("Sunfire AoE - Moonkin")
                    CastSpellByID(Sunfire.Identifier, ThisUnit.UnitID)
                    return
                end
                if ThisUnit:DebuffRemains(MoonfireDebuff) <= 4 and ThisUnit:CanCast(Moonfire) then
                    Bug("Moonfire AoE - Moonkin")
                    ThisUnit:Cast(Moonfire)
                    return
                end
            end
        end
    end
    if Player:Buff(SolarEmpowerment) and Target:CanCast(SolarWrath) then
        Bug("Solar Wrath - Moonkin")
        Target:Cast(SolarWrath)
        return
    end
    if Target:CanCast(LunarStrike) then
        Bug("Lunar Strike - Moonkin")
        Target:Cast(LunarStrike)
        return
    end
end
function Rotation:RestorationAffinity()
    if Lowest and Lowest:SpecialHealthPercentage() < 40 and Lowest:CanCast(Swiftmend) then
        Bug("Swiftmend - Restoration")
        Lowest:Cast(Swiftmend)
        return
    end
    if
    Lowest and Lowest:SpecialHealthPercentage() < 85 and Lowest:BuffRemains(Rejuvenation) <= 4.5 and
    Lowest:CanCast(Rejuvenation)
    then
        Bug("Rejuvenation - Restoration")
        Lowest:Cast(Rejuvenation)
        return
    end
    if
    Lowest and Lowest:SpecialHealthPercentage() < 55 and Player:Standing() >= 0.7 and
    Lowest:BuffRemains(Regrowth) <= 3 and
    Lowest:CanCast(Regrowth)
    then
        Bug("Regrowth - Restoration")
        Lowest:Cast(Regrowth)
        return
    end
    if Lowest and Lowest:SpecialHealthPercentage() < 75 and Player:Standing() >= 0.7 and Lowest:CanCast(HealingTouch) then
        Bug("Healing Touch - Restoration")
        Lowest:Cast(HealingTouch)
        return
    end
end
SetRotation(104, {})
local Rotation = Rotations[104]
function Rotation:Initialize()
    Berserking = Spell(26297, false, false, true)
    BloodFury = Spell(33702, false, false, true)
    Barkskin = Spell(22812, false, false, true)
    BearForm = Spell(5487, false, false, true)
    BristlingFur = Spell(155835, false, false, true)
    CatForm = Spell(768, false, false, true)
    DisplacerBeast = Spell(137452, false, false, true)
    FrenziedRegeneration = Spell(22842, false, false, true)
    GalacticGuardian = Spell(203964)
    GalacticGuardianBuff = Spell(213708)
    GuardianOfElune = Spell(155578)
    GuardianOfEluneBuff = Spell(213680)
    Growl = Spell(6795, false, true, true)
    HealingTouch = Spell(5185, false, false, true)
    Incarnation = Spell(102558, false, false, true)
    Ironfur = Spell(192081, false, false, true)
    LunarBeam = Spell(204066, false, false, true)
    Maul = Spell(6807, true, true, true)
    Mangle = Spell(33917, true, true, true)
    Pulverize = Spell(80313, true, true, true)
    PulverizeBuff = Spell(158792, false, false, true)
    RageOfTheSleeper = Spell(200851, false, false, true)
    Rebirth = Spell(20484, false, false, false, true)
    SoulOfTheForest = Spell(158447)
    SkullBash = Spell(106839, true, true, true)
    SurvivalInstincts = Spell(61336, false, false, true)
    Swipe = Spell(213764, false, false, true)
    Thrash = Spell(106832, false, false, true)
    ThrashDebuff = Spell(192090)
    TravelForm = Spell(783, false, false, true)
    FeralAffinity = Spell(202155)
    FeralThrash = Spell(77758, false, false, true)
    FerociousBite = Spell(22568, true, true, true)
    Rip = Spell(1079, true, true, true)
    Rake = Spell(1822, true, true, true)
    RakeDebuff = Spell(155722)
    Shred = Spell(5221, true, true, true)
    BalanceAffinity = Spell(197488)
    LunarEmpowerment = Spell(164547)
    LunarStrike = Spell(197628, true, true, false)
    MoonkinForm = Spell(197625, false, false, true)
    Moonfire = Spell(8921, true, true, true)
    MoonfireDebuff = Spell(164812)
    Sunfire = Spell(197630, true, true, true)
    SunfireDebuff = Spell(164815)
    SolarEmpowerment = Spell(164545)
    SolarWrath = Spell(197629, true, true, false)
    Starsurge = Spell(197626, true, true, true)
    RestorationAffinity = Spell(197492)
    Regrowth = Spell(8936, false, false, false)
    Rejuvenation = Spell(774, false, false, true)
    Swiftmend = Spell(18562, false, false, true)
    HandOfProtection = Spell(1022, false, false, true)
    HandOfProtectionName = GetSpellInfo(1022)
    EkowraithCreatorOfWorlds = Item(137075)
    LuffaWrappings = Item(137056)
    SkysecsHold = Item(137025)
    Wildflesh = Spell(200400)
    AddPage("常规")
    AddPage("进攻")
    AddPage("防御")
    AddPage("亲和")
    AddCommonOptions()
    AddPresetOption("常规", "Melee", nil, false)
    AddPresetOption("TankingFeatures", { "低吼", "吠声" })
    AddSection("常规", { "辅助", "效用" }, "Yellow")
    AddNewOption("常规", { "熊形态", "熊形态" }, 210, true, nil, nil, { "Automatically handle Bear Form.", "自动处理熊形式。" })
    AddNewOption(
    "常规",
    { "复生", "复生" },
    210,
    true,
    nil,
    nil,
    { "Enable to automatically resurrect targeted dead player targets in combat.", "启用在战斗中自动复活目标死亡玩家目标。" }
    )
    AddPresetOption("进攻")
    AddSection("进攻", { "大技能", "酷唐斯" }, "Yellow")
    AddPresetOption("Cooldown", { "鬃毛倒竖", "鬃毛倒竖" })
    AddPresetOption("Cooldown", { "化身", "化身：乌索克的守护者" })
    AddPresetOption(
    "Cooldown",
    { "明月普照", "明月普照" },
    nil,
    { 1, 1, 10, 1 },
    { "Amount of units that need to be surrounding the current target to use.", "需要围绕当前使用目标的单位数量。" }
    )
    AddSection("进攻", { "能力", "能力" }, "Yellow")
    AddNewOption(
    "进攻",
    { "重殴", "重殴" },
    220,
    false,
    { 80, 1, 85, 1 },
    nil,
    {
        "Use Maul to dump rage when we do not need our Active Mitigation." ..
        C.TOOLTIP_VALUE .. "Minimum Rage needed to use Maul.",
        "当我们不需要我们的主动缓解时，请使用Maul来倾诉愤怒。" .. C.TOOLTIP_VALUE .. "需要使用重殴的最低怒气。"
    }
    )
    AddNewOption(
    "进攻",
    { "多目标 月火术", "多点月火术" },
    222,
    false,
    { 5, 1, 10, 1 },
    { 3, 0, 25, 0.1 },
    {
        "Multi-Dot Moonfire Cycle." ..
        C.TOOLTIP_VALUE_1 ..
        "Number of dots to apply." ..
        C.TOOLTIP_VALUE_2 ..
        "Minimum health (in million) to apply." ..
        C.TOOLTIP_HINT("Also applies to Balance Affinity."),
        "多点月火周期。" ..
        C.TOOLTIP_VALUE_1 .. "要应用的点数。" .. C.TOOLTIP_VALUE_2 .. "最低健康（百万元）申请。" .. C.TOOLTIP_HINT("也适用于平衡关系。")
    }
    )
    AddNewOption(
    "进攻",
    { "横扫", "横扫" },
    120,
    true,
    { 3, 1, 10, 1 },
    nil,
    {
        "Use Swipe while in Bear Form." ..
        C.TOOLTIP_VALUE ..
        "Amount of units needed in range of player to use Swipe." ..
        C.TOOLTIP_HINT("It will still be used as filler even if less units are detected."),
        "在熊形式下使用滑动。" .. C.TOOLTIP_VALUE .. "玩家使用范围所需的单位数量滑动。" .. C.TOOLTIP_HINT("即使检测到较少的单位，它仍将被用作填充物。")
    }
    )
    AddNewOption(
    "进攻",
    { "痛击", "痛击" },
    120,
    true,
    { 3, 1, 10, 1 },
    nil,
    {
        "Use Thrash." ..
        C.TOOLTIP_VALUE ..
        "Amount of units needed in range of player to use Thrash." ..
        C.TOOLTIP_HINT("It will still be used as filler even if less units are detected."),
        "使用痛击。" .. C.TOOLTIP_VALUE .. "在使用痛击的玩家范围内所需的单位数量。" .. C.TOOLTIP_HINT("即使检测到较少的单位，它仍将被用作填充物。")
    }
    )
    AddNewOption(
    "进攻",
    { "星河守护者月火术", "星河守护者以上裂伤" },
    210,
    false,
    nil,
    nil,
    { "Use Moonfire with Galactic Guardian buff over Mangle.", "使用月火术与星河守护者魔法增益超过伤口。" }
    )
    AddNewOption(
    "进攻",
    { "猫形态能量设置", "猫编织能量" },
    120,
    true,
    { 35, 1, 100, 1 },
    nil,
    {
        "Leave Catform when below given energy." ..
        C.TOOLTIP_VALUE ..
        "Amount of energy (at or below) to leave." ..
        C.TOOLTIP_HINT(
        "Only used with catweave macros. Don't set it too low as you may never going out of catform."
        ),
        "低于给定能量时留下猫形。" ..
        C.TOOLTIP_VALUE .. "能量（等于或低于）离开的量。" .. C.TOOLTIP_HINT("只用于猫编织宏。 不要把它设置得太低，因为你可能永远不会走出猫的形式。")
    }
    )
    AddSection("防御", { "减伤", "减轻" }, "Yellow")
    AddNewOption(
    "防御",
    { "狂暴回复", "狂暴回复" },
    210,
    true,
    nil,
    nil,
    { "Activate the use of Frenzied Regeneration.", "激活使用狂暴回复。" }
    )
    AddNewOption(
    "防御",
    { "狂暴回复充能1层", "狂暴回复费1" },
    122,
    true,
    { 50, 1, 100, 1 },
    { 40, 0, 100, 1 },
    {
        "Use Frenzied Regeneration when at 1 charge." ..
        C.TOOLTIP_VALUE_1 ..
        "Health threshold." .. C.TOOLTIP_VALUE_2 .. "Frenzied Regeneration health percentage.",
        "当1充电时使用狂暴回复。" .. C.TOOLTIP_VALUE_1 .. "健康阈值。" .. C.TOOLTIP_VALUE_2 .. "狂暴回复治愈百分比。"
    }
    )
    AddNewOption(
    "防御",
    { "狂暴回复充能2层", "狂暴回复费2" },
    122,
    true,
    { 70, 1, 100, 1 },
    { 25, 0, 100, 1 },
    {
        "Use Frenzied Regeneration when at 2 charges." ..
        C.TOOLTIP_VALUE_1 ..
        "Health threshold." .. C.TOOLTIP_VALUE_2 .. "Frenzied Regeneration health percentage.",
        "使用狂暴回复，当2收费。" .. C.TOOLTIP_VALUE_1 .. "健康阈值。" .. C.TOOLTIP_VALUE_2 .. "狂暴回复治愈百分比。"
    }
    )
    AddNewOption(
    "防御",
    { "狂暴回复充能3层", "狂暴回复费3" },
    122,
    true,
    { 80, 1, 100, 1 },
    { 20, 0, 100, 1 },
    {
        "Use Frenzied Regeneration when at 3 charges." ..
        C.TOOLTIP_VALUE_1 ..
        "Health threshold." .. C.TOOLTIP_VALUE_2 .. "Frenzied Regeneration health percentage.",
        "使用狂暴回复当3收费。" .. C.TOOLTIP_VALUE_1 .. "健康阈值。" .. C.TOOLTIP_VALUE_2 .. "狂暴回复治愈百分比。"
    }
    )
    AddNewOption(
    "防御",
    { "铁鬃", "铁鬃" },
    222,
    true,
    { 30, 1, 100, 1 },
    { 5, 5, 10, 1 },
    {
        "Use Ironfur when we are receiving Physical Damage." ..
        C.TOOLTIP_VALUE_1 ..
        "Health percentage lost via Physical Damage." ..
        C.TOOLTIP_VALUE_2 ..
        "Time Lapse in seconds." ..
        C.TOOLTIP_HINT("Use when you lose Value 1% of health over Value 2 amount of time."),
        "当我们收到身体伤害时，使用铁蹄。" ..
        C.TOOLTIP_VALUE_1 ..
        "身体伤害损失健康百分比。" .. C.TOOLTIP_VALUE_2 .. "时间以秒为单位。" .. C.TOOLTIP_HINT("使用当您失去价值1％的健康超过价值2的时间。")
    }
    )
    AddNewOption(
    "防御",
    { "消耗多余的怒气", "减轻转储" },
    220,
    true,
    { 80, 1, 100, 1 },
    nil,
    {
        "Use Ironfur to dump rage when we have exceeding Rage. If no damage was taken in the last 5 seconds then Maul will be preferred." ..
        C.TOOLTIP_VALUE .. "Rage threshold to dump.",
        "当我们超过愤怒时，使用铁糠或乌尔索尔的标记来呕吐。 如果在最近5秒内没有损坏，那么重殴将是首选。" .. C.TOOLTIP_VALUE .. "愤怒阈值转储。"
    }
    )
    AddSection("防御", { "能力", "能力" }, "Yellow")
    AddNewOption(
    "防御",
    { "树皮术", "树皮术" },
    220,
    true,
    { 40, 1, 100, 1 },
    nil,
    { "Use Barkskin." .. C.TOOLTIP_VALUE .. "Health threshold.", "使用树皮术。" .. C.TOOLTIP_VALUE .. "健康阈值。" }
    )
    AddNewOption(
    "防御",
    { "治疗之触 自己", "治疗之触自己" },
    220,
    true,
    { 80, 1, 100, 1 },
    nil,
    {
        "Use Healing Touch on ourself." .. C.TOOLTIP_VALUE .. "Health threshold while Out of Combat.",
        "使用治疗之触自己。" .. C.TOOLTIP_VALUE .. "健康阈值，而不在战斗。"
    }
    )
    AddNewOption(
    "防御",
    { "粉碎", "粉碎" },
    220,
    true,
    { 6, 0, 26, 1 },
    nil,
    {
        "Use Pulverize." ..
        C.TOOLTIP_VALUE ..
        "Amount of seconds remaining on Pulverize buff. Set to highest amount to use as soon as target has 2 stacks of Thrash debuff.",
        "使用粉碎。" .. C.TOOLTIP_VALUE .. "粉碎魔法增益的剩余秒数。 设定为最高使用量，一旦目标有2堆痛击魔法减益。"
    }
    )
    AddNewOption(
    "防御",
    { "沉睡者之怒", "沉睡者之怒" },
    220,
    true,
    { 45, 1, 100, 1 },
    nil,
    { "Use Rage Of The Sleeper." .. C.TOOLTIP_VALUE .. "Health threshold.", "使用沉睡者之怒。" .. C.TOOLTIP_VALUE .. "健康阈值。" }
    )
    AddNewOption(
    "防御",
    { "生存本能", "生存本能" },
    220,
    true,
    { 25, 1, 100, 1 },
    nil,
    { "Use Survival Instincts." .. C.TOOLTIP_VALUE .. "Health threshold.", "使用生存本能。" .. C.TOOLTIP_VALUE .. "健康阈值。" }
    )
    AddSection("亲和", { "平衡亲和", "平衡亲和" }, "Yellow")
    AddNewOption("亲和", { "平衡亲和", "平衡亲和" }, 210, false, nil, nil, { "Enable Balance Affinity DPS.", "启用平衡亲和力伤害。" })
    AddNewOption(
    "亲和",
    { "多目标 阳炎术", "多点阳炎术" },
    222,
    false,
    { 10, 1, 10, 1 },
    { 3, 0, 25, 0.1 },
    {
        "Multi-Dot Sunfire Cycle." ..
        C.TOOLTIP_VALUE_1 ..
        "Number of dots to apply." .. C.TOOLTIP_VALUE_2 .. "Minimum health (in million) to apply.",
        "多点阳性炎周期。" .. C.TOOLTIP_VALUE_1 .. "要应用的点数。" .. C.TOOLTIP_VALUE_2 .. "最低健康（百万元）申请。"
    }
    )
    AddSection("亲和", { "野性亲和", "野性亲和" }, "Yellow")
    AddNewOption(
    "亲和",
    { "野性亲和", "野性亲和" },
    220,
    false,
    { 80, 1, 100, 1 },
    nil,
    {
        "Enable Feral Affinity DPS when our health is over threshold." .. C.TOOLTIP_VALUE .. "Health threshold.",
        "当我们的健康超过阈值时，启用野性亲和力损伤。" .. C.TOOLTIP_VALUE .. "健康阈值。"
    }
    )
    AddNewOption("亲和", { "割裂", "割裂" }, 210, true, nil, nil, { "Use Rip.", "使用割裂。" })
    AddNewOption(
    "亲和",
    { "野性 横扫", "野性横扫" },
    220,
    true,
    { 3, 1, 10, 1 },
    nil,
    {
        "Use Swipe with Feral Affinity." ..
        C.TOOLTIP_VALUE .. "Amount of units needed within 10 yards of player to use Swipe.",
        "使用滑行与野性亲和力。" .. C.TOOLTIP_VALUE .. "在使用滑动的玩家10码内所需的单位数量。"
    }
    )
    AddSection("亲和", { "恢复亲和", "恢复亲和" }, "Yellow")
    AddNewOption(
    "亲和",
    { "治疗之触", "治疗之触" },
    222,
    true,
    { 95, 0, 100, 1 },
    { 90, 0, 100, 1 },
    {
        "Use Healing Touch." ..
        C.TOOLTIP_VALUE_1 ..
        "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid.",
        "使用治疗之触。" .. C.TOOLTIP_VALUE_1 .. "在坦克上使用的门槛。" .. C.TOOLTIP_VALUE_2 .. "突袭使用的门槛。"
    }
    )
    AddNewOption(
    "亲和",
    { "愈合", "愈合" },
    222,
    true,
    { 35, 0, 100, 1 },
    { 25, 0, 100, 1 },
    {
        "Use Regrowth." ..
        C.TOOLTIP_VALUE_1 ..
        "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid.",
        "使用愈合。" .. C.TOOLTIP_VALUE_1 .. "在坦克上使用的门槛。" .. C.TOOLTIP_VALUE_2 .. "突袭使用的门槛。"
    }
    )
    AddNewOption(
    "亲和",
    { "回春术", "回春术" },
    222,
    true,
    { 85, 0, 100, 1 },
    { 80, 0, 100, 1 },
    {
        "Use Rejuvenation." ..
        C.TOOLTIP_VALUE_1 ..
        "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid.",
        "使用回春术。" .. C.TOOLTIP_VALUE_1 .. "在坦克上使用的门槛。" .. C.TOOLTIP_VALUE_2 .. "突袭使用的门槛。"
    }
    )
    AddNewOption(
    "亲和",
    { "回春术 自己", "回春术你自己" },
    220,
    true,
    { 30, 1, 100, 1 },
    nil,
    {
        "Use Rejuvenation on ourself." .. C.TOOLTIP_VALUE .. "Health threshold.",
        "使用回春术你自己。" .. C.TOOLTIP_VALUE .. "健康阈值。"
    }
    )
    AddNewOption("亲和", { "恢复亲和", "恢复亲和" }, 210, false, nil, nil, { "Enable Restoration Affinity Healing.", "使用恢复亲和愈合。" })
    AddNewOption(
    "亲和",
    { "迅捷治愈", "迅捷治愈" },
    222,
    true,
    { 40, 0, 100, 1 },
    { 25, 0, 100, 1 },
    {
        "Use Swiftmend." ..
        C.TOOLTIP_VALUE_1 ..
        "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid.",
        "使用迅捷治愈。" .. C.TOOLTIP_VALUE_1 .. "在坦克上使用的门槛。" .. C.TOOLTIP_VALUE_2 .. "突袭使用的门槛。"
    }
    )
    AddOutput("5秒内所受的伤害:")
    AddOutput("狂暴回血")
    ISCL = {
        [HealingTouch:ID()] = "治疗之触",
        [LunarStrike:ID()] = "Lunar Strike",
        [Regrowth:ID()] = "愈合",
        [SolarWrath:ID()] = "阳炎之怒"
    }
    RegisterCommand(
    "catweavesingle",
    function()
        if FeralAffinity:Exists() and not Player:Buff(RageOfTheSleeper) then
            if CatweaveSingle == true then
                CatweaveSingle = false
                Bug("Catweave Single Queue Canceled")
            else
                CatweaveSingle = true
                Bug("Catweave Single Queue Enabled")
            end
        else
            Bug("Feral affinity is not known OR Rage of the Sleeper active.")
        end
    end
    )
    self.FrenziedRegenerationHeal = 0
end
function Rotation:Events()
    EventFrame:RegisterForSelfCombatEvent(
    function(...)
        if select(12, ...) == 192083 then
            ShouldMoU = false
            Bug("Mark of Ursol Queue Disabled")
        elseif select(12, ...) == 5487 then
            CatweaveSingle = false
        end
    end,
    "SPELL_CAST_SUCCESS"
    )
end
function Rotation:Pulse()
    SetOutput(
    "5秒内所受的伤害:",
    Player:RecentDamageTakenPercent(5, "Physical") + Player:RecentDamageTakenPercent(5, "Spell") ..
    " (" ..
    Player:RecentDamageTakenPercent(5, "Physical") ..
    "/" .. Player:RecentDamageTakenPercent(5, "Spell") .. ")"
    )
    self.FrenziedRegenerationHeal = self:CalcFrenziedRegenarationHeal()
    SetOutput("狂暴回血", self.FrenziedRegenerationHeal .. "%")
    if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
        return
    end
    if Player:Buff(CatForm) then
        Swipe = Spell(213764, false, false, true)
        Thrash = Spell(106830, false, false, true)
        ThrashDebuff = Spell(106830, false, false, false)
    elseif Player:Buff(BearForm) then
        Swipe = Spell(213771, false, false, true)
        Thrash = Spell(77758, false, false, true)
        ThrashDebuff = Spell(192090, false, false, false)
    else
        Swipe = Spell(213764, false, false, true)
        Thrash = Spell(106832, false, false, true)
        ThrashDebuff = Spell(106832, false, false, false)
    end
    if Target:Exists() and BMPullTime() < 5 then
        self:Opening()
        return
    end
    if GetTime() < Rotation.SpamPrevention then
        return
    end
    Rotation.SpamPrevention = GetTime() + 0.05
    Target = Unit.Target
    local InCombat = Player:IsInCombat()
    if not InCombat then
        self:OutOfCombat()
        return
    end
    if InCombat then
        self:Defensives()
    end
    Rotations:RefreshUnitTables(Rotation.Identifier)
    self:Interrupts()
    self:OffGCDAbilities()
    if Player:GlobalCooldown() == 0 then
        self:Combat()
    end
end
function Rotation:Opening()
    Player:UsePotions(GetSecondOptionValue("使用药水"))
    if
    IsOptionEnabled("抢先施放(需DBM插件)") and
    (GetOptionValue("抢先施放(需DBM插件)") == "无条件使用" or
    (GetOptionValue("抢先施放(需DBM插件)") == "打BOSS使用" and Target:IsBoss()))
    then
        if
        Moonfire:Exists() and BMPullTime() < GetSecondOptionValue("抢先施放(需DBM插件)") and Player:DistanceTo(Target) > 8 and
        Player:DistanceTo(Target) < 25 and
        Target:CanCast(Moonfire)
        then
            Player:StartAttack()
            Target:Cast(Moonfire)
            return
        end
    end
end
function Rotation:Defensives()
    Player:UseHealingItem()
    if Player:IsWithinCastRange(Target, Mangle) then
        if
        Barkskin:Exists() and IsOptionEnabled("树皮术") and Player:HealthPercentage() <= GetOptionValue("树皮术") and
        Player:CanCast(Barkskin)
        then
            Player:Cast(Barkskin)
        end
    end
end
function Rotation:Interrupts()
    Player:UseInterrupt(SkullBash)
end
function Rotation:OffGCDAbilities()
    if IsOptionEnabled("自动取消保护之手") and Player:BuffRemainsAny(HandOfProtection) <= 10 - GetOptionValue("自动取消保护之手") then
        RunMacroText("/cancelaura " .. HandOfProtectionName)
    end
    if Growl:Exists() and Player:TauntManager(Growl, "低吼", Target, TauntEnemies) then
        return
    end
    if
    SurvivalInstincts:Exists() and IsOptionEnabled("生存本能") and Player:HealthPercentage() <= GetOptionValue("生存本能") and
    Player:CanCast(SurvivalInstincts)
    then
        Player:Cast(SurvivalInstincts)
        return
    end
    if
    RageOfTheSleeper:Exists() and IsOptionEnabled("沉睡者之怒") and Player:HealthPercentage() <= GetOptionValue("沉睡者之怒") and
    Player:CanCast(RageOfTheSleeper)
    then
        Player:Cast(RageOfTheSleeper)
        return
    end
    if Player:Rage() >= 45 then
        if Ironfur:Exists() and IsOptionEnabled("铁鬃") and Ironfur:TimeSinceCast() > 0.5 then
            local Option1, Option2 = GetOptionValue("铁鬃"), GetSecondOptionValue("铁鬃")
            if Player:RecentDamageTakenPercent(Option2, "Physical") > Option1 and Player:CanCast(Ironfur) then
                Bug("Mitigation via Ironfur")
                Ironfur.LastCastTime = GetTime()
                Player:Cast(Ironfur)
                return
            end
        end
    end
    if IsOptionEnabled("消耗多余的怒气") and Player:Rage() >= GetOptionValue("消耗多余的怒气") and Ironfur:TimeSinceCast() > 0.5 then
        if Ironfur:Exists() and Player:RecentDamageTakenPercent(5, "Physical") > 0 and Player:CanCast(Ironfur) then
            Bug("Mitigation Rage Dump via Ironfur")
            Ironfur.LastCastTime = GetTime()
            Player:Cast(Ironfur)
            return
        end
    end
    if
    FrenziedRegeneration:Exists() and IsOptionEnabled("狂暴回复") and Player:Rage() >= 10 and
    not Player:Buff(FrenziedRegeneration) and
    FrenziedRegeneration:TimeSinceCast() > 0.5 and
    Player:CanCast(FrenziedRegeneration)
    then
        if
        (FrenziedRegeneration:Charges() == 3 and Player:HealthPercentage() <= GetOptionValue("狂暴回复充能3层") and
        self.FrenziedRegenerationHeal >= GetSecondOptionValue("狂暴回复充能3层")) or
        (FrenziedRegeneration:Charges() == 2 and Player:HealthPercentage() <= GetOptionValue("狂暴回复充能2层") and
        self.FrenziedRegenerationHeal >= GetSecondOptionValue("狂暴回复充能2层")) or
        (FrenziedRegeneration:Charges() == 1 and Player:HealthPercentage() <= GetOptionValue("狂暴回复充能1层") and
        self.FrenziedRegenerationHeal >= GetSecondOptionValue("狂暴回复充能1层"))
        then
            Bug("Frenzied Regeneration - Heal Perc: " .. self.FrenziedRegenerationHeal .. "%")
            FrenziedRegeneration.LastCastTime = GetTime()
            Player:Cast(FrenziedRegeneration)
            return
        end
    end
end
function Rotation:RemoveForm()
    if Player:Buff(MoonkinForm) then
        RunMacroText("/cancelaura " .. MoonkinForm:Name())
    elseif Player:Buff(CatForm) then
        RunMacroText("/cancelaura " .. CatForm:Name())
    elseif Player:Buff(BearForm) then
        RunMacroText("/cancelaura " .. BearForm:Name())
    end
end
Rotation.SwipeSpellIDs = { Spell(213764, false, false, true), Spell(213771, false, false, true) }
function Rotation:SwipeExists()
    for i = 1, #self.SwipeSpellIDs do
        if self.SwipeSpellIDs[i]:Exists() then
            return true
        end
    end
    return false
end
Rotation.ThrashSpellIDs = {
    Spell(106830, false, false, true),
    Spell(77758, false, false, true),
    Spell(106832, false, false, true)
}
function Rotation:ThrashExists()
    for i = 1, #self.ThrashSpellIDs do
        if self.ThrashSpellIDs[i]:Exists() then
            return true
        end
    end
    return false
end
Rotation.CalcFR = {}
function Rotation:CalcFrenziedRegenarationHeal()
    self.CalcFR.Versatility = 1 + (Player:Versatility() / 100)
    self.CalcFR.GuardianOfEluneModifier = Player:Buff(GuardianOfEluneBuff) and 1.2 or 1
    self.CalcFR.WildfleshTrait = 1 + 0.05 * Wildflesh:ArtifactRank()
    self.CalcFR.SkysecsHoldModifier = SkysecsHold:IsEquipped(8) and 0.100078 or 0
    self.CalcFR.TotalHeal = (Player:RecentDamageTaken(5, "Physical") + Player:RecentDamageTaken(5, "Spell")) * 0.5
    self.CalcFR.PercHeal = self.CalcFR.TotalHeal / Player:MaxHealth()
    self.CalcFR.PercHeal = math.max(0.05, self.CalcFR.PercHeal)
    self.CalcFR.PercHeal =     (self.CalcFR.PercHeal * self.CalcFR.GuardianOfEluneModifier * self.CalcFR.WildfleshTrait *
    self.CalcFR.Versatility +
    self.CalcFR.SkysecsHoldModifier)
    return math.floor(self.CalcFR.PercHeal * 10000) / 100
end
function Rotation:UnitTables()
    MainTank, MainTankTarget, OffTank, OffTankTarget = Unit.GetMainTanks()
    HealUnits = Player:HealUnitsAround(100, 40) or {}
    Lowest = Unit.Lowest(HealUnits, MainTank, OffTank)
    Enemies_40y = UseAOE() and Player:EnemiesWithinDistance(40) or {}
    TauntEnemies = Player:EnemiesWithinDistance(30, false)
    MoonfireUnit = UseAOE() and Unit.DotCycle(Enemies_40y, Moonfire, MoonfireDebuff, 16, "多目标 月火术") or nil
    SunfireUnit =     UseAOE() and BalanceAffinity:Exists() and IsOptionEnabled("Moonkin Affinity") and
    Unit.DotCycle(Enemies_40y, Sunfire, SunfireDebuff, 18, "多目标 阳炎术") or
    nil
    self.SwipeRange =     8 + (BalanceAffinity:Exists() and (5 * (EkowraithCreatorOfWorlds:IsEquipped(5) and 1.75 or 1)) or 0)
    self.ThrashRange =     (8 + (BalanceAffinity:Exists() and (5 * (EkowraithCreatorOfWorlds:IsEquipped(5) and 1.75 or 1)) or 0)) *
    (LuffaWrappings:IsEquipped(9) and 1.25 or 1)
    SwipeEnemies = UseAOE() and Player:EnemiesWithinDistance(self.SwipeRange, true) or {}
    ThrashEnemies = UseAOE() and Player:EnemiesWithinDistance(self.ThrashRange, true) or {}
    NumEnemies = #SwipeEnemies
end
function Rotation:HealCycle(Spell, SpellOption, SpellBuff)
    if Spell:Exists() and IsOptionEnabled(SpellOption) then
        if
        MainTank and MainTank:SpecialHealthPercentage() <= GetOptionValue(SpellOption) and
        (not SpellBuff or MainTank:BuffRemains(SpellBuff) < 3) and
        MainTank:CanCast(Spell)
        then
            self:RemoveForm()
            MainTank:Cast(Spell)
            return
        end
        if
        OffTank and OffTank:SpecialHealthPercentage() <= GetOptionValue(SpellOption) and
        (not SpellBuff or OffTank:BuffRemains(SpellBuff) < 3) and
        OffTank:CanCast(Spell)
        then
            self:RemoveForm()
            OffTank:Cast(Spell)
            return
        end
        if
        Lowest and Lowest:SpecialHealthPercentage() <= GetSecondOptionValue(SpellOption) and
        (not SpellBuff or Lowest:BuffRemains(SpellBuff) < 3) and
        Lowest:CanCast(Spell)
        then
            self:RemoveForm()
            Lowest:Cast(Spell)
            return
        end
        if SpellBuff then
            for i = 1, #HealUnits do
                local ThisUnit = HealUnits[i]
                if
                ThisUnit:CanCast(Spell) and ThisUnit:BuffRemains(Spell) < 3 and
                ThisUnit:SpecialHealthPercentage() <= GetSecondOptionValue(SpellOption)
                then
                    self:RemoveForm()
                    ThisUnit:Cast(Spell)
                    return
                end
            end
        end
    end
end
function Rotation:Combat()
    if
    Rebirth:Exists() and IsOptionEnabled("复生") and Target:Exists() and Target:IsDeadOrGhost() and
    not Player:IsMoving() and
    Target:IsPlayer() and
    Target:CanCast(Rebirth)
    then
        Target:Cast(Rebirth)
        return
    end
    if RestorationAffinity:Exists() and IsOptionEnabled("恢复亲和") then
        if Player:Buff(BearForm) and Player:CanCast(BearForm) then
            self:RemoveForm()
            return
        end
        if Swiftmend:Exists() and IsOptionEnabled("迅捷治愈") and not Swiftmend:IsOnCooldown() then
            if MainTank and MainTank:SpecialHealthPercentage() <= GetOptionValue("迅捷治愈") and MainTank:CanCast(Swiftmend) then
                self:RemoveForm()
                MainTank:Cast(Swiftmend)
                return
            end
            if OffTank and OffTank:SpecialHealthPercentage() <= GetOptionValue("迅捷治愈") and OffTank:CanCast(Swiftmend) then
                self:RemoveForm()
                OffTank:Cast(Swiftmend)
                return
            end
            if Lowest and Lowest:SpecialHealthPercentage() <= GetSecondOptionValue("迅捷治愈") and Lowest:CanCast(Swiftmend) then
                self:RemoveForm()
                Lowest:Cast(Swiftmend)
                return
            end
        end
        self:HealCycle(Regrowth, "愈合", Regrowth)
        self:HealCycle(Rejuvenation, "回春术", Rejuvenation)
        self:HealCycle(HealingTouch, "治疗之触", nil)
    end
    if Player:Buff(BearForm) then
        Target = Player:ReTarget(Mangle, true) or Unit.Target
    elseif Player:Buff(MoonkinForm) then
        Target = Player:ReTarget(Moonfire, true) or Unit.Target
    elseif Player:Buff(CatForm) then
        Target = Player:ReTarget(Mangle, true) or Unit.Target
    end
    if Target:Exists() and Player:CanAttack(Target) then
        Player:StartAttack()
        if BalanceAffinity:Exists() and IsOptionEnabled("平衡亲和") then
            if Target:Exists() then
                if
                MoonkinForm:Exists() and not Player:Buff(MoonkinForm) and Player:CanCast(MoonkinForm) and
                (not Player:Buff(CatForm) or Player:Buff(DisplacerBeast)) and
                not Player:Buff(TravelForm)
                then
                    self:RemoveForm()
                    Player:Cast(MoonkinForm)
                    return
                end
                if Player:Buff(MoonkinForm) then
                    if Starsurge:Exists() and Target:CanCast(Starsurge) then
                        Target:Cast(Starsurge)
                        return
                    end
                    if Sunfire:Exists() then
                        if Target:DebuffRemains(SunfireDebuff) < 5 and Target:CanCast(Sunfire) then
                            Target:Cast(Sunfire, true)
                            return
                        end
                        if IsOptionEnabled("多目标 阳炎术") and SunfireUnit and SunfireUnit:CanCast(Sunfire) then
                            SunfireUnit:Cast(Sunfire, true)
                            return
                        end
                    end
                    if Moonfire:Exists() then
                        if Target:DebuffRemains(MoonfireDebuff) < 6 and Target:CanCast(Moonfire) then
                            Target:Cast(Moonfire)
                            return
                        end
                        if IsOptionEnabled("多目标 月火术") and MoonfireUnit and MoonfireUnit:CanCast(Moonfire) then
                            MoonfireUnit:Cast(Moonfire)
                            return
                        end
                    end
                    if SolarWrath:Exists() and Player:Buff(SolarEmpowerment) and Target:CanCast(SolarWrath) then
                        Target:Cast(SolarWrath)
                        return
                    end
                    if LunarStrike:Exists() and Target:CanCast(LunarStrike) then
                        Target:Cast(LunarStrike)
                        return
                    end
                end
            end
            return
        end
        if FeralAffinity:Exists() and CatweaveSingle and not Player:Buff(RageOfTheSleeper) then
            if Player:Buff(CatForm) and Player:Energy() < GetOptionValue("猫形态能量设置") and Player:CanCast(BearForm) then
                Player:Cast(BearForm)
                Bug("Single Catweave ended.")
                CatweaveSingle = false
                return
            end
            if not Player:Buff(CatForm) and Player:CanCast(CatForm) then
                Player:Cast(CatForm)
                return
            end
            if
            Rip:Exists() and Player:ComboPoints() >= 5 and Target:DebuffRemains(Rip) < 6 and
            not (Target:HealthPercentage() < 25 and Target:DebuffRemains(Rip) > 1) and
            Target:CanCast(Rip)
            then
                Target:Cast(Rip)
                return
            end
            if
            FerociousBite:Exists() and
            ((Player:ComboPoints() >= 5 and Target:HealthPercentage() >= 25 and Target:DebuffRemains(Rip) > 15 and
            Player:Energy() >= 50) or
            (Player:ComboPoints() >= 5 and Target:HealthPercentage() < 25 and Target:DebuffRemains(Rip) > 0) or
            (Player:ComboPoints() >= 4 and Target:TimeToDie() < 5)) and
            Target:CanCast(FerociousBite)
            then
                Target:Cast(FerociousBite)
                return
            end
            if Rip:Exists() and Player:ComboPoints() >= 5 and Target:CanCast(Rip) then
                Target:Cast(Rip)
                return
            end
            if Rake:Exists() and Player:ComboPoints() < 5 and Target:DebuffRemains(RakeDebuff) < 5 then
                Target:Cast(Rake)
                return
            end
            if Player:ComboPoints() < 5 and Target:CanCast(Shred) then
                Target:Cast(Shred)
                return
            end
            return
        end
        if FeralAffinity:Exists() and IsOptionEnabled("野性亲和") and Player:HealthPercentage() >= GetOptionValue("野性亲和") then
            if not Player:Buff(CatForm) and Player:CanCast(CatForm) then
                self:RemoveForm()
                Player:Cast(CatForm)
                return
            end
            if
            Rip:Exists() and IsOptionEnabled("割裂") and Player:ComboPoints() >= 5 and Target:DebuffRemains(Rip) < 6 and
            Target:CanCast(Rip)
            then
                Target:Cast(Rip)
                return
            end
            if
            FerociousBite:Exists() and (Player:ComboPoints() >= 5 or Target:TimeToDie() < 5) and
            Target:CanCast(FerociousBite)
            then
                Target:Cast(FerociousBite)
                return
            end
            if self:SwipeExists() and IsOptionEnabled("野性 横扫") and NumEnemies >= GetOptionValue("野性 横扫") then
                if Player:CanCast(Swipe) then
                    Player:Cast(Swipe)
                    return
                end
            else
                if
                Rake:Exists() and Player:ComboPoints() < 5 and Target:DebuffRemains(RakeDebuff) < 5 and
                Target:TimeToDie() > 8
                then
                    Target:Cast(Rake)
                    return
                end
                if Target:CanCast(Shred) then
                    Target:Cast(Shred)
                    return
                end
            end
            return
        end
        if
        BearForm:Exists() and IsOptionEnabled("熊形态") and not Player:Buff(BearForm) and Player:CanCast(BearForm) and
        (not Player:Buff(CatForm) or Player:Buff(DisplacerBeast)) and
        not Player:Buff(TravelForm)
        then
            self:RemoveForm()
            Player:Cast(BearForm)
            return
        end
        if not Player:Buff(BearForm) then
            return
        end
        if Player:IsWithinCastRange(Target, Mangle, true) then
            Player:UseTrinkets()
            if CDOptionEnabled("进攻性种族技能") then
                if BloodFury:Exists() and Player:CanCast(BloodFury) then
                    Player:Cast(BloodFury)
                end
                if Berserking:Exists() and Player:CanCast(Berserking) then
                    Player:Cast(Berserking)
                end
            end
            if Incarnation:Exists() and CDOptionEnabled("化身") and Player:CanCast(Incarnation) then
                Player:Cast(Incarnation)
                return
            end
            if BristlingFur:Exists() and CDOptionEnabled("鬃毛倒竖") and Player:CanCast(BristlingFur) then
                Player:Cast(BristlingFur)
                return
            end
        end
        if
        LunarBeam:Exists() and CDOptionEnabled("明月普照") and Player:Standing() >= 1.5 and
        NumEnemies >= GetSecondOptionValue("明月普照") and
        Player:IsWithinCastRange(Target, Mangle) and
        Player:CanCast(LunarBeam)
        then
            Player:Cast(LunarBeam)
            return
        end
        if
        self:ThrashExists() and #ThrashEnemies >= GetOptionValue("痛击") and Player:CanCast(Thrash) and
        Player:CanCast(FeralThrash)
        then
            Player:Cast(Thrash)
            return
        end
        if
        Maul:Exists() and IsOptionEnabled("重殴") and
        ((IsOptionEnabled("消耗多余的怒气") and Player:Rage() >= GetOptionValue("消耗多余的怒气")) or
        (Player:RageDeficit() <= 5 and Player:Rage() >= GetOptionValue("重殴"))) and
        NumEnemies <= 4 and
        Target:CanCast(Maul, true, true, false, false, true)
        then
            Target:Cast(Maul)
            return
        end
        if GalacticGuardian:Exists() and Player:Buff(GalacticGuardianBuff) and IsOptionEnabled("星河守护者月火术") then
            if MoonfireUnit and MoonfireUnit:Exists() and IsOptionEnabled("多目标 月火术") and MoonfireUnit:CanCast(Moonfire) then
                MoonfireUnit:Cast(Moonfire)
                return
            elseif Target:CanCast(Moonfire) then
                Target:Cast(Moonfire)
                return
            end
        end
        if Mangle:Exists() and Target:CanCast(Mangle, true, true, false, false, true) then
            Target:Cast(Mangle)
            return
        end
        if
        self:ThrashExists() and Player:DistanceTo(Target, false, true) <= self.ThrashRange and
        not Target:IsDeadOrGhost() and
        Player:CanCast(Thrash) and
        Player:CanCast(FeralThrash)
        then
            Player:Cast(Thrash)
            return
        end
        if
        Pulverize:Exists() and IsOptionEnabled("粉碎") and Target:DebuffCount(ThrashDebuff) >= 2 and
        Player:BuffRemains(PulverizeBuff) <= GetOptionValue("粉碎") and
        Target:CanCast(Pulverize, true, true, false, false, true)
        then
            Target:Cast(Pulverize)
            return
        end
        if GalacticGuardian:Exists() and Player:Buff(GalacticGuardianBuff) then
            if
            MoonfireUnit and MoonfireUnit:Exists() and IsOptionEnabled("多目标 月火术") and
            (not MoonfireUnit:Debuff(MoonfireDebuff) or MoonfireUnit:DebuffRemains(MoonfireDebuff) < 4.8) and
            MoonfireUnit:CanCast(Moonfire)
            then
                MoonfireUnit:Cast(Moonfire)
                return
            elseif
            (not Target:Debuff(MoonfireDebuff) or Target:DebuffRemains(MoonfireDebuff) < 4.8) and
            Target:CanCast(Moonfire)
            then
                Target:Cast(Moonfire)
                return
            end
        end
        if
        self:SwipeExists() and NumEnemies >= GetOptionValue("横扫") and not Target:IsDeadOrGhost() and
        Player:DistanceTo(Target, false, true) <= self.SwipeRange and
        Player:CanCast(Swipe)
        then
            Player:Cast(Swipe)
            return
        end
        if
        Maul:Exists() and IsOptionEnabled("重殴") and Player:Rage() >= GetOptionValue("重殴") and NumEnemies <= 4 and
        Target:CanCast(Maul, true, true, false, false, true)
        then
            Target:Cast(Maul)
            return
        end
        if GalacticGuardian:Exists() and Player:Buff(GalacticGuardianBuff) then
            if MoonfireUnit and MoonfireUnit:Exists() and IsOptionEnabled("多目标 月火术") and MoonfireUnit:CanCast(Moonfire) then
                MoonfireUnit:Cast(Moonfire)
                return
            elseif Target:CanCast(Moonfire) then
                Target:Cast(Moonfire)
                return
            end
        end
        if NumEnemies < 4 then
            if Moonfire:Exists() and Target:DebuffRemains(MoonfireDebuff) < 3 and Target:CanCast(Moonfire) then
                Target:Cast(Moonfire)
                return
            end
            if IsOptionEnabled("多目标 月火术") and MoonfireUnit and MoonfireUnit:Exists() and MoonfireUnit:CanCast(Moonfire) then
                MoonfireUnit:Cast(Moonfire)
                return
            end
        end
        if
        self:SwipeExists() and not Target:IsDeadOrGhost() and
        Player:DistanceTo(Target, false, true) <= self.SwipeRange and
        Player:CanCast(Swipe)
        then
            Player:Cast(Swipe)
            return
        end
    end
end
function Rotation:OutOfCombat()
    if
    RestorationAffinity:Exists() and Rejuvenation:Exists() and IsOptionEnabled("回春术 自己") and
    Player:HealthPercentage() <= GetOptionValue("回春术 自己") and
    Player:CanCast(Rejuvenation) and
    not Player:Buff(Rejuvenation)
    then
        self:RemoveForm()
        Player:Cast(Rejuvenation)
        return
    end
    if
    HealingTouch:Exists() and Player:Standing() > 1.5 and IsOptionEnabled("治疗之触 自己") and
    Player:HealthPercentage() <= GetOptionValue("治疗之触 自己") and
    Player:CanCast(HealingTouch)
    then
        self:RemoveForm()
        Player:Cast(HealingTouch)
        return
    end
    if not Player:Buff(CatForm) and not Player:Buff(BearForm) and not Player:Buff(TravelForm) then
        if FeralAffinity:Exists() and IsOptionEnabled("野性亲和") then
            if not Player:Buff(CatForm) and Player:CanCast(CatForm) then
                Player:Cast(CatForm)
                return
            end
        elseif BalanceAffinity:Exists() and IsOptionEnabled("平衡亲和") then
            if not Player:Buff(MoonkinForm) and Player:CanCast(MoonkinForm) then
                Player:Cast(MoonkinForm)
                return
            end
        elseif
        not (RestorationAffinity:Exists() and IsOptionEnabled("恢复亲和")) and BearForm:Exists() and
        IsOptionEnabled("熊形态")
        then
            if not Player:Buff(BearForm) and Player:CanCast(BearForm) then
                Player:Cast(BearForm)
                return
            end
        end
    end
    if
    IsOptionEnabled("自动进入战斗") and Target:Exists() and not Target:IsDeadOrGhost() and not Player:Buff(CatForm) and
    Player:CanAttack(Target)
    then
        if Moonfire:Exists() and Target:CanCast(Moonfire) then
            Target:Cast(Moonfire)
            return
        end
    end
end
SetRotation(105, {})
local Rotation = Rotations[105]
function Rotation:Initialize()
    Trinket1 = Item(13, false, false, true)
    Trinket2 = Item(14, false, false, true)
    Berserking = Spell(26297, false, false, true)
    AstralInfluence = Spell(197524)
    Barkskin = Spell(22812, false, false, true)
    CenarionWard = Spell(102351, false, false, true)
    Clearcasting = Spell(16870, false, false, true)
    Dash = Spell(1850, false, false, true)
    DisplacerBeast = Spell(137452, false, false, true)
    Efflorescence = Spell(145205, false, false, true)
    EssenceOfGHanir = Spell(208253, false, false, true)
    Flourish = Spell(197721, false, false, true)
    Germination = Spell(155675)
    GerminationRejuvenation = Spell(155777, false, false, true)
    HealingTouch = Spell(5185, false, false, false)
    IncarnationTreeOfLife = Spell(33891, false, false, true)
    Ironbark = Spell(102342, false, false, true)
    Lifebloom = Spell(33763, false, false, true)
    MomentOfClarity = Spell(155577)
    NaturesCure = Spell(88423, false, false, true)
    RampantGrowth = Spell(155834, false, false, true)
    Rebirth = Spell(20484, false, false, false, true)
    Rejuvenation = Spell(774, false, false, true)
    Regrowth = Spell(8936, false, false, false)
    Renewal = Spell(108238, false, false, true)
    Revive = Spell(50769, false, false, false, true)
    SoulOfTheForest = Spell(158478, false, false, true)
    SoulOfTheForestBuff = Spell(114108, false, false, true)
    Swiftmend = Spell(18562, false, false, true)
    Tranquility = Spell(740, false, false, true)
    TravelForm = Spell(783, false, false, true)
    WildGrowth = Spell(48438, false, false, false)
    BalanceAffinity = Spell(197632)
    LunarEmpowerment = Spell(164547)
    LunarStrike = Spell(197628, true, true, false)
    MoonkinForm = Spell(197625, false, false, true)
    Moonfire = Spell(8921, true, true, true)
    MoonfireDebuff = Spell(164812)
    Sunfire = Spell(93402, true, true, true)
    SunfireDebuff = Spell(164815)
    SolarEmpowerment = Spell(164545)
    SolarWrath = Spell(5176, true, true, false)
    Starsurge = Spell(197626, true, true, true)
    FeralAffinity = Spell(197490)
    CatForm = Spell(768, false, false, true)
    FerociousBite = Spell(22568, true, true, true)
    Rake = Spell(1822, true, true, true)
    RakeDebuff = Spell(155722)
    Rip = Spell(1079, true, true, true)
    Shred = Spell(5221, true, true, true)
    Swipe = Spell(213764, false, false, true)
    BearForm = Spell(5487, false, false, true)
    GuardianAffinity = Spell(197491)
    FrenziedRegeneration = Spell(22842, false, false, true)
    Ironfur = Spell(192081, false, false, true)
    Mangle = Spell(33917, true, true, true)
    Thrash = Spell(77758, false, false, true)
    ThrashDebuff = Spell(192090)
    AddPage("常规")
    AddPage("治愈")
    AddPage("大技能")
    AddPage("攻/防")
    AddPage("亲和")
    AddCommonOptions()
    AddPresetOption("GeneralHealer")
    AddSection("常规", "辅助", "Yellow")
    AddOption("常规", "复生", true, "Enable to automatically resurrect targeted dead player targets in combat.")
    AddOption(
    "常规",
    "复生 坦克",
    false,
    "Enable to use rebirth to resuscitate a dead tank. Set the delay before using it.",
    true,
    0,
    0,
    3,
    0.1
    )
    AddNewOption(
    "常规",
    "自动变形",
    210,
    false,
    nil,
    nil,
    "Automatically shapeshift out of Cat, Bear, Moonkin form when not using Affinity options."
    )
    AddSection("治愈", "通用治疗参数", "Yellow")
    AddNewOption(
    "治愈",
    "百花齐放",
    222,
    true,
    { 3, 1, 10, 1 },
    { 90, 0, 100, 1 },
    "Use when selected number of units are under health threshold." ..
    C.TOOLTIP_VALUE_1 .. "Number of Units." .. C.TOOLTIP_VALUE_2 .. "Health threshold."
    )
    AddNewOption(
    "治愈",
    "治疗之触",
    222,
    true,
    { 80, 0, 100, 1 },
    { 70, 0, 100, 1 },
    "Use Healing Touch." ..
    C.TOOLTIP_VALUE_1 ..
    "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid."
    )
    AddNewOption(
    "治愈",
    "生命绽放",
    220,
    true,
    { 80, 0, 100, 1 },
    nil,
    "Use Lifebloom." ..
    C.TOOLTIP_VALUE ..
    "Health threshold under wich we want to let the Lifebloom bloom." ..
    C.TOOLTIP_HINT(
    "We will always apply Lifebloom and maintain it as long as the unit have more health than the specified value. Main Tank will be preferred but if it is not tanking then the Off Tank will be preferred."
    )
    )
    AddNewOption(
    "治愈",
    "愈合",
    222,
    true,
    { 65, 0, 100, 1 },
    { 55, 0, 100, 1 },
    "Use Regrowth to apply the Regrowth buff." ..
    C.TOOLTIP_VALUE_1 ..
    "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid."
    )
    AddNewOption(
    "治愈",
    "愈合 急救",
    222,
    true,
    { 40, 0, 100, 1 },
    { 25, 0, 100, 1 },
    "Use Regrowth without Regrowth Buff check." ..
    C.TOOLTIP_VALUE_1 ..
    "Threshold to use on the Tanks." ..
    C.TOOLTIP_VALUE_2 ..
    "Threshold to use on the Raid." ..
    C.TOOLTIP_HINT(
    "This should be set very low unless you know you can afford the high mana cost of Regrowth."
    )
    )
    AddNewOption(
    "治愈",
    "回春术数量限制",
    122,
    true,
    { 10, 1, 25, 1 },
    { 10, 1, 25, 1 },
    "Maximum buffs counts for Rejuvenation and Germination." ..
    C.TOOLTIP_VALUE_1 ..
    "Maximum buffs counts for Rejuvenation." .. C.TOOLTIP_VALUE_2 .. "Maximum buffs counts for Germination."
    )
    AddNewOption(
    "治愈",
    "回春术",
    222,
    true,
    { 90, 0, 100, 1 },
    { 80, 0, 100, 1 },
    "Use Rejuvenation." ..
    C.TOOLTIP_VALUE_1 ..
    "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid."
    )
    AddNewOption(
    "治愈",
    "萌芽回春",
    222,
    true,
    { 80, 0, 100, 1 },
    { 70, 0, 100, 1 },
    "Use Rejuvenation for Germination." ..
    C.TOOLTIP_VALUE_1 ..
    "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid."
    )
    AddNewOption(
    "治愈",
    "野性成长",
    222,
    true,
    { 4, 1, 5, 1 },
    { 80, 0, 100, 1 },
    "Use when selected number of units are under health threshold." ..
    C.TOOLTIP_VALUE_1 .. "Number of Units." .. C.TOOLTIP_VALUE_2 .. "Health threshold."
    )
    AddNewOption(
    "治愈",
    "紧急治疗",
    222,
    true,
    { 30, 1, 75, 1 },
    { 45, 1, 75, 1 },
    "Heal the tanks or the player as very high priority when their health is critical." ..
    C.TOOLTIP_VALUE_1 .. "Tanks health threshold." .. C.TOOLTIP_VALUE_2 .. "Player health threshold."
    )
    AddSection("治愈", "主动治疗", "Yellow")
    AddNewOption(
    "治愈",
    "治疗目标",
    230,
    true,
    { 1, "已知单位", "任何单位" },
    nil,
    "Heal our current target if it is listed to be healed." ..
    C.TOOLTIP_VALUE ..
    "Choose preferred mode." ..
    C.TOOLTIP_SUBVALUE("已知单位") ..
    "Allow Heal Target to be used only when we are targetting a unit listed for it." ..
    C.TOOLTIP_SUBVALUE("任何单位") .. "Allow Heal Target to be used on any unit."
    )
    AddNewOption(
    "治愈",
    "团队成员Debuffs",
    220,
    true,
    { 40, 0, 100, 1 },
    nil,
    "Use Rejuvenation/Germination on Debuffed units." .. C.TOOLTIP_VALUE .. "Helath threshold."
    )
    AddNewOption(
    "治愈",
    "坦克Debuffs",
    220,
    true,
    { 50, 0, 100, 1 },
    nil,
    "Use Rejuvenation/Germination on Debuffed tanks." .. C.TOOLTIP_VALUE .. "Helath threshold."
    )
    AddNewOption(
    "治愈",
    "Topping",
    220,
    true,
    { 100, 0, 100, 1 },
    nil,
    "Use Rejuvenation/Germination/Regrowth/Healing Touch on units to be topped." ..
    C.TOOLTIP_VALUE .. "Helath threshold."
    )
    AddSection("大技能", "大技能", "Yellow")
    AddNewOption(
    "大技能",
    "塞纳里奥结界",
    222,
    true,
    { 80, 0, 100, 1 },
    { 70, 0, 100, 1 },
    "Use Cenarion Ward on tanking units." ..
    C.TOOLTIP_VALUE_1 ..
    "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid."
    )
    AddNewOption(
    "大技能",
    "加尼尔的精华",
    222,
    true,
    { 3, 1, 5, 1 },
    { 80, 0, 100, 1 },
    "Use when selected number of units are under health threshold." ..
    C.TOOLTIP_VALUE_1 .. "Number of Units." .. C.TOOLTIP_VALUE_2 .. "Health threshold."
    )
    AddNewOption(
    "大技能",
    "加尼尔的精华所需的HoT数量",
    120,
    true,
    { 1, 1, 4, 1 },
    nil,
    "Minimum amount of Heal over Time buffs a unit must have to be considered in the Essence Of G'Hanir count."
    )
    AddNewOption(
    "大技能",
    "繁盛",
    222,
    true,
    { 3, 1, 5, 1 },
    { 70, 0, 100, 1 },
    "Use when selected number of units are under health threshold." ..
    C.TOOLTIP_VALUE_1 .. "Number of Units." .. C.TOOLTIP_VALUE_2 .. "Health threshold."
    )
    AddNewOption(
    "大技能",
    "繁盛所需的HoT数量",
    120,
    true,
    { 1, 1, 4, 1 },
    nil,
    "Minimum amount of Heal over Time buffs a unit must have to be considered in the Flourish count."
    )
    AddNewOption(
    "大技能",
    "繁盛配合野性成长",
    222,
    true,
    { 3, 1, 5, 1 },
    { 70, 0, 100, 1 },
    "Use when selected number of units with the Wild Growth buff are under health threshold." ..
    C.TOOLTIP_VALUE_1 .. "Number of Units." .. C.TOOLTIP_VALUE_2 .. "Health threshold."
    )
    AddNewOption(
    "大技能",
    "化身: 生命之树",
    222,
    true,
    { 2, 1, 25, 1 },
    { 60, 0, 100, 1 },
    "Use when selected number of units are under health threshold." ..
    C.TOOLTIP_VALUE_1 .. "Number of Units." .. C.TOOLTIP_VALUE_2 .. "Health threshold."
    )
    AddNewOption("大技能", "铁木树皮", 220, true, { 30, 0, 100, 1 }, nil, "Use Ironbark on a tank that fall under threshold.")
    AddNewOption(
    "大技能",
    "迅捷治愈",
    222,
    true,
    { 35, 0, 100, 1 },
    { 15, 0, 100, 1 },
    "Use Swiftmend." ..
    C.TOOLTIP_VALUE_1 ..
    "Health threshold to use on Tanks." ..
    C.TOOLTIP_VALUE_2 ..
    "Health threshold to use on any Raid members." ..
    C.TOOLTIP_HINT(
    "N.B. Swiftmend will still be used for Soul of the Forest buff before using Wild Growth even if this option is disabled. If you are using the Soul of the Forest talent, this should be set to very low value to make it most likely to use Wild Growth with the SotF buff."
    )
    )
    AddNewOption(
    "大技能",
    "宁静",
    222,
    true,
    { 3, 1, 25, 1 },
    { 70, 0, 100, 1 },
    "Use when selected number of units are under health threshold." ..
    C.TOOLTIP_VALUE_1 .. "Number of Units." .. C.TOOLTIP_VALUE_2 .. "Health threshold."
    )
    AddSection("攻/防", "伤害输出", "Yellow")
    AddNewOption(
    "攻/防",
    "DPS",
    223,
    true,
    { 95, 0, 100, 1 },
    { 1, "高", "Low" },
    "Enables DPS options." ..
    C.TOOLTIP_VALUE_1 ..
    "If set to High priority, Will only DPS if the Lowest unit is above DPS health treshold. If set to Low priority, will only Use Moonfire and Sunfire if our Mana is above thresold." ..
    C.TOOLTIP_VALUE_2 .. "Define if you would like to use the DPS as High or Low priority."
    )
    AddNewOption(
    "攻/防",
    "月火术",
    220,
    false,
    { 70, 1, 100, 1 },
    nil,
    "Use Moonfire in the DPS rotation when our mana is above threshold." ..
    C.TOOLTIP_VALUE_1 ..
    "Mana threshold." ..
    C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold")
    )
    AddNewOption(
    "攻/防",
    "多目标 月火术",
    222,
    false,
    { 5, 1, 10, 1 },
    { 3, 0, 25, 0.1 },
    "Multi-Dot Moonfire Cycle." ..
    C.TOOLTIP_VALUE_1 ..
    "Number of dots to apply." ..
    C.TOOLTIP_VALUE_2 ..
    "Minimum health (in million) to apply." ..
    C.TOOLTIP_HINT("Also applies to Balance, Guardian and Feral Affinities.")
    )
    AddNewOption(
    "攻/防",
    "多目标 阳炎术",
    222,
    false,
    { 10, 1, 10, 1 },
    { 3, 0, 25, 0.1 },
    "Multi-Dot Sunfire Cycle." ..
    C.TOOLTIP_VALUE_1 ..
    "Number of dots to apply." ..
    C.TOOLTIP_VALUE_2 ..
    "Minimum health (in million) to apply." .. C.TOOLTIP_HINT("Also applies to Balance Affinity.")
    )
    AddNewOption(
    "攻/防",
    "阳炎术",
    220,
    false,
    { 70, 1, 100, 1 },
    nil,
    "Use Sunfire in the DPS rotation when our mana is above threshold." ..
    C.TOOLTIP_VALUE_1 ..
    "Mana threshold." ..
    C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold")
    )
    AddNewOption(
    "攻/防",
    "阳炎之怒",
    210,
    false,
    nil,
    nil,
    "Use Solar Wrath in the DPS rotation." ..
    C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold")
    )
    AddSection("攻/防", "防御", "Yellow")
    AddNewOption(
    "攻/防",
    "树皮术",
    220,
    true,
    { 60, 1, 100, 1 },
    nil,
    "Use Barkskin." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddNewOption(
    "攻/防",
    "治疗物品",
    220,
    true,
    { 35, 1, 95, 1 },
    nil,
    "Use Healing Belt / Healing Pot / Healthstone." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddNewOption("攻/防", "新生", 220, true, { 40, 1, 100, 1 }, nil, "Use Renewal." .. C.TOOLTIP_VALUE .. "Health threshold.")
    AddSection("亲和", "平衡亲和", "Yellow")
    AddNewOption(
    "亲和",
    "平衡亲和",
    221,
    false,
    { 70, 0, 100, 1, 15 },
    { 90 },
    "Enable Balance Affinity DPS." ..
    C.TOOLTIP_VALUE_1 ..
    "Swap out of Moonkin Form when the Lowest unit health is under this threshold." ..
    C.TOOLTIP_VALUE_2 ..
    "Enter Moonkin Form when the Lowest unit's health is higher than this threshold."
    )
    AddSection("亲和", "野性亲和", "Yellow")
    AddNewOption(
    "亲和",
    "野性亲和",
    221,
    false,
    { 70, 0, 100, 1, 15 },
    { 90 },
    "Enable Feral Affinity DPS." ..
    C.TOOLTIP_VALUE_1 ..
    "Swap out of Cat Form when the Lowest unit health is under this threshold." ..
    C.TOOLTIP_VALUE_2 .. "Enter Cat Form when the Lowest unit's health is higher than this threshold."
    )
    AddNewOption("亲和", "割裂", 210, true, nil, nil, "Use Rip.")
    AddNewOption(
    "亲和",
    "横扫",
    220,
    true,
    { 3, 1, 10, 1 },
    nil,
    "Use Swipe." .. C.TOOLTIP_VALUE .. "Amount of units needed within 10 yards of player to use Swipe."
    )
    AddSection("亲和", "守护亲和", "Yellow")
    AddNewOption("亲和", "守护亲和", 210, false, nil, nil, "Enable Guardian Affinity Tanking.")
    AddNewOption(
    "亲和",
    "狂暴回复",
    220,
    true,
    { 35, 1, 100, 1 },
    nil,
    "Use Frenzied Regeneration." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddNewOption(
    "亲和",
    "守护亲和多目标月火术",
    222,
    false,
    { 5, 1, 10, 1 },
    { 3, 0, 25, 0.1 },
    "Multi-Dot Moonfire Cycle." ..
    C.TOOLTIP_VALUE_1 ..
    "Number of dots to apply." ..
    C.TOOLTIP_VALUE_2 ..
    "Minimum health (in million) to apply." ..
    C.TOOLTIP_HINT("Also applies to Balance, Guardian and Feral Affinities.")
    )
    AddNewOption(
    "亲和",
    "铁鬃",
    220,
    true,
    { 90, 1, 100, 1 },
    nil,
    "Use Ironfur." ..
    C.TOOLTIP_VALUE ..
    "Health threshold." .. C.TOOLTIP_HINT("Will be used regardless of health when rage is higher than 85.")
    )
    AddOutput("|cFF9A2EFE主T:")
    AddOutput("|cFF9A2EFE副T:")
    AddOutput("|cFF9A2EFE最低:")
    AddOutput("|cFF9A2EFE有害效果:")
    SetOutput("|cFF9A2EFE有害效果:", 0)
    ISCL = {
        [HealingTouch:ID()] = "治疗之触",
        [LunarStrike:ID()] = "Lunar Strike",
        [Regrowth:ID()] = "愈合",
        [SolarWrath:ID()] = "阳炎之怒",
        [Starsurge:ID()] = "星涌术",
        [WildGrowth:ID()] = "野性成长"
    }
end
function Rotation:Events()
end
function Rotation:Pulse()
    if
    Player:Channeling(Tranquility) or not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or
    Player:IsEating() or
    (Player:Buff(Dash) and Player:Buff(CatForm))
    then
        return
    end
    if BMPullTime() < 5 then
        self:Opening()
        return
    end
    if GetTime() < Rotation.SpamPrevention then
        return
    end
    Rotation.SpamPrevention = GetTime() + 0.05
    Target = Unit.Target
    local InCombat = Player:IsInCombat()
    Rotations:RefreshUnitTables(Rotation.Identifier)
    if not InCombat then
        SetOutput("|cFF9A2EFE有害效果:", 0)
        self:OutOfCombat()
        return
    end
    if InCombat then
        self:Defensives()
    end
    Target = Player:ReTarget(SolarWrath, true) or Unit.Target
    self:OffGCDAbilities()
    if Player:GlobalCooldown() == 0 then
        self:Combat()
    end
end
function Rotation:Opening()
    Player:UsePotions("智力药水", GetSecondOptionValue("抢先使用药水"))
    if
    Target:Exists() and IsOptionEnabled("抢先施放(需DBM插件)") and
    (GetOptionValue("抢先施放(需DBM插件)") == "无条件使用" or
    (GetOptionValue("抢先施放(需DBM插件)") == "打BOSS使用" and Target:IsBoss()))
    then
        if SolarWrath:Exists() and BMPullTime() < GetSecondOptionValue("抢先施放(需DBM插件)") and Target:CanCast(SolarWrath) then
            Target:Cast(SolarWrath)
            return
        end
    end
end
function Rotation:OffGCDAbilities()
    if GuardianAffinity:Exists() and IsOptionEnabled("守护亲和") and Player:Buff(BearForm) then
        if IsOptionEnabled("铁鬃") and Player:CanCast(Ironfur) then
            if
            Player:Rage() >= 85 or
            (Player:HealthPercentage() <= GetOptionValue("铁鬃") and Player:Rage() >= 40 and
            not Player:Buff(Ironfur))
            then
                Player:Cast(Ironfur)
                return
            end
        end
        if IsOptionEnabled("狂暴回复") and Player:CanCast(FrenziedRegeneration) and not Player:Buff(FrenziedRegeneration) then
            if Player:HealthPercentage() <= GetOptionValue("狂暴回复") and Player:Rage() >= 10 then
                Player:Cast(FrenziedRegeneration)
                return
            end
        end
    end
end
function Rotation:Defensives()
    Player:UseHealingItem()
    if
    Renewal:Exists() and IsOptionEnabled("新生") and Player:SpecialHealthPercentage() <= GetOptionValue("新生") and
    Player:CanCast(Renewal)
    then
        Player:Cast(Renewal)
        return
    end
    if
    Barkskin:Exists() and IsOptionEnabled("树皮术") and Player:SpecialHealthPercentage() <= GetOptionValue("树皮术") and
    Player:CanCast(Barkskin)
    then
        Player:Cast(Barkskin)
    end
end
Rotation.TanksStatus, Rotation.MainTankTanking, Rotation.OffTankTanking = {
    Main = { IsTanking = GetTime() },
    Off = { IsTanking = GetTime() }
}
function Rotation:RefreshTanksStatus()
    self.TanksStatus = {
        Main = {
            IsTanking = MainTank and MainTank:ThreatSituation() == 3 and GetTime() or self.TanksStatus.Main.IsTanking
        },
        Off = { IsTanking = OffTank and OffTank:ThreatSituation() == 3 and GetTime() or self.TanksStatus.Off.IsTanking }
    }
    self.MainTankTanking = GetTime() - self.TanksStatus.Main.IsTanking < 3 or false
    self.OffTankTanking = GetTime() - self.TanksStatus.Off.IsTanking < 3 or false
end
function Rotation:HealTarget(ThisUnit)
    if ThisUnit:CanCast(Regrowth) then
        Bug("Heal Target - Regrowth")
        ThisUnit:Cast(Regrowth)
        return
    end
end
function Rotation:UnitTables()
    HealingRange = AstralInfluence:Exists() and 45 or 40
    HealUnits = Player:HealUnitsAround(100, 40)
    CurrentBadDebuffs = Player:GetRaidDebuffs(HealUnits)
    if CurrentBadDebuffs ~= nil then
        SetOutput("|cFF9A2EFE有害效果:", #CurrentBadDebuffs.Tanks + #CurrentBadDebuffs.Top + #CurrentBadDebuffs.Debuff)
    end
    DispelUnit = Unit.Dispel(HealUnits, NaturesCure)
    MainTank, MainTankTarget, OffTank, OffTankTarget = Unit.GetMainTanks()
    self:RefreshTanksStatus()
    Lowest = Unit.Lowest(HealUnits)
    SetOutput("|cFF9A2EFE最低:", Lowest and Lowest:Name() or "")
    Trinket1Units =     IsOptionEnabled("使用饰品 1") and Trinket1:IsUsableInventory() and
    #Player:HealUnitsAround(GetSecondOptionValue("使用饰品 1"), HealingRange) or
    0
    Trinket2Units =     IsOptionEnabled("使用饰品 2") and Trinket2:IsUsableInventory() and
    #Player:HealUnitsAround(GetSecondOptionValue("使用饰品 2"), HealingRange) or
    0
    RacialsUnits =     IsOptionEnabled("使用种族技能") and (Berserking:Exists() and Player:CanCast(Berserking)) and
    #Player:HealUnitsAround(GetOptionValue("使用种族技能"), HealingRange) or
    0
    ProlongedPowerUnitsCount =     IsOptionEnabled("延时之力药水") and #Player:HealUnitsAround(GetSecondOptionValue("延时之力药水"), 40) or 0
    RejuvenationUnits = #Player:UnitsWithBuff(HealUnits, Rejuvenation, 4)
    GerminationUnits = #Player:UnitsWithBuff(HealUnits, GerminationRejuvenation, 4)
    WildGrowthUnits = Player:UnitsWithBuff(HealUnits, WildGrowth, 2)
    WildGrowthUnit =     IsOptionEnabled("野性成长") and WildGrowth:Exists() and
    ((Player:Buff(SoulOfTheForestBuff) and
    Player:BestClusterOfAlliesToHeal(GetOptionValue("野性成长") - 1, GetSecondOptionValue("野性成长"), 30)) or
    Player:BestClusterOfAlliesToHeal(GetOptionValue("野性成长"), GetSecondOptionValue("野性成长"), 30)) or
    nil
    TranquilityUnits = Tranquility:Exists() and Player:HealUnitsAround(GetSecondOptionValue("宁静"), HealingRange) or {}
    IncarnationTreeOfLifeUnits =     IncarnationTreeOfLife:Exists() and Player:HealUnitsAround(GetSecondOptionValue("化身: 生命之树"), HealingRange) or {}
    Enemies = Player:EnemiesWithinDistance(40)
    if
    Efflorescence:Exists() and IsOptionEnabled("百花齐放") and not Efflorescence:IsOnCooldown() and
    Efflorescence:TotemDuration() < 23
    then
        EfflorescenceCount, EfflorescenceUnits = Player:BestGroundHealUnits(HealUnits, GetSecondOptionValue("百花齐放"), 10)
        CurrentEfflorescenceUnits =         Efflorescence:TotemDuration() > 0 and Unit.FriendliesNearMushroom(HealUnits, 12) or 0
    else
        EfflorescenceCount, EfflorescenceUnits, CurrentEfflorescenceUnits = 0, {}, 0
    end
    MoonfireUnit = Unit.DotCycle(Enemies, Moonfire, MoonfireDebuff, 22, "多目标 月火术")
    SunfireUnit = Unit.DotCycle(Enemies, Sunfire, SunfireDebuff, 22, "多目标 阳炎术")
    GuardianMoonfireUnit =     GuardianAffinity:Exists() and IsOptionEnabled("守护亲和多目标月火术") and
    Unit.DotCycle(Enemies, Moonfire, MoonfireDebuff, 22, "守护亲和多目标月火术") or
    nil
    PlayerEnemies_10y =     FeralAffinity:Exists() and IsOptionEnabled("野性亲和") and IsOptionEnabled("横扫") and
    Player:EnemiesWithinDistance(10, true) or
    {}
end
function Rotation:RemoveForm()
    if Player:Buff(MoonkinForm) then
        RunMacroText("/cancelaura " .. MoonkinForm:Name())
    elseif Player:Buff(CatForm) then
        RunMacroText("/cancelaura " .. CatForm:Name())
    elseif Player:Buff(BearForm) then
        RunMacroText("/cancelaura " .. BearForm:Name())
    end
end
function Rotation:Combat()
    if Target:Exists() and Target:CanCast(SolarWrath) then
        BestTarget = Target
    elseif MainTankTarget and MainTankTarget:CanCast(SolarWrath) then
        BestTarget = MainTankTarget
    elseif OffTankTarget and OffTankTarget:CanCast(SolarWrath) then
        BestTarget = OffTankTarget
    elseif Mouseover:Exists() and Mouseover:CanCast(SolarWrath) then
        BestTarget = Mouseover
    else
        BestTarget = Target
    end
    if Player:IsInCombat() or GetSecondOptionValue("脱离战斗后暂停治疗") == "启用" then
        if GuardianAffinity:Exists() and IsOptionEnabled("守护亲和") then
            if not Player:Buff(BearForm) and Player:CanCast(BearForm) then
                Player:Cast(BearForm)
                return
            end
            if Player:IsWithinCastRange(BestTarget, Mangle) then
                if not BestTarget:Debuff(ThrashDebuff) and Player:CanCast(Thrash) then
                    Player:Cast(Thrash)
                    return
                end
                if BestTarget:CanCast(Mangle) then
                    BestTarget:Cast(Mangle)
                    return
                end
                if Player:CanCast(Thrash) then
                    Player:Cast(Thrash)
                    return
                end
            end
            if Moonfire:Exists() then
                if BestTarget:DebuffRemains(MoonfireDebuff) < 6 and BestTarget:CanCast(Moonfire) then
                    BestTarget:Cast(Moonfire)
                    return
                end
                if GuardianMoonfireUnit and GuardianMoonfireUnit:CanCast(Moonfire) then
                    GuardianMoonfireUnit:Cast(Moonfire)
                    return
                end
            end
            return
        end
    end
    if MainTank and MainTank:Exists() and not MainTank:IsDeadOrGhost() then
        MainTankResDelay = nil
    end
    if OffTank and OffTank:Exists() and not OffTank:IsDeadOrGhost() then
        OffTankResDelay = nil
    end
    if IsOptionEnabled("复生 坦克") then
        if
        MainTank and MainTank:Exists() and MainTank:IsDeadOrGhost() and MainTank:IsPlayer() and
        MainTank:CanCast(Rebirth)
        then
            if not MainTankResDelay then
                MainTankResDelay = GetTime()
            end
            if GetTime() - MainTankResDelay >= GetOptionValue("复生 坦克") then
                MainTankResDelay = nil
                MainTank:Cast(Rebirth)
                return
            end
        elseif
        OffTank and OffTank:Exists() and OffTank:IsDeadOrGhost() and OffTank:IsPlayer() and OffTank:CanCast(Rebirth)
        then
            if not OffTankResDelay then
                OffTankResDelay = GetTime()
            end
            if GetTime() - OffTankResDelay >= GetOptionValue("复生 坦克") then
                OffTankResDelay = nil
                OffTank:Cast(Rebirth)
                return
            end
        end
    end
    if
    IsOptionEnabled("复生") and Target:Exists() and Target:IsDeadOrGhost() and not Player:IsMoving() and
    Target:IsPlayer() and
    Target:CanCast(Rebirth)
    then
        Target:Cast(Rebirth)
        return
    end
    if CurrentBadDebuffs ~= nil then
        Player:DispelHandler(NaturesCure, "驱散", DispelUnit, CurrentBadDebuffs.Dispel, "高")
    end
    if Player:IsInCombat() or GetSecondOptionValue("脱离战斗后暂停治疗") == "启用" then
        if FeralAffinity:Exists() and IsOptionEnabled("野性亲和") and not (CurrentBadDebuffs and #CurrentBadDebuffs.Top > 0) then
            if
            not Player:Buff(CatForm) and Lowest:HealthPercentage() > GetSecondOptionValue("野性亲和") and BestTarget and
            BestTarget:Exists() and
            Player:CanAttack(BestTarget) and
            Player:IsWithinCastRange(BestTarget, Shred) and
            Player:CanCast(CatForm)
            then
                Player:Cast(CatForm)
                return
            end
            if Player:Buff(CatForm) and Lowest:HealthPercentage() < GetOptionValue("野性亲和") and Player:CanCast(CatForm) then
                self:RemoveForm()
                return
            end
            if
            BestTarget and BestTarget:Exists() and Player:Buff(CatForm) and
            Lowest:HealthPercentage() > GetOptionValue("野性亲和")
            then
                if
                Rip:Exists() and IsOptionEnabled("割裂") and Player:ComboPoints() >= 5 and
                BestTarget:DebuffRemains(Rip) < 8.5 and
                (BestTarget:HealthPercentage() > 25 or not BestTarget:Debuff(Rip)) and
                BestTarget:TimeToDie() > 12 and
                BestTarget:CanCast(Rip)
                then
                    BestTarget:Cast(Rip)
                    return
                end
                if
                Rip:Exists() and IsOptionEnabled("割裂") and Player:ComboPoints() >= 1 and not BestTarget:Debuff(Rip) and
                BestTarget:TimeToDie() < 12 and
                BestTarget:TimeToDie() > 3 and
                BestTarget:CanCast(Rip)
                then
                    BestTarget:Cast(Rip)
                    return
                end
                if
                FerociousBite:Exists() and Player:ComboPoints() >= 1 and BestTarget:Debuff(Rip) and
                BestTarget:DebuffRemains(Rip) < 3 and
                BestTarget:HealthPercentage() < 25 and
                BestTarget:CanCast(FerociousBite)
                then
                    BestTarget:Cast(FerociousBite)
                    return
                end
                if
                FerociousBite:Exists() and Player:ComboPoints() >= 5 and Player:PowerTimeToMax() < 1.5 and
                BestTarget:CanCast(FerociousBite)
                then
                    BestTarget:Cast(FerociousBite)
                    return
                end
                if Player:PowerTimeToMax() < 1.5 then
                    if IsOptionEnabled("横扫") and #PlayerEnemies_10y >= GetOptionValue("横扫") then
                        if Player:CanCast(Swipe) then
                            Player:Cast(Swipe)
                            return
                        end
                    else
                        if
                        Rake:Exists() and BestTarget:DebuffRemains(RakeDebuff) < 4.5 and BestTarget:TimeToDie() > 6 and
                        BestTarget:CanCast(Rake)
                        then
                            BestTarget:Cast(Rake)
                            return
                        end
                        if BestTarget:CanCast(Shred) then
                            BestTarget:Cast(Shred)
                            return
                        end
                    end
                end
            end
            if
            Player:Buff(CatForm) and Lowest:HealthPercentage() > GetOptionValue("野性亲和") and BestTarget and
            BestTarget:Exists() and
            Player:DistanceTo(Target) < 10
            then
                return
            end
        end
        if
        BalanceAffinity:Exists() and IsOptionEnabled("平衡亲和") and BestTarget and BestTarget:Exists() and
        Player:CanAttack(BestTarget) and
        Player:IsWithinCastRange(BestTarget, Moonfire) and
        not (CurrentBadDebuffs and #CurrentBadDebuffs.Top > 0)
        then
            if
            MoonkinForm:Exists() and Lowest:HealthPercentage() > GetSecondOptionValue("平衡亲和") and
            not Player:Buff(MoonkinForm) and
            (not Player:Buff(CatForm) or Player:Buff(DisplacerBeast)) and
            not Player:Buff(BearForm) and
            not Player:Buff(TravelForm) and
            Player:CanCast(MoonkinForm)
            then
                Player:Cast(MoonkinForm)
                return
            end
            if
            Player:Buff(MoonkinForm) and Lowest:HealthPercentage() < GetOptionValue("平衡亲和") and
            Player:CanCast(MoonkinForm)
            then
                self:RemoveForm()
                return
            end
            if Player:Buff(MoonkinForm) and Lowest:HealthPercentage() > GetOptionValue("平衡亲和") then
                if Starsurge:Exists() and BestTarget:CanCast(Starsurge) then
                    BestTarget:Cast(Starsurge)
                    return
                end
                if Sunfire:Exists() and Player:ManaPercentage() >= GetOptionValue("阳炎术") then
                    if BestTarget:DebuffRemains(SunfireDebuff) < 5 and BestTarget:CanCast(Sunfire) then
                        BestTarget:Cast(Sunfire)
                        return
                    end
                    if IsOptionEnabled("多目标 阳炎术") and SunfireUnit and SunfireUnit:CanCast(Sunfire) then
                        SunfireUnit:Cast(Sunfire)
                        return
                    end
                end
                if Moonfire:Exists() and Player:ManaPercentage() >= GetOptionValue("月火术") then
                    if BestTarget:DebuffRemains(MoonfireDebuff) < 6 and BestTarget:CanCast(Moonfire) then
                        BestTarget:Cast(Moonfire)
                        return
                    end
                    if IsOptionEnabled("多目标 月火术") and MoonfireUnit and MoonfireUnit:CanCast(Moonfire) then
                        MoonfireUnit:Cast(Moonfire)
                        return
                    end
                end
                if SolarWrath:Exists() and Player:Buff(SolarEmpowerment) and BestTarget:CanCast(SolarWrath) then
                    BestTarget:Cast(SolarWrath)
                    return
                end
                if LunarStrike:Exists() and BestTarget:CanCast(LunarStrike) then
                    BestTarget:Cast(LunarStrike)
                    return
                end
            end
            if
            Player:Buff(MoonkinForm) and Lowest:HealthPercentage() > GetOptionValue("平衡亲和") and BestTarget and
            BestTarget:Exists() and
            Player:IsWithinCastRange(BestTarget, Moonfire)
            then
                return
            end
        end
    end
    if Player:Buff(BearForm) or Player:Buff(CatForm) or Player:Buff(MoonkinForm) then
        if IsOptionEnabled("自动变形") then
            self:RemoveForm()
        end
        return
    end
    if Player:IsInCombat() or GetSecondOptionValue("脱离战斗后暂停治疗") == "启用" then
        if
        BestTarget and IsOptionEnabled("DPS") and GetSecondOptionValue("DPS") == "高" and
        (not Lowest or Lowest:HealthPercentage() >= GetOptionValue("DPS")) and
        (not MainTank or MainTank:HealthPercentage() >= GetOptionValue("DPS")) and
        (not OffTank or OffTank:HealthPercentage() >= GetOptionValue("DPS")) and
        BestTarget:IsInCombat()
        then
            if Sunfire:Exists() and Player:ManaPercentage() >= GetOptionValue("阳炎术") then
                if
                IsOptionEnabled("阳炎术") and BestTarget:DebuffRemains(SunfireDebuff) < 5 and
                BestTarget:CanCast(Sunfire)
                then
                    BestTarget:Cast(Sunfire)
                    return
                end
                if IsOptionEnabled("多目标 阳炎术") and SunfireUnit and SunfireUnit:CanCast(Sunfire) then
                    SunfireUnit:Cast(Sunfire)
                    return
                end
            end
            if Moonfire:Exists() and Player:ManaPercentage() >= GetOptionValue("月火术") then
                if
                IsOptionEnabled("月火术") and BestTarget:DebuffRemains(MoonfireDebuff) < 6 and
                BestTarget:CanCast(Moonfire)
                then
                    BestTarget:Cast(Moonfire)
                    return
                end
                if IsOptionEnabled("多目标 月火术") and MoonfireUnit and MoonfireUnit:CanCast(Moonfire) then
                    MoonfireUnit:Cast(Moonfire)
                    return
                end
            end
            if SolarWrath:Exists() and IsOptionEnabled("阳炎之怒") and BestTarget:CanCast(SolarWrath) then
                BestTarget:Cast(SolarWrath)
                return
            end
        end
    end
    if Player:IsInCombat() then
        if IsOptionEnabled("使用种族技能") then
            if RacialsUnits >= GetOptionValue("使用种族技能和饰品的单位数量") then
                if Berserking:Exists() and Player:CanCast(Berserking) then
                    CastSpellByID(26297, "player")
                    return
                end
            end
        end
        if IsOptionEnabled("使用饰品 1") and Trinket1:IsUsableInventory() then
            local Option1, Option2 = GetOptionValue("使用饰品 1"), GetSecondOptionValue("使用饰品 1")
            if
            Option1 == "无条件使用" or (Option1 == "血量" and Trinket1Units >= GetOptionValue("使用种族技能和饰品的单位数量")) or
            (Option1 == "蓝量" and Player:PowerPercentage() < GetSecondOptionValue("使用饰品 1"))
            then
                Trinket1:UseInventory()
            end
        end
        if IsOptionEnabled("使用饰品 2") and Trinket2:IsUsableInventory() then
            local Option1, Option2 = GetOptionValue("使用饰品 2"), GetSecondOptionValue("使用饰品 2")
            if
            Option1 == "无条件使用" or (Option1 == "血量" and Trinket2Units >= GetOptionValue("使用种族技能和饰品的单位数量")) or
            (Option1 == "蓝量" and Player:PowerPercentage() < GetSecondOptionValue("使用饰品 2"))
            then
                Trinket2:UseInventory()
            end
        end
        if
        IncarnationTreeOfLife:Exists() and IsOptionEnabled("化身: 生命之树") and
        #IncarnationTreeOfLifeUnits >= GetOptionValue("化身: 生命之树") and
        not Player:Buff(IncarnationTreeOfLife) and
        Player:CanCast(IncarnationTreeOfLife)
        then
            Player:Cast(IncarnationTreeOfLife)
            return
        end
        if
        Tranquility:Exists() and IsOptionEnabled("宁静") and #TranquilityUnits >= GetOptionValue("宁静") and
        Player:CanCast(Tranquility)
        then
            Player:Cast(Tranquility)
            return
        end
        if Ironbark:Exists() and IsOptionEnabled("铁木树皮") then
            if MainTank and MainTank:SpecialHealthPercentage() <= GetOptionValue("铁木树皮") and MainTank:CanCast(Ironbark) then
                Bug("Ironbark - MainTank")
                MainTank:Cast(Ironbark)
                return
            end
            if OffTank and OffTank:SpecialHealthPercentage() <= GetOptionValue("铁木树皮") and OffTank:CanCast(Ironbark) then
                Bug("Ironbark - OffTank")
                OffTank:Cast(Ironbark)
                return
            end
        end
    end
    if Player:IsInCombat() or GetOptionValue("脱离战斗后暂停治疗") == "启用" then
        if Swiftmend:Exists() and IsOptionEnabled("迅捷治愈") then
            if Regrowth:Exists() and Player:Buff(SoulOfTheForestBuff) then
                if
                MainTank and MainTank:SpecialHealthPercentage() < GetOptionValue("迅捷治愈") and
                MainTank:CanCast(Regrowth)
                then
                    Bug("Regrowth SotF instead of Swiftmend Emergency - MainTank")
                    MainTank:Cast(Regrowth)
                    return
                end
                if OffTank and OffTank:SpecialHealthPercentage() < GetOptionValue("迅捷治愈") and OffTank:CanCast(Regrowth) then
                    Bug("Regrowth SotF instead of Swiftmend Emergency - OffTank")
                    OffTank:Cast(Regrowth)
                    return
                end
                if
                Lowest and Lowest:SpecialHealthPercentage() < GetSecondOptionValue("迅捷治愈") and
                Lowest:CanCast(Regrowth)
                then
                    Bug("Regrowth SotF instead of Swiftmend Emergency - Lowest")
                    Lowest:Cast(Regrowth)
                    return
                end
            end
            if MainTank and MainTank:SpecialHealthPercentage() < GetOptionValue("迅捷治愈") and MainTank:CanCast(Swiftmend) then
                Bug("Swiftmend - MainTank")
                MainTank:Cast(Swiftmend)
                return
            end
            if OffTank and OffTank:SpecialHealthPercentage() < GetOptionValue("迅捷治愈") and OffTank:CanCast(Swiftmend) then
                Bug("Swiftmend - OffTank")
                OffTank:Cast(Swiftmend)
                return
            end
            if Lowest and Lowest:SpecialHealthPercentage() < GetSecondOptionValue("迅捷治愈") and Lowest:CanCast(Swiftmend) then
                Bug("Swiftmend - Lowest")
                Lowest:Cast(Swiftmend)
                return
            end
        end
        if Player:IsInCombat() then
            if Flourish:Exists() and IsOptionEnabled("繁盛") and Player:CanCast(Flourish) then
                if not FlourishRefresh or FlourishRefresh < GetTime() then
                    LowHealthUnits =                     Flourish:Exists() and IsOptionEnabled("繁盛") and
                    Player:HealUnitsAround(GetSecondOptionValue("繁盛"), HealingRange) or
                    {}
                    FlourishUnitsCount = 0
                    for i = 1, #LowHealthUnits do
                        ThisUnit, ThisUnitBuffCount = LowHealthUnits[i], 0
                        ThisUnitBuffCount = ThisUnit:Buff(Rejuvenation) and ThisUnitBuffCount + 1 or ThisUnitBuffCount
                        ThisUnitBuffCount =                         ThisUnit:Buff(GerminationRejuvenation) and ThisUnitBuffCount + 1 or ThisUnitBuffCount
                        ThisUnitBuffCount = ThisUnit:Buff(Regrowth) and ThisUnitBuffCount + 1 or ThisUnitBuffCount
                        ThisUnitBuffCount = ThisUnit:Buff(Swiftmend) and ThisUnitBuffCount + 1 or ThisUnitBuffCount
                        ThisUnitBuffCount = ThisUnit:Buff(WildGrowth) and ThisUnitBuffCount + 1 or ThisUnitBuffCount
                        ThisUnitBuffCount = ThisUnit:Buff(Lifebloom) and ThisUnitBuffCount + 1 or ThisUnitBuffCount
                        FlourishUnitsCount =                         ThisUnitBuffCount >= GetOptionValue("繁盛所需的HoT数量") and FlourishUnitsCount + 1 or
                        FlourishUnitsCount
                    end
                    FlourishRefresh = GetTime() + 0.5
                end
                if FlourishUnitsCount >= GetOptionValue("加尼尔的精华") then
                    Bug("Using Flourish with " .. tostring(FlourishUnitsCount) .. " valid units.")
                    Player:Cast(Flourish)
                    return
                end
            end
            if
            Flourish:Exists() and WildGrowth:TimeSinceCast() > 4 and IsOptionEnabled("繁盛配合野性成长") and
            Player:CanCast(Flourish)
            then
                FlourishUnitsCount = 0
                if #WildGrowthUnits >= 3 then
                    for i = 1, #WildGrowthUnits do
                        ThisUnit = WildGrowthUnits[i]
                        if ThisUnit:SpecialHealthPercentage() < GetSecondOptionValue("繁盛配合野性成长") then
                            FlourishUnitsCount = FlourishUnitsCount + 1
                        end
                    end
                end
                if FlourishUnitsCount >= GetOptionValue("繁盛配合野性成长") then
                    Bug("Flourish to refresh Wild Growth")
                    Player:Cast(Flourish)
                    return
                end
            end
            if EssenceOfGHanir:Exists() and IsOptionEnabled("加尼尔的精华") and Player:CanCast(EssenceOfGHanir) then
                if not GhanirRefresh or GhanirRefresh < GetTime() then
                    LowHealthUnits =                     EssenceOfGHanir:Exists() and IsOptionEnabled("加尼尔的精华") and
                    Player:HealUnitsAround(GetSecondOptionValue("加尼尔的精华"), HealingRange) or
                    {}
                    EoGUnitsCount = 0
                    for i = 1, #LowHealthUnits do
                        ThisUnit, ThisUnitBuffCount = LowHealthUnits[i], 0
                        ThisUnitBuffCount = ThisUnit:Buff(Rejuvenation) and ThisUnitBuffCount + 1 or ThisUnitBuffCount
                        ThisUnitBuffCount =                         ThisUnit:Buff(GerminationRejuvenation) and ThisUnitBuffCount + 1 or ThisUnitBuffCount
                        ThisUnitBuffCount = ThisUnit:Buff(Regrowth) and ThisUnitBuffCount + 1 or ThisUnitBuffCount
                        ThisUnitBuffCount = ThisUnit:Buff(Swiftmend) and ThisUnitBuffCount + 1 or ThisUnitBuffCount
                        ThisUnitBuffCount = ThisUnit:Buff(WildGrowth) and ThisUnitBuffCount + 1 or ThisUnitBuffCount
                        ThisUnitBuffCount = ThisUnit:Buff(Lifebloom) and ThisUnitBuffCount + 1 or ThisUnitBuffCount
                        EoGUnitsCount =                         ThisUnitBuffCount >= GetOptionValue("加尼尔的精华所需的HoT数量") and EoGUnitsCount + 1 or EoGUnitsCount
                    end
                    GhanirRefresh = GetTime() + 0.5
                end
                if EoGUnitsCount >= GetOptionValue("加尼尔的精华") then
                    Bug("Using Essence Of GHanir with " .. tostring(EoGUnitsCount) .. " valid units.")
                    Player:Cast(EssenceOfGHanir)
                    return
                end
            end
        end
        if CurrentBadDebuffs ~= nil then
            Player:DispelHandler(NaturesCure, "驱散", DispelUnit, CurrentBadDebuffs.Dispel, "正常")
        end
        if
        Target:CanCast(Regrowth) and IsOptionEnabled("治疗目标") and
        (GetOptionValue("治疗目标") == 2 or
        (Target:ShouldBeHealed() ~= 0 and Target:HealthPercentage() < Target:ShouldBeHealed()))
        then
            self:HealTarget(Target)
            return
        end
        if IsOptionEnabled("紧急治疗") then
            MainTankHealth = MainTank and MainTank:CanCast(Regrowth) and MainTank:SpecialHealthPercentage() or 100
            OffTankHealth = OffTank and OffTank:CanCast(Regrowth) and OffTank:SpecialHealthPercentage() or 100
            BestTankTarget = MainTankHealth < OffTankHealth and MainTank or OffTank
            if BestTankTarget and BestTankTarget:SpecialHealthPercentage() < GetOptionValue("紧急治疗") then
                if Swiftmend:Exists() and BestTankTarget:CanCast(Swiftmend) then
                    Bug("Swiftmend - Tanks Emergency")
                    BestTankTarget:Cast(Swiftmend)
                    return
                elseif not Player:IsMoving() and BestTankTarget:CanCast(Regrowth) then
                    Bug("Regrowth - Tanks Emergency")
                    BestTankTarget:Cast(Regrowth)
                    return
                end
            end
            if Player:SpecialHealthPercentage() < GetSecondOptionValue("紧急治疗") then
                if Swiftmend:Exists() and Player:CanCast(Swiftmend) then
                    Bug("Swiftmend - Player Emergency")
                    Player:Cast(Swiftmend)
                    return
                elseif not Player:IsMoving() and Player:CanCast(Regrowth) then
                    Bug("Regrowth - Player Emergency")
                    Player:Cast(Regrowth)
                    return
                end
            end
        end
        if
        Efflorescence:Exists() and CurrentEfflorescenceUnits < GetOptionValue("百花齐放") and
        EfflorescenceCount >= GetOptionValue("百花齐放") and
        Player:CanCast(Efflorescence)
        then
            Bug(
            "Efflorescence " ..
            " Count:" ..
            EfflorescenceCount ..
            " Units:" .. #EfflorescenceUnits .. "Current Units:" .. CurrentEfflorescenceUnits
            )
            Player:CastGroundHeal(Efflorescence, EfflorescenceUnits)
            return
        end
        if WildGrowthUnit and WildGrowthUnit:CanCast(WildGrowth) then
            if SoulOfTheForest:Exists() and not Swiftmend:IsOnCooldown() and not Player:Buff(SoulOfTheForestBuff) then
                local BestLowest, BestLowestHealth = nil, 100
                if Lowest and Lowest:CanCast(Swiftmend) then
                    BestLowest, BestLowestHealth = Lowest, Lowest:SpecialHealthPercentage()
                end
                if
                OffTank and OffTank:CanCast(Swiftmend) and
                (not BestLowest or OffTank:SpecialHealthPercentage() < BestLowestHealth)
                then
                    BestLowest, BestLowestHealth = OffTank, OffTank:SpecialHealthPercentage()
                end
                if
                MainTank and MainTank:CanCast(Swiftmend) and
                (not BestLowest or MainTank:SpecialHealthPercentage() < BestLowestHealth)
                then
                    BestLowest, BestLowestHealth = MainTank, MainTank:SpecialHealthPercentage()
                end
                if BestLowest and BestLowest:CanCast(Swiftmend) then
                    BestLowest:Cast(Swiftmend)
                    return
                end
            end
            if WildGrowthUnit:CanCast(WildGrowth) then
                WildGrowthUnit:Cast(WildGrowth)
                return
            end
        end
        if IsOptionEnabled("愈合 急救") then
            if MainTank and MainTank:SpecialHealthPercentage() <= GetOptionValue("愈合 急救") and MainTank:CanCast(Regrowth) then
                MainTank:Cast(Regrowth)
                return
            elseif
            OffTank and OffTank:SpecialHealthPercentage() <= GetOptionValue("愈合 急救") and OffTank:CanCast(Regrowth)
            then
                OffTank:Cast(Regrowth)
                return
            elseif
            Lowest and Lowest:SpecialHealthPercentage() <= GetSecondOptionValue("愈合 急救") and
            Lowest:CanCast(Regrowth)
            then
                Lowest:Cast(Regrowth)
                return
            end
        end
        if Lifebloom:Exists() and IsOptionEnabled("生命绽放") and Lifebloom:TimeSinceCast() > 7 then
            if
            MainTank and self.MainTankTanking and
            (not MainTank:Buff(Lifebloom) or
            (MainTank:BuffRemains(Lifebloom) < 3 and
            MainTank:SpecialHealthPercentage() >= GetOptionValue("生命绽放"))) and
            MainTank:CanCast(Lifebloom)
            then
                Lifebloom.LastCastTime = GetTime()
                MainTank:Cast(Lifebloom)
                return
            end
            if
            OffTank and self.OffTankTanking and not (MainTank and self.MainTankTanking) and
            (not OffTank:Buff(Lifebloom) or
            (OffTank:BuffRemains(Lifebloom) < 3 and
            OffTank:SpecialHealthPercentage() >= GetOptionValue("生命绽放"))) and
            OffTank:CanCast(Lifebloom)
            then
                Lifebloom.LastCastTime = GetTime()
                OffTank:Cast(Lifebloom)
                return
            end
            if
            MainTank and not (OffTank and self.OffTankTanking) and
            (not MainTank:Buff(Lifebloom) or
            (MainTank:BuffRemains(Lifebloom) < 3 and
            MainTank:SpecialHealthPercentage() >= GetOptionValue("生命绽放"))) and
            MainTank:CanCast(Lifebloom)
            then
                Lifebloom.LastCastTime = GetTime()
                MainTank:Cast(Lifebloom)
                return
            end
        end
        if CenarionWard:Exists() and IsOptionEnabled("塞纳里奥结界") then
            if
            MainTank and MainTank:ThreatSituation() >= 2 and
            MainTank:SpecialHealthPercentage() <= GetOptionValue("塞纳里奥结界") and
            MainTank:CanCast(CenarionWard)
            then
                MainTank:Cast(CenarionWard)
                return
            elseif
            OffTank and OffTank:ThreatSituation() >= 2 and
            OffTank:SpecialHealthPercentage() <= GetOptionValue("塞纳里奥结界") and
            OffTank:CanCast(CenarionWard)
            then
                OffTank:Cast(CenarionWard)
                return
            elseif
            Lowest and Lowest:ThreatSituation() >= 2 and
            Lowest:SpecialHealthPercentage() <= GetSecondOptionValue("塞纳里奥结界") and
            Lowest:CanCast(CenarionWard)
            then
                Lowest:Cast(CenarionWard)
                return
            end
        end
        if IsOptionEnabled("坦克Debuffs") and CurrentBadDebuffs and #CurrentBadDebuffs.Tanks > 0 then
            local BestUnit, BestUnitHealth = nil, 100
            for i = 1, #CurrentBadDebuffs.Tanks do
                local ThisUnit, ThisUnitHealth =                 CurrentBadDebuffs.Tanks[i],
                CurrentBadDebuffs.Tanks[i]:SpecialHealthPercentage()
                if ThisUnit:CanCast(Rejuvenation) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth
                end
            end
            if IsOptionEnabled("坦克Debuffs") and BestUnit ~= nil and BestUnitHealth < GetOptionValue("坦克Debuffs") then
                if BestUnit:CanCast(Rejuvenation) and not BestUnit:Buff(Rejuvenation) then
                    BestUnit:Cast(Rejuvenation)
                    Bug("Rejuvenation on " .. BestUnit:Name() .. " to heal debuff")
                    return
                end
                if
                Germination:Exists() and BestUnit:CanCast(Rejuvenation) and
                not BestUnit:Buff(GerminationRejuvenation)
                then
                    BestUnit:Cast(Rejuvenation)
                    Bug("Germination on " .. BestUnit:Name() .. " to heal debuff")
                    return
                end
            end
        end
        if IsOptionEnabled("团队成员Debuffs") and CurrentBadDebuffs and #CurrentBadDebuffs.Debuff > 0 then
            local BestUnit, BestUnitHealth = nil, 100
            for i = 1, #CurrentBadDebuffs.Debuff do
                local ThisUnit, ThisUnitHealth =                 CurrentBadDebuffs.Debuff[i],
                CurrentBadDebuffs.Debuff[i]:SpecialHealthPercentage()
                if ThisUnit:CanCast(Rejuvenation) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth
                end
            end
            if IsOptionEnabled("团队成员Debuffs") and BestUnit ~= nil and BestUnitHealth < GetOptionValue("团队成员Debuffs") then
                if BestUnit:CanCast(Rejuvenation) and not BestUnit:Buff(Rejuvenation) then
                    BestUnit:Cast(Rejuvenation)
                    Bug("Rejuvenation on " .. BestUnit:Name() .. " to heal debuff")
                    return
                end
                if
                Germination:Exists() and BestUnit:CanCast(Rejuvenation) and
                not BestUnit:Buff(GerminationRejuvenation)
                then
                    BestUnit:Cast(Rejuvenation)
                    Bug("Germination on " .. BestUnit:Name() .. " to heal debuff")
                    return
                end
            end
        end
        if IsOptionEnabled("愈合") then
            if
            MainTank and MainTank:SpecialHealthPercentage() <= 35 and
            MainTank:BuffRemains(Regrowth) < 3.6 + Regrowth:CastTime() and
            MainTank:CanCast(Regrowth)
            then
                MainTank:Cast(Regrowth)
                return
            elseif
            OffTank and OffTank:SpecialHealthPercentage() <= 35 and
            OffTank:BuffRemains(Regrowth) < 3.6 + Regrowth:CastTime() and
            OffTank:CanCast(Regrowth)
            then
                OffTank:Cast(Regrowth)
                return
            elseif
            Lowest and Lowest:SpecialHealthPercentage() <= GetSecondOptionValue("愈合") and
            Lowest:BuffRemains(Regrowth) < 3.6 + Regrowth:CastTime() and
            Lowest:CanCast(Regrowth)
            then
                Lowest:Cast(Regrowth)
                return
            end
        end
        if IsOptionEnabled("愈合") and Player:Buff(Clearcasting) then
            local BestUnit, BestUnitHealth = nil, 100
            for i = 1, #HealUnits do
                local ThisUnit, ThisUnitHealth = HealUnits[i], HealUnits[i]:SpecialHealthPercentage()
                if ThisUnitHealth <= BestUnitHealth and ThisUnit:CanCast(Regrowth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth
                end
            end
            if BestUnitHealth <= 85 then
                Bug("Regrowth - Cycle with Clearcast")
                BestUnit:Cast(Regrowth)
                return
            end
            if
            MainTank and MainTank:SpecialHealthPercentage() <= 95 and MainTank:BuffRemains(Regrowth) < 6 and
            MainTank:CanCast(Regrowth)
            then
                Bug("Regrowth - Clearcast - Main Tank")
                MainTank:Cast(Regrowth)
                return
            elseif
            OffTank and OffTank:SpecialHealthPercentage() <= 95 and OffTank:BuffRemains(Regrowth) < 6 and
            OffTank:CanCast(Regrowth)
            then
                Bug("Regrowth - Clearcast - Off Tank")
                OffTank:Cast(Regrowth)
                return
            elseif
            Lowest and Lowest:SpecialHealthPercentage() <= 95 and Lowest:BuffRemains(Regrowth) < 6 and
            Lowest:CanCast(Regrowth)
            then
                Bug("Regrowth - Clearcast - Lowest")
                Lowest:Cast(Regrowth)
                return
            end
            if Player:BuffRemains(Clearcasting) < 5 then
                if MainTank and MainTank:BuffRemains(Regrowth) < 6 and MainTank:CanCast(Regrowth) then
                    Bug("Regrowth - Clearcast - Main Tank")
                    MainTank:Cast(Regrowth)
                    return
                elseif OffTank and OffTank:BuffRemains(Regrowth) < 6 and OffTank:CanCast(Regrowth) then
                    Bug("Regrowth - Clearcast - Off Tank")
                    OffTank:Cast(Regrowth)
                    return
                elseif Lowest and Lowest:BuffRemains(Regrowth) < 6 and Lowest:CanCast(Regrowth) then
                    Bug("Regrowth - Clearcast - Lowest")
                    Lowest:Cast(Regrowth)
                    return
                end
            end
        end
        if IsOptionEnabled("Topping") and CurrentBadDebuffs and #CurrentBadDebuffs.Top > 0 then
            local BestUnit, BestUnitHealth = nil, 100
            for i = 1, #CurrentBadDebuffs.Top do
                local ThisUnit, ThisUnitHealth =                 CurrentBadDebuffs.Top[i],
                CurrentBadDebuffs.Top[i]:SpecialHealthPercentage()
                if ThisUnit:CanCast(Regrowth) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth
                end
            end
            if BestUnit ~= nil and BestUnitHealth <= GetOptionValue("Topping") then
                if BestUnit:CanCast(Regrowth) and not BestUnit:Buff(Regrowth) then
                    BestUnit:Cast(Regrowth)
                    Bug("Regrowth on " .. BestUnit:Name() .. " to top it")
                    return
                end
                if not BestUnit:Buff(Rejuvenation) and BestUnit:CanCast(Rejuvenation) then
                    BestUnit:Cast(Rejuvenation)
                    Bug("Rejuvenation on " .. BestUnit:Name() .. " to top it")
                    return
                end
                if
                Germination:Exists() and not BestUnit:Buff(GerminationRejuvenation) and
                BestUnit:CanCast(Rejuvenation)
                then
                    BestUnit:Cast(Rejuvenation)
                    Bug("Germination on " .. BestUnit:Name() .. " to top it")
                    return
                end
                if BestUnit:CanCast(HealingTouch) then
                    BestUnit:Cast(HealingTouch)
                    Bug("Healing Touch on " .. BestUnit:Name() .. " to top it")
                    return
                end
            end
        end
        if IsOptionEnabled("回春术") then
            if
            MainTank and MainTank:SpecialHealthPercentage() <= GetOptionValue("回春术") and
            MainTank:CanCast(Rejuvenation) and
            not (MainTank:Buff(Rejuvenation) or MainTank:Buff(GerminationRejuvenation))
            then
                MainTank:Cast(Rejuvenation)
                return
            elseif
            OffTank and OffTank:SpecialHealthPercentage() <= GetOptionValue("回春术") and OffTank:CanCast(Rejuvenation) and
            not (OffTank:Buff(Rejuvenation) or OffTank:Buff(GerminationRejuvenation))
            then
                OffTank:Cast(Rejuvenation)
                return
            elseif
            Lowest and Lowest:SpecialHealthPercentage() <= GetSecondOptionValue("回春术") and
            Lowest:CanCast(Rejuvenation) and
            not (Lowest:Buff(Rejuvenation) or Lowest:Buff(GerminationRejuvenation))
            then
                Lowest:Cast(Rejuvenation)
                return
            end
        end
        if IsOptionEnabled("萌芽回春") and Germination:Exists() then
            if
            MainTank and MainTank:SpecialHealthPercentage() <= GetOptionValue("萌芽回春") and
            MainTank:CanCast(Rejuvenation) and
            not (MainTank:Buff(Rejuvenation) and MainTank:Buff(GerminationRejuvenation))
            then
                MainTank:Cast(Rejuvenation)
                return
            elseif
            OffTank and OffTank:SpecialHealthPercentage() <= GetOptionValue("萌芽回春") and
            OffTank:CanCast(Rejuvenation) and
            not (OffTank:Buff(Rejuvenation) and OffTank:Buff(GerminationRejuvenation))
            then
                OffTank:Cast(Rejuvenation)
                return
            elseif
            Lowest and Lowest:SpecialHealthPercentage() <= GetSecondOptionValue("萌芽回春") and
            Lowest:CanCast(Rejuvenation) and
            not (Lowest:Buff(Rejuvenation) and Lowest:Buff(GerminationRejuvenation))
            then
                Lowest:Cast(Rejuvenation)
                return
            end
        end
        if IsOptionEnabled("回春术") and RejuvenationUnits < GetOptionValue("回春术数量限制") then
            local BestUnit, BestUnitHealth = nil, 100
            for i = 1, #HealUnits do
                local ThisUnit, ThisUnitHealth = HealUnits[i], HealUnits[i]:SpecialHealthPercentage()
                if
                ThisUnitHealth <= BestUnitHealth and ThisUnit:CanCast(Rejuvenation) and
                ThisUnit:BuffRemains(Rejuvenation) < 3 and
                ThisUnit:BuffRemains(GerminationRejuvenation) < 3
                then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth
                end
            end
            if BestUnit and BestUnitHealth <= GetSecondOptionValue("回春术") then
                Bug("Rejuvenation - Cycle")
                BestUnit:Cast(Rejuvenation)
                return
            end
        end
        if Germination:Exists() and IsOptionEnabled("萌芽回春") and GerminationUnits < GetSecondOptionValue("回春术数量限制") then
            local BestUnit, BestUnitHealth = nil, 100
            for i = 1, #HealUnits do
                local ThisUnit, ThisUnitHealth = HealUnits[i], HealUnits[i]:SpecialHealthPercentage()
                if
                ThisUnitHealth <= BestUnitHealth and ThisUnit:CanCast(Rejuvenation) and
                (ThisUnit:BuffRemains(Rejuvenation) < 3 or not ThisUnit:Buff(GerminationRejuvenation))
                then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth
                end
            end
            if BestUnit and BestUnitHealth <= GetSecondOptionValue("萌芽回春") then
                Bug("Germination - Cycle")
                BestUnit:Cast(Rejuvenation)
                return
            end
        end
        if IsOptionEnabled("治疗之触") then
            if
            MainTank and MainTank:SpecialHealthPercentage() <= GetOptionValue("治疗之触") and
            MainTank:CanCast(HealingTouch)
            then
                MainTank:Cast(HealingTouch)
                return
            elseif
            OffTank and OffTank:SpecialHealthPercentage() <= GetOptionValue("治疗之触") and
            OffTank:CanCast(HealingTouch)
            then
                OffTank:Cast(HealingTouch)
                return
            elseif
            Lowest and Lowest:SpecialHealthPercentage() <= GetSecondOptionValue("治疗之触") and
            Lowest:CanCast(HealingTouch)
            then
                Lowest:Cast(HealingTouch)
                return
            end
        end
    end
    if Player:IsInCombat() or GetSecondOptionValue("脱离战斗后暂停治疗") == "启用" then
        if BestTarget and IsOptionEnabled("DPS") and GetSecondOptionValue("DPS") == "Low" and BestTarget:IsInCombat() then
            if Player:ManaPercentage() >= GetOptionValue("DPS") then
                if Sunfire:Exists() and Player:ManaPercentage() >= GetOptionValue("阳炎术") then
                    if
                    IsOptionEnabled("阳炎术") and BestTarget:DebuffRemains(SunfireDebuff) < 5 and
                    BestTarget:CanCast(Sunfire)
                    then
                        BestTarget:Cast(Sunfire)
                        return
                    end
                    if IsOptionEnabled("多目标 阳炎术") and SunfireUnit and SunfireUnit:CanCast(Sunfire) then
                        SunfireUnit:Cast(Sunfire)
                        return
                    end
                end
                if Moonfire:Exists() and Player:ManaPercentage() >= GetOptionValue("月火术") then
                    if
                    IsOptionEnabled("月火术") and BestTarget:DebuffRemains(MoonfireDebuff) < 6 and
                    BestTarget:CanCast(Moonfire)
                    then
                        BestTarget:Cast(Moonfire)
                        return
                    end
                    if IsOptionEnabled("多目标 月火术") and MoonfireUnit and MoonfireUnit:CanCast(Moonfire) then
                        MoonfireUnit:Cast(Moonfire)
                        return
                    end
                end
            end
            if SolarWrath:Exists() and IsOptionEnabled("阳炎之怒") and BestTarget:CanCast(SolarWrath) then
                BestTarget:Cast(SolarWrath)
                return
            end
        end
    end
end
function Rotation:OutOfCombat()
    if IsOptionEnabled("自动进入战斗") and Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        local EngageSpell = Moonfire
        if EngageSpell:Exists() and Target:CanCast(EngageSpell) then
            Target:Cast(EngageSpell)
            return
        end
    end
    if IsOptionEnabled("脱离战斗后暂停治疗") then
        self:Combat()
    end
end
SetRotation(253, {})
local Rotation = Rotations[253]
function Rotation:Initialize()
    ArcaneTorrent = Spell(80483, false, false, true)
    RocketBarrage = Spell(69041, true, true, true)
    BloodFury = Spell(20572, false, false, true)
    Berserking = Spell(26297, false, false, true)
    GiftOfTheNaaru = Spell(59543, false, false, true)
    AMurderOfCrows = Spell(131894, false, true, true)
    AspectOfTheTurtle = Spell(186265, false, false, true)
    AspectOfTheWild = Spell(193530, false, false, true)
    Barrage = Spell(120360, true, true, false)
    BeastCleave = Spell(118455, false, false, true)
    BestialWrath = Spell(19574, false, false, true)
    ChimaeraShot = Spell(53209, true, true, true)
    CobraShot = Spell(193455, true, true, false)
    ConcussiveShot = Spell(5116, true, true, true)
    CounterShot = Spell(147362, true, true, true)
    DireBeast = Spell(120679, false, true, true)
    DireFrenzy = Spell(217200, false, true, true)
    DireStable = Spell(193532)
    Exhilaration = Spell(109304, false, false, true)
    FeignDeath = Spell(5384, false, false, true)
    HeartOfThePhoenix = Spell(55709, false, false, true)
    KillCommand = Spell(34026, false, true, true)
    KillerCobra = Spell(199532)
    MendPet = Spell(982, false, false, true)
    MendPetBuff = Spell(136, false, false, true)
    Misdirection = Spell(34477, false, false, true)
    MisdirectionBuff = Spell(35079, false, false, true)
    MultiShot = Spell(2643, true, true, true)
    ParselsTongueBuff = Spell(248085, true, true, false)
    Stampede = Spell(201430, false, true, true)
    TitansThunder = Spell(207068, false, false, true)
    Volley = Spell(194386, false, false, true)
    ParselsTongue = Item(151805)
    QaplaEredunWarOrder = Item(137227)
    TheMantleOfCommand = Item(144326)
    CallPets = {
        Spell(883, false, false, true),
        Spell(83242, false, false, true),
        Spell(83243, false, false, true),
        Spell(83244, false, false, true),
        Spell(83245, false, false, true)
    }
    RevivePet = Spell(982, false, false, false)
    AddPage("常规")
    AddPage("进攻")
    AddPage("防御")
    AddCommonOptions()
    AddPresetOption("常规", "Hunter", nil, false)
    AddSection("常规", { "辅助", "效用" }, "Yellow")
    AddNewOption(
    "常规",
    { "自动召唤/复活宠物", "自动召唤/复兴宠物" },
    222,
    true,
    { 3, 1, 25, 0.5 },
    { 1, 1, 5, 1 },
    {
        "Automatically Whistle/Revive your Pet." ..
        C.TOOLTIP_VALUE_1 ..
        "How long would you like to wait before using Whistle when your pet is dismissed." ..
        C.TOOLTIP_VALUE_2 .. "Which pet you would like to auto summon?",
        "自动吹口哨/复活您的宠物" .. C.TOOLTIP_VALUE_1 .. "在您的宠物被解雇之前，您需要等待多长时间才能使用口哨。" .. C.TOOLTIP_VALUE_2 .. "你想要什么宠物自动召唤？"
    }
    )
    AddNewOption(
    "常规",
    { "误导", "误导" },
    232,
    true,
    { 1, { "无条件使用", "总是" }, { "Engage", "从事" }, { "Threat Any", "威胁任何" }, { "Threat Target", "威胁目标" } },
    { 80, 0, 100, 5 },
    {
        "Use Misdirection on your Tank, Focus or Pet." ..
        C.TOOLTIP_VALUE_1 ..
        "Choose prefered Mode." ..
        C.TOOLTIP_VALUE_2 .. "Define threat percentage threshold. Set to 100 to use always.",
        "在你的坦克，焦点或宠物上使用误导。" .. C.TOOLTIP_VALUE_1 .. "选择优先模式。" .. C.TOOLTIP_VALUE_2 .. "定义威胁百分比阈值。 设置为100，始终使用。"
    }
    )
    AddPresetOption("进攻")
    AddSection("进攻", { "大技能", "酷唐斯" }, "Yellow")
    AddPresetOption(
    "Cooldown",
    { "夺命黑鸦", "夺命黑鸦" },
    1,
    { 2, 1, 30, 1 },
    { "Minimum Time To Die of the current target to use.", "目前使用目标的最短时间。" }
    )
    AddPresetOption("Cooldown", { "野性守护", "野性守护" })
    AddNewOption(
    "进攻",
    { "野性守护配合狂野怒火", "野性守护重叠" },
    220,
    false,
    { 1, 0, 10, 0.5 },
    nil,
    {
        "How many seconds Aspect Of The Wild has to overlap with Bestial Wrath buff. Normally you want Aspect + Bestial Wrath, but you may want to only use it when Bestial Wrath buff has more than the given amount of seconds left." ..
        C.TOOLTIP_VALUE .. "Seconds to overlap.",
        "野性守护必须与狂野怒火魔法增益多少秒。 通常你想要野性守护+狂野怒火，但是当狂野怒火魔法增益超过给定的秒数时，你可能只想使用它。" .. C.TOOLTIP_VALUE .. "秒重叠。"
    }
    )
    AddPresetOption("Cooldown", { "狂野怒火", "狂野怒火" }, 1, { 5, 1, 30, 1 }, "Minimum Time To Die of the current target to use.")
    AddPresetOption(
    "Cooldown",
    { "群兽奔腾", "群兽奔腾" },
    nil,
    { 5, 1, 30, 1 },
    { "Minimum Time To Die of the current target to use.", "目前使用目标的最短时间。" }
    )
    AddPresetOption("Cooldown", { "泰坦之雷", "泰坦之雷" })
    AddNewOption(
    "进攻",
    { "凶暴野兽后泰坦之雷", "泰坦之雷凶暴后野兽" },
    220,
    false,
    { 1, 0.5, 7, 0.5 },
    nil,
    {
        "Only use Titan's Thunder within the given number of seconds after Dire Beast cast." ..
        C.TOOLTIP_VALUE .. "Number of seconds after Dire Beast cast.",
        "在凶暴野兽演员后数秒钟内使用泰坦之雷。" .. C.TOOLTIP_VALUE .. "凶暴野兽后的秒数。"
    }
    )
    AddSection("进攻", { "能力", "能力" }, "Yellow")
    AddNewOption(
    "进攻",
    { "弹幕射击", "弹幕射击" },
    220,
    true,
    { 1, 1, 5, 1 },
    nil,
    {
        "Use Barrage." .. C.TOOLTIP_VALUE .. "Minimum number of units to use Barrage.",
        "使用弹幕射击。" .. C.TOOLTIP_VALUE .. "弹幕射击的最小敌人数量。"
    }
    )
    AddNewOption(
    "进攻",
    { "震荡射击", "震荡射击" },
    210,
    false,
    nil,
    nil,
    { "Maintain Concussive Shot on our current target.", "维持震荡射击我们目前的目标。" }
    )
    AddNewOption(
    "进攻",
    { "眼镜蛇射击", "眼镜蛇射击" },
    122,
    false,
    { 90, 1, 120, 1 },
    { 105, 1, 120, 1 },
    {
        "Cobra Shot Focus thresholds." ..
        C.TOOLTIP_VALUE_1 ..
        "Minimum Focus to use as filler without Killer Cobra." ..
        C.TOOLTIP_VALUE_2 .. "Minimum Focus to use as filler with Killer Cobra.",
        "眼镜蛇射击焦点阈值。" .. C.TOOLTIP_VALUE_1 .. "最低限度使用作为填充剂没有杀戮眼镜蛇。" .. C.TOOLTIP_VALUE_2 .. "最小焦点用作杀戮眼镜蛇的填充物。"
    }
    )
    AddNewOption(
    "进攻",
    { "智能眼镜蛇射击", "眼镜蛇射击自动" },
    210,
    true,
    nil,
    nil,
    {
        "Use Cobra Shot based on calculations instead of focus setting above. EXPERIMENTAL !",
        "根据计算而不是以上的焦点设置，使用眼镜蛇拍摄。 实验！"
    }
    )
    AddNewOption(
    "进攻",
    "蛇语者之舌优先级",
    222,
    true,
    { 1.5, 0.1, 8, 0.1 },
    { 3, 0.1, 8, 0.1 },
    "Set a High Priority and Low Priority to keep Parsels Tongue legendary buff up. This will use Cobra Shot above Multi-Shot to keep the buff up." ..
    C.TOOLTIP_VALUE_1 ..
    "High Priority when buff remains lower then threshold." ..
    C.TOOLTIP_VALUE_2 .. "Low Priority, when buff remains lower then threshold."
    )
    AddNewOption("进攻", { "凶暴野兽", "凶暴野兽" }, 210, true, nil, nil, { "Use Dire Beast or Dire Frenzy.", "使用凶暴野兽或凶猛狂暴。" })
    AddNewOption(
    "进攻",
    { "奎普拉,艾瑞达战争指令", "奎普拉，艾瑞达战争指令" },
    210,
    true,
    nil,
    nil,
    { "Use Kill Command over Dire Beast when wearing QaPla Legendary boots.", "使用杀死命令作为更高的优先级凶暴野兽穿穿奎普拉，艾瑞达战争指令。" }
    )
    AddNewOption(
    "进攻",
    { "多重射击", "多重射击" },
    122,
    false,
    { 2, 1, 4, 1 },
    { 5, 1, 10, 1 },
    {
        "Multi-Shot units thresholds." ..
        C.TOOLTIP_VALUE_1 ..
        "Minimum units to use for Beast Cleave (Lower priority than Kill Command)." ..
        C.TOOLTIP_VALUE_2 .. "Minimum units to use for Beast Cleave (Higher priority than Kill Command)",
        "多重射击单位门槛。" .. C.TOOLTIP_VALUE_1 .. "用于野兽切割的最小单位（低于杀死命令的优先级）。" .. C.TOOLTIP_VALUE_2 .. "最小敌人用于野兽顺劈（优先于杀命令）。"
    }
    )
    AddNewOption(
    "进攻",
    { "宠物输出处理", "宠物伤害处理" },
    230,
    true,
    { 1, { "Handle Assist", "手柄辅助" }, { "Do Not Handle Assist", "不要处理协助" } },
    nil,
    {
        "Manage Pet." ..
        C.TOOLTIP_VALUE_1 ..
        "Enable this to automatically change between assist and passive mode depending if you have a target or not.",
        "管理宠物" .. C.TOOLTIP_VALUE_1 .. "根据您是否有目标,启用此功能已在辅助和被动模式之间自动切换。"
    }
    )
    AddNewOption(
    "进攻",
    { "乱射", "乱射" },
    220,
    true,
    { 1, 0, 20, 1 },
    nil,
    {
        "Use Volley." ..
        C.TOOLTIP_VALUE ..
        "Minimum amount of units to use." ..
        C.TOOLTIP_HINT("Setting to 0 keeps Volley active regardless of target count or AoE setting."),
        "使用乱射。" .. C.TOOLTIP_VALUE .. "最少使用敌人。" .. C.TOOLTIP_HINT("设置为0可使乱射活动，无论目标数量或效果区域设置如何。")
    }
    )
    AddPresetOption("防御")
    AddSection("防御", { "能力", "能力" }, "Yellow")
    AddNewOption(
    "防御",
    { "治疗宠物", "复活宠物" },
    222,
    true,
    { 35, 0, 100, 1 },
    { 85, 0, 100, 1 },
    {
        "Enable use of Mend Pet when pet health fall under threshold." ..
        C.TOOLTIP_VALUE_1 .. "In combat threshold." .. C.TOOLTIP_VALUE_2 .. "Out of combat threshold.",
        "当宠物健康下降到阈值以下时，可以使用复活宠物。" .. C.TOOLTIP_VALUE_1 .. "在战斗门槛。" .. C.TOOLTIP_VALUE_2 .. "不在战斗门槛。"
    }
    )
    AddSection("防御", { "大技能", "酷唐斯" }, "Yellow")
    AddNewOption(
    "防御",
    { "自动假死", "自动假死" },
    220,
    true,
    { 10, 0, 100, 1 },
    nil,
    { "Use Feign Death." .. C.TOOLTIP_VALUE .. "Health threshold.", "使用假死。" .. C.TOOLTIP_VALUE .. "健康阈值。" }
    )
    AddNewOption(
    "防御",
    { "灵龟守护", "灵龟守护" },
    220,
    true,
    { 35, 0, 100, 1 },
    nil,
    { "Use Aspect Of The Turtle." .. C.TOOLTIP_VALUE .. "Health threshold.", "使用灵龟守护。" .. C.TOOLTIP_VALUE .. "健康阈值。" }
    )
    AddNewOption(
    "防御",
    { "意气风发", "意气风发" },
    220,
    true,
    { 20, 1, 100, 1 },
    nil,
    { "Use Exhilaration." .. C.TOOLTIP_VALUE .. "Health threshold.", "使用意气风发。" .. C.TOOLTIP_VALUE .. "健康阈值。" }
    )
    RegisterCommand(
    "barrage",
    function()
        if Barrage:Exists() then
            if ShouldBarrage == true then
                ShouldBarrage = false
                Bug("Barrage Queue Canceled")
            elseif Barrage:Cooldown() < 5 then
                ShouldBarrage = true
                Bug("Barrage Queued")
            end
        else
            Bug("You do not have Barrage talented.")
        end
    end
    )
    self.HeartOfThePhoenixAttempt = 0
    function Unit:Threat(Other)
        if UnitThreatSituation(self.UnitID, Other.UnitID) then
            local isTanking, status, scaledPercent, rawPercent, threatValue =             UnitDetailedThreatSituation(self.UnitID, Other.UnitID)
            return scaledPercent ~= nil and scaledPercent or 0
        end
        return 0
    end
    ClassColor = "|c" .. _G["RAID_CLASS_COLORS"]["HUNTER"]["colorStr"]
    AddOutput(ClassColor .. "标记射击 单位:")
    SetOutput(ClassColor .. "标记射击 单位:", "0")
end
function Rotation:Events()
    self.PetDismissed = 0
    EventFrame:RegisterForSelfCombatEvent(
    function(...)
        if select(12, ...) == 2641 then
            self.PetDismissed = GetTime() + 5
        end
    end,
    "SPELL_CAST_SUCCESS"
    )
    EventFrame:RegisterForCombatEvent(
    function(...)
        if select(15, ...) == SPELL_FAILED_NOPATH then
            KillFailTime = GetTime() + 3
        end
    end,
    "SPELL_CAST_FAILED"
    )
    EventFrame:RegisterForCombatEvent(
    function(...)
        if select(15, ...) == _G["SPELL_FAILED_NOPATH"] then
            self.CommandFailTime = GetTime() + 2
        end
    end,
    "SPELL_CAST_FAILED"
    )
end
function Rotation:CanKillCommand()
    return not self.CommandFailTime or GetTime() > self.CommandFailTime
end
function Rotation:Pulse()
    if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() or Player:Buff(FeignDeath) then
        return
    end
    if Target:Exists() and BMPullTime() < 5 then
        self:Opening()
        return
    end
    if GetTime() < Rotation.SpamPrevention then
        return
    end
    Rotation.SpamPrevention = GetTime() + 0.05
    Target = Unit.Target
    local InCombat = Player:IsInCombat()
    if not InCombat then
        self:OutOfCombat()
        SetOutput(ClassColor .. "标记射击 单位:", "0")
        return
    end
    if InCombat then
        self:Defensives()
    end
    Target = Player:ReTarget(CobraShot, false) or Unit.Target
    if Target:Exists() then
        Rotations:RefreshUnitTables(Rotation.Identifier)
        SetOutput(ClassColor .. "标记射击 单位:", NumEnemies)
        self:Interrupts()
        if
        IsOptionEnabled("开怪技能") and
        (GetOptionValue("开怪技能") == "无条件使用" or (GetOptionValue("开怪技能") == "打BOSS使用" and Target:IsBoss()) or
        (GetOptionValue("开怪技能") == "CDs Only" and CooldownsAllowed())) and
        not OpenerEnded
        then
            self:Opener()
            return
        elseif CombatTime() > 10 then
            OpenerEnded = true
        end
        self:OffGCDAbilities()
        if Player:GlobalCooldown() == 0 then
            self:Combat()
        end
    end
end
function Rotation:Opening()
    Player:UsePotions("Agility")
    if
    (GetOptionValue("误导") == "无条件使用" or GetOptionValue("误导") == "Engage") and
    BMPullTime() < GetSecondOptionValue("抢先施放(需DBM插件)") + 0.2
    then
        self:MisdirectionHandler()
    end
    if
    IsOptionEnabled("抢先施放(需DBM插件)") and
    (GetOptionValue("抢先施放(需DBM插件)") == "无条件使用" or
    (GetOptionValue("抢先施放(需DBM插件)") == "打BOSS使用" and Target:IsBoss())) and
    BMPullTime() < GetSecondOptionValue("抢先施放(需DBM插件)")
    then
        Player:StartAttack(75)
        if BestialWrath:Exists() and CDOptionEnabled("狂野怒火") and Player:CanCast(BestialWrath) then
            Player:Cast(BestialWrath)
            return
        end
        if AspectOfTheWild:Exists() and CDOptionEnabled("野性守护") and Player:CanCast(AspectOfTheWild) then
            Player:Cast(AspectOfTheWild)
            return
        end
        if AMurderOfCrows:Exists() and Target:CanCast(AMurderOfCrows) then
            Target:Cast(AMurderOfCrows)
            return
        end
        TargetEnemies_8y = Target:EnemiesWithinDistance(8, true, true)
        if KillCommand:Exists() and #TargetEnemies_8y < 2 and Target:CanCast(CobraShot) then
            if
            PlayerPet:DistanceTo(Target) < 25 and PlayerPet:Exists() and not PlayerPet:IsDead() and
            self:CanKillCommand() and
            Target:CanCast(KillCommand)
            then
                Target:Cast(KillCommand)
                return
            else
                Target:Cast(CobraShot)
                return
            end
        end
        if MultiShot:Exists() and #TargetEnemies_8y >= 2 and Target:CanCast(MultiShot) then
            Target:Cast(MultiShot)
            return
        end
    end
end
function Rotation:Opener()
    self.ChoosenOpener = nil
    if self.ChoosenOpener ~= nil then
        OpenerParser(self.ChoosenOpener)
    else
        Bug("Invalid Talents combination, Opener will not be used.")
        OpenerEnded = true
    end
end
function Rotation:MisdirectionHandler()
    if IsOptionEnabled("误导") and not Player:Buff(MisdirectionBuff) then
        MainTank, MainTankTarget, OffTank, OffTankTarget = Unit.GetMainTanks()
        local MisdirectionTarget =         (Focus and Focus:Exists() and Focus:CanCast(Misdirection) and Focus) or
        (MainTank and MainTank:Exists() and MainTank:CanCast(Misdirection) and MainTank) or
        (OffTank and OffTank:Exists() and OffTank:CanCast(Misdirection) and OffTank) or
        (PlayerPet and PlayerPet:Exists() and PlayerPet:CanCast(Misdirection) and PlayerPet)
        if MisdirectionTarget then
            if GetOptionValue("误导") == "无条件使用" then
                MisdirectionTarget:Cast(Misdirection)
                return
            end
            if GetOptionValue("误导") == "Engage" and CombatTime() < 5 then
                MisdirectionTarget:Cast(Misdirection)
                return
            end
            if GetOptionValue("误导") == "Threath Target" and Player:Threat(Target) >= GetSecondOptionValue("误导") then
                MisdirectionTarget:Cast(Misdirection)
                return
            end
            if GetOptionValue("误导") == "Threath Any" then
                for i = 1, #BarrageEnemies do
                    local ThisUnit = BarrageEnemies[i]
                    if Player:Threat(ThisUnit) >= GetSecondOptionValue("误导") then
                        Bug(
                        "Misdirection on " ..
                        MisdirectionTarget:Name() ..
                        " as " .. ThisUnit:Name() .. " is at " .. Player:Threat(ThisUnit) .. "% threath"
                        )
                        MisdirectionTarget:Cast(Misdirection)
                        return
                    end
                end
            end
        end
    end
end
function Rotation:Defensives()
    Player:UseHealingItem()
    if
    Exhilaration:Exists() and IsOptionEnabled("意气风发") and Player:HealthPercentage() <= GetOptionValue("意气风发") and
    Player:CanCast(Exhilaration)
    then
        Player:Cast(Exhilaration)
        return
    end
    if
    GiftOfTheNaaru:Exists() and IsOptionEnabled("纳鲁的赐福") and Player:HealthPercentage() <= GetOptionValue("纳鲁的赐福") and
    Player:CanCast(GiftOfTheNaaru)
    then
        Player:Cast(GiftOfTheNaaru)
        return
    end
    if
    AspectOfTheTurtle:Exists() and IsOptionEnabled("灵龟守护") and Player:HealthPercentage() <= GetOptionValue("灵龟守护") and
    Player:CanCast(AspectOfTheTurtle)
    then
        Player:Cast(AspectOfTheTurtle)
        return
    end
    if
    FeignDeath:Exists() and IsOptionEnabled("自动假死") and Player:HealthPercentage() <= GetOptionValue("自动假死") and
    Player:CanCast(FeignDeath)
    then
        Player:Cast(FeignDeath)
    end
end
function Rotation:Interrupts()
    Player:UseInterrupt(CounterShot, ArcaneTorrent)
end
function Rotation:OffGCDAbilities()
    if
    AspectOfTheWild:Exists() and CDOptionEnabled("野性守护") and
    ((not IsOptionEnabled("野性守护配合狂野怒火") and Player:Buff(BestialWrath)) or
    (Player:BuffRemains(BestialWrath) >= GetOptionValue("野性守护配合狂野怒火"))) and
    (Target:TimeToDie() >= 15 or (Target:IsBoss() and Target:TimeToDie() >= 5)) and
    Player:CanCast(AspectOfTheWild)
    then
        Player:Cast(AspectOfTheWild)
        return
    end
    if
    TitansThunder:Exists() and CDOptionEnabled("泰坦之雷") and
    ((not IsOptionEnabled("凶暴野兽后泰坦之雷") and DireBeast:TimeSinceCast() < 1) or
    DireBeast:TimeSinceCast() <= GetOptionValue("凶暴野兽后泰坦之雷")) and
    Player:CanCast(TitansThunder)
    then
        Player:Cast(TitansThunder)
    end
end
Rotation.TriedToSummonPet, Rotation.TriedToResurrectPet = 0, 0
function Rotation:ManagePet()
    if IsOptionEnabled("自动召唤/复活宠物") and (InstantWhistle or self.PetDismissed + GetOptionValue("自动召唤/复活宠物") < GetTime()) then
        InstantWhistle = false
        if
        not PlayerPet:Exists() and GetTime() > self.TriedToSummonPet and
        Player:CanCast(CallPets[GetSecondOptionValue("自动召唤/复活宠物")])
        then
            self.TriedToSummonPet = GetTime() + 5
            Player:Cast(CallPets[GetSecondOptionValue("自动召唤/复活宠物")])
            return
        end
        if
        not Player:IsMoving() and (not PlayerPet:Exists() or PlayerPet:IsDead()) and Player:CanCast(RevivePet) and
        GetTime() > self.TriedToResurrectPet
        then
            if Player:IsInCombat() and self.HeartOfThePhoenixAttempt < GetTime() then
                self.HeartOfThePhoenixAttempt = GetTime() + 485
                Player:Cast(HeartOfThePhoenix)
                return
            elseif self.HeartOfThePhoenixAttempt - 483 < GetTime() then
                self.TriedToResurrectPet = GetTime() + 3
                Player:Cast(MendPet)
                return
            end
        end
    end
    if
    PlayerPet:Exists() and IsOptionEnabled("治疗宠物") and Player:CanCast(MendPet) and not PlayerPet:Buff(MendPetBuff) and
    MendPet:TimeSinceCast() > 8
    then
        if
        (Player:IsInCombat() and PlayerPet:HealthPercentage() <= GetOptionValue("治疗宠物")) or
        (not Player:IsInCombat() and PlayerPet:HealthPercentage() <= GetSecondOptionValue("治疗宠物"))
        then
            PlayerPet:Cast(MendPet)
            return
        end
    end
end
Rotation.PetAssisting, Rotation.PetForceAssistDelay = false, 0
function Rotation:PlayerPetHandling()
    if IsOptionEnabled("宠物输出处理") and PlayerPet:Exists() then
        if GetOptionValue("宠物输出处理") == "Handle Assist" then
            if Target:Exists() and not self.PetAssisting then
                RunMacroText("/petattack target")
                PetAssistMode()
                self.PetAssisting = true
            elseif not Target:Exists() and self.PetAssisting then
                PetPassiveMode()
                self.PetAssisting = false
            end
            if
            Target:Exists() and self.PetAssisting and PlayerPetTarget and PlayerPetTarget:GUID() ~= Target:GUID() and
            self.PetForceAssistDelay < GetTime()
            then
                PetPassiveMode()
                PetAssistMode()
                RunMacroText("/petattack target")
                self.PetForceAssistDelay = GetTime() + 2
            end
        end
    end
end
function Rotation:UnitTables()
    BarrageEnemies = UseAOE() and Player:UnitsInFrontConeAroundUnit(Target, 45, 160) or {}
    Enemies_40y = UseAOE() and Player:EnemiesWithinDistance(40, false) or {}
    TargetEnemies_8y = UseAOE() and Target:EnemiesWithinDistance(8, true, true) or {}
    NumEnemies = #TargetEnemies_8y
end
function Rotation:Combat()
    self:ManagePet()
    self:PlayerPetHandling()
    if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) and Player:IsFacing(Target) then
        Player:StartAttack(75)
        if Barrage:Exists() and ShouldBarrage == true then
            if Barrage:Cooldown() > 6 then
                ShouldBarrage = false
            else
                if Player:Focus() < 60 then
                    if
                    PlayerPet:Exists() and PlayerPetTarget:Exists() and not PlayerPet:IsDead() and
                    self:CanKillCommand() and
                    PlayerPet:DistanceTo(PlayerPetTarget) < 20
                    then
                        if ChimaeraShot:Exists() and Target:CanCast(ChimaeraShot) then
                            Target:Cast(ChimaeraShot)
                            return
                        end
                        if DireBeast:Exists() and not DireFrenzy:Exists() and PlayerPetTarget:CanCast(DireBeast) then
                            PlayerPetTarget:Cast(DireBeast)
                            return
                        end
                        if DireFrenzy:Exists() and PlayerPetTarget:CanCast(DireFrenzy) then
                            PlayerPetTarget:Cast(DireFrenzy)
                            return
                        end
                    end
                    return
                end
                if Player:Focus() >= 60 and Target:CanCast(Barrage) then
                    Target:Cast(Barrage)
                    return
                end
            end
        end
        self:MisdirectionHandler()
        if ConcussiveShot:Exists() and IsOptionEnabled("震荡射击") and Target:CanCast(ConcussiveShot) then
            Target:Cast(ConcussiveShot)
            return
        end
        BestialWrathEnabled = CDOptionEnabled("狂野怒火") and Target:TimeToDie() > GetSecondOptionValue("狂野怒火") or false
        if Player:IsWithinCastRange(Target, CobraShot) then
            Player:UseTrinkets()
            Player:UsePotions("Agility")
            if CDOptionEnabled("进攻性种族技能") then
                if ArcaneTorrent:Exists() and Player:FocusDeficit() >= 40 and Player:CanCast(ArcaneTorrent) then
                    Player:Cast(ArcaneTorrent)
                    return
                end
                if BloodFury:Exists() and Player:CanCast(BloodFury) then
                    Player:Cast(BloodFury)
                end
                if Berserking:Exists() and Player:CanCast(Berserking) then
                    Player:Cast(Berserking)
                end
            end
        end
        if
        Volley:Exists() and IsOptionEnabled("乱射") and NumEnemies >= GetOptionValue("乱射") and
        Volley:TimeSinceCast() > 1
        then
            if not Player:Buff(Volley) and Player:CanCast(Volley) then
                Volley.LastCastTime = GetTime()
                Player:Cast(Volley)
            end
        else
            if IsOptionEnabled("乱射") and Player:Buff(Volley) and NumEnemies < GetOptionValue("乱射") then
                Volley.LastCastTime = GetTime()
                Player:Cast(Volley)
            end
        end
        if
        TitansThunder:Exists() and CDOptionEnabled("泰坦之雷") and
        ((DireFrenzy:Exists() and Player:Buff(BestialWrath)) or
        (not IsOptionEnabled("凶暴野兽后泰坦之雷") and
        (DireBeast:Cooldown() >= 3 or (Player:Buff(BestialWrath) and Player:Buff(DireBeast))))) and
        Player:CanCast(TitansThunder)
        then
            Player:Cast(TitansThunder)
            return
        end
        if
        DireFrenzy:Exists() and
        ((PlayerPet:BuffRemains(DireFrenzy) <= Player:GCD() * 1.2) or DireFrenzy:FractionalCharges() >= 1.8) and
        PlayerPetTarget:CanCast(DireFrenzy)
        then
            PlayerPetTarget:Cast(DireFrenzy)
            return
        end
        if
        CobraShot:Exists() and IsOptionEnabled("蛇语者之舌优先级") and ParselsTongue:IsEquipped(5) and
        Player:BuffRemains(ParselsTongueBuff) <= GetOptionValue("蛇语者之舌优先级") and
        Target:CanCast(CobraShot)
        then
            Target:Cast(CobraShot)
            return
        end
        if
        AMurderOfCrows:Exists() and CDOptionEnabled("夺命黑鸦") and Target:TimeToDie() >= GetSecondOptionValue("夺命黑鸦") and
        Target:CanCast(AMurderOfCrows)
        then
            Target:Cast(AMurderOfCrows)
            return
        end
        if
        Stampede:Exists() and CDOptionEnabled("群兽奔腾") and
        (Player:HasHero() or Player:Buff(BestialWrath) or
        (BestialWrathEnabled and BestialWrath:IsOnCooldown() and BestialWrath:Cooldown() < 2)) and
        Target:TimeToDie() >= GetSecondOptionValue("群兽奔腾") and
        Target:CanCast(Stampede)
        then
            Target:Cast(Stampede)
            return
        end
        if IsOptionEnabled("奎普拉,艾瑞达战争指令") and QaplaEredunWarOrder:IsEquipped(8) then
            if
            KillCommand:Exists() and (NumEnemies < GetSecondOptionValue("多重射击") or Player:Focus() > 70) and
            PlayerPet:Exists() and
            PlayerPetTarget:Exists() and
            not PlayerPet:IsDead() and
            self:CanKillCommand() and
            PlayerPet:DistanceTo(PlayerPetTarget) - PlayerPetTarget:CombatReach() < 20 and
            PlayerPetTarget:CanCast(KillCommand)
            then
                Bug("Kill Command over Dire Beast with QaPla")
                PlayerPetTarget:Cast(KillCommand)
                return
            end
        end
        if
        IsOptionEnabled("凶暴野兽") and not DireFrenzy:Exists() and
        (BestialWrath:Cooldown() > 3 or not BestialWrathEnabled) and
        Target:CanCast(DireBeast)
        then
            DireBeast.LastCastTime = GetTime()
            Target:Cast(DireBeast)
            return
        end
        if
        BestialWrath:Exists() and BestialWrathEnabled and
        (not Player:Buff(BestialWrath) or
        (Player:Buff(BestialWrath) and
        ((not DireFrenzy:Exists() and BestialWrath:Cooldown() < 3) or
        (DireFrenzy:Exists() and (BestialWrath:Cooldown() < 6))))) and
        Player:CanCast(BestialWrath) and
        PlayerPet:Exists() and
        PlayerPetTarget:Exists() and
        not PlayerPet:IsDead() and
        PlayerPet:DistanceTo(PlayerPetTarget) - PlayerPetTarget:CombatReach() < 20
        then
            Player:Cast(BestialWrath)
            return
        end
        if
        CobraShot:Exists() and IsOptionEnabled("蛇语者之舌优先级") and ParselsTongue:IsEquipped(5) and
        Player:BuffRemains(ParselsTongueBuff) <= GetSecondOptionValue("蛇语者之舌优先级") and
        Target:CanCast(CobraShot)
        then
            Target:Cast(CobraShot)
            return
        end
        if
        Barrage:Exists() and IsOptionEnabled("弹幕射击") and #BarrageEnemies >= GetOptionValue("弹幕射击") and
        Barrage:Cooldown() < 5
        then
            if Player:Focus() >= 60 and Target:CanCast(Barrage) then
                Target:Cast(Barrage)
                return
            end
        end
        if
        MultiShot:Exists() and NumEnemies >= GetSecondOptionValue("多重射击") and
        PlayerPet:BuffRemains(BeastCleave) < Player:GCD() * 1.5 and
        Target:CanCast(MultiShot)
        then
            Bug("Multi-Shot - 5+ (AoE)")
            Target:Cast(MultiShot)
            return
        end
        if
        KillCommand:Exists() and (NumEnemies < GetSecondOptionValue("多重射击") or Player:Focus() > 70) and
        PlayerPet:Exists() and
        PlayerPetTarget:Exists() and
        not PlayerPet:IsDead() and
        self:CanKillCommand() and
        PlayerPet:DistanceTo(PlayerPetTarget) - PlayerPetTarget:CombatReach() < 20 and
        PlayerPetTarget:CanCast(KillCommand)
        then
            PlayerPetTarget:Cast(KillCommand)
            return
        end
        if
        DireFrenzy:Exists() and PlayerPet:Exists() and Target:TimeToDie() < 9 and PlayerPetTarget:Exists() and
        not PlayerPet:IsDead() and
        PlayerPet:DistanceTo(PlayerPetTarget) - PlayerPetTarget:CombatReach() < 20 and
        PlayerPetTarget:CanCast(DireFrenzy)
        then
            PlayerPetTarget:Cast(DireFrenzy)
            return
        end
        if
        MultiShot:Exists() and NumEnemies >= GetOptionValue("多重射击") and
        PlayerPet:BuffRemains(BeastCleave) < Player:GCD() and
        Target:CanCast(MultiShot)
        then
            Bug("Multi-Shot - 2+ (Beast Cleave)")
            Target:Cast(MultiShot)
            return
        end
        if ChimaeraShot:Exists() and Player:Focus() < 90 and Target:CanCast(ChimaeraShot) then
            Target:Cast(ChimaeraShot)
            return
        end
        if
        CobraShot:Exists() and not IsOptionEnabled("智能眼镜蛇射击") and
        (KillCommand:Cooldown() > Player:GCD() or
        (PlayerPet:Exists() and PlayerPetTarget:Exists() and not PlayerPet:IsDead() and
        PlayerPet:DistanceTo(PlayerPetTarget) - PlayerPetTarget:CombatReach() > 30)) and
        ((KillerCobra:Exists() and
        (BestialWrath:Cooldown() >= 4 and (Player:Buff(BestialWrath) and KillCommand:Cooldown() >= 2) or
        Player:Focus() > GetSecondOptionValue("眼镜蛇射击"))) or
        (not KillerCobra:Exists() and Player:Focus() > GetOptionValue("眼镜蛇射击"))) and
        Target:CanCast(CobraShot)
        then
            Target:Cast(CobraShot)
            return
        end
        if
        CobraShot:Exists() and IsOptionEnabled("智能眼镜蛇射击") and
        (KillCommand:Cooldown() > Player:GCD() or
        (PlayerPet:Exists() and PlayerPetTarget:Exists() and not PlayerPet:IsDead() and
        PlayerPet:DistanceTo(PlayerPetTarget) - PlayerPetTarget:CombatReach() > 30)) and
        ((KillCommand:Cooldown() > Player:FocusTimeToMax() and
        (BestialWrath:Cooldown() > Player:FocusTimeToMax() or not BestialWrathEnabled)) or
        (Player:Buff(BestialWrath) and Player:FocusRegen() * KillCommand:Cooldown() > 30) or
        Target:TimeToDie() < KillCommand:Cooldown()) or
        (ParselsTongue:IsEquipped(5) and Player:BuffRemains(ParselsTongueBuff) <= Player:GCD() * 2) and
        Target:CanCast(CobraShot)
        then
            Target:Cast(CobraShot)
            return
        end
    end
end
function Rotation:OutOfCombat()
    self:ManagePet()
    if IsOptionEnabled("自动进入战斗") and Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        if KillCommand:Exists() and Target:CanCast(CobraShot) then
            if
            Player:DistanceTo(Target) < 25 and PlayerPet:Exists() and not PlayerPet:IsDead() and
            self:CanKillCommand() and
            Target:CanCast(KillCommand)
            then
                Target:Cast(KillCommand)
                return
            else
                Target:Cast(CobraShot)
                return
            end
        end
        if CobraShot:Exists() and Target:CanCast(CobraShot) then
            Target:Cast(CobraShot)
            return
        end
    end
end
SetRotation(254, {})
local Rotation = Rotations[254]
function Rotation:Initialize()
    self.HasBetaRotation = true
    ArcaneTorrent = Spell(80483, false, false, true)
    RocketBarrage = Spell(69041, true, true, true)
    BloodFury = Spell(20572, false, false, true)
    Berserking = Spell(26297, false, false, true)
    GiftOfTheNaaru = Spell(59543, false, false, true)
    AimedShot = Spell(19434, true, true, false)
    AMurderOfCrows = Spell(131894, false, true, true)
    ArcaneShot = Spell(185358, true, true, true)
    AspectOfTheTurtle = Spell(186265, false, false, true)
    Barrage = Spell(120360, true, true, true)
    BlackArrow = Spell(194599, true, true, true)
    Bullseye = Spell(204090)
    BurstingShot = Spell(186387, false, false, true)
    CarefulAim = Spell(53238)
    ConcussiveShot = Spell(5116, true, true, true)
    CounterShot = Spell(147362, true, true, true)
    CriticalAimed = Spell(242243)
    Exhilaration = Spell(109304, false, false, true)
    ExplosiveShot = Spell(212431, false, false, true)
    FeignDeath = Spell(5384, false, false, true)
    HeartOfThePhoenix = Spell(55709, false, false, true)
    HuntersMark = Spell(185365)
    LockAndLoad = Spell(194594)
    LoneWolf = Spell(155228)
    MarkedShot = Spell(185901, true, true, true)
    MarkingTargets = Spell(223138)
    MendPet = Spell(982, false, false, true)
    MendPetBuff = Spell(136, false, false, true)
    Misdirection = Spell(34477, false, false, true)
    MisdirectionBuff = Spell(35079, false, false, true)
    MultiShot = Spell(2643, true, true, true)
    PatientSniper = Spell(234588)
    PiercingShot = Spell(198670, true, true, true)
    Precision = Spell(246153)
    Sentinel = Spell(206817, true, true, true)
    Sidewinders = Spell(214579, true, true, true)
    SteadyFocus = Spell(193533)
    SteadyFocusBuff = Spell(193534)
    TrickShot = Spell(199522)
    TrueAim = Spell(199527)
    TrueAimDebuff = Spell(199803)
    Trueshot = Spell(193526, false, false, true)
    Volley = Spell(194386, false, false, true)
    Vulnerable = Spell(187131)
    Windburst = Spell(204147, true, true, true)
    CallPets = {
        Spell(883, false, false, true),
        Spell(83242, false, false, true),
        Spell(83243, false, false, true),
        Spell(83244, false, false, true),
        Spell(83245, false, false, true)
    }
    RevivePet = Spell(982, false, false, false)
    WarBeltOfTheSentinelArmy = Item(137081)
    SentinelsSight = Spell(208913)
    MarkOfTheWindrunner = Spell(308)
    AddPage("常规")
    AddPage("进攻")
    AddPage("防御")
    if self.HasBetaRotation then
        AddNewOption(
        "常规",
        "测试版循环",
        210,
        true,
        nil,
        nil,
        "Use the lastest updated combat routine. May not be as optimized and can contain error regarding execution!"
        )
    end
    AddCommonOptions()
    AddPresetOption("常规", "Hunter", nil, true)
    AddSection("常规", "辅助", "Yellow")
    AddNewOption(
    "常规",
    "自动召唤/复活宠物",
    222,
    true,
    { 3, 1, 25, 0.5 },
    { 1, 1, 5, 1 },
    "Automatically Whistle/Revive your Pet." ..
    C.TOOLTIP_VALUE_1 ..
    "How long would you like to wait before using Whistle when your pet is dismissed." ..
    C.TOOLTIP_VALUE_2 .. "Which pet you would like to auto summon?"
    )
    AddNewOption("常规", "震荡射击", 210, false, nil, nil, "Maintain Concussive Shot on our current target.")
    AddNewOption(
    "常规",
    "误导",
    232,
    true,
    { 1, "无条件使用", "Engage", "Threath Any", "Threath Target" },
    { 80, 0, 100, 5 },
    "Use Misdirection on your Tank, Focus or Pet." ..
    C.TOOLTIP_VALUE_1 ..
    "Choose prefered Mode." ..
    C.TOOLTIP_VALUE_2 .. "Define threath percentage threshold. Set to 100 to use always."
    )
    AddPresetOption("进攻")
    AddSection("进攻", "大技能", "Yellow")
    AddPresetOption("Cooldown", "夺命黑鸦")
    AddPresetOption("Cooldown", "哨兵")
    AddPresetOption("Cooldown", "百发百中")
    AddSection("进攻", "能力", "Yellow")
    AddNewOption(
    "进攻",
    "弹幕射击",
    220,
    true,
    { 1, 1, 10, 1 },
    nil,
    "Use Barrage." .. C.TOOLTIP_VALUE .. "Minimum amount of units to use."
    )
    AddNewOption(
    "进攻",
    "爆炸射击",
    220,
    true,
    { 1, 1, 10, 1 },
    nil,
    "Use Explosive Shot." ..
    C.TOOLTIP_VALUE ..
    "Minimum amount of units that needs to be in 8 yards of our target to use Explosive Shot."
    )
    AddNewOption(
    "进攻",
    "穿刺射击",
    220,
    true,
    { 1, 1, 10, 1 },
    nil,
    "Use Piercing Shot." ..
    C.TOOLTIP_VALUE ..
    "Minimum amount of units that needs to be in the path to our target to use Piercing Shot."
    )
    AddNewOption(
    "进攻",
    "多重射击",
    220,
    true,
    { 2, 1, 10, 1 },
    nil,
    "Use Multi-Shot." ..
    C.TOOLTIP_VALUE .. "Minimum amount of units that needs to be in 8 yards of our target to use Multi-Shot."
    )
    AddNewOption(
    "进攻",
    "宠物输出处理",
    230,
    true,
    { 1, "Handle Assist", "Do Not Handle Assist" },
    nil,
    "Manage Pet." ..
    C.TOOLTIP_VALUE_1 ..
    "Enable this to automatically change between assist and passive mode depending if you have a target or not."
    )
    AddNewOption(
    "进攻",
    "乱射",
    220,
    true,
    { 1, 0, 20, 1 },
    nil,
    "Use Volley." ..
    C.TOOLTIP_VALUE ..
    "Minimum amount of units to use." ..
    C.TOOLTIP_HINT("Setting to 0 keeps Volley active regardless of target count or AoE setting.")
    )
    AddNewOption("进攻", "Windburst", 210, true, nil, nil, "Use Windburst.")
    AddSection("进攻", "Expert Only", "Red")
    AddNewOption(
    "进攻",
    "Disable Aimed Shot",
    210,
    false,
    nil,
    nil,
    "EXPERT ONLY: Disable the use of Aimed Shot. Can cause serious rotational issues."
    )
    AddPresetOption("防御")
    AddSection("防御", "能力", "Yellow")
    AddNewOption(
    "防御",
    "治疗宠物",
    222,
    true,
    { 35, 0, 100, 1 },
    { 85, 0, 100, 1 },
    "Enable use of Mend Pet when pet health fall under threshold. \n\n|cFF0088FFValue 1:|r In combat threshold. \n\n|cFF0088FFValue 2:|r Out of combat threshold."
    )
    AddSection("防御", "大技能", "Yellow")
    AddNewOption(
    "防御",
    "自动假死",
    220,
    true,
    { 10, 0, 100, 1 },
    nil,
    "Use Feign Death." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddNewOption(
    "防御",
    "灵龟守护",
    220,
    true,
    { 35, 0, 100, 1 },
    nil,
    "Use Aspect Of The Turtle." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddNewOption(
    "防御",
    "意气风发",
    220,
    true,
    { 35, 0, 100, 1 },
    nil,
    "Use Exhilaration." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    RegisterCommand(
    "barrage",
    function()
        if Barrage:Exists() then
            if ShouldBarrage == true then
                ShouldBarrage = false
                Bug("Barrage Queue Canceled")
            elseif Barrage:Cooldown() < 5 then
                ShouldBarrage = true
                Bug("Barrage Queued")
            end
        else
            Bug("You do not have Barrage talented.")
        end
    end
    )
    local Frame = CreateFrame("Frame")
    local function DetonateExplosiveShot(self, ...)
        if ExplosiveShotCastedTime and GetTime() - ExplosiveShotCastedTime < 3 and Detonate and GetTime() > DetonateTime then
            Detonate = false
            Bug("Explosive Shot - Explode")
            Player:Cast(ExplosiveShot)
        end
    end
    Frame:SetScript("OnUpdate", DetonateExplosiveShot)
    AddOutput("目标距离:")
    SetOutput("目标距离:", "无目标")
    ISCL = {[Windburst:ID()] = "Windburst", [AimedShot:ID()] = "Aimed Shot" }
    ShotCount = 0
    PetDismissed = 0
    TriedToSummonPet = 0
    self.HeartOfThePhoenixAttempt = 0
    function Unit:Threat(Other)
        if UnitThreatSituation(self.UnitID, Other.UnitID) then
            local isTanking, status, scaledPercent, rawPercent, threatValue =             UnitDetailedThreatSituation(self.UnitID, Other.UnitID)
            return scaledPercent ~= nil and scaledPercent or 0
        end
        return 0
    end
    self.TrueshotCooldown = 0
    self.PoolingForPiercing = nil
    self.VulnerableRemains = nil
    self.Vuln_Window = nil
    self.FullRechargeTime = nil
    AimedShot.LastExecutedTime = 0
    Windburst.LastExecutedTime = 0
    function AimedShot:Exists()
        return IsPlayerSpell(self.Identifier) and not IsOptionEnabled("Disable Aimed Shot")
    end
end
function Rotation:UseBetaRotation()
    return self.HasBetaRotation and IsOptionEnabled("测试版循环")
end
function Rotation:Events()
    self.PetDismissed = 0
    EventFrame:RegisterForSelfCombatEvent(
    function(...)
        if select(12, ...) == 2641 then
            self.PetDismissed = GetTime() + 5
        end
    end,
    "SPELL_CAST_SUCCESS"
    )
    EventFrame:RegisterForSelfCombatEvent(
    function(...)
        SpellID = select(12, ...)
        if SpellID == 185358 or SpellID == 2643 then
            ShotCount = ShotCount + 1
        else
            ShotCount = 0
        end
        if SpellID == 212431 then
            ExplosiveShotCastedTime = GetTime()
        end
        if SpellID == 19434 then
            AimedShot.LastExecutedTime = GetTime()
        end
        if SpellID == 204147 and MarkOfTheWindrunner:ArtifactEnabled() then
            Windburst.LastCastTime = GetTime()
            Windburst.LastExecutedTime = GetTime()
        end
    end,
    "SPELL_CAST_SUCCESS"
    )
end
function Rotation:Pulse()
    if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() or Player:Buff(FeignDeath) then
        return
    end
    if Target:Exists() then
        local PlayerDistance = math.floor(Player:DistanceTo(Target) * 10) / 10
        local DistanceColor = PlayerDistance < 30 and "|cff00FF00" or "|cffFF0000"
        SetOutput("目标距离:", DistanceColor .. PlayerDistance .. "|r")
    else
        SetOutput("目标距离:", "无目标")
    end
    if Target:Exists() and BMPullTime() < 5 then
        self:Opening()
        return
    end
    if GetTime() < Rotation.SpamPrevention then
        return
    end
    Rotation.SpamPrevention = GetTime() + 0.05
    Target = Unit.Target
    local InCombat = Player:IsInCombat()
    if not InCombat then
        self:OutOfCombat()
        return
    end
    if InCombat then
        self:Defensives()
    end
    Target = Player:ReTarget(ArcaneShot, false) or Unit.Target
    if Target:Exists() then
        Rotations:RefreshUnitTables(Rotation.Identifier)
        self:Interrupts()
        if
        IsOptionEnabled("开怪技能") and
        (GetOptionValue("开怪技能") == "无条件使用" or (GetOptionValue("开怪技能") == "打BOSS使用" and Target:IsBoss()) or
        (GetOptionValue("开怪技能") == "CDs Only" and CooldownsAllowed())) and
        not OpenerEnded
        then
            self:Opener()
            return
        elseif CombatTime() > 10 then
            OpenerEnded = true
        end
        self:OffGCDAbilities()
        if Player:GlobalCooldown() == 0 then
            if self:UseBetaRotation() then
                self:CombatBeta()
            else
                self:Combat()
            end
        end
    end
end
function Rotation:Opening()
    Player:UsePotions("Agility")
    if
    IsOptionEnabled("抢先施放(需DBM插件)") and
    (GetOptionValue("抢先施放(需DBM插件)") == "无条件使用" or
    (GetOptionValue("抢先施放(需DBM插件)") == "打BOSS使用" and Target:IsBoss()))
    then
        local OpenerSpell = AMurderOfCrows:Exists() and AMurderOfCrows or Windburst
        if OpenerSpell:Exists() and BMPullTime() < GetSecondOptionValue("抢先施放(需DBM插件)") and Target:CanCast(OpenerSpell) then
            Target:Cast(OpenerSpell)
            return
        end
    end
end
function Rotation:Opener()
    self.ChoosenOpener = nil
    local BuilderSpell = Target:Exists() and NumEnemies > 2 and MultiShot or ArcaneShot
    if PiercingShot:Exists() and ExplosiveShot:Exists() then
        if not ExplosiveShot:IsOnCooldown() then
            local RealDistance = Player:DistanceTo(Target, true)
            local AdjustedDistance =             RealDistance < 10 and RealDistance + 3 or RealDistance < 20 and RealDistance + 1.5 or
            RealDistance < 30 and RealDistance - 1 or
            RealDistance < 35 and RealDistance - 2 or
            RealDistance < 40 and RealDistance - 3 or
            RealDistance - 4
            Detonate, DetonateTime = true, GetTime() + AdjustedDistance * 0.0625
        end
        self.ChoosenOpener = {
            [1] = { Windburst, Target, true },
            [2] = { Trueshot, Player, true },
            [3] = { "Trinkets" },
            [4] = { "Racials", { BloodFury, Berserking } },
            [5] = { PiercingShot, Target, true },
            [6] = { ExplosiveShot, Player, true },
            [7] = { BuilderSpell, Target, true },
            [8] = { MarkedShot, Target, Target:Debuff(HuntersMark) ~= nil },
            [9] = { BuilderSpell, Target, true },
            [10] = { MarkedShot, Target, Target:Debuff(HuntersMark) ~= nil },
            [11] = { BuilderSpell, Target, true },
            [12] = { MarkedShot, Target, Target:Debuff(HuntersMark) ~= nil },
            [13] = { BuilderSpell, Target, true },
            [14] = { MarkedShot, Target, Target:Debuff(HuntersMark) ~= nil },
            [15] = { BuilderSpell, Target, true },
            [16] = { MarkedShot, Target, Target:Debuff(HuntersMark) ~= nil },
            [17] = { BuilderSpell, Target, true },
            [18] = { MarkedShot, Target, Target:Debuff(HuntersMark) ~= nil },
            [19] = "Meme Opener"
        }
    elseif not Sidewinders:Exists() then
        self.ChoosenOpener = {
            [1] = { AMurderOfCrows, Target, AMurderOfCrows:Exists() },
            [2] = { Windburst, Target, true },
            [3] = { Trueshot, Player, true },
            [4] = { "Trinkets" },
            [5] = { "Racials", { BloodFury, Berserking } },
            [6] = { AimedShot, Target, true },
            [7] = { BuilderSpell, Target, true },
            [8] = { MarkedShot, Target, not Target:Debuff(Vulnerable) },
            [9] = { AimedShot, Target, Target:DebuffRemains(Vulnerable) > AimedShot:CastTime() + AimedShot:TravelTime() },
            [10] = { AimedShot, Target, Target:DebuffRemains(Vulnerable) > AimedShot:CastTime() + AimedShot:TravelTime() },
            [11] = { AimedShot, Target, Target:DebuffRemains(Vulnerable) > AimedShot:CastTime() + AimedShot:TravelTime() },
            [12] = { BuilderSpell, Target, true },
            [13] = { MarkedShot, Target, Target:Debuff(HuntersMark) ~= nil },
            [14] = { BuilderSpell, Target, true },
            [15] = { AimedShot, Target, Target:DebuffRemains(Vulnerable) > AimedShot:CastTime() + AimedShot:TravelTime() },
            [16] = { AimedShot, Target, Target:DebuffRemains(Vulnerable) > AimedShot:CastTime() + AimedShot:TravelTime() },
            [17] = { AimedShot, Target, Target:DebuffRemains(Vulnerable) > AimedShot:CastTime() + AimedShot:TravelTime() },
            [18] = "Trick Opener"
        }
    end
    if self.ChoosenOpener ~= nil then
        OpenerParser(self.ChoosenOpener)
    else
        Bug("Invalid Talents combination, Opener will not be used.")
        OpenerEnded = true
    end
end
function Rotation:MisdirectionHandler()
    if IsOptionEnabled("误导") and not Player:Buff(MisdirectionBuff) then
        MainTank, MainTankTarget, OffTank, OffTankTarget = Unit.GetMainTanks()
        local MisdirectionTarget =         (Focus and Focus:Exists() and Focus:CanCast(Misdirection) and Focus) or
        (MainTank and MainTank:Exists() and MainTank:CanCast(Misdirection) and MainTank) or
        (OffTank and OffTank:Exists() and OffTank:CanCast(Misdirection) and OffTank) or
        (PlayerPet and PlayerPet:Exists() and PlayerPet:CanCast(Misdirection) and PlayerPet)
        if MisdirectionTarget then
            if GetOptionValue("误导") == "无条件使用" then
                MisdirectionTarget:Cast(Misdirection)
                return
            end
            if GetOptionValue("误导") == "Engage" and CombatTime() < 5 then
                MisdirectionTarget:Cast(Misdirection)
                return
            end
            if GetOptionValue("误导") == "Threath Target" and Player:Threat(Target) >= GetSecondOptionValue("误导") then
                MisdirectionTarget:Cast(Misdirection)
                return
            end
            if GetOptionValue("误导") == "Threath Any" then
                for i = 1, #BarrageEnemies do
                    local ThisUnit = BarrageEnemies[i]
                    if Player:Threat(ThisUnit) >= GetSecondOptionValue("误导") then
                        Bug(
                        "Misdirection on " ..
                        MisdirectionTarget:Name() ..
                        " as " .. ThisUnit:Name() .. " is at " .. Player:Threat(ThisUnit) .. "% threath"
                        )
                        MisdirectionTarget:Cast(Misdirection)
                        return
                    end
                end
            end
        end
    end
end
function Rotation:Defensives()
    Player:UseHealingItem()
    if
    Exhilaration:Exists() and IsOptionEnabled("意气风发") and Player:HealthPercentage() <= GetOptionValue("意气风发") and
    Player:CanCast(Exhilaration)
    then
        Player:Cast(Exhilaration)
        return
    end
    if
    GiftOfTheNaaru:Exists() and IsOptionEnabled("纳鲁的赐福") and Player:HealthPercentage() <= GetOptionValue("纳鲁的赐福") and
    Player:CanCast(GiftOfTheNaaru)
    then
        Player:Cast(GiftOfTheNaaru)
        return
    end
    if
    AspectOfTheTurtle:Exists() and IsOptionEnabled("灵龟守护") and Player:HealthPercentage() <= GetOptionValue("灵龟守护") and
    Player:CanCast(AspectOfTheTurtle)
    then
        Player:Cast(AspectOfTheTurtle)
        return
    end
    if
    FeignDeath:Exists() and IsOptionEnabled("自动假死") and Player:HealthPercentage() <= GetOptionValue("自动假死") and
    Player:CanCast(FeignDeath)
    then
        Player:Cast(FeignDeath)
    end
end
function Rotation:Interrupts()
    Player:UseInterrupt(CounterShot, ArcaneTorrent)
end
function Rotation:OffGCDAbilities()
end
Rotation.TriedToSummonPet, Rotation.TriedToResurrectPet = 0, 0
function Rotation:ManagePet()
    if IsOptionEnabled("自动召唤/复活宠物") and (InstantWhistle or self.PetDismissed + GetOptionValue("自动召唤/复活宠物") < GetTime()) then
        InstantWhistle = false
        if
        not PlayerPet:Exists() and GetTime() > self.TriedToSummonPet and
        Player:CanCast(CallPets[GetSecondOptionValue("自动召唤/复活宠物")])
        then
            self.TriedToSummonPet = GetTime() + 5
            Player:Cast(CallPets[GetSecondOptionValue("自动召唤/复活宠物")])
            return
        end
        if
        not Player:IsMoving() and (not PlayerPet:Exists() or PlayerPet:IsDead()) and Player:CanCast(RevivePet) and
        GetTime() > self.TriedToResurrectPet
        then
            if Player:IsInCombat() and self.HeartOfThePhoenixAttempt < GetTime() then
                self.HeartOfThePhoenixAttempt = GetTime() + 485
                Player:Cast(HeartOfThePhoenix)
                return
            elseif self.HeartOfThePhoenixAttempt - 483 < GetTime() then
                self.TriedToResurrectPet = GetTime() + 3
                Player:Cast(MendPet)
                return
            end
        end
    end
    if
    PlayerPet:Exists() and IsOptionEnabled("治疗宠物") and Player:CanCast(MendPet) and not PlayerPet:Buff(MendPetBuff) and
    MendPet:TimeSinceCast() > 8
    then
        if
        (Player:IsInCombat() and PlayerPet:HealthPercentage() <= GetOptionValue("治疗宠物")) or
        (not Player:IsInCombat() and PlayerPet:HealthPercentage() <= GetSecondOptionValue("治疗宠物"))
        then
            PlayerPet:Cast(MendPet)
            return
        end
    end
end
Rotation.PetAssisting = false
function Rotation:PlayerPetHandling()
    if IsOptionEnabled("宠物输出处理") and PlayerPet:Exists() then
        if GetOptionValue("宠物输出处理") == "Handle Assist" then
            if Target:Exists() and not self.PetAssisting then
                RunMacroText("/petattack target")
                PetAssistMode()
                self.PetAssisting = true
            elseif not Target:Exists() and self.PetAssisting then
                PetPassiveMode()
                self.PetAssisting = false
            end
        end
    end
end
function Rotation:CastExplosiveShot()
    if ExplosiveShot:Exists() and IsOptionEnabled("爆炸射击") and Player:CanCast(ExplosiveShot) then
        local RealDistance = Player:DistanceTo(Target, true)
        local CanExplosiveShot, ExplosiveShotTargets = false, 0
        for i = 1, #ExplosiveShotEnemies do
            local ThisUnit = ExplosiveShotEnemies[i]
            if not CanExplosiveShot and ThisUnit:GUID() == Target:GUID() then
                CanExplosiveShot = true
            end
            if
            Player:DistanceTo(ThisUnit, true) < RealDistance + 3 and
            Player:DistanceTo(ThisUnit, true) > RealDistance - 3
            then
                ExplosiveShotTargets = ExplosiveShotTargets + 1
            end
        end
        if CanExplosiveShot and ExplosiveShotTargets >= GetOptionValue("爆炸射击") then
            local AdjustedDistance =             RealDistance < 10 and RealDistance + 3 or RealDistance < 20 and RealDistance + 1.5 or
            RealDistance < 30 and RealDistance - 1 or
            RealDistance < 35 and RealDistance - 2 or
            RealDistance < 40 and RealDistance - 3 or
            RealDistance - 4
            Detonate, DetonateTime = true, GetTime() + AdjustedDistance * 0.0625
            Player:Cast(ExplosiveShot)
            return
        end
    end
end
function Rotation:InFlight(Spell)
    return Spell.LastExecutedTime + Spell:TravelTime() > GetTime()
end
function Rotation:UnitTables()
    PiercingShotEnemies = UseAOE() and #Player:UnitsInFrontRectangle(Player:DistanceTo(Target, true), 3) or 1
    ExplosiveShotEnemies = UseAOE() and Player:UnitsInFrontRectangle(40, 5) or {}
    BarrageEnemies = UseAOE() and Barrage:Exists() and Player:UnitsInFrontConeAroundUnit(Target, 45, 100) or {}
    Enemies_40y = UseAOE() and Player:EnemiesWithinDistance(40, false) or {}
    VulnerableTargets = UseAOE() and Player:FilterEnemiesByDebuff(Enemies_40y, Vulnerable) or {}
    MarkedTargets = UseAOE() and Player:FilterEnemiesByDebuff(Enemies_40y, HuntersMark) or {}
    TargetEnemies_8y = UseAOE() and Target:EnemiesWithinDistance(8, true, true) or {}
    NumEnemies = #TargetEnemies_8y
end
function Rotation:Combat()
    if not LoneWolf:Exists() then
        self:ManagePet()
        self:PlayerPetHandling()
    end
    local GCDMax, Focus, FocusRegen =     math.max(1.5 / (1 + 0.01 * UnitSpellHaste("player"))),
    Player:Focus(),
    Player:FocusRegen()
    if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) and Player:IsFacing(Target) then
        Player:StartAttack(75)
        if
        ConcussiveShot:Exists() and IsOptionEnabled("震荡射击") and Target:DebuffRemains(ConcussiveShot) < Player:GCD() and
        Target:CanCast(ConcussiveShot)
        then
            Target:Cast(ConcussiveShot)
            return
        end
        if MarkedShot:Exists() and Target:Debuff(HuntersMark) and MarkedShotQueued and Target:CanCast(MarkedShot) then
            MarkedShotQueued = false
            Target:Cast(MarkedShot)
            return
        end
        if Barrage:Exists() and ShouldBarrage == true then
            if Barrage:Cooldown() > 6 then
                ShouldBarrage = false
            else
                if Focus < 60 then
                    if not Sidewinders:Exists() then
                        if Target:CanCast(ArcaneShot) then
                            Bug("Pool for Barrage")
                            Target:Cast(ArcaneShot)
                            return
                        end
                    elseif Target:CanCast(Sidewinders) then
                        Bug("Pool for Barrage")
                        Target:Cast(Sidewinders)
                        return
                    end
                end
                if Focus >= 60 and Target:CanCast(Barrage, true) then
                    Target:Cast(Barrage)
                    return
                end
            end
        end
        self:MisdirectionHandler()
        if Player:IsWithinCastRange(Target, AimedShot) then
            Player:UsePotions("Agility")
            Player:UseTrinkets()
            if CDOptionEnabled("进攻性种族技能") then
                if
                ArcaneTorrent:Exists() and Player:FocusDeficit() >= 30 and
                (not Sidewinders:Exists() or Sidewinders:Charges() < 2) and
                Player:CanCast(ArcaneTorrent)
                then
                    Player:Cast(ArcaneTorrent)
                    return
                end
                if Berserking:Exists() and Player:Buff(Trueshot) and Player:CanCast(Berserking) then
                    Player:Cast(Berserking)
                end
                if BloodFury:Exists() and Player:Buff(Trueshot) and Player:CanCast(BloodFury) then
                    Player:Cast(BloodFury)
                end
            end
            if self.TrueshotCooldown == 0 and CombatTime() > 15 and not Trueshot:IsOnCooldown() then
                self.TrueshotCooldown = CombatTime() * 1.1
            end
            if
            Trueshot:Exists() and CDOptionEnabled("百发百中") and
            (self.TrueshotCooldown == 0 or
            (self.TrueshotCooldown > 0 and Target:TimeToDie() > (self.TrueshotCooldown + 15)) or
            Player:BuffCount(Bullseye) > 25 or
            Target:TimeToDie() < 16) and
            Player:CanCast(Trueshot)
            then
                Player:Cast(Trueshot)
                return
            end
        end
        if
        Volley:Exists() and IsOptionEnabled("乱射") and NumEnemies >= GetOptionValue("乱射") and
        Volley:TimeSinceCast() > 1
        then
            if not Player:Buff(Volley) and Player:CanCast(Volley) then
                Volley.LastCastTime = GetTime()
                Player:Cast(Volley)
            end
        else
            if IsOptionEnabled("乱射") and Player:Buff(Volley) and NumEnemies < GetOptionValue("乱射") then
                Volley.LastCastTime = GetTime()
                Player:Cast(Volley)
            end
        end
        self.VulnerableRemains = Target:DebuffRemains(Vulnerable)
        AttackHaste = 1 - GetHaste() / 100
        self.PoolingForPiercing =         PiercingShot:Exists() and IsOptionEnabled("穿刺射击") and PiercingShotEnemies >= GetOptionValue("穿刺射击") and
        PiercingShot:Cooldown() < 5 and
        self.VulnerableRemains > 0 and
        self.VulnerableRemains > PiercingShot:Cooldown() and
        (not Player:Buff(Trueshot) or NumEnemies == 1)
        WaitingForSentinel =         Sentinel:Exists() and (Player:Buff(MarkingTargets) or Player:Buff(Trueshot)) and Sentinel:IsOnCooldown() and
        ((Sentinel:Cooldown() > 54 and Sentinel:Cooldown() < 54 + Player:GCD()) or
        (Sentinel:Cooldown() > 48 and Sentinel:Cooldown() < 48 + Player:GCD()) or
        (Sentinel:Cooldown() > 42 and Sentinel:Cooldown() < 42 + Player:GCD()))
        if not PatientSniper:Exists() then
            if ExplosiveShot:Exists() then
                self:CastExplosiveShot()
            end
            if
            PiercingShot:Exists() and IsOptionEnabled("穿刺射击") and PiercingShotEnemies >= GetOptionValue("穿刺射击") and
            self.VulnerableRemains > 0 and
            Player:Focus() > 100 and
            Target:CanCast(PiercingShot)
            then
                Target:Cast(PiercingShot)
                return
            end
            if
            AimedShot:Exists() and TrickShot:Exists() and Target:DebuffRemains(Vulnerable) > AimedShot:CastTime() and
            (not self.PoolingforPiercing or
            (Player:Buff(LockAndLoad) and Target:DebuffRemains(Vulnerable) > Player:GCD())) and
            (NumEnemies < 4 or TrickShot:Exists() or Player:BuffCount(SentinelsSight) == 20) and
            Target:CanCast(AimedShot)
            then
                Target:Cast(AimedShot)
                return
            end
            if
            AimedShot:Exists() and PiercingShot:Exists() and Target:DebuffRemains(Vulnerable) > AimedShot:CastTime() and
            (not self.PoolingforPiercing or
            (Player:Buff(LockAndLoad) and Target:DebuffRemains(Vulnerable) > Player:GCD())) and
            (NumEnemies < 4 or TrickShot:Exists() or Player:BuffCount(SentinelsSight) == 20) and
            not Player:Buff(MarkingTargets) and
            not Player:Buff(Trueshot) and
            not Target:Debuff(HuntersMark) and
            Target:CanCast(AimedShot)
            then
                Target:Cast(AimedShot)
                return
            end
            if
            AimedShot:Exists() and Player:Buff(LockAndLoad) and Target:DebuffRemains(Vulnerable) > Player:GCD() and
            Target:CanCast(AimedShot)
            then
                Target:Cast(AimedShot)
                return
            end
            if MarkedShot:Exists() and Target:Debuff(HuntersMark) and NumEnemies > 1 and Target:CanCast(MarkedShot) then
                Target:Cast(MarkedShot)
                return
            end
            if
            MultiShot:Exists() and not Sidewinders:Exists() and IsOptionEnabled("多重射击") and
            NumEnemies >= GetOptionValue("多重射击") and
            (Player:Buff(MarkingTargets) or Player:Buff(Trueshot)) and
            Target:CanCast(MultiShot)
            then
                Target:Cast(MultiShot)
                return
            end
            if
            Sentinel:Exists() and CDOptionEnabled("哨兵") and not Target:Debuff(HuntersMark) and
            Target:CanCast(Sentinel)
            then
                MarkedShotQueued = true
                Target:Cast(Sentinel)
                return
            end
            if BlackArrow:Exists() and (Sidewinders:Exists() or NumEnemies < 6) and Target:CanCast(BlackArrow) then
                Target:Cast(BlackArrow)
                return
            end
            if AMurderOfCrows:Exists() and CDOptionEnabled("夺命黑鸦") and Target:CanCast(AMurderOfCrows) then
                Target:Cast(AMurderOfCrows)
                return
            end
            if Windburst:Exists() and IsOptionEnabled("Windburst") and Target:CanCast(Windburst) then
                Target:Cast(Windburst)
                return
            end
            if
            Barrage:Exists() and IsOptionEnabled("弹幕射击") and
            (#BarrageEnemies >= GetOptionValue("弹幕射击") or
            (#BarrageEnemies >= 2 and Target:HealthPercentage() < 20 and Player:BuffCount(Bullseye) < 25)) and
            Target:CanCast(Barrage, true)
            then
                Target:Cast(Barrage)
                return
            end
            if
            MarkedShot:Exists() and Target:Debuff(HuntersMark) and
            (Player:Buff(MarkingTargets) or Player:Buff(Trueshot)) and
            Target:CanCast(MarkedShot)
            then
                Target:Cast(MarkedShot)
                return
            end
            if
            Sidewinders:Exists() and not WaitingForSentinel and
            (not Target:Debuff(HuntersMark) or (not Player:Buff(Trueshot) and not Player:Buff(MarkingTargets))) and
            ((Player:Buff(MarkingTargets) or Player:Buff(Trueshot)) or Sidewinders:FractionalCharges() > 1.8) and
            (Player:FocusDeficit() > Player:FocusRegen()) and
            Target:CanCast(Sidewinders)
            then
                Target:Cast(Sidewinders)
                return
            end
            if
            AimedShot:Exists() and Sidewinders:Exists() and self.VulnerableRemains > AimedShot:CastTime() and
            Target:CanCast(AimedShot)
            then
                Target:Cast(AimedShot)
                return
            end
            if
            AimedShot:Exists() and TrickShot:Exists() and self.VulnerableRemains > AimedShot:CastTime() and
            (not self.PoolingForPiercing or (Player:Buff(LockAndLoad) and self.VulnerableRemains > GCDMax)) and
            (NumEnemies < 4 or TrickShot:Exists() or Player:BuffCount(SentinelsSight) == 20) and
            Target:CanCast(AimedShot)
            then
                Target:Cast(AimedShot)
                return
            end
            if MarkedShot:Exists() and Target:Debuff(HuntersMark) and Target:CanCast(MarkedShot) then
                Target:Cast(MarkedShot)
                return
            end
            if
            AimedShot:Exists() and Sidewinders:Exists() and NumEnemies == 1 and Player:Focus() > 110 and
            Target:CanCast(AimedShot)
            then
                Target:Cast(AimedShot)
                return
            end
            if
            MultiShot:Exists() and not Sidewinders:Exists() and IsOptionEnabled("多重射击") and
            NumEnemies >= GetOptionValue("多重射击") and
            not WaitingForSentinel and
            Target:CanCast(MultiShot)
            then
                Target:Cast(MultiShot)
                return
            end
            if
            ArcaneShot:Exists() and not Sidewinders:Exists() and
            (NumEnemies < GetOptionValue("多重射击") or not IsOptionEnabled("多重射击")) and
            not WaitingForSentinel and
            Target:CanCast(ArcaneShot)
            then
                Target:Cast(ArcaneShot)
                return
            end
        end
        if PatientSniper:Exists() then
            self.Vuln_Window = Target:DebuffRemains(Vulnerable)
            self.FullRechargeTime =             select(2, Sidewinders:Charges()) - Sidewinders:FractionalCharges() * Sidewinders:Recharge()
            if Sidewinders:Exists() and self.FullRechargeTime < self.Vuln_Window then
                self.Vuln_Window = self.FullRechargeTime
            else
                self.Vuln_Window = Target:DebuffRemains(Vulnerable)
            end
            Vuln_Aim_Casts =             AimedShot:CastTime() ~= 0 and math.floor(self.Vuln_Window / AimedShot:CastTime()) or
            math.floor(self.Vuln_Window / GCDMax)
            if
            Vuln_Aim_Casts > 0 and
            Vuln_Aim_Casts >
            math.floor((Player:Focus() + AimedShot:CastTime() * Player:FocusRegen()) * (Vuln_Aim_Casts - 1)) /
            50
            then
                Vuln_Aim_Casts =                 math.floor((Player:Focus() + AimedShot:CastTime() * Player:FocusRegen()) * (Vuln_Aim_Casts - 1)) /
                50
            end
            Can_GCD =             self.Vuln_Window < AimedShot:CastTime() or
            self.Vuln_Window > Vuln_Aim_Casts * AimedShot:CastTime() + GCDMax
            if
            PiercingShot:Exists() and IsOptionEnabled("穿刺射击") and PiercingShotEnemies >= GetOptionValue("穿刺射击") and
            self.VulnerableRemains > 0 and
            self.VulnerableRemains < 1 and
            Target:CanCast(PiercingShot)
            then
                Target:Cast(PiercingShot)
                return
            end
            if
            PiercingShot:Exists() and IsOptionEnabled("穿刺射击") and PiercingShotEnemies >= GetOptionValue("穿刺射击") and
            self.VulnerableRemains > 0 and
            ((not Player:Buff(Trueshot) and Player:Focus() > 80 and
            (self.VulnerableRemains < 1 or Target:Debuff(HuntersMark))) or
            (Player:Buff(Trueshot) and Player:Focus() > 105 and self.VulnerableRemains < 6)) and
            Target:CanCast(PiercingShot)
            then
                Target:Cast(PiercingShot)
                return
            end
            if
            AimedShot:Exists() and NumEnemies > 1 and self.VulnerableRemains > AimedShot:CastTime() and
            TrickShot:Exists() and
            (Player:Buff(LockAndLoad) or Player:BuffCount(SentinelsSight) == 20 or
            (Player:Buff(Trueshot) and Player:BuffCount(SentinelsSight) >= NumEnemies * 5)) and
            Target:CanCast(AimedShot)
            then
                Target:Cast(AimedShot)
                return
            end
            if
            MarkedShot:Exists() and Target:Debuff(HuntersMark) and IsOptionEnabled("多重射击") and
            NumEnemies >= GetOptionValue("多重射击") and
            Target:CanCast(MarkedShot)
            then
                Target:Cast(MarkedShot)
                return
            end
            if
            MultiShot:Exists() and not Sidewinders:Exists() and IsOptionEnabled("多重射击") and
            NumEnemies >= GetOptionValue("多重射击") and
            (Player:Buff(MarkingTargets) or Player:Buff(Trueshot)) and
            Target:CanCast(MultiShot)
            then
                Target:Cast(MultiShot)
                return
            end
            if
            Windburst:Exists() and IsOptionEnabled("Windburst") and Vuln_Aim_Casts < 1 and
            not self.PoolingForPiercing and
            Target:CanCast(Windburst)
            then
                Target:Cast(Windburst)
                return
            end
            if
            BlackArrow:Exists() and Can_GCD and
            (not self.PoolingForPiercing or (self.VulnerableRemains > GCDMax and Player:Focus() > 85)) and
            Target:CanCast(BlackArrow)
            then
                Target:Cast(BlackArrow)
                return
            end
            if
            AMurderOfCrows:Exists() and CDOptionEnabled("夺命黑鸦") and
            (not self.PoolingForPiercing or self.VulnerableRemains > GCDMax) and
            (Target:TimeToDie() >= 60 + 15 or Target:HealthPercentage() < 20 or Target:TimeToDie() < 16) and
            Vuln_Aim_Casts == 0 and
            Target:CanCast(AMurderOfCrows)
            then
                Target:Cast(AMurderOfCrows)
                return
            end
            if
            Barrage:Exists() and IsOptionEnabled("弹幕射击") and
            (#BarrageEnemies >= GetOptionValue("弹幕射击") or
            (#BarrageEnemies >= 2 and Target:HealthPercentage() < 20 and Player:BuffCount(Bullseye) < 25)) and
            Target:CanCast(Barrage, true)
            then
                Target:Cast(Barrage)
                return
            end
            if
            AimedShot:Exists() and Target:Debuff(Vulnerable) and Player:Buff(LockAndLoad) and
            (not self.PoolingForPiercing or self.VulnerableRemains > GCDMax) and
            Target:CanCast(AimedShot)
            then
                Target:Cast(AimedShot)
                return
            end
            if
            AimedShot:Exists() and NumEnemies > 1 and
            self.VulnerableRemains > AimedShot:CastTime() + AimedShot:TravelTime() and
            (not self.PoolingForPiercing or
            (Player:Focus() > 100 and
            self.VulnerableRemains > (AimedShot:CastTime() + AimedShot:TravelTime() + GCDMax))) and
            Target:CanCast(AimedShot)
            then
                Target:Cast(AimedShot)
                return
            end
            if
            MultiShot:Exists() and not Sidewinders:Exists() and IsOptionEnabled("多重射击") and
            NumEnemies >= GetOptionValue("多重射击") and
            Can_GCD and
            Player:Focus() + Player:FocusRegen() + AimedShot:CastTime() * Player:FocusRegen() <
            Player:FocusMax() and
            (not self.PoolingForPiercing or self.VulnerableRemains > GCDMax) and
            Target:CanCast(MultiShot)
            then
                Target:Cast(MultiShot)
                return
            end
            if
            ArcaneShot:Exists() and not Sidewinders:Exists() and
            (NumEnemies < GetOptionValue("多重射击") or not IsOptionEnabled("多重射击")) and
            (not HasT20_2Pc or not Player:Buff(Trueshot) or Player:Buff(CriticalAimed)) and
            Vuln_Aim_Casts > 0 and
            Can_GCD and
            Player:Focus() + Player:FocusRegen() + AimedShot:CastTime() * Player:FocusRegen() <
            Player:FocusMax() and
            (not self.PoolingForPiercing or self.VulnerableRemains > GCDMax) and
            Target:CanCast(ArcaneShot)
            then
                Target:Cast(ArcaneShot)
                return
            end
            if
            AimedShot:Exists() and Sidewinders:Exists() and
            (self.VulnerableRemains > AimedShot:CastTime() or (not Player:Buff(LockAndLoad))) and
            (self.Vuln_Window - ((AimedShot:CastTime() + AimedShot:TravelTime()) * Vuln_Aim_Casts) < 1 or
            Player:FocusDeficit() < 25 or
            Player:Buff(Trueshot)) and
            (NumEnemies == 1 or Player:Focus() > 100) and
            Windburst:TimeSinceCast() > Player:GCD() and
            Target:CanCast(AimedShot)
            then
                Target:Cast(AimedShot)
                return
            end
            if
            AimedShot:Exists() and not Sidewinders:Exists() and self.VulnerableRemains > AimedShot:CastTime() and
            (not self.PoolingForPiercing or
            (Player:Focus() > 100 and
            self.VulnerableRemains > (AimedShot:CastTime() + AimedShot:TravelTime() + GCDMax))) and
            Target:CanCast(AimedShot)
            then
                Target:Cast(AimedShot)
                return
            end
            if
            MarkedShot:Exists() and Target:Debuff(HuntersMark) and not Sidewinders:Exists() and
            not self.PoolingForPiercing and
            Windburst:TimeSinceCast() > Player:GCD() and
            Target:CanCast(MarkedShot)
            then
                Target:Cast(MarkedShot)
                return
            end
            if
            MarkedShot:Exists() and Target:Debuff(HuntersMark) and Sidewinders:Exists() and
            (Vuln_Aim_Casts < 1 or Player:Buff(Trueshot) or self.Vuln_Window < AimedShot:CastTime()) and
            Target:CanCast(MarkedShot)
            then
                Target:Cast(MarkedShot)
                return
            end
            if
            AimedShot:Exists() and (NumEnemies < GetOptionValue("多重射击") or not IsOptionEnabled("多重射击")) and
            Player:Focus() > 110 and
            Target:CanCast(AimedShot)
            then
                Target:Cast(AimedShot)
                return
            end
            if
            Sidewinders:Exists() and
            (not Target:Debuff(HuntersMark) or (not Player:Buff(MarkingTargets) and not Player:Buff(Trueshot))) and
            ((Player:Buff(MarkingTargets) and Vuln_Aim_Casts < 1) or Player:Buff(Trueshot) or
            Sidewinders:FractionalCharges() > 1.9) and
            Target:CanCast(Sidewinders)
            then
                Target:Cast(Sidewinders)
                return
            end
            if
            ArcaneShot:Exists() and not Sidewinders:Exists() and
            (NumEnemies < GetOptionValue("多重射击") or not IsOptionEnabled("多重射击")) and
            (not self.PoolingForPiercing or self.VulnerableRemains > GCDMax) and
            Target:CanCast(ArcaneShot)
            then
                Target:Cast(ArcaneShot)
                return
            end
            if
            MultiShot:Exists() and not Sidewinders:Exists() and IsOptionEnabled("多重射击") and
            NumEnemies >= GetOptionValue("多重射击") and
            (not self.PoolingForPiercing or self.VulnerableRemains > GCDMax) and
            Target:CanCast(MultiShot)
            then
                Target:Cast(MultiShot)
                return
            end
        end
        if Target:TimeToDie() < 6 and NumEnemies == 1 then
            if
            PiercingShot:Exists() and IsOptionEnabled("穿刺射击") and PiercingShotEnemies >= GetOptionValue("穿刺射击") and
            Target:Debuff(Vulnerable) and
            Target:CanCast(PiercingShot)
            then
                Target:Cast(PiercingShot)
                return
            end
            if Windburst:Exists() and IsOptionEnabled("Windburst") and Target:CanCast(Windburst) then
                Target:Cast(Windburst)
                return
            end
            if
            AimedShot:Exists() and self.VulnerableRemains > AimedShot:CastTime() and
            Target:TimeToDie() > AimedShot:CastTime() and
            Target:CanCast(AimedShot)
            then
                Target:Cast(AimedShot)
                return
            end
            if MarkedShot:Exists() and Target:CanCast(MarkedShot) then
                Target:Cast(MarkedShot)
                return
            end
            if Sidewinders:Exists() and Target:CanCast(Sidewinders) then
                Target:Cast(Sidewinders)
                return
            end
            if ArcaneShot:Exists() and not Sidewinders:Exists() and Target:CanCast(ArcaneShot) then
                Target:Cast(ArcaneShot)
                return
            end
        end
    end
end
function Rotation:CombatBeta()
    if not LoneWolf:Exists() then
        self:ManagePet()
        self:PlayerPetHandling()
    end
    local GCDMax, Focus, FocusRegen =     math.max(1.5 / (1 + 0.01 * UnitSpellHaste("player"))),
    Player:Focus(),
    Player:FocusRegen()
    if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) and Player:IsFacing(Target) then
        Player:StartAttack(75)
        if
        ConcussiveShot:Exists() and IsOptionEnabled("震荡射击") and Target:DebuffRemains(ConcussiveShot) < Player:GCD() and
        Target:CanCast(ConcussiveShot)
        then
            Target:Cast(ConcussiveShot)
            return
        end
        if MarkedShot:Exists() and Target:Debuff(HuntersMark) and MarkedShotQueued and Target:CanCast(MarkedShot) then
            MarkedShotQueued = false
            Target:Cast(MarkedShot)
            return
        end
        if Barrage:Exists() and ShouldBarrage == true then
            if Barrage:Cooldown() > 6 then
                ShouldBarrage = false
            else
                if Focus < 60 then
                    if not Sidewinders:Exists() then
                        if Target:CanCast(ArcaneShot) then
                            Bug("Pool for Barrage")
                            Target:Cast(ArcaneShot)
                            return
                        end
                    elseif Target:CanCast(Sidewinders) then
                        Bug("Pool for Barrage")
                        Target:Cast(Sidewinders)
                        return
                    end
                end
                if Focus >= 60 and Target:CanCast(Barrage, true) then
                    Target:Cast(Barrage)
                    return
                end
            end
        end
        self:MisdirectionHandler()
        if Player:IsWithinCastRange(Target, AimedShot) then
            Player:UsePotions("Agility")
            Player:UseTrinkets()
            if CDOptionEnabled("进攻性种族技能") then
                if
                ArcaneTorrent:Exists() and Player:FocusDeficit() >= 30 and
                (not Sidewinders:Exists() or Sidewinders:Charges() < 2) and
                Player:CanCast(ArcaneTorrent)
                then
                    Player:Cast(ArcaneTorrent)
                    return
                end
                if Berserking:Exists() and Player:Buff(Trueshot) and Player:CanCast(Berserking) then
                    Player:Cast(Berserking)
                end
                if BloodFury:Exists() and Player:Buff(Trueshot) and Player:CanCast(BloodFury) then
                    Player:Cast(BloodFury)
                end
            end
            if self.TrueshotCooldown == 0 and CombatTime() > 15 and not Trueshot:IsOnCooldown() then
                self.TrueshotCooldown = CombatTime() * 1.1
            end
            if
            Trueshot:Exists() and CDOptionEnabled("百发百中") and
            (self.TrueshotCooldown == 0 or
            (self.TrueshotCooldown > 0 and Target:TimeToDie() > (self.TrueshotCooldown + 15)) or
            Player:BuffCount(Bullseye) > 25 or
            Target:TimeToDie() < 16) and
            Player:CanCast(Trueshot)
            then
                Player:Cast(Trueshot)
                return
            end
        end
        if
        Volley:Exists() and IsOptionEnabled("乱射") and NumEnemies >= GetOptionValue("乱射") and
        Volley:TimeSinceCast() > 1
        then
            if not Player:Buff(Volley) and Player:CanCast(Volley) then
                Volley.LastCastTime = GetTime()
                Player:Cast(Volley)
            end
        else
            if IsOptionEnabled("乱射") and Player:Buff(Volley) and NumEnemies < GetOptionValue("乱射") then
                Volley.LastCastTime = GetTime()
                Player:Cast(Volley)
            end
        end
        self.VulnerableRemains = Target:DebuffRemains(Vulnerable)
        AttackHaste = 1 - GetHaste() / 100
        self.PoolingForPiercing =         PiercingShot:Exists() and IsOptionEnabled("穿刺射击") and PiercingShotEnemies >= GetOptionValue("穿刺射击") and
        PiercingShot:Cooldown() < 5 and
        self.VulnerableRemains > 0 and
        self.VulnerableRemains > PiercingShot:Cooldown() and
        (not Player:Buff(Trueshot) or NumEnemies == 1)
        WaitingForSentinel =         Sentinel:Exists() and (Player:Buff(MarkingTargets) or Player:Buff(Trueshot)) and Sentinel:IsOnCooldown() and
        ((Sentinel:Cooldown() > 54 and Sentinel:Cooldown() < 54 + Player:GCD()) or
        (Sentinel:Cooldown() > 48 and Sentinel:Cooldown() < 48 + Player:GCD()) or
        (Sentinel:Cooldown() > 42 and Sentinel:Cooldown() < 42 + Player:GCD()))
        if not PatientSniper:Exists() then
            if ExplosiveShot:Exists() then
                self:CastExplosiveShot()
            end
            if
            PiercingShot:Exists() and IsOptionEnabled("穿刺射击") and PiercingShotEnemies >= GetOptionValue("穿刺射击") and
            self.VulnerableRemains > 0 and
            Player:Focus() > 100 and
            Target:CanCast(PiercingShot)
            then
                Target:Cast(PiercingShot)
                return
            end
            if
            AimedShot:Exists() and Player:BuffCount(SentinelsSight) == 20 and
            ((TrickShot:Exists() and #VulnerableTargets > 1) or Player:Buff(LockAndLoad)) and
            Target:DebuffRemains(Vulnerable) > AimedShot:CastTime() and
            Target:CanCast(AimedShot)
            then
                Target:Cast(AimedShot)
                return
            end
            if
            AimedShot:Exists() and TrickShot:Exists() and #VulnerableTargets > 1 and
            Target:DebuffRemains(Vulnerable) > AimedShot:CastTime() and
            HasT20_2Pc and
            not Player:Buff(CriticalAimed) and
            self:InFlight(AimedShot) and
            Target:CanCast(AimedShot)
            then
                Target:Cast(AimedShot)
                return
            end
            if MarkedShot:Exists() and #MarkedTargets > 1 and Target:CanCast(MarkedShot) then
                Target:Cast(MarkedShot)
                return
            end
            if
            MultiShot:Exists() and not Sidewinders:Exists() and IsOptionEnabled("多重射击") and
            NumEnemies >= GetOptionValue("多重射击") and
            (Player:Buff(MarkingTargets) or Player:Buff(Trueshot)) and
            Target:CanCast(MultiShot)
            then
                Target:Cast(MultiShot)
                return
            end
            if
            Sentinel:Exists() and CDOptionEnabled("哨兵") and not Target:Debuff(HuntersMark) and
            Target:CanCast(Sentinel)
            then
                MarkedShotQueued = true
                Target:Cast(Sentinel)
                return
            end
            if BlackArrow:Exists() and (Sidewinders:Exists() or NumEnemies < 6) and Target:CanCast(BlackArrow) then
                Target:Cast(BlackArrow)
                return
            end
            if AMurderOfCrows:Exists() and CDOptionEnabled("夺命黑鸦") and Target:CanCast(AMurderOfCrows) then
                Target:Cast(AMurderOfCrows)
                return
            end
            if Windburst:Exists() and IsOptionEnabled("Windburst") and Target:CanCast(Windburst) then
                Target:Cast(Windburst)
                return
            end
            if
            Barrage:Exists() and IsOptionEnabled("弹幕射击") and
            (#BarrageEnemies >= GetOptionValue("弹幕射击") or
            (#BarrageEnemies >= 2 and Target:HealthPercentage() < 20 and Player:BuffCount(Bullseye) < 25)) and
            Target:CanCast(Barrage, true)
            then
                Target:Cast(Barrage)
                return
            end
            if
            MarkedShot:Exists() and Target:Debuff(HuntersMark) and
            (Player:Buff(MarkingTargets) or Player:Buff(Trueshot)) and
            Target:CanCast(MarkedShot)
            then
                Target:Cast(MarkedShot)
                return
            end
            if
            Sidewinders:Exists() and not WaitingForSentinel and
            (not Target:Debuff(HuntersMark) or (not Player:Buff(Trueshot) and not Player:Buff(MarkingTargets))) and
            ((Player:Buff(MarkingTargets) or Player:Buff(Trueshot)) or Sidewinders:FractionalCharges() > 1.8) and
            (Player:FocusDeficit() > Player:FocusRegen()) and
            Target:CanCast(Sidewinders)
            then
                Target:Cast(Sidewinders)
                return
            end
            if
            AimedShot:Exists() and Sidewinders:Exists() and self.VulnerableRemains > AimedShot:CastTime() and
            Target:CanCast(AimedShot)
            then
                Target:Cast(AimedShot)
                return
            end
            if
            AimedShot:Exists() and not Sidewinders:Exists() and self.VulnerableRemains > AimedShot:CastTime() and
            (not self.PoolingForPiercing or (Player:Buff(LockAndLoad) and self.VulnerableRemains > GCDMax)) and
            (TrickShot:Exists() or Player:BuffCount(SentinelsSight) == 20) and
            Target:CanCast(AimedShot)
            then
                Target:Cast(AimedShot)
                return
            end
            if MarkedShot:Exists() and Target:Debuff(HuntersMark) and Target:CanCast(MarkedShot) then
                Target:Cast(MarkedShot)
                return
            end
            if
            AimedShot:Exists() and Focus + (FocusRegen * AimedShot:CastTime()) >= Player:FocusMax() and
            not Player:Buff(SentinelsSight) and
            Target:CanCast(AimedShot)
            then
                Target:Cast(AimedShot)
                return
            end
            if
            MultiShot:Exists() and not Sidewinders:Exists() and IsOptionEnabled("多重射击") and
            NumEnemies >= GetOptionValue("多重射击") and
            not WaitingForSentinel and
            Target:CanCast(MultiShot)
            then
                Target:Cast(MultiShot)
                return
            end
            if
            ArcaneShot:Exists() and not Sidewinders:Exists() and
            (NumEnemies < GetOptionValue("多重射击") or not IsOptionEnabled("多重射击")) and
            not WaitingForSentinel and
            Target:CanCast(ArcaneShot)
            then
                Target:Cast(ArcaneShot)
                return
            end
        end
        if PatientSniper:Exists() then
            self.Vuln_Window = Target:DebuffRemains(Vulnerable)
            self.FullRechargeTime =             select(2, Sidewinders:Charges()) - Sidewinders:FractionalCharges() * Sidewinders:Recharge()
            if Sidewinders:Exists() and self.FullRechargeTime < self.Vuln_Window then
                self.Vuln_Window = self.FullRechargeTime
            else
                self.Vuln_Window = Target:DebuffRemains(Vulnerable)
            end
            self.Vuln_Window = self.Vuln_Window - 0.1
            self.AimedShotCastRegen =             AimedShot:CastTime() ~= 0 and AimedShot:CastTime() * Player:FocusRegen() or GCDMax * Player:FocusRegen()
            Vuln_Aim_Casts =             AimedShot:CastTime() ~= 0 and math.floor(self.Vuln_Window / AimedShot:CastTime()) or
            math.floor(self.Vuln_Window / GCDMax)
            if
            Vuln_Aim_Casts > 0 and
            Vuln_Aim_Casts >
            math.floor(
            (Player:Focus() + self.AimedShotCastRegen * (Vuln_Aim_Casts - 1)) /
            (Player:Buff(Precision) and 46 or 50)
            )
            then
                Vuln_Aim_Casts =                 math.floor(
                (Player:Focus() + self.AimedShotCastRegen * (Vuln_Aim_Casts - 1)) /
                (Player:Buff(Precision) and 46 or 50)
                )
            end
            Can_GCD =             self.Vuln_Window < AimedShot:CastTime() or
            self.Vuln_Window > Vuln_Aim_Casts * AimedShot:CastTime() + GCDMax + 0.1
            if
            PiercingShot:Exists() and IsOptionEnabled("穿刺射击") and PiercingShotEnemies >= GetOptionValue("穿刺射击") and
            self.VulnerableRemains > 0 and
            self.VulnerableRemains < 1 and
            Target:CanCast(PiercingShot)
            then
                Target:Cast(PiercingShot)
                return
            end
            if
            PiercingShot:Exists() and IsOptionEnabled("穿刺射击") and PiercingShotEnemies >= GetOptionValue("穿刺射击") and
            self.VulnerableRemains > 0 and
            ((not Player:Buff(Trueshot) and Player:Focus() > 80 and
            (self.VulnerableRemains < 1 or Target:Debuff(HuntersMark))) or
            (Player:Buff(Trueshot) and Player:Focus() > 105 and self.VulnerableRemains < 6)) and
            Target:CanCast(PiercingShot)
            then
                Target:Cast(PiercingShot)
                return
            end
            if
            AimedShot:Exists() and #VulnerableTargets > 1 and TrickShot:Exists() and
            self.VulnerableRemains > AimedShot:CastTime() and
            (Player:BuffCount(SentinelsSight) >= NumEnemies * 5 or
            (Player:BuffCount(SentinelsSight) + (NumEnemies / 2) > 20) or
            Player:Buff(LockAndLoad) or
            (HasT20_2Pc and not Player:Buff(CriticalAimed) and self:InFlight(AimedShot))) and
            Target:CanCast(AimedShot)
            then
                Target:Cast(AimedShot)
                return
            end
            if MarkedShot:Exists() and #MarkedTargets > 1 and Target:CanCast(MarkedShot) then
                Target:Cast(MarkedShot)
                return
            end
            if
            MultiShot:Exists() and not Sidewinders:Exists() and IsOptionEnabled("多重射击") and
            NumEnemies >= GetOptionValue("多重射击") and
            (Player:Buff(MarkingTargets) or Player:Buff(Trueshot)) and
            Target:CanCast(MultiShot)
            then
                Target:Cast(MultiShot)
                return
            end
            if
            Windburst:Exists() and IsOptionEnabled("Windburst") and Vuln_Aim_Casts < 1 and
            not self.PoolingForPiercing and
            Target:CanCast(Windburst)
            then
                Target:Cast(Windburst)
                return
            end
            if
            BlackArrow:Exists() and Can_GCD and
            (not self.PoolingForPiercing or (self.VulnerableRemains > GCDMax and Player:Focus() > 85)) and
            Target:CanCast(BlackArrow)
            then
                Target:Cast(BlackArrow)
                return
            end
            if
            AMurderOfCrows:Exists() and CDOptionEnabled("夺命黑鸦") and
            (not self.PoolingForPiercing or self.VulnerableRemains > GCDMax) and
            (Target:TimeToDie() >= 60 + 15 or Target:HealthPercentage() < 20 or Target:TimeToDie() < 16) and
            Vuln_Aim_Casts == 0 and
            Target:CanCast(AMurderOfCrows)
            then
                Target:Cast(AMurderOfCrows)
                return
            end
            if
            Barrage:Exists() and IsOptionEnabled("弹幕射击") and
            (#BarrageEnemies >= GetOptionValue("弹幕射击") or
            (#BarrageEnemies >= 2 and Target:HealthPercentage() < 20 and Player:BuffCount(Bullseye) < 25)) and
            Target:CanCast(Barrage, true)
            then
                Target:Cast(Barrage)
                return
            end
            if
            AimedShot:Exists() and Target:Debuff(Vulnerable) and Player:Buff(LockAndLoad) and
            (not self.PoolingForPiercing or self.VulnerableRemains > GCDMax) and
            Target:CanCast(AimedShot)
            then
                Target:Cast(AimedShot)
                return
            end
            if
            AimedShot:Exists() and NumEnemies > 1 and
            self.VulnerableRemains > AimedShot:CastTime() + AimedShot:TravelTime() and
            (not self.PoolingForPiercing or
            (Player:Focus() > 100 and
            self.VulnerableRemains > (AimedShot:CastTime() + AimedShot:TravelTime() + GCDMax))) and
            Target:CanCast(AimedShot)
            then
                Target:Cast(AimedShot)
                return
            end
            if
            MultiShot:Exists() and not Sidewinders:Exists() and IsOptionEnabled("多重射击") and
            NumEnemies >= GetOptionValue("多重射击") and
            Can_GCD and
            Player:Focus() + Player:FocusRegen() + AimedShot:CastTime() * Player:FocusRegen() <
            Player:FocusMax() and
            (not self.PoolingForPiercing or self.VulnerableRemains > GCDMax) and
            Target:CanCast(MultiShot)
            then
                Target:Cast(MultiShot)
                return
            end
            if
            ArcaneShot:Exists() and not Sidewinders:Exists() and
            (NumEnemies < GetOptionValue("多重射击") or not IsOptionEnabled("多重射击")) and
            (not HasT20_2Pc or not self:InFlight(AimedShot) or
            Player:BuffRemains(CriticalAimed) > AimedShot:CastTime() + GCDMax) and
            Vuln_Aim_Casts > 0 and
            Can_GCD and
            Player:Focus() + (Player:FocusRegen() * GCDMax) + self.AimedShotCastRegen < Player:FocusMax() and
            (not self.PoolingForPiercing or self.VulnerableRemains > GCDMax) and
            Target:CanCast(ArcaneShot)
            then
                Target:Cast(ArcaneShot)
                return
            end
            if
            AimedShot:Exists() and Sidewinders:Exists() and
            (self.VulnerableRemains > AimedShot:CastTime() or
            (not Player:Buff(LockAndLoad) and self:InFlight(Windburst))) and
            (self.Vuln_Window - ((AimedShot:CastTime() + AimedShot:TravelTime()) * Vuln_Aim_Casts) < 1 or
            Player:FocusDeficit() < 25 or
            Player:Buff(Trueshot)) and
            (NumEnemies == 1 or Player:Focus() > 100) and
            Windburst:TimeSinceCast() > Player:GCD() and
            Target:CanCast(AimedShot)
            then
                Target:Cast(AimedShot)
                return
            end
            if
            AimedShot:Exists() and not Sidewinders:Exists() and self.VulnerableRemains > AimedShot:CastTime() and
            (not self.PoolingForPiercing or
            (self.VulnerableRemains > (AimedShot:CastTime() + AimedShot:TravelTime() + GCDMax))) and
            Target:CanCast(AimedShot)
            then
                Target:Cast(AimedShot)
                return
            end
            if
            MarkedShot:Exists() and Target:Debuff(HuntersMark) and not Sidewinders:Exists() and
            not self.PoolingForPiercing and
            not self:InFlight(Windburst) and
            (Focus > 65 or Player:Buff(Trueshot)) and
            Target:CanCast(MarkedShot)
            then
                Target:Cast(MarkedShot)
                return
            end
            if
            MarkedShot:Exists() and Target:Debuff(HuntersMark) and Sidewinders:Exists() and
            (Vuln_Aim_Casts < 1 or Player:Buff(Trueshot) or self.Vuln_Window < AimedShot:CastTime()) and
            Target:CanCast(MarkedShot)
            then
                Target:Cast(MarkedShot)
                return
            end
            if
            AimedShot:Exists() and (NumEnemies < GetOptionValue("多重射击") or not IsOptionEnabled("多重射击")) and
            Focus + self.AimedShotCastRegen >= Player:FocusMax() and
            not Player:Buff(SentinelsSight) and
            Target:CanCast(AimedShot)
            then
                Target:Cast(AimedShot)
                return
            end
            if
            Sidewinders:Exists() and
            (not Target:Debuff(HuntersMark) or (not Player:Buff(MarkingTargets) and not Player:Buff(Trueshot))) and
            ((Player:Buff(MarkingTargets) and Vuln_Aim_Casts < 1) or Player:Buff(Trueshot) or
            Sidewinders:FractionalCharges() > 1.9) and
            Target:CanCast(Sidewinders)
            then
                Target:Cast(Sidewinders)
                return
            end
            if
            ArcaneShot:Exists() and not Sidewinders:Exists() and
            (NumEnemies < GetOptionValue("多重射击") or not IsOptionEnabled("多重射击")) and
            (not self.PoolingForPiercing or self.VulnerableRemains > GCDMax) and
            Target:CanCast(ArcaneShot)
            then
                Target:Cast(ArcaneShot)
                return
            end
            if
            MultiShot:Exists() and not Sidewinders:Exists() and IsOptionEnabled("多重射击") and
            NumEnemies >= GetOptionValue("多重射击") and
            (not self.PoolingForPiercing or self.VulnerableRemains > GCDMax) and
            Target:CanCast(MultiShot)
            then
                Target:Cast(MultiShot)
                return
            end
        end
        if Target:TimeToDie() < 6 and NumEnemies == 1 then
            if
            PiercingShot:Exists() and IsOptionEnabled("穿刺射击") and PiercingShotEnemies >= GetOptionValue("穿刺射击") and
            Target:Debuff(Vulnerable) and
            Target:CanCast(PiercingShot)
            then
                Target:Cast(PiercingShot)
                return
            end
            if Windburst:Exists() and IsOptionEnabled("Windburst") and Target:CanCast(Windburst) then
                Target:Cast(Windburst)
                return
            end
            if
            AimedShot:Exists() and self.VulnerableRemains > AimedShot:CastTime() and
            Target:TimeToDie() > AimedShot:CastTime() and
            Target:CanCast(AimedShot)
            then
                Target:Cast(AimedShot)
                return
            end
            if MarkedShot:Exists() and Target:CanCast(MarkedShot) then
                Target:Cast(MarkedShot)
                return
            end
            if Sidewinders:Exists() and Target:CanCast(Sidewinders) then
                Target:Cast(Sidewinders)
                return
            end
            if ArcaneShot:Exists() and not Sidewinders:Exists() and Target:CanCast(ArcaneShot) then
                Target:Cast(ArcaneShot)
                return
            end
        end
    end
end
function Rotation:OutOfCombat()
    self.TrueshotCooldown = 0
    if not LoneWolf:Exists() then
        self:ManagePet()
    end
    if IsOptionEnabled("自动进入战斗") and Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        if Sidewinders:Exists() and Target:CanCast(Sidewinders) then
            Target:Cast(Sidewinders)
            return
        end
        if ArcaneShot:Exists() and not Sidewinders:Exists() and Target:CanCast(ArcaneShot) then
            Target:Cast(ArcaneShot)
            return
        end
    end
end
SetRotation(255, {})
local Rotation = Rotations[255]
function Rotation:Initialize()
    ArcaneTorrent = Spell(80483, false, false, true)
    RocketBarrage = Spell(69041, true, true, true)
    BloodFury = Spell(20572, false, false, true)
    Berserking = Spell(26297, false, false, true)
    GiftOfTheNaaru = Spell(59543, false, false, true)
    AMurderOfCrows = Spell(206505, false, true, true)
    AspectOfTheEagle = Spell(186289, false, false, true)
    AspectOfTheTurtle = Spell(186265, false, false, true)
    Butchery = Spell(212436, false, false, true)
    Caltrops = Spell(194277, false, true, true)
    CaltropsDebuff = Spell(194279)
    Carve = Spell(187708, false, false, true)
    DragonsfireGrenade = Spell(194855, true, true, true)
    Exhilaration = Spell(109304, false, false, true)
    ExplosiveTrap = Spell(191433, false, true, true)
    FeignDeath = Spell(5384, false, false, true)
    FlankingStrike = Spell(202800, true, true, true)
    FuryOfTheEagle = Spell(203415, false, false, true)
    Harpoon = Spell(190925, true, true, true)
    HatchetToss = Spell(193265, true, true, true)
    HeartOfThePhoenix = Spell(55709, false, false, true)
    Lacerate = Spell(185855, true, true, true)
    MendPet = Spell(982, false, false, true)
    MendPetBuff = Spell(136, false, false, true)
    MoknathalTactics = Spell(201081)
    MongooseBite = Spell(190928, true, true, true)
    MongooseFury = Spell(190931)
    Muzzle = Spell(187707, true, true, true)
    RangersNet = Spell(200108, true, true, true)
    RaptorStrike = Spell(186270, true, true, true)
    RangersNetSlow = Spell(206755)
    SerpentSting = Spell(87935)
    SerpentStingDebuff = Spell(118253)
    SnakeHunter = Spell(201078, false, false, true)
    SpittingCobra = Spell(194407, false, false, true)
    SteelTrap = Spell(162488, false, true, true)
    ThrowingAxes = Spell(200163, true, true, true)
    WayOfTheMokNathal = Spell(201082)
    WingClip = Spell(195645, true, true, true)
    CallPets = {
        Spell(883, false, false, true),
        Spell(83242, false, false, true),
        Spell(83243, false, false, true),
        Spell(83244, false, false, true),
        Spell(83245, false, false, true)
    }
    RevivePet = Spell(982, false, false, false)
    FrizzosFingertrap = Item(137043)
    AddPage("常规")
    AddPage("进攻")
    AddPage("防御")
    AddCommonOptions()
    AddPresetOption("常规", "Melee", nil, true)
    AddSection("常规", "辅助", "Yellow")
    AddNewOption(
    "常规",
    "自动召唤/复活宠物",
    222,
    true,
    { 3, 1, 25, 0.5 },
    { 1, 1, 5, 1 },
    "Automatically Whistle/Revive your Pet." ..
    C.TOOLTIP_VALUE_1 ..
    "How long would you like to wait before using Whistle when your pet is dismissed." ..
    C.TOOLTIP_VALUE_2 .. "Which pet you would like to auto summon?"
    )
    AddPresetOption("进攻")
    AddSection("进攻", "大技能", "Yellow")
    AddPresetOption("Cooldown", "夺命黑鸦", 1, { 2, 1, 30, 1 }, "Minimum Time To Die of the current target to use.")
    AddPresetOption("Cooldown", "雄鹰守护", 1)
    AddPresetOption("Cooldown", "龙焰手雷", 1)
    AddPresetOption("Cooldown", "雄鹰之怒", 1, { 1, 1, 10, 1 }, "Amount of units that need to be in front of us to use.")
    AddPresetOption("Cooldown", "毒蛇猎手", 1)
    AddPresetOption("Cooldown", "喷毒眼镜蛇", 1)
    AddSection("进攻", "能力", "Yellow")
    AddNewOption(
    "进攻",
    "铁蒺藜",
    232,
    true,
    { 2, "目标", "Target Standing" },
    { 1, 1, 10, 1 },
    "Use Caltrops." ..
    C.TOOLTIP_VALUE_1 ..
    "Choose preferred mode." ..
    C.TOOLTIP_SUBVALUE("目标") ..
    "Always use on the current target." ..
    C.TOOLTIP_SUBVALUE("Target Standing") ..
    "Always use on the current target. Target must be standing still." ..
    C.TOOLTIP_SUBVALUE("Centered") ..
    "Use centered on a cluster of enemies." ..
    C.TOOLTIP_SUBVALUE("Centered Standing") ..
    "Use centered on a cluster of enemies. Enemies must be standing still." ..
    C.TOOLTIP_VALUE_2 ..
    "Amount of enemies that must be in the spell effect to use."
    )
    AddNewOption(
    "进攻",
    "爆炸陷阱",
    220,
    true,
    { 1, 1, 10, 1 },
    nil,
    "Use Explosive Trap." .. C.TOOLTIP_VALUE .. "Minimum amount of units to use."
    )
    AddNewOption("进攻", "投掷手斧", 210, true, nil, nil, "Use Hatchet Toss while we are out of range.")
    AddNewOption(
    "进攻",
    "宠物输出处理",
    230,
    true,
    { 1, "Handle Assist", "Do Not Handle Assist" },
    nil,
    "Manage Pet." ..
    C.TOOLTIP_VALUE_1 ..
    "Enable this to automatically change between assist and passive mode depending if you have a target or not."
    )
    AddNewOption("进攻", "摔绊 | 游侠之网", 210, false, nil, nil, "Maintain Wing Clip or Ranger's Net on our current target.")
    AddPresetOption("防御")
    AddSection("防御", "能力", "Yellow")
    AddNewOption(
    "防御",
    "治疗宠物",
    222,
    true,
    { 35, 0, 100, 1 },
    { 85, 0, 100, 1 },
    "Enable use of Mend Pet when pet health fall under threshold." ..
    C.TOOLTIP_VALUE_1 .. "In combat threshold." .. C.TOOLTIP_VALUE_2 .. "Out of combat threshold."
    )
    AddSection("防御", "大技能", "Yellow")
    AddNewOption(
    "防御",
    "自动假死",
    220,
    true,
    { 10, 0, 100, 1 },
    nil,
    "Use Feign Death." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddNewOption(
    "防御",
    "灵龟守护",
    220,
    true,
    { 35, 0, 100, 1 },
    nil,
    "Use Aspect Of The Turtle." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddNewOption(
    "防御",
    "意气风发",
    220,
    true,
    { 35, 0, 100, 1 },
    nil,
    "Use Exhilaration." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    self.HeartOfThePhoenixAttempt = 0
end
function Rotation:Events()
    self.PetDismissed = 0
    EventFrame:RegisterForSelfCombatEvent(
    function(...)
        if select(12, ...) == 2641 then
            self.PetDismissed = GetTime() + 5
        end
    end,
    "SPELL_CAST_SUCCESS"
    )
    EventFrame:RegisterForCombatEvent(
    function(...)
        if select(15, ...) == _G["SPELL_FAILED_NOPATH"] then
            self.CommandFailTime = GetTime() + 2
        end
    end,
    "SPELL_CAST_FAILED"
    )
end
function Rotation:CanFlankingStrike()
    return not self.CommandFailTime or GetTime() > self.CommandFailTime
end
function Rotation:Pulse()
    if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() or Player:Buff(FeignDeath) then
        return
    end
    if Target:Exists() and BMPullTime() < 5 then
        self:Opening()
        return
    end
    if GetTime() < Rotation.SpamPrevention then
        return
    end
    Rotation.SpamPrevention = GetTime() + 0.05
    Target = Unit.Target
    local InCombat = Player:IsInCombat()
    if not InCombat then
        self:OutOfCombat()
        return
    end
    if InCombat then
        self:Defensives()
    end
    Target = Player:ReTarget(RaptorStrike, false) or Unit.Target
    if Target:Exists() then
        self:ManagePet()
        self:PlayerPetHandling()
        Rotations:RefreshUnitTables(Rotation.Identifier)
        self:Interrupts()
        if
        IsOptionEnabled("开怪技能") and
        (GetOptionValue("开怪技能") == "无条件使用" or (GetOptionValue("开怪技能") == "打BOSS使用" and Target:IsBoss()) or
        (GetOptionValue("开怪技能") == "CDs Only" and CooldownsAllowed())) and
        not OpenerEnded
        then
            self:Opener()
            return
        elseif CombatTime() > 10 then
            OpenerEnded = true
        end
        self:OffGCDAbilities()
        if Player:GlobalCooldown() == 0 then
            self:Combat()
        end
    end
end
function Rotation:Opening()
    Player:UsePotions("Agility")
    if
    IsOptionEnabled("抢先施放(需DBM插件)") and
    (GetOptionValue("抢先施放(需DBM插件)") == "无条件使用" or
    (GetOptionValue("抢先施放(需DBM插件)") == "打BOSS使用" and Target:IsBoss()))
    then
        if
        Harpoon:Exists() and BMPullTime() < GetSecondOptionValue("抢先施放(需DBM插件)") and Player:DistanceTo(Target) > 5 and
        Player:DistanceTo(Target) < 40 and
        Target:CanCast(Harpoon)
        then
            Player:StartAttack()
            Target:Cast(Harpoon)
            return
        end
    end
end
function Rotation:Opener()
    self.ChoosenOpener = nil
    self.ChoosenOpener = {
        [1] = { ExplosiveTrap, Target, true },
        [2] = { AMurderOfCrows, Target, AMurderOfCrows:Exists() },
        [3] = { SpittingCobra, Player, SpittingCobra:Exists() },
        [4] = { Lacerate, Target, true },
        [5] = { SteelTrap, Target, SteelTrap:Exists() },
        [6] = { Caltrops, Target, Caltrops:Exists() },
        [7] = { RaptorStrike, Target, WayOfTheMokNathal:Exists() },
        [8] = { RaptorStrike, Target, WayOfTheMokNathal:Exists() },
        [9] = { RaptorStrike, Target, WayOfTheMokNathal:Exists() },
        [10] = { "Trinkets" },
        [11] = { "Racials", { BloodFury, Berserking } },
        [12] = { MongooseBite, Target, MongooseBite:Charges() >= 1 },
        [13] = "Meme Opener"
    }
    if self.ChoosenOpener ~= nil then
        OpenerParser(self.ChoosenOpener)
    else
        Bug("Invalid Talents combination, Opener will not be used.")
        OpenerEnded = true
    end
end
function Rotation:Defensives()
    Player:UseHealingItem()
    if
    Exhilaration:Exists() and IsOptionEnabled("意气风发") and Player:HealthPercentage() <= GetOptionValue("意气风发") and
    Player:CanCast(Exhilaration)
    then
        Player:Cast(Exhilaration)
        return
    end
    if
    GiftOfTheNaaru:Exists() and IsOptionEnabled("纳鲁的赐福") and Player:HealthPercentage() <= GetOptionValue("纳鲁的赐福") and
    Player:CanCast(GiftOfTheNaaru)
    then
        Player:Cast(GiftOfTheNaaru)
        return
    end
    if
    AspectOfTheTurtle:Exists() and IsOptionEnabled("灵龟守护") and Player:HealthPercentage() <= GetOptionValue("灵龟守护") and
    Player:CanCast(AspectOfTheTurtle)
    then
        Player:Cast(AspectOfTheTurtle)
        return
    end
    if
    FeignDeath:Exists() and IsOptionEnabled("自动假死") and Player:HealthPercentage() <= GetOptionValue("自动假死") and
    Player:CanCast(FeignDeath)
    then
        Player:Cast(FeignDeath)
    end
end
function Rotation:Interrupts()
    Player:UseInterrupt(Muzzle, ArcaneTorrent)
end
function Rotation:OffGCDAbilities()
end
Rotation.TriedToSummonPet, Rotation.TriedToResurrectPet = 0, 0
function Rotation:ManagePet()
    if IsOptionEnabled("自动召唤/复活宠物") and (InstantWhistle or self.PetDismissed + GetOptionValue("自动召唤/复活宠物") < GetTime()) then
        InstantWhistle = false
        if
        not PlayerPet:Exists() and GetTime() > self.TriedToSummonPet and
        Player:CanCast(CallPets[GetSecondOptionValue("自动召唤/复活宠物")])
        then
            self.TriedToSummonPet = GetTime() + 5
            Player:Cast(CallPets[GetSecondOptionValue("自动召唤/复活宠物")])
            return
        end
        if
        not Player:IsMoving() and (not PlayerPet:Exists() or PlayerPet:IsDead()) and Player:CanCast(RevivePet) and
        GetTime() > self.TriedToResurrectPet
        then
            if Player:IsInCombat() and self.HeartOfThePhoenixAttempt < GetTime() then
                self.HeartOfThePhoenixAttempt = GetTime() + 485
                Player:Cast(HeartOfThePhoenix)
                return
            elseif self.HeartOfThePhoenixAttempt - 483 < GetTime() then
                self.TriedToResurrectPet = GetTime() + 3
                Player:Cast(MendPet)
                return
            end
        end
    end
    if
    PlayerPet:Exists() and IsOptionEnabled("治疗宠物") and Player:CanCast(MendPet) and not PlayerPet:Buff(MendPetBuff) and
    MendPet:TimeSinceCast() > 8
    then
        if
        (Player:IsInCombat() and PlayerPet:HealthPercentage() <= GetOptionValue("治疗宠物")) or
        (not Player:IsInCombat() and PlayerPet:HealthPercentage() <= GetSecondOptionValue("治疗宠物"))
        then
            PlayerPet:Cast(MendPet)
            return
        end
    end
end
Rotation.PetAssisting, Rotation.PetForceAssistDelay = false, 0
function Rotation:PlayerPetHandling()
    if IsOptionEnabled("宠物输出处理") and PlayerPet:Exists() then
        if GetOptionValue("宠物输出处理") == "Handle Assist" then
            if Target:Exists() and not self.PetAssisting then
                RunMacroText("/petattack target")
                PetAssistMode()
                self.PetAssisting = true
            elseif not Target:Exists() and self.PetAssisting then
                PetPassiveMode()
                self.PetAssisting = false
            end
            if
            Target:Exists() and self.PetAssisting and PlayerPetTarget and PlayerPetTarget:GUID() ~= Target:GUID() and
            self.PetForceAssistDelay < GetTime()
            then
                PetPassiveMode()
                PetAssistMode()
                RunMacroText("/petattack target")
                self.PetForceAssistDelay = GetTime() + 2
            end
        end
    end
end
function Rotation:CheckForSerpentString()
    for i = 1, #FrontUnits do
        if FrontUnits[i]:DebuffRemains(SerpentStingDebuff) < Player:GCD() then
            return true
        end
    end
    return false
end
function Rotation:UnitTables()
    FrontUnits = UseAOE() and Player:UnitsInFrontCone(7, 180) or {}
    ButcheryEnemies = UseAOE() and Butchery:Exists() and #Player:EnemiesWithinDistance(7, true) or 0
    NumEnemies = #FrontUnits
end
function Rotation:Combat()
    local GCDMax, Focus, FocusRegen = Player:GCD(), Player:Focus(), Player:FocusRegen()
    if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) and Player:IsFacing(Target) then
        Player:StartAttack()
        if IsOptionEnabled("摔绊 | 游侠之网") then
            if RangersNet:Exists() then
                if not Target:Debuff(RangersNet) and not Target:Debuff(RangersNetSlow) and Target:CanCast(RangersNet) then
                    Target:Cast(RangersNet)
                    return
                end
            else
                if not Target:Debuff(WingClip) and Target:CanCast(WingClip) then
                    Target:Cast(WingClip)
                    return
                end
            end
        end
        SnakeHunterEnabled = SnakeHunter:Exists() and CDOptionEnabled("毒蛇猎手")
        FuryOfTheEagleEnabled = FuryOfTheEagle:Exists() and CDOptionEnabled("雄鹰之怒")
        if
        FuryOfTheEagle:Exists() and FuryOfTheEagleEnabled and NumEnemies >= GetSecondOptionValue("雄鹰之怒") and
        Player:IsWithinCastRange(Target, MongooseBite) and
        (not WayOfTheMokNathal:Exists() or Player:BuffRemains(MoknathalTactics) > (GCDMax * (8 / 3)))
        then
            if
            Player:BuffCount(MongooseFury) >= 6 and Player:BuffRemains(MongooseFury) < 2 and
            Player:CanCast(FuryOfTheEagle)
            then
                Bug(
                "Stacks: " ..
                tostring(Player:BuffCount(MongooseFury)) ..
                " Remains: " .. tostring(math.floor(Player:BuffRemains(MongooseFury)))
                )
                Player:Cast(FuryOfTheEagle)
                return
            end
            if
            (not SnakeHunter:Exists() or not SnakeHunterEnabled or SnakeHunter:Cooldown() > 40) and
            (Player:BuffCount(MongooseFury) > 3 or Player:Buff(FuryOfTheEagle)) and
            Player:BuffRemains(MongooseFury) < 2 and
            Player:CanCast(FuryOfTheEagle)
            then
                Bug(
                "Stacks: " ..
                tostring(Player:BuffCount(MongooseFury)) ..
                " Remains: " .. tostring(math.floor(Player:BuffRemains(MongooseFury)))
                )
                Player:Cast(FuryOfTheEagle)
                return
            end
        end
        if WayOfTheMokNathal:Exists() then
            if
            RaptorStrike:Exists() and Player:BuffRemains(MoknathalTactics) < Player:GCD() * 2 and
            Target:CanCast(RaptorStrike)
            then
                Bug("Raptor Strike - Mok'Nathal Tactics 1")
                Target:Cast(RaptorStrike)
                return
            end
            if RaptorStrike:Exists() and Player:BuffCount(MoknathalTactics) < 2 and Target:CanCast(RaptorStrike) then
                Bug("Raptor Strike - Mok'Nathal Tactics 2")
                Target:Cast(RaptorStrike)
                return
            end
            if
            RaptorStrike:Exists() and Player:Buff(MoknathalTactics) and Player:BuffRemains(MoknathalTactics) < 5 and
            Player:Buff(MongooseFury) and
            Player:BuffRemains(MongooseFury) < 4 and
            Target:CanCast(RaptorStrike)
            then
                Bug("Raptor Strike - Mok'Nathal Tactics 3")
                Target:Cast(RaptorStrike)
                return
            end
        end
        if
        Player:IsWithinCastRange(Target, MongooseBite) and
        (Player:BuffCount(MoknathalTactics) >= 2 or not MoknathalTactics:Exists())
        then
            if CDOptionEnabled("进攻性种族技能") then
                if ArcaneTorrent:Exists() and Focus <= 30 and Player:CanCast(ArcaneTorrent) then
                    Player:Cast(ArcaneTorrent)
                    return
                end
                if Berserking:Exists() and Player:Buff(AspectOfTheEagle) and Player:CanCast(Berserking) then
                    Player:Cast(Berserking)
                end
                if BloodFury:Exists() and Player:Buff(AspectOfTheEagle) and Player:CanCast(BloodFury) then
                    Player:Cast(BloodFury)
                end
            end
            Player:UsePotions("Agility")
            Player:UseTrinkets()
            if
            SnakeHunterEnabled and CDOptionEnabled("毒蛇猎手") and MongooseBite:Charges() == 0 and
            Player:BuffRemains(MongooseFury) > 3 * GCDMax and
            Player:CanCast(SnakeHunter)
            then
                Player:Cast(SnakeHunter)
                return
            end
            if
            AspectOfTheEagle:Exists() and CDOptionEnabled("雄鹰守护") and
            (Player:BuffRemains(MongooseFury) <= 7 and Player:Buff(MongooseFury)) and
            FuryOfTheEagle:Cooldown() < Player:BuffRemains(MongooseFury) and
            Player:CanCast(AspectOfTheEagle)
            then
                Player:Cast(AspectOfTheEagle)
                return
            end
        end
        if not Player:Buff(MongooseFury) then
            if
            FlankingStrike:Exists() and PlayerPet:Exists() and PlayerPetTarget:Exists() and not PlayerPet:IsDead() and
            self:CanFlankingStrike() and
            PlayerPet:DistanceTo(PlayerPetTarget) - PlayerPetTarget:CombatReach() < 20 and
            PlayerPetTarget:CanCast(FlankingStrike)
            then
                PlayerPetTarget:Cast(FlankingStrike)
                return
            end
            if SpittingCobra:Exists() and CDOptionEnabled("喷毒眼镜蛇") and Player:CanCast(SpittingCobra) then
                Player:Cast(SpittingCobra)
                return
            end
            if Lacerate:Exists() and not Target:Debuff(Lacerate) and Target:CanCast(Lacerate) then
                Target:Cast(Lacerate)
                return
            end
            if
            RaptorStrike:Exists() and NumEnemies == 1 and SerpentSting:Exists() and
            not Target:Debuff(SerpentStingDebuff) and
            Target:CanCast(RaptorStrike)
            then
                Target:Cast(RaptorStrike)
                return
            end
            if SteelTrap:Exists() and not Target:IsMoving() and Target:CanCast(SteelTrap) then
                Target:Cast(SteelTrap)
                return
            end
            if
            AMurderOfCrows:Exists() and CDOptionEnabled("夺命黑鸦") and
            Target:TimeToDie() > GetSecondOptionValue("夺命黑鸦") and
            Target:CanCast(AMurderOfCrows)
            then
                Target:Cast(AMurderOfCrows)
                return
            end
            if DragonsfireGrenade:Exists() and CDOptionEnabled("龙焰手雷") and Target:CanCast(DragonsfireGrenade) then
                Target:Cast(DragonsfireGrenade)
                return
            end
            if
            ExplosiveTrap:Exists() and Player:IsWithinCastRange(Target, RaptorStrike) and not Player:IsMoving() and
            IsOptionEnabled("爆炸陷阱") and
            NumEnemies >= GetOptionValue("爆炸陷阱") and
            Target:CanCast(ExplosiveTrap)
            then
                Target:Cast(ExplosiveTrap)
                return
            end
            if
            Caltrops:Exists() and IsOptionEnabled("铁蒺藜") and not Target:Debuff(CaltropsDebuff) and
            Target:CanCast(Caltrops)
            then
                if Target:CastGroundSpell(Caltrops, "铁蒺藜", 6) then
                    return
                end
            end
            if
            Butchery:Exists() and FrizzosFingertrap:IsEquipped(11, 12) and Target:DebuffRemains(Lacerate) < 3.6 and
            Player:IsFacing(Target) and
            Player:IsWithinCastRange(Target, RaptorStrike) and
            Player:CanCast(Butchery)
            then
                Player:Cast(Butchery)
                return
            end
            if
            Carve:Exists() and FrizzosFingertrap:IsEquipped(11, 12) and Target:DebuffRemains(Lacerate) < 3.6 and
            Player:IsFacing(Target) and
            Player:IsWithinCastRange(Target, RaptorStrike) and
            Player:CanCast(Carve)
            then
                Player:Cast(Carve)
                return
            end
            if Lacerate:Exists() and Target:DebuffRemains(Lacerate) < 3.6 and Target:CanCast(Lacerate) then
                Target:Cast(Lacerate)
                return
            end
        end
        if NumEnemies >= 2 then
            if
            Butchery:Exists() and Player:IsFacing(Target) and Player:IsWithinCastRange(Target, RaptorStrike) and
            Player:CanCast(Butchery)
            then
                Player:Cast(Butchery)
                return
            end
            if
            Caltrops:Exists() and IsOptionEnabled("铁蒺藜") and not Target:Debuff(CaltropsDebuff) and
            Target:CanCast(Caltrops)
            then
                if Target:CastGroundSpell(Caltrops, "铁蒺藜", 6) then
                    return
                end
            end
            if
            ExplosiveTrap:Exists() and Player:IsWithinCastRange(Target, RaptorStrike) and not Player:IsMoving() and
            IsOptionEnabled("爆炸陷阱") and
            NumEnemies >= GetOptionValue("爆炸陷阱") and
            Target:CanCast(ExplosiveTrap)
            then
                Target:Cast(ExplosiveTrap)
                return
            end
            if
            Carve:Exists() and Player:IsFacing(Target) and Player:IsWithinCastRange(Target, RaptorStrike) and
            (SerpentSting:Exists() and not Target:Debuff(SerpentStingDebuff)) and
            Player:CanCast(Carve)
            then
                Player:Cast(Carve)
                return
            end
            if
            Carve:Exists() and Player:IsFacing(Target) and Player:IsWithinCastRange(Target, RaptorStrike) and
            NumEnemies > 5 and
            Player:CanCast(Carve)
            then
                Player:Cast(Carve)
                return
            end
        end
        if
        MongooseBite:Exists() and
        ((MongooseBite:Charges() >= 2 and MongooseBite:Recharge() < GCDMax * 2) or MongooseBite:Charges() == 3) and
        (not SnakeHunter:Exists() or not SnakeHunterEnabled or SnakeHunter:Cooldown() > 15 or
        SnakeHunter:Cooldown() < 7) and
        (not FuryOfTheEagle:Exists() or FuryOfTheEagle:Cooldown() > 20 or FuryOfTheEagle:Cooldown() < 13) and
        Target:CanCast(MongooseBite)
        then
            Bug(
            "Charges: " ..
            tostring(MongooseBite:Charges()) .. " Remains: " .. tostring(math.floor(MongooseBite:Recharge()))
            )
            Target:Cast(MongooseBite)
            return
        end
        if
        FlankingStrike:Exists() and
        ((Player:BuffRemains(MongooseFury) > (GCDMax * (MongooseBite:Charges() + 2))) and
        MongooseBite:Charges() <= 1) and
        not Player:Buff(AspectOfTheEagle) and
        PlayerPet:Exists() and
        PlayerPetTarget:Exists() and
        not PlayerPet:IsDead() and
        self:CanFlankingStrike() and
        PlayerPet:DistanceTo(PlayerPetTarget) - PlayerPetTarget:CombatReach() < 20 and
        PlayerPetTarget:CanCast(FlankingStrike)
        then
            PlayerPetTarget:Cast(FlankingStrike)
            return
        end
        if MongooseBite:Exists() and Player:BuffRemains(MongooseFury) > 0.25 and Target:CanCast(MongooseBite) then
            Bug(
            "Charges: " ..
            tostring(MongooseBite:Charges()) .. " Remains: " .. tostring(math.floor(MongooseBite:Recharge()))
            )
            Target:Cast(MongooseBite)
            return
        end
        if
        FlankingStrike:Exists() and PlayerPet:Exists() and PlayerPetTarget:Exists() and not PlayerPet:IsDead() and
        self:CanFlankingStrike() and
        PlayerPet:DistanceTo(PlayerPetTarget) - PlayerPetTarget:CombatReach() < 20 and
        PlayerPetTarget:CanCast(FlankingStrike)
        then
            PlayerPetTarget:Cast(FlankingStrike)
            return
        end
        if SpittingCobra:Exists() and CDOptionEnabled("喷毒眼镜蛇") and Player:CanCast(SpittingCobra) then
            Player:Cast(SpittingCobra)
            return
        end
        if
        Butchery:Exists() and FrizzosFingertrap:IsEquipped(11, 12) and Target:DebuffRemains(Lacerate) < 3.6 and
        Player:IsFacing(Target) and
        Player:IsWithinCastRange(Target, RaptorStrike) and
        Player:CanCast(Butchery)
        then
            Player:Cast(Butchery)
            return
        end
        if
        Carve:Exists() and FrizzosFingertrap:IsEquipped(11, 12) and Target:DebuffRemains(Lacerate) < 3.6 and
        Player:IsFacing(Target) and
        Player:IsWithinCastRange(Target, RaptorStrike) and
        Player:CanCast(Carve)
        then
            Player:Cast(Carve)
            return
        end
        if Lacerate:Exists() and Target:DebuffRemains(Lacerate) < 3.6 and Target:CanCast(Lacerate) then
            Target:Cast(Lacerate)
            return
        end
        if
        RaptorStrike:Exists() and NumEnemies == 1 and SerpentSting:Exists() and
        not Target:Debuff(SerpentStingDebuff) and
        Target:CanCast(RaptorStrike)
        then
            Target:Cast(RaptorStrike)
            return
        end
        if SteelTrap:Exists() and not Target:IsMoving() and Target:CanCast(SteelTrap) then
            Target:Cast(SteelTrap)
            return
        end
        if
        AMurderOfCrows:Exists() and CDOptionEnabled("夺命黑鸦") and Target:TimeToDie() > GetSecondOptionValue("夺命黑鸦") and
        Target:CanCast(AMurderOfCrows)
        then
            Target:Cast(AMurderOfCrows)
            return
        end
        if DragonsfireGrenade:Exists() and CDOptionEnabled("龙焰手雷") and Target:CanCast(DragonsfireGrenade) then
            Target:Cast(DragonsfireGrenade)
            return
        end
        if
        ExplosiveTrap:Exists() and Player:IsWithinCastRange(Target, RaptorStrike) and not Player:IsMoving() and
        IsOptionEnabled("爆炸陷阱") and
        NumEnemies >= GetOptionValue("爆炸陷阱") and
        Target:CanCast(ExplosiveTrap)
        then
            Target:Cast(ExplosiveTrap)
            return
        end
        if
        Caltrops:Exists() and IsOptionEnabled("铁蒺藜") and not Target:Debuff(CaltropsDebuff) and
        Target:CanCast(Caltrops)
        then
            if Target:CastGroundSpell(Caltrops, "铁蒺藜", 6) then
                return
            end
        end
        if
        Carve:Exists() and NumEnemies > 1 and SerpentSting:Exists() and not Target:Debuff(SerpentStingDebuff) and
        Player:IsFacing(Target) and
        Player:IsWithinCastRange(Target, RaptorStrike) and
        Player:CanCast(Carve)
        then
            Player:Cast(Carve)
            return
        end
        if ThrowingAxes:Exists() and Target:CanCast(ThrowingAxes) then
            Target:Cast(ThrowingAxes)
            return
        end
        if
        Carve:Exists() and NumEnemies > 2 and Player:IsFacing(Target) and
        Player:IsWithinCastRange(Target, RaptorStrike) and
        Player:CanCast(Carve)
        then
            Player:Cast(Carve)
            return
        end
        if
        RaptorStrike:Exists() and (WayOfTheMokNathal:Exists() and Player:BuffRemains(MoknathalTactics) < GCDMax * 4) and
        Target:CanCast(RaptorStrike)
        then
            Bug("Raptor Strike - Filler Way of the Mok'Nathal")
            Target:Cast(RaptorStrike)
            return
        end
        if RaptorStrike:Exists() and Focus > ((25 - Player:FocusRegen() * GCDMax) + 55) and Target:CanCast(RaptorStrike) then
            Bug("Raptor Strike - Filler High Focus")
            Target:Cast(RaptorStrike)
            return
        end
        if HatchetToss:Exists() and IsOptionEnabled("投掷手斧") and Target:CanCast(HatchetToss) then
            if Player:DistanceTo(Target) >= 5 and Player:DistanceTo(Target) < 30 then
                Target:Cast(HatchetToss)
                return
            end
        end
    end
end
function Rotation:OutOfCombat()
    self:ManagePet()
    if IsOptionEnabled("自动进入战斗") and Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        if
        Harpoon:Exists() and Player:DistanceTo(Target) > 5 and Player:DistanceTo(Target) < 40 and
        Target:CanCast(Harpoon)
        then
            Target:Cast(Harpoon)
            return
        end
    end
end
SetRotation(62, {})
local Rotation = Rotations[62]
function Rotation:Initialize()
    ArcaneTorrent = Spell(28730, false, false, true)
    Berserking = Spell(26297, false, false, true)
    BloodFury = Spell(33702, false, false, true)
    GiftOfTheNaaru = Spell(59548, false, false, true)
    ArcaneBarrage = Spell(44425, true, true, true)
    ArcaneBlast = Spell(30451, true, true, false)
    ArcaneExplosion = Spell(1449, false, false, true)
    ArcaneFamiliar = Spell(205022, false, false, true)
    ArcaneFamiliarBuff = Spell(210126)
    ArcaneMissiles = Spell(5143, true, true, false)
    ArcaneMissilesBuff = Spell(79683)
    ArcaneOrb = Spell(153626, false, false, true)
    ArcanePower = Spell(12042, false, false, true)
    ChargedUp = Spell(205032, false, false, true)
    ColdSnap = Spell(11958, false, false, true)
    Counterspell = Spell(2139, false, true, true)
    Evocation = Spell(12051, false, false, false)
    GreaterInvisibility = Spell(110959, false, false, true)
    GreaterInvisibilityBuff = Spell(110960)
    IceBlock = Spell(45438, false, false, true)
    IceFloes = Spell(108839, false, false, true)
    IncantersFlow = Spell(1463, false, false, false)
    IncantersFlowBuff = Spell(116267)
    IncantersFlowDirection = 0
    MarkOfAluneth = Spell(224968, true, true, false)
    MirrorImage = Spell(55342, false, false, true)
    NetherTempest = Spell(114923, false, true, true)
    Overpowered = Spell(155147)
    Polymorph = Spell(118, false, true, false)
    PresenceOfMind = Spell(205025, false, false, true)
    PrismaticBarrier = Spell(235450, false, false, true)
    Quickening = Spell(198923)
    QuickeningBuff = Spell(198924)
    RuneOfPower = Spell(116011, false, false, false)
    RuneOfPowerBuff = Spell(116014)
    UnstableMagic = Spell(157976)
    Supernova = Spell(157980, false, true, true)
    MysticKiltOfTheRuneMaster = Item(132451)
    RhoninsAssaultingArmwraps = Item(132413)
    RhoninsAssaultingArmwrapsBuff = Spell(208080)
    AddPage("常规")
    AddPage("进攻")
    AddPage("防御")
    AddCommonOptions()
    AddPresetOption("常规", "Caster", nil, false)
    AddSection("常规", "辅助", "Yellow")
    AddOption("常规", "浮冰", true)
    AddSection("常规", "爆发阶段设置", "Yellow")
    AddNewOption(
    "常规",
    "爆发模式",
    230,
    true,
    { 1, "自动", "Manual" },
    nil,
    "Enters Burn phase based on conditions set by SimCraft. If you leave this enabled, it will always use Auto Burn. To use Manual Burn, disable this option and read the tooltip for Manual Burn below carefully."
    )
    AddNewOption(
    "常规",
    "唤醒",
    232,
    true,
    { 2, "Mana Threshold", "After AP & RoP" },
    { 25, 10, 90, 1 },
    "Use Evocation when we reach a certain Mana Threshold or after Using Cooldowns." ..
    C.TOOLTIP_VALUE_1 ..
    C.TOOLTIP_SUBVALUE("Mana Threshold", true) ..
    "Only use under Mana Threshold." ..
    C.TOOLTIP_SUBVALUE("After AP & RoP") ..
    "Use after Arcane Power and Rune of Power." ..
    C.TOOLTIP_VALUE_2 .. "Mana percentage to use with Mana Threshold option."
    )
    AddNewOption(
    "常规",
    "强制爆发",
    210,
    false,
    nil,
    nil,
    "Enters Forced Burn phase." ..
    C.TOOLTIP_HINT(
    "Usefull at the end of a fight where you want to burn regardless of cooldowns or Mana. Toggle itself off while out of combat."
    )
    )
    AddNewOption(
    "常规",
    "手动爆发",
    233,
    false,
    { 2, "Evocation After", "正常" },
    { 1, "自动", "Manual" },
    "Enable Manual burn phase as soon as possible." ..
    C.TOOLTIP_VALUE_1 ..
    "When do we want to use Evocation with Manual Burn." ..
    C.TOOLTIP_SUBVALUE("Evocation After") ..
    "Use Evocation when we disable Manual Burn after using Arcane Power and Rune of Power." ..
    C.TOOLTIP_SUBVALUE("正常") ..
    "Use Evocation normally using Evocation conditions." ..
    C.TOOLTIP_VALUE_2 ..
    "Define if you want to Manual Burn to automatically disable itself after evocation." ..
    C.TOOLTIP_SUBVALUE("自动") ..
    "Automatically toggle off Manual Burn when we use Evocation." ..
    C.TOOLTIP_SUBVALUE("Manual") ..
    "Do not automatically turn off Manual Burn." ..
    C.TOOLTIP_HINT(
    'Disable "Auto Burn" and make a macro to enable burn phases. \n|cffFF0044/soap toggleoption Manual Burn'
    )
    )
    AddPresetOption("进攻")
    AddSection("进攻", "大技能", "Yellow")
    AddPresetOption("Cooldown", "奥术强化")
    AddPresetOption("Cooldown", "镜像")
    AddPresetOption("Cooldown", "气定神闲", 1)
    AddPresetOption("Cooldown", "能量符文")
    AddSection("进攻", "能力", "Yellow")
    AddNewOption(
    "进攻",
    "魔爆术",
    222,
    true,
    { 2, 1, 10, 1 },
    { 3, 1, 10, 1 },
    "Use Arcane Explosion." ..
    C.TOOLTIP_VALUE_1 ..
    "Amount of units that needs to be within 14y around player to use." ..
    C.TOOLTIP_VALUE_2 ..
    "Amount of units that needs to be within 14y around player to use with the Unstable Magic talent during Burn phase."
    )
    AddNewOption(
    "进攻",
    "奥术宝珠",
    220,
    true,
    { 1, 1, 10, 1 },
    nil,
    "Use Arcane Orb." ..
    C.TOOLTIP_VALUE .. "Amount of units that needs to be in 40y corridor in front of us to use."
    )
    AddNewOption(
    "进攻",
    "精力充沛",
    230,
    true,
    { 1, "无条件使用", "Not Out Of Combat", "Opener Only" },
    nil,
    "Use Charged Up." ..
    C.TOOLTIP_VALUE ..
    C.TOOLTIP_SUBVALUE("无条件使用", true) ..
    "Use Charged Up when we have 0 Arcane Charges even when Out Of Combat." ..
    C.TOOLTIP_SUBVALUE("Not Out Of Combat", true) ..
    "Only use Cahrged Up we are at 0 charges and are in Combat." ..
    C.TOOLTIP_SUBVALUE("Opener Only", true) .. "Only use in the opener."
    )
    AddNewOption(
    "进攻",
    "虚空风暴",
    220,
    true,
    { 1, 1, 10, 1 },
    nil,
    "Use Nether Tempest." ..
    C.TOOLTIP_VALUE .. "Amount of units that needs to be within 10y around our target to use."
    )
    AddNewOption(
    "进攻",
    "超级新星",
    220,
    true,
    { 1, 1, 10, 1 },
    nil,
    "Use Supernova." .. C.TOOLTIP_VALUE .. "Amount of units that needs to be within 8y around our target to use."
    )
    AddPresetOption("防御")
    AddSection("防御", "能力", "Yellow")
    AddNewOption(
    "防御",
    "强化隐形术",
    220,
    true,
    { 20, 1, 100, 1 },
    nil,
    "Use Greater Invisibility." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddNewOption(
    "防御",
    "棱光屏障",
    220,
    true,
    { 80, 1, 100, 1 },
    nil,
    "Use Ice Barrier." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddNewOption(
    "防御",
    "寒冰屏障",
    220,
    true,
    { 30, 1, 100, 1 },
    nil,
    "Use Ice Block." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    local Frame = CreateFrame("Frame")
    Frame:RegisterEvent("PLAYER_DAMAGE_DONE_MODS")
    local function IncantersFlowTracker(self, ...)
        IncantersFlowBuffCount = Player:BuffCount(IncantersFlowBuff)
        if IncantersFlowBuffCount == 1 then
            IncantersFlowDirection = 1
        elseif IncantersFlowBuffCount == 5 then
            IncantersFlowDirection = 2
        end
    end
    Frame:SetScript("OnEvent", IncantersFlowTracker)
    ISCL = {[ArcaneBlast:ID()] = "Arcane Blast" }
    AddOutput("阶段:")
    SetOutput("阶段:", "|cff00A4E6Conserve")
    AddOutput("手动爆发准备:")
    SetOutput("手动爆发准备:", "还没好")
end
function Rotation:Events()
end
function Rotation:Pulse()
    if Player:Channeling(Evocation) and Player:PowerPercentage() >= 95 then
        SpellStopCasting()
    end
    if
    not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() or
    Player:Channeling(ArcaneMissiles) or
    (Player:Channeling(Evocation) and Player:PowerPercentage() < 95)
    then
        return
    end
    SetOutput("阶段:", BurnPhaseEnabled and "|cffE60000Burning" or "|cff00A4E6Conserve")
    BurnReady = ArcanePower:Exists() and not ArcanePower:IsOnCooldown() or false
    SetOutput("手动爆发准备:", BurnReady and "|cff00E60FReady" or "还没好")
    if Target:Exists() and BMPullTime() < 5 then
        self:Opening()
        return
    end
    if GetTime() < Rotation.SpamPrevention then
        return
    end
    Rotation.SpamPrevention = GetTime() + 0.05
    Target = Unit.Target
    local InCombat = Player:IsInCombat()
    if not InCombat then
        self:OutOfCombat()
        return
    end
    if InCombat then
        self:Defensives()
    end
    Target = Player:ReTarget(ArcaneBlast, false) or Unit.Target
    if Target:Exists() then
        Rotations:RefreshUnitTables(Rotation.Identifier)
        self:Interrupts()
        if
        IsOptionEnabled("开怪技能") and
        (GetOptionValue("开怪技能") == "无条件使用" or (GetOptionValue("开怪技能") == "打BOSS使用" and Target:IsBoss()) or
        (GetOptionValue("开怪技能") == "CDs Only" and CooldownsAllowed())) and
        not OpenerEnded
        then
            self:Opener()
            return
        elseif CombatTime() > 10 then
            OpenerEnded = true
        end
        self:OffGCDAbilities()
        if Player:GlobalCooldown() == 0 and Player:IsReady() then
            self:Combat()
        end
    end
end
function Rotation:Opening()
    Player:UsePotions("智力药水", GetSecondOptionValue("抢先使用药水"))
    if
    IsOptionEnabled("抢先施放(需DBM插件)") and
    (GetOptionValue("抢先施放(需DBM插件)") == "无条件使用" or
    (GetOptionValue("抢先施放(需DBM插件)") == "打BOSS使用" and Target:IsBoss()))
    then
        OpenerSpell = MarkOfAluneth:Exists() and MarkOfAluneth or ArcaneBlast
        if ChargedUp:Exists() and IsOptionEnabled("精力充沛") and Player:ArcaneCharges() ~= 4 and Player:CanCast(ChargedUp) then
            Player:Cast(ChargedUp)
        end
        if GetOptionValue("Pre-Pull") == "启用" then
            if
            MirrorImage:Exists() and BMPullTime() < GetSecondOptionValue("抢先施放(需DBM插件)") + Player:GCD() and
            CDOptionEnabled("镜像") and
            Player:CanCast(MirrorImage)
            then
                Bug("镜像")
                Player:Cast(MirrorImage)
                return
            end
            if
            RuneOfPower:Exists() and BMPullTime() < GetSecondOptionValue("抢先施放(需DBM插件)") + RuneOfPower:CastTime() and
            CDOptionEnabled("能量符文") and
            Player:CanCast(RuneOfPower)
            then
                Bug("Rune of Power")
                Player:Cast(RuneOfPower)
                return
            end
        end
        if
        PrismaticBarrier:Exists() and BMPullTime() > GetSecondOptionValue("抢先施放(需DBM插件)") + 3 and BMPullTime() < 5 and
        not Player:Buff(PrismaticBarrier) and
        Player:CanCast(PrismaticBarrier)
        then
            Bug("Pre-Pull - Prismatic Barrier")
            Player:Cast(PrismaticBarrier)
            return
        end
        if OpenerSpell:Exists() and BMPullTime() < GetSecondOptionValue("抢先施放(需DBM插件)") and Target:CanCast(OpenerSpell) then
            Bug("Pre-Pull - " .. OpenerSpell:Name())
            Target:Cast(OpenerSpell)
            return
        end
    end
end
function Rotation:Opener()
    self.ChoosenOpener = nil
    if Player:GlobalCooldown() == 0 then
        if self.ChoosenOpener ~= nil then
            OpenerParser(self.ChoosenOpener)
        else
            Bug("Invalid Talents combination, Opener will not be used.")
            OpenerEnded = true
        end
    end
end
function Rotation:Defensives()
    Player:UseHealingItem()
    if
    IceBlock:Exists() and IsOptionEnabled("寒冰屏障") and Player:HealthPercentage() <= GetOptionValue("寒冰屏障") and
    not Player:Buff(GreaterInvisibilityBuff) and
    Player:CanCast(IceBlock)
    then
        SpellStopCasting()
        Player:Cast(IceBlock)
        return
    end
    if
    PrismaticBarrier:Exists() and IsOptionEnabled("棱光屏障") and Player:HealthPercentage() <= GetOptionValue("棱光屏障") and
    not Player:Buff(PrismaticBarrier) and
    Player:CanCast(PrismaticBarrier)
    then
        Player:Cast(PrismaticBarrier)
        return
    end
    if
    GreaterInvisibility:Exists() and IsOptionEnabled("强化隐形术") and
    Player:HealthPercentage() <= GetOptionValue("强化隐形术") and
    not Player:Buff(IceBlock) and
    Player:CanCast(GreaterInvisibility)
    then
        SpellStopCasting()
        Player:Cast(GreaterInvisibility)
        return
    end
    if
    GiftOfTheNaaru:Exists() and IsOptionEnabled("纳鲁的赐福") and Player:HealthPercentage() <= GetOptionValue("纳鲁的赐福") and
    Player:CanCast(GiftOfTheNaaru)
    then
        Player:Cast(GiftOfTheNaaru)
        return
    end
end
function Rotation:Interrupts()
    Player:UseInterrupt(Counterspell, ArcaneTorrent)
end
function Rotation:OffGCDAbilities()
    if
    IsOptionEnabled("浮冰") and IceFloes:Exists() and Player:IsMoving() and not Player:Buff(IceFloes) and
    Player:CanCast(IceFloes) and
    IceFloes:TimeSinceCast() > 1
    then
        Player:Cast(IceFloes)
        IceFloes.LastCastTime = GetTime()
    end
end
function Rotation:Arcane_Cooldowns()
    if Player:IsWithinCastRange(Target, ArcaneBlast) then
        Player:UseTrinkets()
        if Player:Buff(ArcanePower) then
            Player:UsePotions("智力药水")
        end
        if CDOptionEnabled("进攻性种族技能") then
            if BloodFury:Exists() and Player:CanCast(BloodFury) then
                Player:Cast(BloodFury)
            end
            if Berserking:Exists() and Player:CanCast(Berserking) then
                Player:Cast(Berserking)
            end
            if ArcaneTorrent:Exists() and ManaPct < 95 and Player:CanCast(ArcaneTorrent) then
                Player:Cast(ArcaneTorrent)
            end
        end
        if
        RuneOfPower:Exists() and CDOptionEnabled("能量符文") and RuneOfPower:TimeSinceCast() >= 5 and
        not Player:Buff(RuneOfPowerBuff) and
        Player:Standing() >= 1 and
        Player:CanCast(RuneOfPower)
        then
            Bug("Rune Of Power - After Evocation")
            Player:Cast(RuneOfPower)
            RuneOfPower.LastCastTime = GetTime()
            return "Cast"
        end
        if ShouldArcanePower and Player:CanCast(ArcanePower) then
            if
            RuneOfPower:Exists() and CDOptionEnabled("能量符文") and RuneOfPower:TimeSinceCast() >= 5 and
            not Player:Buff(RuneOfPowerBuff) and
            Player:Standing() >= 1 and
            Player:CanCast(RuneOfPower)
            then
                Bug("Rune Of Power - Before Arcane Power")
                Player:Cast(RuneOfPower)
                RuneOfPower.LastCastTime = GetTime()
                return "Cast"
            end
            Player:Cast(ArcanePower)
            return "Cast"
        end
        if MirrorImage:Exists() and CDOptionEnabled("镜像") and Player:CanCast(MirrorImage) then
            Player:Cast(MirrorImage)
            return "Cast"
        end
    end
end
function Rotation:Arcane_Conserve()
    if ArcaneMissiles:Exists() and Player:BuffCount(ArcaneMissilesBuff) == 3 and Target:CanCast(ArcaneMissiles) then
        Target:Cast(ArcaneMissiles)
        return "Cast"
    end
    if ArcaneBlast:Exists() and ManaPct > 99 and Target:CanCast(ArcaneBlast) then
        Target:Cast(ArcaneBlast)
        return "Cast"
    end
    if
    NetherTempest:Exists() and
    (Target:DebuffRemains(NetherTempest) < 3.6 or
    (RuneOfPower:Exists() and CDOptionEnabled("能量符文") and RuneOfPower:Cooldown() < Player:GCD() and
    Target:DebuffRemains(NetherTempest) < 10)) and
    Target:CanCast(NetherTempest)
    then
        Target:Cast(NetherTempest)
        return "Cast"
    end
    if
    ArcaneBlast:Exists() and Player:Buff(RhoninsAssaultingArmwrapsBuff) and RhoninsAssaultingArmwraps:IsEquipped(9) and
    Target:CanCast(ArcaneBlast)
    then
        Target:Cast(ArcaneBlast)
        return "Cast"
    end
    if ArcaneMissiles:Exists() and Player:Buff(ArcaneMissilesBuff) and Target:CanCast(ArcaneMissiles) then
        Target:Cast(ArcaneMissiles)
        return "Cast"
    end
    if
    Supernova:Exists() and IsOptionEnabled("超级新星") and #TargetEnemies_8y >= GetOptionValue("超级新星") and ManaPct < 100 and
    Target:CanCast(Supernova)
    then
        Target:Cast(Supernova)
        return "Cast"
    end
    if
    ArcaneExplosion:Exists() and IsOptionEnabled("魔爆术") and NumEnemies >= GetOptionValue("魔爆术") and ManaPct >= 82 and
    MysticKiltOfTheRuneMaster:IsEquipped(7) and
    Player:CanCast(ArcaneExplosion)
    then
        Player:Cast(ArcaneExplosion)
        return "Cast"
    end
    if
    ArcaneBlast:Exists() and ManaPct >= 82 and MysticKiltOfTheRuneMaster:IsEquipped(7) and
    Target:CanCast(ArcaneBlast)
    then
        Target:Cast(ArcaneBlast)
        return "Cast"
    end
    if
    ArcaneBarrage:Exists() and not BurnPhaseEnabled and ManaPct < 100 and ArcaneCharges >= 4 and
    Target:CanCast(ArcaneBarrage)
    then
        Target:Cast(ArcaneBarrage)
        return "Cast"
    end
    if ArcaneBlast:Exists() and Target:CanCast(ArcaneBlast) then
        Target:Cast(ArcaneBlast)
        return "Cast"
    end
end
function Rotation:Arcane_RoP()
    if ArcaneMissiles:Exists() and Player:BuffCount(ArcaneMissilesBuff) == 3 and Target:CanCast(ArcaneMissiles) then
        Target:Cast(ArcaneMissiles)
        return "Cast"
    end
    if
    ArcaneExplosion:Exists() and IsOptionEnabled("魔爆术") and NumEnemies >= GetOptionValue("魔爆术") and
    Player:BuffRemains(QuickeningBuff) < ArcaneBlast:CastTime() and
    Player:CanCast(ArcaneExplosion)
    then
        Player:Cast(ArcaneExplosion)
        return "Cast"
    end
    if
    NetherTempest:Exists() and IsOptionEnabled("虚空风暴") and ArcaneCharges >= 4 and
    #TargetEnemies_10y >= GetOptionValue("虚空风暴") and
    NetherTempest:TimeSinceCast() >= 10 and
    Target:CanCast(NetherTempest)
    then
        NetherTempest.LastCastTime = GetTime()
        Target:Cast(NetherTempest)
        return "Cast"
    end
    if ArcaneMissiles:Exists() and Player:ArcaneCharges() == 4 and Target:CanCast(ArcaneMissiles) then
        Target:Cast(ArcaneMissiles)
        return "Cast"
    end
    if
    ArcaneExplosion:Exists() and IsOptionEnabled("魔爆术") and NumEnemies >= GetOptionValue("魔爆术") and
    Player:CanCast(ArcaneExplosion)
    then
        Player:Cast(ArcaneExplosion)
        return "Cast"
    end
    if ArcaneBlast:Exists() and ManaPct > 45 and Target:CanCast(ArcaneBlast) then
        Target:Cast(ArcaneBlast)
        return "Cast"
    end
    if ArcaneBarrage:Exists() and not BurnPhaseEnabled and Target:CanCast(ArcaneBarrage) then
        Target:Cast(ArcaneBarrage)
        return "Cast"
    end
end
function Rotation:Arcane_Build()
    if
    ChargedUp:Exists() and IsOptionEnabled("精力充沛") and GetOptionValue("精力充沛") ~= "Opener Only" and
    Player:ArcaneCharges() == 0 and
    Player:CanCast(ChargedUp)
    then
        Player:Cast(ChargedUp)
    end
    if ArcaneMissiles:Exists() and Player:BuffCount(ArcaneMissilesBuff) == 3 and Target:CanCast(ArcaneMissiles) then
        Target:Cast(ArcaneMissiles)
        return "Cast"
    end
    if
    ArcaneOrb:Exists() and IsOptionEnabled("奥术宝珠") and ArcaneOrbUnits >= GetOptionValue("奥术宝珠") and
    Player:CanCast(ArcaneOrb)
    then
        Player:Cast(ArcaneOrb)
        return "Cast"
    end
    if
    ArcaneExplosion:Exists() and IsOptionEnabled("魔爆术") and NumEnemies >= GetOptionValue("魔爆术") and
    Player:CanCast(ArcaneExplosion)
    then
        Player:Cast(ArcaneExplosion)
        return "Cast"
    end
    if ArcaneBlast:Exists() and Target:CanCast(ArcaneBlast) then
        Target:Cast(ArcaneBlast)
        return "Cast"
    end
end
function Rotation:Arcane_Burn()
    if Evocation:Exists() and Player:CanCast(Evocation) then
        if
        (GetOptionValue("唤醒") == "Mana Threshold" and Player:PowerPercentage() <= GetSecondOptionValue("唤醒")) or
        (GetOptionValue("唤醒") == "After AP & RoP" and (not RuneOfPower:Exists() or RuneOfPower:IsOnCooldown()) and
        ArcanePower:IsOnCooldown() and
        not Player:Buff(RuneOfPowerBuff) and
        not Player:Buff(ArcanePower))
        then
            if GetSecondOptionValue("手动爆发") == "自动" then
                Bug("Disabling Manual Burn")
                SetSetting("手动爆发_Checked", false)
                UpdateOptions()
            end
            BurnPhaseEnabled = false
            Player:Cast(Evocation)
            return
        end
    end
    if self:Arcane_Cooldowns() then
        Bug("大技能")
        return
    end
    if ArcaneMissiles:Exists() and Player:BuffCount(ArcaneMissilesBuff) == 3 and Target:CanCast(ArcaneMissiles) then
        Target:Cast(ArcaneMissiles)
        return "Cast"
    end
    if
    NetherTempest:Exists() and IsOptionEnabled("虚空风暴") and ArcaneCharges >= 4 and
    #TargetEnemies_10y >= GetOptionValue("虚空风暴") and
    NetherTempest:TimeSinceCast() >= 10 and
    Target:CanCast(NetherTempest)
    then
        NetherTempest.LastCastTime = GetTime()
        Target:Cast(NetherTempest)
        return "Cast"
    end
    if
    PresenceOfMind:Exists() and CDOptionEnabled("气定神闲") and Player:BuffRemains(ArcanePower) > Player:GCD() * 2 and
    Player:CanCast(ArcanePower)
    then
        Player:Cast(ArcanePower)
        return "Cast"
    end
    if ArcaneMissiles:Exists() and Player:BuffCount(ArcaneMissilesBuff) > 1 and Target:CanCast(ArcaneMissiles) then
        Target:Cast(ArcaneMissiles)
        return "Cast"
    end
    if
    ArcaneBlast:Exists() and
    (Player:Buff(PresenceOfMind) or Player:BuffRemains(ArcanePower) > ArcaneBlast:CastTime()) and
    Target:CanCast(ArcaneBlast)
    then
        Target:Cast(ArcaneBlast)
        return "Cast"
    end
    if
    Supernova:Exists() and IsOptionEnabled("超级新星") and #TargetEnemies_8y >= GetOptionValue("超级新星") and ManaPct < 100 and
    Target:CanCast(Supernova)
    then
        Target:Cast(Supernova)
        return "Cast"
    end
    if
    ArcaneMissiles:Exists() and Player:Buff(ArcaneMissilesBuff) and (Player:Buff(ArcanePower) or ManaPct > 10) and
    Target:CanCast(ArcaneMissiles)
    then
        Target:Cast(ArcaneMissiles)
        return "Cast"
    end
    if
    ArcaneExplosion:Exists() and IsOptionEnabled("魔爆术") and
    ((not UnstableMagic:Exists() and NumEnemies >= GetOptionValue("魔爆术")) or
    (UnstableMagic:Exists() and NumEnemies >= GetSecondOptionValue("魔爆术"))) and
    Player:CanCast(ArcaneExplosion)
    then
        Player:Cast(ArcaneExplosion)
        return "Cast"
    end
    if ArcaneBlast:Exists() and Target:CanCast(ArcaneBlast) then
        Target:Cast(ArcaneBlast)
        return "Cast"
    end
end
function Rotation:Arcane_Init_Burn()
    if not BurnPhaseEnabled and not ArcanePower:IsOnCooldown() and ShouldArcanePower then
        Bug("Enabling Burn Phase")
        BurnPhaseEnabled = true
        UpdateOptions()
    end
    if MarkOfAluneth:Exists() and Target:CanCast(MarkOfAluneth) then
        Target:Cast(MarkOfAluneth)
        return "Cast"
    end
    if
    NetherTempest:Exists() and IsOptionEnabled("虚空风暴") and #TargetEnemies_10y >= GetOptionValue("虚空风暴") and
    NetherTempest:TimeSinceCast() > 2 and
    (Target:DebuffRemains(NetherTempest) < 10 and
    (MarkOfAluneth:TimeSinceCast() < Player:GCD() + 0.2 or
    (RuneOfPower:Exists() and RuneOfPower:Cooldown() < Player:GCD()))) and
    Target:CanCast(NetherTempest)
    then
        NetherTempest.LastCastTime = GetTime()
        Target:Cast(NetherTempest)
        return "Cast"
    end
    if
    RuneOfPower:Exists() and CDOptionEnabled("能量符文") and GetSecondOptionValue("能量符文") == "任何时候" and
    RuneOfPower:TimeSinceCast() >= 5 and
    not Player:Buff(RuneOfPowerBuff) and
    Player:Standing() >= 1 and
    Player:CanCast(RuneOfPower)
    then
        Bug("Rune Of Power - Anytime")
        Player:Cast(RuneOfPower)
        RuneOfPower.LastCastTime = GetTime()
        return "Cast"
    end
end
function Rotation:UnitTables()
    ArcaneOrbUnits = UseAOE() and ArcaneOrb:Exists() and #Player:UnitsInFrontRectangle(40, 5) or 0
    Enemies_14y = UseAOE() and Player:EnemiesWithinDistance(14, true) or {}
    TargetEnemies_10y = UseAOE() and Target:EnemiesWithinDistance(10) or {}
    TargetEnemies_8y = UseAOE() and Target:FilterEnemiesByDistance(TargetEnemies_10y, 8, false) or {}
    NumEnemies = #Enemies_14y
end
function Rotation:Combat()
    ArcaneCharges, ManaPct =     Player:Casting(ArcaneBlast) and Player:ArcaneCharges() + 1 or Player:ArcaneCharges(),
    Player:ManaPercentage()
    if ArcaneFamiliar:Exists() and not Player:Buff(ArcaneFamiliarBuff) and Player:CanCast(ArcaneFamiliar) then
        Player:Cast(ArcaneFamiliar)
        return
    end
    if Target:Exists() and Player:CanAttack(Target) then
        ShouldArcanePower = ArcanePower:Exists() and CDOptionEnabled("奥术强化")
        ShouldEvocation =         GetOptionValue("爆发模式") == "Manual" and IsOptionEnabled("手动爆发") and
        GetOptionValue("手动爆发") == "Evocation After" and
        true or
        ShouldEvocation
        if Evocation:Exists() and not IsOptionEnabled("手动爆发") and ShouldEvocation and Player:CanCast(Evocation) then
            if
            (not RuneOfPower:Exists() or RuneOfPower:IsOnCooldown()) and ArcanePower:IsOnCooldown() and
            not Player:Buff(RuneOfPowerBuff) and
            not Player:Buff(ArcanePower)
            then
                BurnPhaseEnabled = false
                Player:Cast(Evocation)
                return
            end
        end
        if MarkOfAluneth:Exists() and ArcanePower:Cooldown() > 20 and Target:CanCast(MarkOfAluneth) then
            Target:Cast(MarkOfAluneth)
            return
        end
        if
        ShouldArcanePower and
        (ArcaneCharges < 4 and
        (ManaPct >= 70 or
        (ArcanePower:Cooldown() < 3 or
        (RuneOfPower:Exists() and RuneOfPower:Recharge() < ArcanePower:Recharge()))) or
        (ArcaneCharges < 3 and ManaPct >= 50)) or
        ArcaneCharges < 2
        then
            if self:Arcane_Build() then
                Bug("Build")
                return
            end
        end
        if (GetOptionValue("爆发模式") == "自动" or (GetOptionValue("爆发模式") == "Manual" and IsOptionEnabled("手动爆发"))) then
            if
            not Player:Buff(ArcanePower) and ArcaneCharges == 4 and
            (not RuneOfPower:Exists() or
            (ArcanePower:Cooldown() <= Player:GCD() + RuneOfPower:CastTime() or
            RuneOfPower:Recharge() < ArcanePower:Cooldown()))
            then
                if self:Arcane_Init_Burn() then
                    Bug("Init Burn")
                    return
                end
            end
            if BurnPhaseEnabled then
                if self:Arcane_Burn() then
                    Bug("Burn")
                    return
                end
            end
        end
        if IsOptionEnabled("强制爆发") then
            if self:Arcane_Burn() then
                Bug("Forced Burn")
                return
            end
        end
        if Player:Buff(RuneOfPowerBuff) then
            if self:Arcane_RoP() then
                Bug("RoP")
                return
            end
        end
        if self:Arcane_Conserve() then
            Bug("Conserve")
            return
        end
    end
end
function Rotation:OutOfCombat()
    if BurnPhaseEnabled then
        Bug("Disabling Burn Phase")
        BurnPhaseEnabled = false
    end
    if IsOptionEnabled("强制爆发") then
        Bug("Disabling Force Burn")
        SetSetting("强制爆发_Checked", false)
    end
    if ShouldEvocation then
        ShouldEvocation = nil
    end
    if ArcaneFamiliar:Exists() and not Player:Buff(ArcaneFamiliarBuff) and Player:CanCast(ArcaneFamiliar) then
        Player:Cast(ArcaneFamiliar)
        return
    end
    if
    ChargedUp:Exists() and IsOptionEnabled("精力充沛") and GetOptionValue("精力充沛") == "无条件使用" and
    Player:ArcaneCharges() == 0 and
    Player:CanCast(ChargedUp)
    then
        Player:Cast(ChargedUp)
    end
    if IsOptionEnabled("自动进入战斗") and Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        local EngageSpell = MarkOfAluneth:Exists() and not MarkOfAluneth:IsOnCooldown() and MarkOfAluneth or ArcaneBlast
        if EngageSpell:Exists() and Target:CanCast(EngageSpell) then
            Target:Cast(EngageSpell)
            return
        end
    end
end
SetRotation(63, {})
local Rotation = Rotations[63]
function Rotation:Initialize()
    ArcaneTorrent = Spell(28730, false, false, true)
    Berserking = Spell(26297, false, false, true)
    BloodFury = Spell(33702, false, false, true)
    GiftOfTheNaaru = Spell(59548, false, false, true)
    AlextraszasFury = Spell(235870)
    BlastWave = Spell(157981, false, true, true)
    BlazingBarrier = Spell(235313, false, false, true)
    Cinderstorm = Spell(198929, false, false, false)
    Combustion = Spell(190319, false, false, true)
    Counterspell = Spell(2139, false, true, true)
    DragonsBreath = Spell(31661, true, false, true)
    Fireball = Spell(133, true, true, false)
    FireBlast = Spell(108853, true, true, true)
    FireStarter = Spell(205026)
    FlameOn = Spell(205029, false, false, true)
    Flamestrike = Spell(2120, false, true, false)
    FlamestrikeInstant = Spell(2120, false, true, true)
    Invisibility = Spell(66, false, false, true)
    HeatingUp = Spell(48107, false, true, true)
    HotStreak = Spell(48108)
    IceBlock = Spell(45438, false, false, true)
    IncantersFlow = Spell(1463, false, false, false)
    IncantersFlowBuff = Spell(116267, false, false, false)
    Kindling = Spell(155148, false, true, true)
    LivingBomb = Spell(44457, false, true, true)
    Meteor = Spell(153561, false, true, true)
    MirrorImage = Spell(55342, false, false, true)
    PhoenixsFlames = Spell(194466, true, true, true)
    PhoenixReborn = Spell(215773)
    PyreticIncantation = Spell(194329)
    Pyroblast = Spell(11366, true, true, false)
    PyroblastInstant = Spell(11366, true, true, true)
    RuneOfPower = Spell(116011, false, false, false)
    RuneOfPowerBuff = Spell(116014, false, false, true)
    Scorch = Spell(2948, true, true, false)
    UnstableMagic = Spell(157976, false, false, true)
    KoralonsBurningTouch = Item(132454)
    MarqueeBindingsOfTheSunKing = Item(132406)
    KaelthassUltimateAbility = Spell(209455)
    DarcklisDragonfireDiadem = Item(132863)
    WrigglingSinew = Item(139326)
    AddPage("常规")
    AddPage("进攻")
    AddPage("防御")
    AddCommonOptions()
    AddPresetOption("常规", "Caster", nil, true)
    AddSection("常规", "辅助", "Yellow")
    AddNewOption("常规", "移动时施放灼烧", 210, true, nil, nil, "Use Scorch when we are moving.")
    AddNewOption(
    "常规",
    "强制爆发",
    210,
    false,
    nil,
    nil,
    "Enters Forced Burn phase." ..
    C.TOOLTIP_HINT(
    "Usefull at the end of a fight where you want to burn regardless of cooldowns. Toggle itself off while out of combat."
    )
    )
    AddPresetOption("进攻")
    AddNewOption(
    "进攻",
    "抢先使用蠕动肌腱",
    220,
    true,
    { 5, 0, 10, 0.1 },
    nil,
    "Use Wriggling Sinew in the opener." .. C.TOOLTIP_VALUE .. "Use when countdown time is lower than this value."
    )
    AddSection("进攻", "大技能", "Yellow")
    AddPresetOption("Cooldown", "镜像")
    AddPresetOption(
    "Cooldown",
    "能量符文",
    nil,
    { 1, "正常", "Pair With Meteor" },
    C.TOOLTIP_SUBVALUE("正常", true) ..
    "Use the second charge normally whenever it is ready." ..
    C.TOOLTIP_SUBVALUE("Pair With Meteor") .. "Use the second charge with Meteor."
    )
    AddPresetOption("Cooldown", "燃烧")
    AddSection("进攻", "能力", "Yellow")
    AddNewOption(
    "进攻",
    "冲击波",
    220,
    true,
    { 1, 1, 10, 1 },
    nil,
    "Use Blast Wave." ..
    C.TOOLTIP_VALUE ..
    "Define minimum number of units that needs to be in 8 yards around our target to use Blast Wave."
    )
    AddNewOption(
    "进攻",
    "燃烬风暴",
    222,
    true,
    { 1, 1, 10, 1 },
    { 1, 1, 10, 1 },
    "Use Cinderstorm." ..
    C.TOOLTIP_VALUE_1 ..
    "Define minimum number of units that needs to be in front of you for Cinderstorm." ..
    C.TOOLTIP_VALUE_2 ..
    "Define minimum number of units that needs to be in front of you for Cinderstorm when at optimal range (between 27 and 29 yard)."
    )
    AddNewOption(
    "进攻",
    "Cinderstorm Range Check",
    210,
    true,
    nil,
    nil,
    "Cinderstorm uses a range calculation for your current target to hit with most possible cinders. You can disable this option when you are condfident in hitting with Cinderstorm yourself, but you have to be aware of when rotation casts Cinderstorm."
    )
    AddNewOption(
    "进攻",
    "燃烬风暴 炽烈之咒",
    220,
    true,
    { 2, 1, 5, 1 },
    nil,
    "Use Cinderstorm only if we have less than Value stacks of Pyretic Incantation." ..
    C.TOOLTIP_VALUE .. "Pyretic Incantation stacks threshold."
    )
    AddNewOption(
    "进攻",
    "龙息术",
    222,
    true,
    { 5, 1, 10, 1 },
    { 1, 1, 10, 1 },
    "Use Dragon's Breath." ..
    C.TOOLTIP_VALUE_1 ..
    "Define minimum number of units that needs to be in spell effect to use Dragon's Breath without Darckli's Dragonfire Diadem." ..
    C.TOOLTIP_VALUE_2 ..
    "Define minimum number of units that needs to be in spell effect to use Dragon's Breath with Darckli's Dragonfire Diadem." ..
    C.TOOLTIP_HINT(
    "If Dragon's Breath is enabled, it will be used on as few as one unit as long as Alextrasza's Fury talent is selected."
    )
    )
    AddNewOption(
    "进攻",
    "对其余目标施放纵火者",
    210,
    true,
    { 1, 1, 10, 1 },
    nil,
    "Use Fireball on other units above 90% Health." .. C.TOOLTIP_HINT("Requires Fire Starter talent.")
    )
    AddNewOption(
    "进攻",
    "烈焰风暴",
    232,
    true,
    { 2, "目标", "Target Standing", "Centered", "Centered Standing" },
    { 5, 1, 25, 1 },
    "Use Flamestrike." ..
    C.TOOLTIP_VALUE_1 ..
    "Choose preferred mode." ..
    C.TOOLTIP_SUBVALUE("目标") ..
    "Always use on the current target." ..
    C.TOOLTIP_SUBVALUE("Target Standing") ..
    "Always use on the current target. Target must be standing still." ..
    C.TOOLTIP_SUBVALUE("Centered") ..
    "Use centered on a cluster of enemies." ..
    C.TOOLTIP_SUBVALUE("Centered Standing") ..
    "Use centered on a cluster of enemies. Enemies must be standing still." ..
    C.TOOLTIP_VALUE_2 ..
    "Amount of enemies that must be in the spell effect to use."
    )
    AddNewOption(
    "进攻",
    "持续施放烈焰风暴",
    232,
    true,
    { 2, "目标", "Target Standing", "Centered", "Centered Standing" },
    { 3, 1, 25, 1 },
    "Use Flamestrike." ..
    C.TOOLTIP_VALUE_1 ..
    "Choose preferred mode." ..
    C.TOOLTIP_SUBVALUE("目标") ..
    "Always use on the current target." ..
    C.TOOLTIP_SUBVALUE("Target Standing") ..
    "Always use on the current target. Target must be standing still." ..
    C.TOOLTIP_SUBVALUE("Centered") ..
    "Use centered on a cluster of enemies." ..
    C.TOOLTIP_SUBVALUE("Centered Standing") ..
    "Use centered on a cluster of enemies. Enemies must be standing still." ..
    C.TOOLTIP_VALUE_2 ..
    "Amount of enemies that must be in the spell effect to use."
    )
    AddNewOption(
    "进攻",
    "燃烧搭配烈焰风暴",
    210,
    true,
    nil,
    nil,
    "Allow using Flamestrike trought it's usual handlers during Combustion."
    )
    AddNewOption(
    "进攻",
    "Flamestrike Blacklist Ignore",
    210,
    true,
    nil,
    nil,
    "When Flamestrike silently failed to be cast on a unit, the unit will be blacklisted for a short amount of time. This option disables this check. If rotation behaves awkwardly you may need to disable this option. This may happen if it trys to cast Flamestrike on a position where it can't be cast."
    )
    AddNewOption("进攻", "火焰冲击", 210, true, nil, nil, "Use Fire Blast.")
    AddNewOption(
    "进攻",
    "活动炸弹",
    222,
    false,
    { 1, 1, 10, 1 },
    { 3, 0, 25, 0.1 },
    "Use Living Bomb." ..
    C.TOOLTIP_VALUE_1 ..
    "Amount of enemies that must be in the spell effect to use." ..
    C.TOOLTIP_VALUE_2 .. "Minimum health (in million) to apply."
    )
    AddNewOption(
    "进攻",
    "流星",
    232,
    true,
    { 2, "目标", "Target Standing", "Centered", "Centered Standing" },
    { 2, 1, 25, 1 },
    "Use Meteor." ..
    C.TOOLTIP_VALUE_1 ..
    "Choose preferred mode." ..
    C.TOOLTIP_SUBVALUE("目标") ..
    "Always use on the current target." ..
    C.TOOLTIP_SUBVALUE("Target Standing") ..
    "Always use on the current target. Target must be standing still." ..
    C.TOOLTIP_SUBVALUE("Centered") ..
    "Use centered on a cluster of enemies." ..
    C.TOOLTIP_SUBVALUE("Centered Standing") ..
    "Use centered on a cluster of enemies. Enemies must be standing still." ..
    C.TOOLTIP_VALUE_2 ..
    "Amount of enemies that must be in the spell effect to use."
    )
    AddNewOption(
    "进攻",
    "流星冷却设置",
    130,
    false,
    { 2, "无条件使用", "大技能用法" },
    nil,
    "Meteor Cooldowns options" ..
    C.TOOLTIP_VALUE ..
    C.TOOLTIP_SUBVALUE("无条件使用", true) ..
    "Will use the ability even if CDs are disabled." ..
    C.TOOLTIP_SUBVALUE("大技能用法") .. "Will only use the ability if CDs are enabled."
    )
    AddNewOption(
    "进攻",
    "凤凰烈焰",
    220,
    true,
    { 2, 1, 10, 1 },
    nil,
    "Use Phoenix's Flames." ..
    C.TOOLTIP_VALUE ..
    "Define minimum number of units that needs to be in 8 yards around our target to use Phoenix's Flames with 1.75 charges or more." ..
    C.TOOLTIP_HINT(
    "Phoenix's Flames will still be used with any amount of units when we have 2.65 charges. It will also systematically be used during Rune of Power or Combustion."
    )
    )
    AddNewOption(
    "进攻",
    "科拉隆的燃烧之触",
    210,
    true,
    nil,
    nil,
    "Use Scorch when the target is below 30% hp when wearing the Koralon's Burning Touch legendary." ..
    C.TOOLTIP_HINT("Should be disabled when using the Kindling talent.")
    )
    AddNewOption(
    "进攻",
    "Marquee Bindings",
    230,
    true,
    { 1, "无条件使用", "Outside Combustion" },
    nil,
    "Use hardcasted Pyroblast with the Kaelthass Ultimate Ability buff."
    )
    AddPresetOption("防御")
    AddSection("防御", "能力", "Yellow")
    AddNewOption(
    "防御",
    "烈焰护体",
    222,
    true,
    { 80, 1, 100, 1 },
    { 40, 1, 100, 1 },
    "Use Blazing Barrier." ..
    C.TOOLTIP_VALUE_1 ..
    "Health threshold to use out of Combustion." ..
    C.TOOLTIP_VALUE_2 .. "Health threshold to use during Combustion."
    )
    AddNewOption(
    "防御",
    "寒冰屏障",
    220,
    true,
    { 30, 1, 100, 1 },
    nil,
    "Use Ice Block." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddNewOption(
    "防御",
    "隐形术",
    220,
    true,
    { 20, 1, 100, 1 },
    nil,
    "Use Invisibility." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    local Frame = CreateFrame("Frame")
    Frame:RegisterEvent("PLAYER_DAMAGE_DONE_MODS")
    local function IncantersFlowTracker(self, ...)
        IncantersFlowBuffCount = Player:BuffCount(IncantersFlowBuff)
        if IncantersFlowBuffCount == 1 then
            IncantersFlowDirection = 1
        elseif IncantersFlowBuffCount == 5 then
            IncantersFlowDirection = 2
        end
    end
    Frame:SetScript("OnEvent", IncantersFlowTracker)
    AddOutput("目标距离:")
    SetOutput("目标距离:", "无目标")
    ISCL = {[Pyroblast:ID()] = "Pyroblast", [RuneOfPower:ID()] = "能量符文" }
end
function Rotation:Events()
end
function Rotation:Pulse()
    if Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
        return
    end
    if Target:Exists() then
        local PlayerDistance = math.floor(Player:DistanceTo(Target) * 10) / 10
        local TargetReach = Target:CombatReach() and Target:CombatReach() > 0 and Target:CombatReach() or 1
        local SuitedDistance = 41.25 / TargetReach < 27 and 41.25 / TargetReach or 27
        local DistanceColor = PlayerDistance > SuitedDistance and PlayerDistance < 29 and "|cff00FF00" or "|cffFF0000"
        SetOutput("目标距离:", DistanceColor .. PlayerDistance .. "|r")
    else
        SetOutput("目标距离:", "无目标")
    end
    if Target:Exists() and BMPullTime() < 5 then
        self:Opening()
        return
    end
    if GetTime() < Rotation.SpamPrevention then
        return
    end
    Rotation.SpamPrevention = GetTime() + 0.05
    Target = Unit.Target
    local InCombat = Player:IsInCombat()
    if not InCombat then
        self:OutOfCombat()
        return
    end
    if InCombat then
        self:Defensives()
    end
    Target = Player:ReTarget(Fireball, false) or Unit.Target
    if Target:Exists() then
        Rotations:RefreshUnitTables(Rotation.Identifier)
        self:Interrupts()
        if
        IsOptionEnabled("开怪技能") and
        (GetOptionValue("开怪技能") == "无条件使用" or (GetOptionValue("开怪技能") == "打BOSS使用" and Target:IsBoss()) or
        (GetOptionValue("开怪技能") == "CDs Only" and CooldownsAllowed())) and
        not OpenerEnded
        then
            self:Opener()
            return
        elseif CombatTime() > 10 then
            OpenerEnded = true
        end
        self:OffGCDAbilities()
        if Player:GlobalCooldown() == 0 and Player:IsReady() then
            self:Combat()
        end
    end
end
function Rotation:Opening()
    if IsOptionEnabled("抢先使用蠕动肌腱") and BMPullTime() < GetOptionValue("抢先使用蠕动肌腱") then
        if WrigglingSinew:IsEquipped(13) and Item(13):IsUsableInventory() then
            Item(13):UseInventory()
        elseif WrigglingSinew:IsEquipped(14) and Item(14):IsUsableInventory() then
            Item(14):UseInventory()
        end
    end
    Player:UsePotions("智力药水", GetSecondOptionValue("抢先使用药水"))
    if
    IsOptionEnabled("抢先施放(需DBM插件)") and
    (GetOptionValue("抢先施放(需DBM插件)") == "无条件使用" or
    (GetOptionValue("抢先施放(需DBM插件)") == "打BOSS使用" and Target:IsBoss()))
    then
        if Pyroblast:Exists() and BMPullTime() < GetSecondOptionValue("抢先施放(需DBM插件)") and Target:CanCast(Pyroblast) then
            Target:Cast(Pyroblast)
            return
        end
    end
end
function Rotation:Opener()
    self.ChoosenOpener = nil
    if Kindling:Exists() and RuneOfPower:Exists() and PhoenixsFlames:Exists() then
        self.ChoosenOpener = {
            [1] = { RuneOfPower, Player, not Player:Buff(RuneOfPowerBuff) },
            [2] = { Combustion, Player, true },
            [3] = { "Trinkets" },
            [4] = { "Racials", { BloodFury, Berserking } },
            [5] = { FireBlast, Target, not Player:Buff(HeatingUp) },
            [6] = { PhoenixsFlames, Target, not Player:Buff(HotStreak) },
            [7] = "Kindling Opener"
        }
    end
    if Cinderstorm:Exists() and RuneOfPower:Exists() and PhoenixsFlames:Exists() then
        if Player:Casting(Cinderstorm) and Player:CastedPercent() >= 65 then
            Player:Cast(Combustion)
        end
        self.ChoosenOpener = {
            [1] = { RuneOfPower, Player, not Player:Buff(RuneOfPowerBuff) },
            [2] = { "Trinkets" },
            [3] = { "Racials", { BloodFury, Berserking } },
            [4] = { Cinderstorm, Player, true },
            [5] = { FireBlast, Target, not Player:Buff(HotStreak) },
            [6] = { PhoenixsFlames, Target, not Player:Buff(HotStreak) },
            [7] = "Cinderstorm Opener"
        }
    end
    if Player:GlobalCooldown() == 0 then
        if self.ChoosenOpener ~= nil then
            OpenerParser(self.ChoosenOpener)
        else
            Bug("Invalid Talents combination, Opener will not be used.")
            OpenerEnded = true
        end
    end
end
function Rotation:Defensives()
    Player:UseHealingItem()
    if
    IceBlock:Exists() and IsOptionEnabled("寒冰屏障") and Player:HealthPercentage() <= GetOptionValue("寒冰屏障") and
    not Player:Buff(Invisibility) and
    Player:CanCast(IceBlock)
    then
        SpellStopCasting()
        Player:Cast(IceBlock)
        return
    end
    if
    BlazingBarrier:Exists() and IsOptionEnabled("烈焰护体") and
    ((not Player:Buff(Combustion) and Player:HealthPercentage() <= GetOptionValue("烈焰护体")) or
    (Player:Buff(Combustion) and Player:HealthPercentage() <= GetSecondOptionValue("烈焰护体"))) and
    not Player:Buff(BlazingBarrier) and
    Player:CanCast(BlazingBarrier)
    then
        Player:Cast(BlazingBarrier)
        return
    end
    if
    Invisibility:Exists() and IsOptionEnabled("隐形术") and Player:HealthPercentage() <= GetOptionValue("隐形术") and
    not Player:Buff(IceBlock) and
    Player:CanCast(Invisibility)
    then
        SpellStopCasting()
        Player:Cast(Invisibility)
        return
    end
    if
    GiftOfTheNaaru:Exists() and IsOptionEnabled("纳鲁的赐福") and Player:HealthPercentage() <= GetOptionValue("纳鲁的赐福") and
    Player:CanCast(GiftOfTheNaaru)
    then
        Player:Cast(GiftOfTheNaaru)
        return
    end
end
function Rotation:Interrupts()
    Player:UseInterrupt(Counterspell, ArcaneTorrent)
end
function Rotation:OffGCDAbilities()
    if
    Combustion:Exists() and CDOptionEnabled("燃烧") and CombatTime() < 5 and
    (Player:Buff(RuneOfPowerBuff) or RuneOfPower:TimeSinceCast() < 2) and
    not Player:Buff(HeatingUp) and
    not Player:Buff(HotStreak) and
    Player:CanCast(Combustion)
    then
        if Fireball:Exists() and Target:CanCast(Fireball) then
            Bug("Fireball to get Heating Up")
            Target:Cast(Fireball)
            return
        end
        if Combustion:Exists() and (Player:Casting(Scorch) or Player:Casting(Fireball)) and Player:CastedPercent() >= 25 then
            Bug("Combutstion Scorch to get Heating Up")
            Player:Cast(Combustion)
        end
    end
    if
    Combustion:Exists() and CDOptionEnabled("燃烧") and
    (not (RuneOfPower:Exists() and CDOptionEnabled("能量符文")) or Player:Buff(RuneOfPowerBuff)) and
    (Player:Casting(Scorch) or Player:Casting(Fireball) or
    (Cinderstorm:Exists() and Player:Casting(Cinderstorm))) and
    Player:CastedPercent() >= 25 and
    QueueCombustion and
    Player:CanCast(Combustion)
    then
        QueueCombustion = false
        Player:Cast(Combustion)
        return
    end
    if not Player:Buff(Combustion) and not IsOptionEnabled("强制爆发") then
        if
        FireBlast:Exists() and (not UsedOpener or CombatTime() > 4) and
        (Player:Casting(Fireball) or Player:Casting(Scorch)) and
        ((Player:Buff(HeatingUp) and Player:CastedPercent() >= 50 and Player:CastedPercent() < 92) or
        CombatTime() < 1) and
        FireBlast:TimeSinceCast() > 1 and
        (Combustion:Cooldown() > 25 or
        ((FireBlast:Charges() >= 1 and FireBlast:Recharge() < 1.5) or FireBlast:Charges() >= 2)) and
        Target:CanCast(FireBlast)
        then
            Bug("Fire Blast - Without Combustion.")
            Target:Cast(FireBlast)
            return
        end
    else
        if
        FireBlast:Exists() and Player:Buff(HeatingUp) and not Player:Casting(Scorch) and
        FireBlast:TimeSinceCast() > 0.5 and
        Target:CanCast(FireBlast)
        then
            Bug("Fire Blast - With Combustion.")
            Target:Cast(FireBlast)
            return
        end
    end
end
function Rotation:ActiveTalents()
    if
    UseAOE() and BlastWave:Exists() and IsOptionEnabled("冲击波") and #Enemies_8y >= GetOptionValue("冲击波") and
    ((not Player:Buff(Combustion)) or
    (Player:Buff(Combustion) and FireBlast:Charges() < 1 and PhoenixsFlames:Charges() < 1)) and
    Target:CanCast(BlastWave)
    then
        Target:Cast(BlastWave)
        return
    end
    if
    UseAOE() and (CooldownsAllowed() or GetOptionValue("Meteor Cooldowns Only") == "无条件使用") and Meteor:Exists() and
    IsOptionEnabled("流星") and
    (Combustion:Cooldown() > 40 or Player:Buff(RuneOfPower)) and
    Target:CanCast(Meteor)
    then
        if Target:CastGroundSpell(Meteor, "流星", 8) then
            return
        end
    end
    if
    UseAOE() and Cinderstorm:Exists() and IsOptionEnabled("燃烬风暴") and
    Player:BuffCount(PyreticIncantation) <= PyreticIncantationStacks
    then
        local TargetReach = Target:CombatReach() and Target:CombatReach() > 0 and Target:CombatReach() or 1
        local SuitedDistance = 41.25 / TargetReach < 27 and 41.25 / TargetReach or 27
        if
        (CombatTime() < 5 or
        (not IsOptionEnabled("Cinderstorm Range Check") or
        (Player:DistanceTo(Target) > SuitedDistance and Player:DistanceTo(Target) < 29))) and
        (CinderstormEnemies >= GetOptionValue("燃烬风暴") or CinderstormEnemies >= GetSecondOptionValue("燃烬风暴")) and
        (Combustion:Cooldown() > 12 or not Combustion:IsOnCooldown()) and
        Player:CanCast(Cinderstorm)
        then
            if CombustionEnabled and QueueCombustion == false and not Combustion:IsOnCooldown() then
                QueueCombustion = true
            end
            Bug("Cinderstorm - High Priority")
            Player:Cast(Cinderstorm)
            return
        end
    end
    if
    UseAOE() and DragonsBreath:Exists() and IsOptionEnabled("龙息术") and
    ((DarcklisDragonfireDiadem:IsEquipped(1) and DragonsBreathUnits >= GetSecondOptionValue("龙息术")) or
    (not DarcklisDragonfireDiadem:IsEquipped(1) and DragonsBreathUnits >= GetOptionValue("龙息术")) or
    (DragonsBreathUnits >= 1 and AlextraszasFury:Exists() and not Player:Buff(HotStreak))) and
    Player:CanCast(DragonsBreath)
    then
        Player:Cast(DragonsBreath)
        return
    end
    if
    UseAOE() and LivingBomb:Exists() and IsOptionEnabled("活动炸弹") and #Enemies_10y >= GetOptionValue("活动炸弹") and
    not Player:Buff(Combustion) and
    (Target:IsDummy() or Target:Health() >= GetSecondOptionValue("活动炸弹") * 1000000) and
    Target:CanCast(LivingBomb)
    then
        Target:Cast(LivingBomb)
        return
    end
end
function Rotation:UnitTables()
    Enemies = UseAOE() and FireStarter:Exists() and Player:EnemiesWithinDistance(40) or {}
    DragonsBreathUnits =     UseAOE() and #Player:UnitsInFrontCone(DarcklisDragonfireDiadem:IsEquipped(1) and 35 or 10, 140) or 0
    CinderstormEnemies = UseAOE() and #Player:UnitsInFrontRectangle(32, 5) or 0
    Enemies_10y = UseAOE() and Target:EnemiesWithinDistance(10) or {}
    Enemies_8y = UseAOE() and Target:FilterEnemiesByDistance(Enemies_10y, 8, true) or {}
    NumEnemies = #Enemies_10y
    BlastWaveEnemies = #Enemies_8y
end
function Rotation:Combat()
    if Target:Exists() and Player:CanAttack(Target) then
        PyreticIncantationStacks = IsOptionEnabled("燃烬风暴 炽烈之咒") and GetOptionValue("燃烬风暴 炽烈之咒") or 5
        UseKoralonsBurningTouch = IsOptionEnabled("科拉隆的燃烧之触") and KoralonsBurningTouch:IsEquipped(6)
        RuneOfPowerEnabled = RuneOfPower:Exists() and IsOptionEnabled("能量符文") or false
        CombustionEnabled = Combustion:Exists() and CDOptionEnabled("燃烧") or false
        if Player:IsWithinCastRange(Target, Fireball) and (Player:Moving() == 0 or RuneOfPower:Exists()) then
            if CDOptionEnabled("进攻性种族技能") then
                if BloodFury:Exists() and Player:CanCast(BloodFury) then
                    Player:Cast(BloodFury)
                end
                if Berserking:Exists() and Player:CanCast(Berserking) then
                    Player:Cast(Berserking)
                end
            end
            if not WrigglingSinew:IsEquipped(13, 14) then
                Player:UseTrinkets()
            else
                if
                GetOptionValue("饰品: 1 | 2") == "无条件使用" or
                (CooldownsAllowed() and GetOptionValue("饰品: 1 | 2") == "Cooldowns Only")
                then
                    if WrigglingSinew:IsEquipped(13) then
                        if Item(13):IsUsableInventory() and CombustionEnabled and Combustion:Cooldown() < 7 then
                            Item(13):UseInventory()
                        end
                    elseif Player:Buff(Combustion) and Item(13):IsUsableInventory() then
                        Item(13):UseInventory()
                    end
                end
                if
                GetSecondOptionValue("饰品: 1 | 2") == "无条件使用" or
                (CooldownsAllowed() and GetOptionValue("饰品: 1 | 2") == "Cooldowns Only")
                then
                    if WrigglingSinew:IsEquipped(14) then
                        if Item(14):IsUsableInventory() and CombustionEnabled and Combustion:Cooldown() < 7 then
                            Item(14):UseInventory()
                        end
                    elseif Player:Buff(Combustion) and Item(14):IsUsableInventory() then
                        Item(14):UseInventory()
                    end
                end
            end
            MeteorReady =             UseAOE() and (CooldownsAllowed() or GetOptionValue("Meteor Cooldowns Only") == "无条件使用") and
            Meteor:Exists() and
            IsOptionEnabled("流星") and
            Combustion:Cooldown() > 35 and
            Meteor:Cooldown() < 2.5
            if
            RuneOfPowerEnabled and not Player:Buff(Combustion) and not Player:Buff(RuneOfPowerBuff) and
            ((RuneOfPower:FractionalCharges() >= 1.8 and GetOptionValue("能量符文") == "无条件使用") or
            (not Kindling:Exists() and Combustion:Cooldown() > 40) or
            (Kindling:Exists() and Combustion:Cooldown() > 60) or
            IsOptionEnabled("强制爆发")) and
            (not Meteor:Exists() or GetSecondOptionValue("能量符文") == "正常" or
            (GetSecondOptionValue("能量符文") == "Pair With Meteor" and MeteorReady) or
            RuneOfPower:FractionalCharges() > 1.5 and Combustion:Cooldown() > RuneOfPower:Recharge() and
            Combustion:Cooldown() > 10) and
            Player:CanCast(RuneOfPower)
            then
                Player:Cast(RuneOfPower)
                return
            end
            if
            MirrorImage:Exists() and CDOptionEnabled("镜像") and not Player:Buff(Combustion) and
            Player:CanCast(MirrorImage)
            then
                Player:Cast(MirrorImage)
                return
            end
        end
        if
        (CDOptionEnabled("燃烧") and
        ((RuneOfPowerEnabled and Combustion:Cooldown() <= RuneOfPower:CastTime()) or
        (not RuneOfPowerEnabled and not Combustion:IsOnCooldown()))) or
        Player:Buff(Combustion)
        then
            if
            RuneOfPowerEnabled and (Player:Buff(HeatingUp) or Player:Buff(HotStreak)) and
            not Player:Buff(Combustion) and
            not Player:Buff(RuneOfPowerBuff) and
            Player:CanCast(RuneOfPower)
            then
                Player:Cast(RuneOfPower)
                return
            end
            self:ActiveTalents()
            if
            Combustion:Exists() and
            (not RuneOfPowerEnabled or Player:Buff(RuneOfPowerBuff) or
            (Player:Casting(RuneOfPower) and Player:CastedPercent() > 75) or
            (RuneOfPower:Exists() and RuneOfPower:Cooldown() > 10 and IsOptionEnabled("强制爆发")) or
            (not RuneOfPower:Exists() and IsOptionEnabled("强制爆发"))) and
            Player:CanCast(Combustion)
            then
                Bug("Normal Combustion")
                Player:Cast(Combustion)
                return
            end
            if Player:IsWithinCastRange(Target, Fireball) and Player:Buff(Combustion) then
                Player:UsePotions("智力药水")
                Player:UseTrinkets()
                if CDOptionEnabled("进攻性种族技能") then
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury)
                    end
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        Player:Cast(Berserking)
                    end
                end
            end
            if
            UseAOE() and IsOptionEnabled("燃烧搭配烈焰风暴") and FlamestrikeInstant:Exists() and Player:Buff(HotStreak) and
            IsOptionEnabled("持续施放烈焰风暴") and
            Target:CanCast(FlamestrikeInstant)
            then
                if
                Target:CastGroundSpell(
                FlamestrikeInstant,
                "持续施放烈焰风暴",
                8,
                IsOptionEnabled("Flamestrike Blacklist Ignore")
                )
                then
                    return
                end
            end
            if
            Pyroblast:Exists() and IsOptionEnabled("Marquee Bindings") and
            GetOptionValue("Marquee Bindings") == "无条件使用" and
            Player:BuffRemains(KaelthassUltimateAbility) > Pyroblast:CastTime() + 0.1 and
            Player:BuffRemains(Combustion) > Pyroblast:CastTime() + 0.1 and
            not Player:Buff(HotStreak) and
            Target:CanCast(Pyroblast)
            then
                Target:Cast(Pyroblast)
                return
            end
            if PyroblastInstant:Exists() and Player:Buff(HotStreak) and Target:CanCast(PyroblastInstant) then
                Target:Cast(PyroblastInstant)
                return
            end
            if Player:Buff(HotStreak) then
                return
            end
            if
            PyroblastInstant:TimeSinceCast() < Player:GCD() + 0.1 and Player:Buff(Combustion) and
            FireBlast:Charges() >= 1
            then
                Bug("Wait for Pyro Crit")
                return
            end
            if Player:Buff(HeatingUp) and Player:Buff(Combustion) and FireBlast:Charges() >= 1 then
                Bug("Wait for Fireblast")
                return
            end
            if
            PhoenixsFlames:Exists() and IsOptionEnabled("凤凰烈焰") and
            (not Player:BuffRemains(Combustion) or (Scorch:TimeSinceCast() > Scorch:CastTime() + 0.2)) and
            Target:CanCast(PhoenixsFlames)
            then
                Target:Cast(PhoenixsFlames)
                return
            end
            if
            Scorch:Exists() and Scorch:TimeSinceCast() > Scorch:CastTime() + 0.2 and
            Player:BuffRemains(Combustion) > Scorch:CastTime() + 0.1 and
            Target:CanCast(Scorch, true)
            then
                Bug("Scorch Filler")
                Target:Cast(Scorch)
                return
            end
            if
            UseAOE() and DragonsBreath:Exists() and IsOptionEnabled("龙息术") and
            ((DarcklisDragonfireDiadem:IsEquipped(1) and DragonsBreathUnits >= GetSecondOptionValue("龙息术")) or
            (not DarcklisDragonfireDiadem:IsEquipped(1) and DragonsBreathUnits >= GetOptionValue("龙息术")) or
            (DragonsBreathUnits >= 1 and AlextraszasFury:Exists() and not Player:Buff(HotStreak))) and
            not Player:Buff(HotStreak) and
            FireBlast:Charges() < 1 and
            PhoenixsFlames:Charges() < 1 and
            Player:CanCast(DragonsBreath)
            then
                Player:Cast(DragonsBreath)
                return
            end
            if
            Scorch:Exists() and Target:HealthPercentage() < 30 and UseKoralonsBurningTouch and
            Scorch:TimeSinceCast() > Scorch:CastTime() + 0.2 and
            Target:CanCast(Scorch, true)
            then
                Target:Cast(Scorch)
                return
            end
            if Player:BuffRemains(Combustion) > Scorch:CastTime() + 0.1 then
                return
            end
        end
        if Player:Buff(RuneOfPower) then
            if
            UseAOE() and FlamestrikeInstant:Exists() and Player:Buff(HotStreak) and IsOptionEnabled("持续施放烈焰风暴") and
            Target:CanCast(FlamestrikeInstant)
            then
                if
                Target:CastGroundSpell(
                FlamestrikeInstant,
                "持续施放烈焰风暴",
                8,
                IsOptionEnabled("Flamestrike Blacklist Ignore")
                )
                then
                    return
                end
            end
            if
            PyroblastInstant:Exists() and Player:Buff(HotStreak) and
            (not PyroblastInstant:WasLastCast() or Player:Buff(Combustion)) and
            Target:CanCast(PyroblastInstant)
            then
                Target:Cast(PyroblastInstant)
                return
            end
            self:ActiveTalents()
            if
            Pyroblast:Exists() and IsOptionEnabled("Marquee Bindings") and
            Player:BuffRemains(KaelthassUltimateAbility) > Pyroblast:CastTime() + 0.1 and
            not Player:Buff(HotStreak) and
            Target:CanCast(Pyroblast)
            then
                Target:Cast(Pyroblast)
                return
            end
            if
            PhoenixsFlames:Exists() and IsOptionEnabled("凤凰烈焰") and PhoenixsFlames:FractionalCharges() > 2.7 and
            FireStarter:Exists() and
            Target:HealthPercentage() > 90 and
            Target:CanCast(PhoenixsFlames)
            then
                Target:Cast(PhoenixsFlames)
                return
            end
            if
            PhoenixsFlames:Exists() and IsOptionEnabled("凤凰烈焰") and PhoenixsFlames:FractionalCharges() > 2.7 and
            Target:CanCast(PhoenixsFlames)
            then
                Target:Cast(PhoenixsFlames)
                return
            end
            if
            Scorch:Exists() and Target:HealthPercentage() < 30 and UseKoralonsBurningTouch and
            Target:CanCast(Scorch, true)
            then
                Target:Cast(Scorch)
                return
            end
            if
            UseAOE() and FlamestrikeInstant:Exists() and IsOptionEnabled("烈焰风暴") and
            Target:CanCast(FlamestrikeInstant)
            then
                if Target:CastGroundSpell(FlamestrikeInstant, "烈焰风暴", 8) then
                    return
                end
            end
            if FireStarter:Exists() and not Player:IsMoving() and IsOptionEnabled("对其余目标施放纵火者") then
                local BestFireballUnit =                 Target:HealthPercentage() < 90 and Unit.LightEnemyAvailableForSpellHP(Enemies, Fireball, 90, true) or
                nil
                if BestFireballUnit and BestFireballUnit:CanCast(Fireball) then
                    Bug("Fireball Other Unit - With Fire Starter")
                    BestFireballUnit:Cast(Fireball)
                    return
                end
            end
            if Fireball:Exists() and not Player:IsMoving() and Target:CanCast(Fireball) then
                Target:Cast(Fireball)
                return
            end
        end
        if
        UseAOE() and FlamestrikeInstant:Exists() and Player:Buff(HotStreak) and IsOptionEnabled("持续施放烈焰风暴") and
        Target:CanCast(FlamestrikeInstant)
        then
            if
            Target:CastGroundSpell(
            FlamestrikeInstant,
            "持续施放烈焰风暴",
            8,
            IsOptionEnabled("Flamestrike Blacklist Ignore")
            )
            then
                return
            end
        end
        if
        PyroblastInstant:Exists() and Player:Buff(HotStreak) and Player:BuffRemains(HotStreak) < Fireball:CastTime() and
        Target:CanCast(PyroblastInstant)
        then
            Target:Cast(PyroblastInstant)
            return
        end
        if
        PyroblastInstant:Exists() and Player:Buff(HotStreak) and FireStarter:Exists() and
        Target:HealthPercentage() > 90 and
        not RuneOfPower:Exists() and
        Target:CanCast(PyroblastInstant)
        then
            Target:Cast(PyroblastInstant)
            return
        end
        if
        PhoenixsFlames:Exists() and IsOptionEnabled("凤凰烈焰") and NumEnemies >= GetOptionValue("凤凰烈焰") and
        PhoenixsFlames:FractionalCharges() >= 2.7 and
        Target:CanCast(PhoenixsFlames)
        then
            Target:Cast(PhoenixsFlames)
            return
        end
        if
        PyroblastInstant:Exists() and Player:Buff(HotStreak) and not PyroblastInstant:WasLastCast() and
        Target:CanCast(PyroblastInstant)
        then
            Target:Cast(PyroblastInstant)
            return
        end
        if
        PyroblastInstant:Exists() and Player:Buff(HotStreak) and Target:HealthPercentage() <= 30 and
        UseKoralonsBurningTouch and
        Target:CanCast(PyroblastInstant)
        then
            Target:Cast(PyroblastInstant)
            return
        end
        if
        Pyroblast:Exists() and IsOptionEnabled("Marquee Bindings") and
        Player:BuffRemains(KaelthassUltimateAbility) > Pyroblast:CastTime() + 0.1 and
        not Player:Buff(HotStreak) and
        Target:CanCast(Pyroblast)
        then
            Target:Cast(Pyroblast)
            return
        end
        self:ActiveTalents()
        if
        PhoenixsFlames:Exists() and IsOptionEnabled("凤凰烈焰") and
        ((Player:Buff(Combustion) or Player:Buff(RuneOfPower) or Player:BuffCount(IncantersFlowBuff) > 3 or
        MirrorImage:Exists()) and
        PhoenixReborn:ArtifactEnabled() and
        (4 - PhoenixsFlames:FractionalCharges()) * 13 < Combustion:Cooldown() + 5 or
        (Target:IsBoss() and Target:TimeToDie() < 10)) and
        Target:CanCast(PhoenixsFlames)
        then
            Target:Cast(PhoenixsFlames)
            return
        end
        if
        PhoenixsFlames:Exists() and IsOptionEnabled("凤凰烈焰") and
        ((Player:Buff(Combustion) or Player:Buff(RuneOfPower)) and
        (4 - PhoenixsFlames:FractionalCharges()) * 30 < Combustion:Cooldown() + 5) and
        Target:CanCast(PhoenixsFlames)
        then
            Target:Cast(PhoenixsFlames)
            return
        end
        if
        PhoenixsFlames:Exists() and IsOptionEnabled("凤凰烈焰") and PhoenixsFlames:FractionalCharges() > 2.5 and
        Combustion:Cooldown() > 23 and
        Target:CanCast(PhoenixsFlames)
        then
            Target:Cast(PhoenixsFlames)
            return
        end
        if UseAOE() and FlamestrikeInstant:Exists() and IsOptionEnabled("烈焰风暴") and Target:CanCast(FlamestrikeInstant) then
            if Target:CastGroundSpell(FlamestrikeInstant, "烈焰风暴", 8) then
                return
            end
        end
        if
        Scorch:Exists() and Target:HealthPercentage() < 30 and UseKoralonsBurningTouch and
        Target:CanCast(Scorch, true)
        then
            Target:Cast(Scorch)
            return
        end
        if FireStarter:Exists() and not Player:IsMoving() and IsOptionEnabled("对其余目标施放纵火者") then
            local BestFireballUnit =             Target:HealthPercentage() < 90 and Unit.LightEnemyAvailableForSpellHP(Enemies, Fireball, 90, true) or
            nil
            if BestFireballUnit and BestFireballUnit:CanCast(Fireball) then
                Bug("Fireball Other Unit - With Fire Starter")
                BestFireballUnit:Cast(Fireball)
                return
            end
        end
        if Fireball:Exists() and not Player:IsMoving() and Target:CanCast(Fireball) then
            Target:Cast(Fireball)
            return
        end
        if Scorch:Exists() and IsOptionEnabled("移动时施放灼烧") and Player:IsMoving() and Target:CanCast(Scorch, true) then
            Target:Cast(Scorch)
            return
        end
    end
end
function Rotation:OutOfCombat()
    if IsOptionEnabled("强制爆发") then
        Bug("Disabling Force Burn")
        SetSetting("强制爆发_Checked", false)
    end
    OpenerSpellCasted, UsedOpener = false, false
    if IsOptionEnabled("自动进入战斗") and Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        if Fireball:Exists() and Target:CanCast(Fireball) then
            Target:Cast(Fireball)
            return
        end
    end
end
SetRotation(64, {})
local Rotation = Rotations[64]
function Rotation:Initialize()
    ArcaneTorrent = Spell(28730, false, false, true)
    Berserking = Spell(26297, false, false, true)
    BloodFury = Spell(33702, false, false, true)
    GiftOfTheNaaru = Spell(59548, false, false, true)
    ArcticGale = Spell(205038)
    Blizzard = Spell(190356, false, true, false)
    BoneChilling = Spell(205027)
    BoneChillingBuff = Spell(205766)
    BrainFreeze = Spell(190446)
    ChainReaction = Spell(195418)
    ColdSnap = Spell(11958, false, false, true)
    CometStorm = Spell(153595, true, true, true)
    ConeOfCold = Spell(120, false, false, true)
    Counterspell = Spell(2139, false, true, true)
    Ebonbolt = Spell(214634, true, true, false)
    FingersOfFrost = Spell(44544)
    Flurry = Spell(44614, true, true, false)
    FlurryInstant = Spell(44614, true, true, true)
    Freeze = Spell(33395, false, true, true)
    Frostbolt = Spell(116, true, true, true)
    FrostBomb = Spell(112948, true, true, false)
    FrozenOrb = Spell(84714, false, false, true)
    FrozenMass = Spell(242253)
    FrozenTouch = Spell(205030, false, false, true)
    GlacialSpike = Spell(199786, true, true, false)
    IceBarrier = Spell(11426, false, false, true)
    IceBlock = Spell(45438, false, false, true)
    IceFloes = Spell(108839, false, false, true)
    IceLance = Spell(30455, true, true, true)
    IceNova = Spell(157997, true, true, true)
    Icicles = Spell(205473)
    IcyVeins = Spell(12472, false, false, true)
    Invisibility = Spell(66, false, false, true)
    InvisibilityBuff = Spell(32612)
    LonelyWinter = Spell(205024)
    MirrorImage = Spell(55342, false, false, true)
    Polymorph = Spell(118, false, true, false)
    RayOfFrost = Spell(205021, true, true, false)
    RuneOfPower = Spell(116011, false, false, false)
    RuneOfPowerBuff = Spell(116014)
    SpellSteal = Spell(30449, true, true, true)
    SplittingIce = Spell(56377)
    SummonWaterElemental = Spell(31687, false, false, false)
    ThermalVoid = Spell(155149)
    Waterbolt = Spell(31707, true, true, true)
    WaterJet = Spell(135029, true, true, true)
    WintersChill = Spell(228358)
    ZannesuJourney = Item(133970)
    ZannesuJourneyBuff = Spell(206397)
    MagtheridonsBanishedBracersBuff = Spell(214404)
    AddPage("常规")
    AddPage("进攻")
    AddPage("防御")
    AddCommonOptions()
    AddPresetOption("常规", "Caster", nil, true)
    AddSection("常规", "辅助", "Yellow")
    AddNewOption("常规", "浮冰", 210, true, nil, nil, "")
    AddSection("常规", "宠物选项", "Yellow")
    AddNewOption(
    "常规",
    "自动召唤水元素",
    220,
    true,
    { 3, 1, 25, 0.5 },
    nil,
    "Automatically Summon your Pet." ..
    C.TOOLTIP_VALUE_1 .. "How long would you like to wait before using Summon when your Elemental is dismissed."
    )
    AddNewOption(
    "常规",
    "冰冻术",
    232,
    false,
    { 2, "目标", "Target Standing", "Centered", "Centered Standing" },
    { 2, 1, 5, 1 },
    "Use Freeze." ..
    C.TOOLTIP_VALUE_1 ..
    "Choose preferred mode." ..
    C.TOOLTIP_SUBVALUE("目标") ..
    "Always use on the current target." ..
    C.TOOLTIP_SUBVALUE("Target Standing") ..
    "Always use on the current target. Target must be standing still." ..
    C.TOOLTIP_SUBVALUE("Centered") ..
    "Use centered on a cluster of enemies." ..
    C.TOOLTIP_SUBVALUE("Centered Standing") ..
    "Use centered on a cluster of enemies. Enemies must be standing still." ..
    C.TOOLTIP_VALUE_2 ..
    "Amount of enemies that must be in the spell effect to use." ..
    C.TOOLTIP_HINT(
    "This ability uses the same cooldown as Water Jet. It should only be used for dungeons or questing."
    ) ..
    C.TOOLTIP_HINT("Pet Damage Handling must be checked.")
    )
    AddNewOption(
    "常规",
    "宠物输出处理",
    233,
    true,
    { 1, "Handle Assist", "Do Not Handle Assist" },
    { 1, "Handle Spells", "Do Not Handle Spells" },
    "Manage Pet Casts." ..
    C.TOOLTIP_VALUE_1 ..
    "Enable this to automatically change between assist and passive mode depending if you have a target or not." ..
    C.TOOLTIP_VALUE_2 ..
    "Enable this to automatically disable spells the profile should be handling so that they are handled by the rotation." ..
    C.TOOLTIP_HINT(
    "Spells handling applies to Waterbolt(Enable Auto) and Water Jet(Disable Auto)."
    )
    )
    AddNewOption(
    "常规",
    "水流喷射",
    210,
    true,
    nil,
    { 1, 1, 10, 1 },
    "Use Water Jet while we are casting Frostbolt to get Fingers Of Frost buffs." ..
    C.TOOLTIP_HINT("Pet Damage Handling must be checked.")
    )
    AddPresetOption("进攻")
    AddSection("进攻", "大技能", "Yellow")
    AddPresetOption(
    "Cooldown",
    "冰冷血脉",
    nil,
    { 2, "Do Not Keep", "保持" },
    C.TOOLTIP_SUBVALUE("Do Not Keep", true) ..
    "Always use Fingers of Frost procs while Icy Veins is disabled." ..
    C.TOOLTIP_SUBVALUE("保持") .. "Keep Fingers of Frost procs while Icy Veins is disabled."
    )
    AddPresetOption("Cooldown", "镜像")
    AddPresetOption(
    "Cooldown",
    "能量符文",
    nil,
    { 2, "任何时候", "Before Icy Veins" },
    C.TOOLTIP_SUBVALUE("任何时候", true) ..
    "Use Rune Of Power whenever it is ready." ..
    C.TOOLTIP_SUBVALUE("Before Icy Veins") .. "Save one charge for Icy Veins."
    )
    AddSection("进攻", "能力", "Yellow")
    AddNewOption(
    "进攻",
    "暴风雪",
    232,
    true,
    { 2, "目标", "Target Standing", "Centered", "Centered Standing" },
    { 4, 1, 10, 1 },
    "Use Blizzard." ..
    C.TOOLTIP_VALUE_1 ..
    "Choose preferred mode." ..
    C.TOOLTIP_SUBVALUE("目标") ..
    "Always use on the current target." ..
    C.TOOLTIP_SUBVALUE("Target Standing") ..
    "Always use on the current target. Target must be standing still." ..
    C.TOOLTIP_SUBVALUE("Centered") ..
    "Use centered on a cluster of enemies." ..
    C.TOOLTIP_SUBVALUE("Centered Standing") ..
    "Use centered on a cluster of enemies. Enemies must be standing still." ..
    C.TOOLTIP_VALUE_2 ..
    "Amount of enemies that must be in the spell effect to use."
    )
    AddNewOption(
    "进攻",
    "暴风雪选项",
    130,
    true,
    { 1, "无条件使用", "Only On Boss" },
    nil,
    "Use Blizzard with the normal handler only if the options are met." ..
    C.TOOLTIP_VALUE ..
    "Choose preferred mode." ..
    C.TOOLTIP_SUBVALUE("无条件使用") ..
    "Always use Blizzard." ..
    C.TOOLTIP_SUBVALUE("Only On Boss") ..
    "Only use if the current target is a boss." ..
    C.TOOLTIP_HINT(
    "This option is bypassed whenever the Blizzard's first option is set to Centered or Centered Standing. It also does not apply to the Zann'esu Journey blizzard."
    )
    )
    AddNewOption(
    "进攻",
    "冰锥术",
    210,
    true,
    nil,
    nil,
    "Use Cone of Cold as filler while moving if the amount of units in its area of effect is greater than one unit without Splitting Ice talent and greater than two with Splitting Ice talent."
    )
    AddNewOption(
    "进攻",
    "彗星风暴",
    220,
    true,
    { 1, 1, 10, 1 },
    nil,
    "Use Comet Storm." .. C.TOOLTIP_VALUE .. "Amount of units that needs to be within 4 yards of the target to use."
    )
    AddNewOption(
    "进攻",
    "Ebonbolt",
    220,
    true,
    { 5, 1, 100, 0.1 },
    nil,
    "Use Ebonbolt." .. C.TOOLTIP_VALUE .. "Minimum Health of the target to use."
    )
    AddNewOption(
    "进攻",
    "寒冰炸弹",
    220,
    true,
    { 3, 1, 10, 1 },
    nil,
    "Use Frost Bomb." .. C.TOOLTIP_VALUE .. "Amount of units that needs to be within 10 yards of the target to use."
    )
    AddNewOption(
    "进攻",
    "寒冰宝珠",
    222,
    true,
    { 1, 1, 10, 1 },
    { 5, 1, 100, 0.1 },
    "Use Frozen Orb." ..
    C.TOOLTIP_VALUE_1 ..
    "Amount of units that needs to be in 40y corridor in front of us to use." ..
    C.TOOLTIP_VALUE_2 .. "Minimum Health of the target to use."
    )
    AddNewOption(
    "进攻",
    "寒冰新星",
    220,
    true,
    { 3, 1, 10, 1 },
    nil,
    "Use Ice Nova." .. C.TOOLTIP_VALUE .. "Amount of units that needs to be within 8 yards of the target to use."
    )
    AddNewOption("进攻", "冰霜射线", 210, true, nil, nil, "Use Ray Of Frost.")
    AddSection("进攻", "传奇物品", "Orange")
    AddNewOption(
    "进攻",
    "扎奈苏的旅程",
    220,
    true,
    { 1, 1, 10, 1 },
    nil,
    "Use Blizzard when we have 5 stacks of the Zann'esu Journey buff." ..
    C.TOOLTIP_VALUE ..
    "Amount of enemies that must be around the current target to use." ..
    C.TOOLTIP_HINT("This Blizzard will always be cast on the current target.")
    )
    AddNewOption(
    "进攻",
    "Magtheridons Bracer",
    220,
    true,
    { 0.2, 0, 2, 0.1 },
    nil,
    "Use Ice Lance as high priority without Fingers of Frost to keep buff up." ..
    C.TOOLTIP_VALUE ..
    "Amount of seconds added to cast time calculation for spells. Depending on latency you may need to raise it to not let buff fall due to to tight calculations."
    )
    AddPresetOption("防御")
    AddSection("防御", "能力", "Yellow")
    AddNewOption(
    "防御",
    "隐形术",
    220,
    true,
    { 20, 1, 100, 1 },
    nil,
    "Use Greater Invisibility." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddNewOption(
    "防御",
    "寒冰护体",
    220,
    true,
    { 80, 1, 100, 1 },
    nil,
    "Use Ice Barrier." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddNewOption(
    "防御",
    "寒冰屏障",
    220,
    true,
    { 30, 1, 100, 1 },
    nil,
    "Use Ice Block." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    IncantersFlow = Spell(1463, false, false, false)
    IncantersFlowBuff = Spell(116267)
    IncantersFlowDirection = 0
    local Frame = CreateFrame("Frame")
    Frame:RegisterEvent("PLAYER_DAMAGE_DONE_MODS")
    local function IncantersFlowTracker(self, ...)
        IncantersFlowBuffCount = Player:BuffCount(IncantersFlowBuff)
        if IncantersFlowBuffCount == 1 then
            IncantersFlowDirection = 1
        elseif IncantersFlowBuffCount == 5 then
            IncantersFlowDirection = 2
        end
    end
    Frame:SetScript("OnEvent", IncantersFlowTracker)
    ISCL = {
        [Ebonbolt:ID()] = "Ebonbolt",
        [Flurry:ID()] = "Flurry",
        [Frostbolt:ID()] = "Frostbolt",
        [FrostBomb:ID()] = "寒冰炸弹",
        [GlacialSpike:ID()] = "Glacial Spike"
    }
end
function Rotation:Events()
    self.PetDismissed = 0
    EventFrame:RegisterForEvent(
    function(...)
        self.PetDismissed = GetTime() + 5
    end,
    "PET_DISMISS_START"
    )
    self.WaterJetChanneling = 0
    EventFrame:RegisterForCombatEvent(
    function(...)
        if select(12, ...) == 135029 and select(4, ...) == PlayerPet:GUID() then
            Bug("Water Jet Started")
            self.WaterJetChanneling = GetTime() + 3.7
        end
    end,
    "SPELL_AURA_APPLIED"
    )
    EventFrame:RegisterForCombatEvent(
    function(...)
        if select(12, ...) == 135029 and select(4, ...) == PlayerPet:GUID() then
            Bug("Water Jet Ended")
            self.WaterJetChanneling = 0
        end
    end,
    "SPELL_AURA_REMOVED"
    )
    local RegisteredGCD = {
        [190356] = "暴风雪",
        [153595] = "彗星风暴",
        [120] = "Cone of Cold",
        [214634] = "Ebonbolt",
        [44614] = "Flurry",
        [112948] = "寒冰炸弹",
        [122] = "Frost Nova",
        [116] = "Frostbolt",
        [84714] = "寒冰宝珠",
        [199786] = "Glacial Spike",
        [11426] = "寒冰护体",
        [45438] = "寒冰屏障",
        [30455] = "Ice Lance",
        [157997] = "寒冰新星",
        [55342] = "镜像",
        [118] = "Polymorph",
        [205021] = "Ray of Frost",
        [113724] = "Ring of Frost",
        [116011] = "Rune of Power",
        [130] = "Slowfall",
        [30449] = "Spellsteal",
        [31687] = "Summon Water Elemental"
    }
    EventFrame:RegisterForSelfCombatEvent(
    function(...)
        DestGUID, _, _, _, SpellID = select(8, ...)
        if RegisteredGCD[SpellID] ~= nil then
            LastCast = SpellID
            Bug("Last GCD Triggered by " .. RegisteredGCD[SpellID])
        end
    end,
    "SPELL_CAST_SUCCESS"
    )
    Rotation.WaterJetFrame = CreateFrame("Frame")
    function Rotation.WaterJetFunction(self, ...)
        if
        EngineRunning and PlayerPet:Exists() and IsOptionEnabled("宠物输出处理") and
        GetSecondOptionValue("宠物输出处理") == "Handle Spells" and
        IsOptionEnabled("水流喷射") and
        Player:BuffCount(FingersOfFrost) < 2 and
        not Player:Buff(BrainFreeze)
        then
            if Player:Casting(Frostbolt) and not WaterJet:IsOnCooldown() then
                CastBeforeTime = Frostbolt:TravelTime() - 1.5
                PercentBeforeCastEnd = ((math.abs(CastBeforeTime) / Frostbolt:CastTime()) * 100)
                CastPercentThreshold = 100 - PercentBeforeCastEnd < 85 and 100 - PercentBeforeCastEnd or 85
                if
                Player:CastedPercent() > CastPercentThreshold and Player:CastedPercent() < CastPercentThreshold + 15 and
                Target:PetCanCast(WaterJet)
                then
                    Rotation.WaterJetChanneling = GetTime() + 4.7
                    Target:Cast(WaterJet)
                end
            end
        end
    end
    Rotation.WaterJetFrame:SetScript("OnUpdate", Rotation.WaterJetFunction)
end
function Rotation:Pulse()
    if
    not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() or
    Player:Channeling(RayOfFrost)
    then
        return
    end
    if Target:Exists() and BMPullTime() < 5 then
        self:Opening()
        return
    end
    if GetTime() < Rotation.SpamPrevention then
        return
    end
    Rotation.SpamPrevention = GetTime() + 0.05
    Target = Unit.Target
    local InCombat = Player:IsInCombat()
    if not InCombat then
        self:OutOfCombat()
        return
    end
    if InCombat then
        self:Defensives()
    end
    Target = Player:ReTarget(Frostbolt, false) or Unit.Target
    if Target:Exists() then
        Rotations:RefreshUnitTables(Rotation.Identifier)
        self:Interrupts()
        if
        IsOptionEnabled("开怪技能") and
        (GetOptionValue("开怪技能") == "无条件使用" or (GetOptionValue("开怪技能") == "打BOSS使用" and Target:IsBoss()) or
        (GetOptionValue("开怪技能") == "CDs Only" and CooldownsAllowed())) and
        not OpenerEnded
        then
            self:Opener()
            return
        elseif CombatTime() > 10 then
            OpenerEnded = true
        end
        self:OffGCDAbilities()
        if Player:GlobalCooldown() == 0 and Player:IsReady() then
            self:Combat()
        end
    end
end
function Rotation:Opening()
    Player:UsePotions("智力药水", GetSecondOptionValue("抢先使用药水"))
    if
    IsOptionEnabled("抢先施放(需DBM插件)") and
    (GetOptionValue("抢先施放(需DBM插件)") == "无条件使用" or
    (GetOptionValue("抢先施放(需DBM插件)") == "打BOSS使用" and Target:IsBoss()))
    then
        OpenerSpell = Ebonbolt:Exists() and Ebonbolt or Frostbolt
        if
        MirrorImage:Exists() and BMPullTime() < GetSecondOptionValue("抢先施放(需DBM插件)") + Player:GCD() and
        Player:CanCast(MirrorImage)
        then
            Player:Cast(MirrorImage)
            return
        end
        if
        RuneOfPower:Exists() and BMPullTime() < GetSecondOptionValue("抢先施放(需DBM插件)") + RuneOfPower:CastTime() and
        Player:CanCast(RuneOfPower)
        then
            Player:Cast(RuneOfPower)
            return
        end
        if PlayerPet:Exists() and BMPullTime() < GetSecondOptionValue("抢先施放(需DBM插件)") and Target:PetCanCast(Waterbolt) then
            Target:Cast(Waterbolt)
            return
        end
        if OpenerSpell:Exists() and BMPullTime() < GetSecondOptionValue("抢先施放(需DBM插件)") and Target:CanCast(OpenerSpell) then
            Target:Cast(OpenerSpell)
            return
        end
        if
        IceBarrier:Exists() and BMPullTime() > GetSecondOptionValue("抢先施放(需DBM插件)") + 3 and BMPullTime() < 5 and
        not Player:Buff(IceBarrier) and
        Player:CanCast(IceBarrier)
        then
            Player:Cast(IceBarrier)
            return
        end
    end
end
function Rotation:Opener()
    self.ChoosenOpener = nil
    if LonelyWinter:Exists() then
        self.ChoosenOpener = {
            [1] = { IcyVeins, Player, CDOptionEnabled("冰冷血脉") },
            [2] = { "Trinkets" },
            [3] = { "Racials", { BloodFury, Berserking } },
            [4] = { IceLance, Target, Player:Buff(FingersOfFrost) ~= nil },
            [5] = { FlurryInstant, Target, Player:Buff(BrainFreeze) ~= nil },
            [6] = { IceLance, Target, LastCast == Flurry:ID() },
            [7] = { IceLance, Target, Player:Buff(FingersOfFrost) ~= nil },
            [8] = { IceLance, Target, Player:Buff(FingersOfFrost) ~= nil },
            [9] = { FrozenOrb, Player, IsOptionEnabled("寒冰宝珠") and Target:Health() >= GetSecondOptionValue("寒冰宝珠") },
            [10] = "Lonely Winter"
        }
    end
    if BoneChilling:Exists() then
        self.ChoosenOpener = {
            [1] = { IcyVeins, Player, CDOptionEnabled("冰冷血脉") },
            [2] = { "Trinkets" },
            [3] = { "Racials", { BloodFury, Berserking } },
            [4] = { IceLance, Target, Player:Buff(FingersOfFrost) ~= nil },
            [5] = { FlurryInstant, Target, Player:Buff(BrainFreeze) ~= nil },
            [6] = { IceLance, Target, LastCast == Flurry:ID() },
            [7] = { Frostbolt, Target, true },
            [8] = { Frostbolt, Target, true },
            [9] = { IceLance, Target, Player:Buff(FingersOfFrost) ~= nil },
            [10] = { IceLance, Target, Player:Buff(FingersOfFrost) ~= nil },
            [11] = { IceLance, Target, Player:Buff(FingersOfFrost) ~= nil },
            [12] = { FrozenOrb, Player, IsOptionEnabled("寒冰宝珠") and Target:Health() >= GetSecondOptionValue("寒冰宝珠") },
            [13] = "Bone Chilling"
        }
    end
    if Player:GlobalCooldown() == 0 then
        if self.ChoosenOpener ~= nil then
            OpenerParser(self.ChoosenOpener)
        else
            Bug("Invalid Talents combination, Opener will not be used.")
            OpenerEnded = true
        end
    end
end
Rotation.WaterboltPosition, Rotation.WaterJetPosition = 1, 1
function Rotation:PlayerPetHandling()
    if PlayerPet:Exists() then
        if IsOptionEnabled("宠物输出处理") then
            if GetSecondOptionValue("宠物输出处理") == "Handle Spells" then
                self.PetActionName, _, _, _, _, _, self.IsPetActionActive, self.PetActionID =                 GetPetActionInfo(self.WaterboltPosition)
                if self.PetActionID == 31707 and not self.IsPetActionActive then
                    EnableSpellAutocast(self.PetActionName)
                else
                    self.ShouldFindAbilities = true
                end
                self.PetActionName, _, _, _, _, _, self.IsPetActionActive, self.PetActionID =                 GetPetActionInfo(self.WaterJetPosition)
                if self.PetActionID == 135029 and self.IsPetActionActive then
                    DisableSpellAutocast(self.PetActionName)
                else
                    self.ShouldFindAbilities = true
                end
                if self.ShouldFindAbilities == true then
                    for i = 1, 10 do
                        self.PetActionName, _, _, _, _, _, self.IsPetActionActive, self.PetActionID =                         GetPetActionInfo(i)
                        if self.PetActionID == 31707 and not self.IsPetActionActive then
                            self.WaterboltPosition = i
                            EnableSpellAutocast(self.PetActionName)
                        end
                        if self.PetActionID == 135029 and self.IsPetActionActive then
                            self.WaterJetPosition = i
                            DisableSpellAutocast(self.PetActionName)
                        end
                    end
                    self.ShouldFindAbilities = false
                end
            end
            if GetOptionValue("宠物输出处理") == "Handle Assist" then
                if Target:Exists() and Player:CanAttack(Target) and not IsPetAttackActive() then
                    PetAssistMode()
                elseif (not Target:Exists() or not Player:CanAttack(Target)) and IsPetAttackActive() then
                    PetPassiveMode()
                end
            end
            if Player:BuffCount(FingersOfFrost) < 2 then
                if IsOptionEnabled("冰冻术") and Target:PetCanCast(Freeze) then
                    if Target:CastGroundSpell(Freeze, "冰冻术", 10) then
                        return
                    end
                end
            end
        else
            self.PetActionName, _, _, _, _, _, self.IsPetActionActive, self.PetActionID =             GetPetActionInfo(self.WaterboltPosition)
            if self.PetActionID == 31707 and not self.IsPetActionActive then
                EnableSpellAutocast(self.PetActionName)
            else
                self.ShouldFindAbilities = true
            end
            self.PetActionName, _, _, _, _, _, self.IsPetActionActive, self.PetActionID =             GetPetActionInfo(self.WaterJetPosition)
            if self.PetActionID == 135029 and not self.IsPetActionActive then
                EnableSpellAutocast(self.PetActionName)
            else
                self.ShouldFindAbilities = true
            end
            if self.ShouldFindAbilities == true then
                for i = 1, 10 do
                    self.PetActionName, _, _, _, _, _, self.IsPetActionActive, self.PetActionID = GetPetActionInfo(i)
                    if self.PetActionID == 31707 and not self.IsPetActionActive then
                        self.WaterboltPosition = i
                        EnableSpellAutocast(self.PetActionName)
                    end
                    if self.PetActionID == 135029 and not self.IsPetActionActive then
                        self.WaterJetPosition = i
                        EnableSpellAutocast(self.PetActionName)
                    end
                end
                self.ShouldFindAbilities = false
            end
        end
    end
end
function Rotation:Defensives()
    Player:UseHealingItem()
    if
    IceBlock:Exists() and IsOptionEnabled("寒冰屏障") and Player:HealthPercentage() <= GetOptionValue("寒冰屏障") and
    not Player:Buff(IceBlock) and
    not Player:Buff(InvisibilityBuff) and
    not Player:Buff(Invisibility) and
    Player:CanCast(IceBlock)
    then
        SpellStopCasting()
        Player:Cast(IceBlock)
        return
    end
    if
    IceBarrier:Exists() and IsOptionEnabled("寒冰护体") and Player:HealthPercentage() <= GetOptionValue("寒冰护体") and
    not Player:Buff(IceBarrier) and
    Player:CanCast(IceBarrier)
    then
        Player:Cast(IceBarrier)
        return
    end
    if
    Invisibility:Exists() and IsOptionEnabled("隐形术") and Player:HealthPercentage() <= GetOptionValue("隐形术") and
    not Player:Buff(IceBlock) and
    Player:CanCast(Invisibility)
    then
        SpellStopCasting()
        Player:Cast(Invisibility)
        return
    end
    if
    GiftOfTheNaaru:Exists() and IsOptionEnabled("纳鲁的赐福") and Player:HealthPercentage() <= GetOptionValue("纳鲁的赐福") and
    Player:CanCast(GiftOfTheNaaru)
    then
        Player:Cast(GiftOfTheNaaru)
        return
    end
end
function Rotation:Interrupts()
    Player:UseInterrupt(Counterspell, ArcaneTorrent)
end
function Rotation:OffGCDAbilities()
    self:PlayerPetHandling()
    if
    IsOptionEnabled("浮冰") and IceFloes:Exists() and Player:IsMoving() and not Player:Buff(IceFloes) and
    Player:CanCast(IceFloes) and
    IceFloes:TimeSinceCast() > 1
    then
        Player:Cast(IceFloes)
        IceFloes.LastCastTime = GetTime()
    end
end
function Rotation:FrostboltHandler()
    if IceFloes:Exists() and Player:IsMoving() and not Player:Buff(IceFloes) and Player:CanCast(IceFloes) then
        Player:Cast(IceFloes)
        return
    end
    if (not Player:IsMoving() or Player:Buff(IceFloes)) and Target:CanCast(Frostbolt) then
        Frostbolt.LastCastTime = GetTime()
        Target:Cast(Frostbolt)
        return
    end
end
function Rotation:MagtheridonsBracerKeepBuff(FollowingSpell)
    if IsOptionEnabled("Magtheridons Bracer") then
        if
        Player:Buff(MagtheridonsBanishedBracersBuff) and
        FollowingSpell:CastTime() + GetOptionValue("Magtheridons Bracer") >=
        Player:BuffRemains(MagtheridonsBanishedBracersBuff)
        then
            Bug("Ice Lance - Keep Magtheridons Bracers Buff")
            Target:Cast(IceLance)
            return true
        end
    end
    return false
end
function Rotation:ManagePet()
    if
    IsOptionEnabled("自动召唤水元素") and not LonelyWinter:Exists() and not PlayerPet:Exists() and
    self.PetDismissed + GetOptionValue("自动召唤水元素") < GetTime() and
    Player:CanCast(SummonWaterElemental)
    then
        Player:Cast(SummonWaterElemental)
        return
    end
end
function Rotation:UnitTables()
    FrozenOrbCount = UseAOE() and FrozenOrb:Exists() and #Player:UnitsInFrontRectangle(40, 5) or 0
    ConeOfColdCount = UseAOE() and #Player:UnitsInFrontCone(10, 140) or 0
    TargetEnemies_10y = UseAOE() and Target:EnemiesWithinDistance(10, false) or {}
    TargetEnemies_8y = UseAOE() and Target:FilterEnemiesByDistance(TargetEnemies_10y, 8, false) or {}
    TargetEnemies_4y = UseAOE() and Target:FilterEnemiesByDistance(TargetEnemies_8y, 4, false) or {}
end
function Rotation:Combat()
    self:ManagePet()
    if Target:Exists() and Player:CanAttack(Target) then
        if
        IceLance:Exists() and Player:Buff(MagtheridonsBanishedBracersBuff) and
        Player:BuffRemains(MagtheridonsBanishedBracersBuff) <= Player:GCD() and
        Target:CanCast(IceLance)
        then
            Bug("Ice Lance - Keep Magtheridons Bracers Buff - High Prio")
            Target:Cast(IceLance)
            return
        end
        if
        Flurry:Exists() and Player:Buff(BrainFreeze) and Player:BuffRemains(BrainFreeze) < Frostbolt:CastTime() and
        Target:CanCast(FlurryInstant)
        then
            Target:Cast(FlurryInstant)
            return
        end
        if IceLance:Exists() and LastCast == Flurry:ID() and Target:CanCast(IceLance) then
            Bug("Ice Lance - High Prio")
            Target:Cast(IceLance)
            return
        end
        if
        Flurry:Exists() and Ebonbolt:Exists() and LastCast == Ebonbolt:ID() and
        Ebonbolt:TimeSinceCast() < Ebonbolt:CastTime() + 0.5 and
        Player:Buff(BrainFreeze) and
        Target:CanCast(FlurryInstant)
        then
            Bug("Flurry - High Prio with Ebonbolt flying")
            Target:Cast(FlurryInstant)
            return
        end
        if Player:IsWithinCastRange(Target, Frostbolt) then
            IcyVeinsSoon =             IcyVeins:Exists() and CDOptionEnabled("冰冷血脉") and Player:Standing() > 1 and IcyVeins:IsOnCooldown() and
            IcyVeins:Cooldown() < 30
            ShouldRayOfFrost =             RayOfFrost:Exists() and IsOptionEnabled("冰霜射线") and not IcyVeinsSoon and Player:Standing() >= 1 and
            Target:CanCast(RayOfFrost)
            ShouldIcyVeins =             IcyVeins:Exists() and CDOptionEnabled("冰冷血脉") and Player:Standing() > 1 and Player:CanCast(IcyVeins)
            if
            RuneOfPower:Exists() and CDOptionEnabled("能量符文") and RuneOfPower:TimeSinceCast() >= 5 and
            not Player:Buff(RuneOfPowerBuff) and
            Player:Standing() >= 1 and
            Player:CanCast(RuneOfPower)
            then
                if
                (ShouldIcyVeins or
                ((RuneOfPower:Charges() == 2 or (RuneOfPower:Charges() == 1 and RuneOfPower:Recharge() < 5)) and
                IcyVeins:Cooldown() > 10) or
                Player:Buff(IcyVeins)) or
                GetSecondOptionValue("能量符文") == "任何时候"
                then
                    RuneOfPower.LastCastTime = GetTime()
                    Player:Cast(RuneOfPower)
                    return
                end
            end
            Player:UseTrinkets()
            if IcyVeins:Cooldown() < 1 or Player:Buff(IcyVeins) then
                Player:UsePotions("智力药水")
            end
            if ShouldIcyVeins then
                Player:Cast(IcyVeins)
                return
            end
            if MirrorImage:Exists() and CDOptionEnabled("镜像") and Player:CanCast(MirrorImage) then
                Player:Cast(MirrorImage)
                return
            end
            if CDOptionEnabled("进攻性种族技能") then
                if BloodFury:Exists() and Player:CanCast(BloodFury) then
                    Player:Cast(BloodFury)
                end
                if Berserking:Exists() and Player:CanCast(Berserking) then
                    Player:Cast(Berserking)
                end
            end
        end
        if #TargetEnemies_8y >= 4 then
            if
            Frostbolt:Exists() and
            self.WaterJetChanneling > GetTime() + Frostbolt:CastTime() + Frostbolt:TravelTime() and
            Player:BuffCount(FingersOfFrost) < 3 and
            Target:CanCast(Frostbolt)
            then
                if self:MagtheridonsBracerKeepBuff(Frostbolt) then
                    return
                end
                self:FrostboltHandler()
            end
            if
            FrozenOrb:Exists() and IsOptionEnabled("寒冰宝珠") and FrozenOrbCount >= GetOptionValue("寒冰宝珠") and
            Target:Health() >= GetSecondOptionValue("寒冰宝珠") and
            Player:CanCast(FrozenOrb)
            then
                Player:Cast(FrozenOrb)
                return
            end
            if
            Blizzard:Exists() and IsOptionEnabled("暴风雪") and
            (GetOptionValue("暴风雪") == "Centered" or GetOptionValue("暴风雪") == "Centered Standing" or
            GetOptionValue("暴风雪选项") == "无条件使用" or
            Target:IsBoss()) and
            Target:CanCast(Blizzard)
            then
                if self:MagtheridonsBracerKeepBuff(Blizzard) then
                    return
                end
                if Target:CastGroundSpell(Blizzard, "暴风雪", 12) then
                    return
                end
            end
            if
            Blizzard:Exists() and IsOptionEnabled("扎奈苏的旅程") and #TargetEnemies_8y >= GetOptionValue("扎奈苏的旅程") and
            ZannesuJourney:IsEquipped(6) and
            Player:BuffCount(ZannesuJourneyBuff) >= 5 and
            Player:BuffRemains(ZannesuJourneyBuff) > Blizzard:CastTime() and
            Target:CanCast(Blizzard)
            then
                if self:MagtheridonsBracerKeepBuff(Blizzard) then
                    return
                end
                Player:ForceCastGroundTowardUnit(Target, Blizzard, Player:DistanceTo(Target, true), 7)
                return
            end
            if
            CometStorm:Exists() and IsOptionEnabled("彗星风暴") and #TargetEnemies_4y >= GetOptionValue("彗星风暴") and
            Target:CanCast(CometStorm)
            then
                Target:Cast(CometStorm)
                return
            end
            if
            IceNova:Exists() and IsOptionEnabled("寒冰新星") and #TargetEnemies_8y >= GetOptionValue("寒冰新星") and
            Target:CanCast(IceNova)
            then
                Target:Cast(IceNova)
                return
            end
            if
            Flurry:Exists() and
            (LastCast == Ebonbolt:ID() or
            ((LastCast == GlacialSpike:ID() or LastCast == Frostbolt:ID()) and Player:Buff(BrainFreeze))) and
            Target:CanCast(FlurryInstant)
            then
                Target:Cast(FlurryInstant)
                return
            end
            if
            FrostBomb:Exists() and IsOptionEnabled("寒冰炸弹") and #TargetEnemies_10y >= GetOptionValue("寒冰炸弹") and
            Target:DebuffRemains(FrostBomb) < IceLance:TravelTime() and
            Player:Buff(FingersOfFrost) and
            Target:CanCast(FrostBomb)
            then
                Target:Cast(FrostBomb)
                return
            end
            if IceLance:Exists() and Player:BuffCount(FingersOfFrost) > 0 and Target:CanCast(IceLance) then
                Bug("Ice Lance - Normal (AoE)")
                Target:Cast(IceLance)
                return
            end
            if
            Ebonbolt:Exists() and IsOptionEnabled("Ebonbolt") and
            Target:Health() >= GetOptionValue("Ebonbolt") * 1000000 and
            not Player:Buff(BrainFreeze) and
            Target:CanCast(Ebonbolt)
            then
                if self:MagtheridonsBracerKeepBuff(Ebonbolt) then
                    return
                end
                Ebonbolt.LastCastTime = GetTime()
                Target:Cast(Ebonbolt)
                return
            end
            if GlacialSpike:Exists() and Target:CanCast(GlacialSpike) then
                if self:MagtheridonsBracerKeepBuff(GlacialSpike) then
                    return
                end
                Target:Cast(GlacialSpike)
                return
            end
            if Frostbolt:Exists() and Target:CanCast(Frostbolt) then
                if self:MagtheridonsBracerKeepBuff(Frostbolt) then
                    return
                end
                self:FrostboltHandler()
            end
            if Player:IsMoving() then
                if
                ConeOfCold:Exists() and
                ((not SplittingIce:Exists() and ConeOfColdCount >= 2) or
                (SplittingIce:Exists() and ConeOfColdCount >= 3)) and
                Player:CanCast(ConeOfCold)
                then
                    Player:Cast(ConeOfCold)
                    return
                end
                if IceLance:Exists() and Target:CanCast(IceLance) then
                    Target:Cast(IceLance)
                    return
                end
            end
        end
        if IceNova:Exists() and Target:Debuff(WintersChill) and Target:CanCast(IceNova) then
            Target:Cast(IceNova)
            return
        end
        if
        FrozenOrb:Exists() and HasT20_2Pc and IsOptionEnabled("寒冰宝珠") and FrozenOrbCount >= GetOptionValue("寒冰宝珠") and
        Target:Health() >= GetSecondOptionValue("寒冰宝珠") and
        Player:CanCast(FrozenOrb)
        then
            Player:Cast(FrozenOrb)
            return
        end
        if
        Frostbolt:Exists() and self.WaterJetChanneling > GetTime() + Frostbolt:CastTime() + Frostbolt:TravelTime() and
        Player:BuffCount(FingersOfFrost) < 3 and
        Target:CanCast(Frostbolt)
        then
            if self:MagtheridonsBracerKeepBuff(Frostbolt) then
                return
            end
            self:FrostboltHandler()
        end
        if
        RayOfFrost:Exists() and not Player:IsMoving() and
        (Player:Buff(IcyVeins) or (IcyVeins:Cooldown() > 60 and not Player:Buff(RuneOfPowerBuff))) and
        ShouldRayOfFrost
        then
            Target:Cast(RayOfFrost)
            return
        end
        if
        Flurry:Exists() and
        (LastCast == Ebonbolt:ID() or
        (Player:Buff(BrainFreeze) and
        ((not GlacialSpike:Exists() and LastCast == Frostbolt:ID()) or
        (GlacialSpike:Exists() and
        ((LastCast == GlacialSpike:ID() or LastCast == Frostbolt:ID()) and
        (Player:BuffCount(Icicles) <= 3 or (FrozenOrb:Cooldown() <= 10 and HasT20_2Pc))))))) and
        not Player:Buff(FingersOfFrost) and
        Target:CanCast(FlurryInstant)
        then
            Target:Cast(FlurryInstant)
            return
        end
        if
        Blizzard:Exists() and IsOptionEnabled("暴风雪") and
        (GetOptionValue("暴风雪") == "Centered" or GetOptionValue("暴风雪") == "Centered Standing" or
        GetOptionValue("暴风雪选项") == "无条件使用" or
        Target:IsBoss()) and
        #TargetEnemies_8y > 1 and
        Player:BuffCount(FingersOfFrost) < 3 and
        Target:CanCast(Blizzard)
        then
            if self:MagtheridonsBracerKeepBuff(Blizzard) then
                return
            end
            if Target:CastGroundSpell(Blizzard, "暴风雪", 12) then
                return
            end
        end
        if
        FrostBomb:Exists() and IsOptionEnabled("寒冰炸弹") and #TargetEnemies_10y >= GetOptionValue("寒冰炸弹") and
        Target:DebuffRemains(FrostBomb) < IceLance:TravelTime() and
        Player:Buff(FingersOfFrost) and
        Target:CanCast(FrostBomb)
        then
            Target:Cast(FrostBomb)
            return
        end
        if
        IceLance:Exists() and Player:BuffCount(FingersOfFrost) > 0 and
        (IcyVeins:Cooldown() > 10 or Player:BuffCount(FingersOfFrost) > 2 or
        (not IsOptionEnabled("冰冷血脉") and GetSecondOptionValue("冰冷血脉") == "Do Not Keep")) and
        Target:CanCast(IceLance)
        then
            Bug("Ice Lance - Normal (ST)")
            Target:Cast(IceLance)
            return
        end
        if
        Ebonbolt:Exists() and IsOptionEnabled("Ebonbolt") and
        Target:Health() >= GetOptionValue("Ebonbolt") * 1000000 and
        not Player:Buff(BrainFreeze) and
        Target:CanCast(Ebonbolt)
        then
            if self:MagtheridonsBracerKeepBuff(Ebonbolt) then
                return
            end
            Ebonbolt.LastCastTime = GetTime()
            Target:Cast(Ebonbolt)
            return
        end
        if
        FrozenOrb:Exists() and IsOptionEnabled("寒冰宝珠") and FrozenOrbCount >= GetOptionValue("寒冰宝珠") and
        Target:Health() >= GetSecondOptionValue("寒冰宝珠") and
        Player:CanCast(FrozenOrb)
        then
            Player:Cast(FrozenOrb)
            return
        end
        if
        IceNova:Exists() and IsOptionEnabled("寒冰新星") and #TargetEnemies_8y >= GetOptionValue("寒冰新星") and
        Target:CanCast(IceNova)
        then
            Target:Cast(IceNova)
            return
        end
        if
        CometStorm:Exists() and IsOptionEnabled("彗星风暴") and #TargetEnemies_4y >= GetOptionValue("彗星风暴") and
        Target:CanCast(CometStorm)
        then
            Target:Cast(CometStorm)
            return
        end
        if
        Blizzard:Exists() and IsOptionEnabled("扎奈苏的旅程") and #TargetEnemies_8y >= GetOptionValue("扎奈苏的旅程") and
        ZannesuJourney:IsEquipped(6)
        then
            if
            (#TargetEnemies_8y > 2 or
            (#TargetEnemies_8y > 1 and not (GlacialSpike:Exists() and SplittingIce:Exists())) or
            (Player:BuffCount(ZannesuJourneyBuff) == 5 and
            Player:BuffRemains(ZannesuJourneyBuff) > Blizzard:CastTime()))
            then
                if self:MagtheridonsBracerKeepBuff(Blizzard) then
                    return
                end
                if Target:CastGroundSpell(Blizzard, "暴风雪", 12) then
                    return
                end
            end
        end
        if
        Frostbolt:Exists() and
        Player:BuffRemains(FrozenMass) >
        Frostbolt:CastTime() + GlacialSpike:CastTime() + GlacialSpike:TravelTime() and
        not Player:Buff(BrainFreeze) and
        GlacialSpike:Exists() and
        Target:CanCast(Frostbolt)
        then
            if self:MagtheridonsBracerKeepBuff(Frostbolt) then
                return
            end
            self:FrostboltHandler()
        end
        if GlacialSpike:Exists() and (FrozenOrb:Cooldown() > 10 or not HasT20_2Pc) and Target:CanCast(GlacialSpike) then
            if self:MagtheridonsBracerKeepBuff(GlacialSpike) then
                return
            end
            Target:Cast(GlacialSpike)
            return
        end
        if Frostbolt:Exists() and Target:CanCast(Frostbolt) then
            if self:MagtheridonsBracerKeepBuff(Frostbolt) then
                return
            end
            self:FrostboltHandler()
        end
        if Player:IsMoving() then
            if
            Blizzard:Exists() and IsOptionEnabled("暴风雪") and
            (GetOptionValue("暴风雪") == "Centered" or GetOptionValue("暴风雪") == "Centered Standing" or
            GetOptionValue("暴风雪选项") == "无条件使用" or
            Target:IsBoss()) and
            Blizzard:CastTime() == 0 and
            Target:CanCast(Blizzard)
            then
                if Target:CastGroundSpell(Blizzard, "暴风雪", 12) then
                    return
                end
            end
            if IceLance:Exists() and Target:CanCast(IceLance) then
                Target:Cast(IceLance)
                return
            end
        end
    end
end
function Rotation:OutOfCombat()
    self:ManagePet()
    self:PlayerPetHandling()
    if IsOptionEnabled("自动进入战斗") and Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        local EngageSpell = Frostbolt
        if EngageSpell:Exists() and Target:CanCast(EngageSpell) then
            Target:Cast(EngageSpell)
            return
        end
    end
end
SetRotation(268, {})
local Rotation = Rotations[268]
function Rotation:Initialize()
    self.HasBetaRotation = true
    ArcaneTorrent = Spell(129597, false, false, true)
    Berserking = Spell(26297, false, false, true)
    BloodFury = Spell(20572, false, false, true)
    GiftOfTheNaaru = Spell(59547, false, false, true)
    BlackoutCombo = Spell(196736)
    BlackoutComboBuff = Spell(228563)
    BlackoutStrike = Spell(205523, true, true, true)
    BlackOxBrew = Spell(115399, false, false, true)
    BreathOfFire = Spell(115181, false, false, true)
    BreathOfFireDebuff = Spell(123725)
    ChiBurst = Spell(123986, false, false, true)
    ChiWave = Spell(115098, true, true, true)
    CracklingJadeLightning = Spell(117952, true, true, false)
    DampenHarm = Spell(122278, false, false, true)
    Detox = Spell(218164, false, false, true)
    DiffuseMagic = Spell(122783, false, false, true)
    Effuse = Spell(116694, false, false, false)
    ExpelHarm = Spell(115072, false, false, true)
    FlamingKeg = Spell(214326, false, true, true)
    FortifyingBrew = Spell(115203, false, false, true)
    InvokeNiuzao = Spell(132578, true, true, true)
    IronskinBrew = Spell(115308, false, false, true)
    IronskinBrewBuff = Spell(215479)
    HealingElixir = Spell(122281, false, false, true)
    KegSmash = Spell(121253, true, true, true)
    LightBrewing = Spell(196721)
    Paralysis = Spell(115078, false, true, true)
    Provoke = Spell(115546, false, true, true)
    PurifyingBrew = Spell(119582, false, false, true)
    Resuscitate = Spell(115178, false, false, false, true)
    RushingJadeWind = Spell(116847, false, false, true)
    SpearHandStrike = Spell(116705, true, true, true)
    TigerPalm = Spell(100780, true, true, true)
    ZenMeditation = Spell(115176, false, false, false)
    HeavyStagger = Spell(124273, false, false, true)
    LightStagger = Spell(124275, false, false, true)
    ModerateStagger = Spell(124274, false, false, true)
    HeavyStagger = Spell(124273, false, false, true)
    LightStagger = Spell(124275, false, false, true)
    ModerateStagger = Spell(124274, false, false, true)
    SalsalabimsLostTunic = Item(137016)
    StormstoutsLastGasp = Item(151788, { 3 })
    PotentKickTrait = Spell(213047)
    HandOfProtection = Spell(1022, false, false, true)
    HandOfProtectionName = GetSpellInfo(1022)
    AddPage("常规")
    AddPage("进攻")
    AddPage("防御")
    if self.HasBetaRotation then
        AddNewOption(
        "常规",
        "测试版循环",
        210,
        true,
        nil,
        nil,
        "Use the lastest updated combat routine. May not be as optimized and can contain error regarding execution!"
        )
        AddPage("BETA")
        AddSection("BETA", "进攻", "Yellow")
        AddNewOption(
        "BETA",
        "BoC Offensive",
        210,
        true,
        nil,
        nil,
        "Uses Blackout Combo offensivly. All buffs will go into Tiger Palm if possible."
        )
        AddNewOption(
        "BETA",
        "BoC Breath High Prio",
        220,
        false,
        { 4, 1, 20, 1 },
        nil,
        "Use Breath Of Fire as higher priority. You should only use it if you want Burst AoE damage as this may hurt your DPS in the long run by clashing with CDs of other abilities. Only used with BoC Offensive enabled." ..
        C.TOOLTIP_VALUE .. "Amount of units that needs to be in range to use."
        )
        AddNewOption(
        "BETA",
        "Rushing Jade Wind Filler",
        210,
        true,
        nil,
        nil,
        "Use Rushing Jade Wind as filler when nothing else to press even if target is not in range and buff is still up."
        )
        AddNewOption(
        "BETA",
        "Tiger Palm High Energy",
        220,
        false,
        { 65, 0, 100, 1 },
        nil,
        "Use Tiger Palm above Blackout Strike when you have more than the given amount of energy. Only used when not talented into Blackout Combo. This may cost you DPS but gives you more brew generation."
        )
        AddNewOption(
        "BETA",
        "Keg Smash Shoulders",
        120,
        false,
        { 1, 1, 2, 0.1 },
        nil,
        "Use with given amount of fractional charges of Keg Smash. Don't mess with it unless you are told to."
        )
        AddSection("BETA", "防御", "Yellow")
        AddNewOption(
        "BETA",
        "ISB Maximum Remains",
        222,
        true,
        { 2.1, 0, 3, 0.1 },
        { 0.5, 0, 3, 0.1 },
        "How much of ISB remains (in fraction). 1 = Base duration. 3 = Maximum ISB duration." ..
        C.TOOLTIP_VALUE_1 ..
        "Time left as fraction. Don't set above 2 if you do not want to waste any second of ISB application." ..
        C.TOOLTIP_VALUE_2 .. "Time left as fraction to use ISB as Emergency above Purify."
        )
        AddNewOption(
        "BETA",
        "No BoC ISB",
        210,
        false,
        nil,
        nil,
        "Don't use Ironskin Brew with Blackout Combo buff, even if below emergency threshold."
        )
        AddNewOption(
        "BETA",
        "Purifying",
        230,
        true,
        { 1, "自动", "Static" },
        nil,
        "Use Purifying Brew with Calculated value or Static."
        )
        AddSection("BETA", "Purify Automatic", "Yellow")
        AddNewOption(
        "BETA",
        "Stagger Value",
        120,
        true,
        { 3.5, 1, 25, 0.1 },
        nil,
        "Stagger Value in % of maximum player health per second." ..
        C.TOOLTIP_VALUE .. "% of maximum health per second."
        )
        AddNewOption(
        "BETA",
        "Mod Player Health",
        220,
        true,
        { 0.2, 0, 3, 0.1 },
        nil,
        "Modifier Player Health. Lower Health = Lower Stagger Value needed for purify. " ..
        C.TOOLTIP_VALUE .. "Expert only."
        )
        AddNewOption(
        "BETA",
        "Mod Blackout Combo",
        220,
        true,
        { 0.5, 0, 3, 0.1 },
        nil,
        "Modifier Blackout Combo. If Blackout Combo Buff is up = Higher Stagger Value needed for purify. " ..
        C.TOOLTIP_VALUE .. "Expert only."
        )
        AddNewOption(
        "BETA",
        "Mod Brew Charges",
        220,
        true,
        { 2, 0, 3, 0.1 },
        nil,
        "Modifier Brew Charges. Lower Brew Charges count = Higher Stagger Value needed for purify." ..
        C.TOOLTIP_VALUE .. "Expert only."
        )
        AddNewOption(
        "BETA",
        "Mod ISB Remains",
        220,
        true,
        { 1, 0, 5, 0.1 },
        nil,
        "Modifier ISB Remains. Lower ISB remains = Higher Stagger Value needed for purify." ..
        C.TOOLTIP_VALUE .. "Expert only."
        )
        AddNewOption(
        "BETA",
        "Mod BoB",
        210,
        true,
        nil,
        nil,
        "Modifier BoB. Adds 3 virtual Brew Charges to calculation if Blackox Brew is ready and enabled." ..
        C.TOOLTIP_VALUE .. "Expert only."
        )
        AddSection("BETA", "Purify Static", "Yellow")
        AddNewOption(
        "BETA",
        { "Purifying Brew 1", "活血酒" },
        220,
        true,
        { 10.5, 1, 25, 0.1 },
        nil,
        {
            "Use Purifying Brew when we have 1 Brew." ..
            C.TOOLTIP_VALUE ..
            "Health percentage staggered." ..
            C.TOOLTIP_HINT(
            "This will always have higher priority than Ironskin Brew. Yellow Stagger begins at 3%, Red begins at 6%."
            ),
            "当我们遭受中度/当我们有1个酿造时使用净化酿造。" ..
            C.TOOLTIP_VALUE .. "健康百分比错乱。" .. C.TOOLTIP_HINT("这将永远比铁骨酒更优先。 黄色交错开始于3％，红色开始于6％。")
        }
        )
        AddNewOption(
        "BETA",
        { "Purifying Brew 2", "活血酒" },
        220,
        true,
        { 8.5, 1, 25, 0.1 },
        nil,
        {
            "Use Purifying Brew when we have 2 Brews." ..
            C.TOOLTIP_VALUE ..
            "Health percentage staggered." ..
            C.TOOLTIP_HINT(
            "This will always have higher priority than Ironskin Brew. Yellow Stagger begins at 3%, Red begins at 6%."
            ),
            "当我们遭受中度/当我们有2个酿造时使用净化酿造。" ..
            C.TOOLTIP_VALUE .. "健康百分比错乱。" .. C.TOOLTIP_HINT("这将永远比铁骨酒更优先。 黄色交错开始于3％，红色开始于6％。")
        }
        )
        AddNewOption(
        "BETA",
        { "Purifying Brew 3", "活血酒" },
        220,
        true,
        { 4.5, 1, 25, 0.1 },
        nil,
        {
            "Use Purifying Brew when we have 3 Brews." ..
            C.TOOLTIP_VALUE ..
            "Health percentage staggered." ..
            C.TOOLTIP_HINT(
            "This will always have higher priority than Ironskin Brew. Yellow Stagger begins at 3%, Red begins at 6%."
            ),
            "当我们遭受中度/当我们有3个酿造时使用净化酿造。" ..
            C.TOOLTIP_VALUE .. "健康百分比错乱。" .. C.TOOLTIP_HINT("这将永远比铁骨酒更优先。 黄色交错开始于3％，红色开始于6％。")
        }
        )
    end
    AddCommonOptions()
    AddPresetOption("常规", "Melee", nil, false)
    AddPresetOption("TankingFeatures", { "嚎镇八方", "惹" })
    AddSection("常规", "辅助", "Yellow")
    AddNewOption(
    "常规",
    "使用分筋错骨打断",
    210,
    false,
    nil,
    nil,
    "Try to interrupt farthest unit with Paralysis. NOTE: Does not check if enemy is stunnable. So it may be wasted!"
    )
    AddPresetOption("进攻")
    AddSection("进攻", { "大技能", "酷唐斯" }, "Yellow")
    AddPresetOption("Cooldown", { "玄牛砮皂", "玄牛砮皂" })
    AddSection("进攻", { "能力", "能力" }, "Yellow")
    AddNewOption(
    "进攻",
    { "幻灭连击", "幻灭连击" },
    130,
    true,
    { 1, { "自动", "自动" }, { "Breath of Fire", "火焰之息" }, { "Keg Smash", "醉酿投" }, { "猛虎掌", "猛虎掌" } },
    nil,
    {
        "Handle Blackout Combo priority." .. C.TOOLTIP_VALUE .. "Spell to use with Blackout Combo.",
        "处理停电组合优先。" .. C.TOOLTIP_VALUE .. "拼写与停电组合使用。"
    }
    )
    AddNewOption(
    "进攻",
    { "幻灭连击(萨萨拉比姆)", "幻灭连击 萨萨拉比姆遗失的外套" },
    210,
    true,
    nil,
    nil,
    {
        "Deactivates the combination of Blackout Combo + Breath Of Fire as Sal'salabim resets Breath Of Fire cooldown when using Keg Smash. You will lose Single Target DPS, but will gain more AoE DPS." ..
        C.TOOLTIP_HINT(
        "The combination can still occur when all other offensive abilities are on cooldown or not usable e.g. not enough energy."
        ),
        "灭火组合+灭火组合Sal'salabim在使用醉酿投时重置消防冷却时间。 您将失去单目标DPS，但会获得更多的AoE DPS。" ..
        C.TOOLTIP_HINT("当所有其他进攻能力都处于冷却状态或不可用时，组合仍然可以发生。 没有足够的能量。")
    }
    )
    AddNewOption(
    "进攻",
    { "火焰之息", "火焰之息" },
    222,
    true,
    { 1, 1, 10, 1 },
    { 3, 1, 10, 1 },
    {
        "Use Breath Of Fire." ..
        C.TOOLTIP_VALUE_1 ..
        "Amount of units that needs to be in range to use. Low Priority = Keep Debuff up." ..
        C.TOOLTIP_VALUE_2 ..
        "Amount of units that needs to be in range to use. High Priority = More AoE DPS.",
        "使用 火焰之息." .. C.TOOLTIP_VALUE_1 .. "需要使用范围的单位数量。低优先级。" .. C.TOOLTIP_VALUE_2 .. "需要使用范围的单位数量。高优先。"
    }
    )
    AddNewOption(
    "进攻",
    { "真气爆裂", "真气爆裂" },
    220,
    true,
    { 1, 1, 10, 1 },
    nil,
    {
        "Use Chi Burst." .. C.TOOLTIP_VALUE .. "Amount of units that needs to be in the effect zone to use.",
        "使用 真气爆裂." .. C.TOOLTIP_VALUE .. "需要在效果区域中使用的单位数量。"
    }
    )
    AddNewOption(
    "进攻",
    { "爆炸酒桶", "爆炸酒桶" },
    232,
    true,
    { 2, { "目标", "目标" }, { "Target Standing", "目标站立" }, { "Centered", "中心" }, { "Centered Standing", "中心站立" } },
    { 4, 1, 20, 1 },
    {
        "Use Flaming Keg." ..
        C.TOOLTIP_VALUE_1 ..
        "Choose preferred mode." ..
        C.TOOLTIP_SUBVALUE("目标") ..
        "Always use on the current target." ..
        C.TOOLTIP_SUBVALUE("Target Standing") ..
        "Always use on the current target. Target must be standing still." ..
        C.TOOLTIP_SUBVALUE("Centered") ..
        "Use centered on a cluster of enemies." ..
        C.TOOLTIP_SUBVALUE("Centered Standing") ..
        "Use centered on a cluster of enemies. Enemies must be standing still." ..
        C.TOOLTIP_VALUE_2 ..
        "Amount of enemies that must be in the spell effect to use.",
        "使用 爆炸酒桶." ..
        C.TOOLTIP_VALUE_1 ..
        "选择首选模式。" ..
        C.TOOLTIP_SUBVALUE("目标") ..
        "始终使用当前目标。" ..
        C.TOOLTIP_SUBVALUE("目标站立") ..
        "始终使用当前目标。 目标必须站稳" ..
        C.TOOLTIP_SUBVALUE("中心") ..
        "以一群敌人为中心。" ..
        C.TOOLTIP_SUBVALUE("中心站立") ..
        "以一群敌人为中心。 敌人必须站稳" .. C.TOOLTIP_VALUE_2 .. "必须使用法术效果的敌人的数量。"
    }
    )
    AddNewOption(
    "进攻",
    { "碧玉疾风", "碧玉疾风" },
    222,
    true,
    { 1, 1, 10, 1 },
    { 2, 1, 10, 1 },
    {
        "Use Rushing Jade Wind." ..
        C.TOOLTIP_VALUE_1 ..
        "Amount of units that needs to be in range to use. Low Priority." ..
        C.TOOLTIP_VALUE_2 .. "Amount of units that needs to be in range to use. High Priority.",
        "使用 碧玉疾风." .. C.TOOLTIP_VALUE_1 .. "需要使用范围的单位数量。低优先级。" .. C.TOOLTIP_VALUE_2 .. "需要使用范围的单位数量。高优先。"
    }
    )
    AddNewOption(
    "进攻",
    { "禁用醉酿投", "禁止酿酿投" },
    210,
    false,
    nil,
    nil,
    {
        "Disables the usage of Keg Smash. Use with caution, as it will have an impact on your rotation. Only use it when you really need to control Keg Smash yourself." ..
        C.TOOLTIP_HINT("ONLY for experienced user. Don't activate if you don't know what it will cause!"),
        "禁用醉酿投的使用。 谨慎使用，因为它会对您的旋转产生影响。 只有当你真的需要控制醉酿投时，才能使用它。" .. C.TOOLTIP_HINT("只有经验丰富的用户。 不要激活，如果你不知道会造成什么！")
    }
    )
    AddPresetOption("防御")
    AddSection("防御", { "减伤", "减轻" }, "Yellow")
    AddNewOption(
    "防御",
    { "铁骨酒", "铁骨酒" },
    222,
    true,
    { 20, 1, 100, 1 },
    { 5, 5, 10, 1 },
    {
        "Use Ironskin Brew when we are receiving Damage." ..
        C.TOOLTIP_VALUE_1 ..
        "Health percentage lost via Damage." ..
        C.TOOLTIP_VALUE_2 ..
        "Time Lapse in seconds." ..
        C.TOOLTIP_HINT("Use when you lose Value 1% of health over Value 2 amount of time."),
        "当我们收到伤害时，请使用铁骨酒。" ..
        C.TOOLTIP_VALUE_1 ..
        "健康百分比损失损失。" .. C.TOOLTIP_VALUE_2 .. "时间以秒为单位。" .. C.TOOLTIP_HINT("使用当您失去价值1％的健康超过价值2的时间。")
    }
    )
    AddNewOption(
    "防御",
    { "活血酒", "活血酒" },
    220,
    true,
    { 4.5, 1, 25, 0.1 },
    nil,
    {
        "Use Purifying Brew when we are suffering Moderate/Heavy Stagger." ..
        C.TOOLTIP_VALUE ..
        "Health percentage staggered." ..
        C.TOOLTIP_HINT(
        "This will always have higher priority than Ironskin Brew. Yellow Stagger begins at 3%, Red begins at 6%."
        ),
        "当我们遭受中度/重度交错时使用净化冲泡。" .. C.TOOLTIP_VALUE .. "健康百分比错乱。" .. C.TOOLTIP_HINT("这将永远比铁骨酒更优先。 黄色交错开始于3％，红色开始于6％。")
    }
    )
    AddNewOption(
    "防御",
    { "消耗多余的怒气", "缓解转储" },
    210,
    true,
    nil,
    nil,
    {
        "Use Ironskin Brew to dump the last charge when are taking little damage and have maximum brew charges. If no damage was taken in the last 5 seconds then we will keep the charges.",
        "使用铁骨酒可以收取最后的费用，但几乎不会受到任何损害，并且可以获得最大的酿造费用。 如果在过去5秒内没有损坏，我们将继续收费。"
    }
    )
    AddNewOption(
    "防御",
    { "最大限制使用铁骨酒", "ISB最大化" },
    210,
    true,
    nil,
    nil,
    {
        "Will always use ironskin Brew when near maximum charges. Regardless of damage taken.",
        "在接近最高收费时，总是会使用熨烫布丁。 不管损坏了。"
    }
    )
    AddNewOption(
    "防御",
    { "最大限制使用铁骨酒+玄牛酒", "最大化ISB+ BOB的" },
    210,
    true,
    nil,
    nil,
    {
        "Will use all charges for IronskinBrew when Black Ox Brew is ready. And use Black Ox Brew thereafter to regain charges.",
        "当玄牛酒准备好时，将使用IronskinBrew的所有费用。 然后使用玄牛酒重新收取费用。"
    }
    )
    AddNewOption(
    "防御",
    { "最大限制使用铁骨酒防止充满", "ISB最大化防止帽" },
    220,
    true,
    { 3, 1, 10, 0.5 },
    nil,
    {
        "At how much time left on Ironskin Brew charge to reach 3 charges it should use it to prevent capping." ..
        C.TOOLTIP_VALUE ..
        "Time left until reaching max charges." .. C.TOOLTIP_HINT("Used for the Maximize ISB options."),
        "铁骨酒剩下多少时间可以收取3笔费用，以防止封顶。" .. C.TOOLTIP_VALUE .. "剩余时间直到达到最高收费。" .. C.TOOLTIP_HINT("用于最大化ISB选项。")
    }
    )
    AddNewOption(
    "防御",
    { "智能铁骨酒", "最大化ISB智能" },
    210,
    false,
    nil,
    nil,
    {
        "Tries to look ahead and uses Ironskin Brew so it does not cap when using next brew reduction ability." ..
        C.TOOLTIP_HINT("Used for the Maximize ISB options. EXPERIMENTAL !"),
        "尝试向前看，并使用铁骨酒，以便在使用下一个冲泡减少能力时不会上限。" .. C.TOOLTIP_HINT("用于最大化ISB选项。 实验！")
    }
    )
    AddSection("防御", { "能力", "能力" }, "Yellow")
    AddNewOption(
    "防御",
    { "移花接木", "移花接木" },
    222,
    true,
    { 2, 1, 5, 1 },
    { 65, 1, 100, 1 },
    {
        "Use Expel Harm." ..
        C.TOOLTIP_VALUE_1 ..
        "Minimum amount of Healing Spheres to use." .. C.TOOLTIP_VALUE_2 .. "Health threshold.",
        "使用 移花接木." .. C.TOOLTIP_VALUE_1 .. "最少量的治疗球使用。" .. C.TOOLTIP_VALUE_2 .. "健康阈值。"
    }
    )
    AddSection("防御", { "大技能", "酷唐斯" }, "Yellow")
    AddNewOption(
    "防御",
    { "玄牛酒", "玄牛酒" },
    220,
    true,
    { 3, 1, 10, 0.5 },
    nil,
    {
        "Use Black Ox Brew when we do not have any Brew charges remaining." ..
        C.TOOLTIP_VALUE_1 .. "Minimum time left on Brew recharge.",
        "当我们没有任何酿造费用时，请使用黑牛肉酿造。" .. C.TOOLTIP_VALUE_1 .. "啤酒充电时间最短。"
    }
    )
    AddNewOption(
    "防御",
    { "躯不坏", "躯不坏" },
    220,
    true,
    { 30, 1, 100, 1 },
    nil,
    { "Use Dampen Harm." .. C.TOOLTIP_VALUE .. "Health threshold.", "使用 躯不坏." .. C.TOOLTIP_VALUE .. "健康阈值。" }
    )
    AddNewOption(
    "防御",
    { "真气贯通 自己", "真气贯通自我" },
    222,
    true,
    { 20, 1, 100, 1 },
    { 80, 1, 100, 1 },
    {
        "Use Effuse on ourself." ..
        C.TOOLTIP_VALUE_1 ..
        "Health threshold while In Combat." .. C.TOOLTIP_VALUE_2 .. "Health threshold while Out of Combat.",
        "对自己使用真气贯通。" .. C.TOOLTIP_VALUE_1 .. "健康阈值在作战" .. C.TOOLTIP_VALUE_2 .. "健康阈值，而不在战斗。"
    }
    )
    AddNewOption(
    "防御",
    { "壮胆酒", "壮胆酒" },
    220,
    true,
    { 20, 1, 100, 1 },
    nil,
    { "Use Fortifying Brew." .. C.TOOLTIP_VALUE .. "Health threshold.", "使用 壮胆酒." .. C.TOOLTIP_VALUE .. "健康阈值。" }
    )
    AddNewOption(
    "防御",
    { "金创药", "金创药" },
    220,
    true,
    { 70, 1, 100, 1 },
    nil,
    {
        "Use one charge of Healing Elixir." ..
        C.TOOLTIP_VALUE ..
        "Health threshold." ..
        C.TOOLTIP_HINT(
        "Second charge will always be kept and will be used automatically when your health fall under 35%."
        ),
        "使用一次治疗灵药。" .. C.TOOLTIP_VALUE .. "健康阈值。" .. C.TOOLTIP_HINT("当您的健康状况低于35％时，第二次收费将始终保持并自动使用。")
    }
    )
    RegisterCommand(
    "staggerpausesingle",
    function()
        if IronskinBrew:Exists() and BlackoutStrike:Exists() and BlackoutCombo:Exists() then
            if StaggerPauseSingle == true then
                StaggerPauseSingle = false
                Bug("StaggerPauseSingle Canceled")
            elseif IronskinBrew:Charges() > 0 then
                StaggerPauseSingle = true
                Bug("StaggerPauseSingle Queued")
            else
                Bug("No Ironskin Brew charges.")
            end
        else
            Bug("You don't have the required spells.")
        end
    end
    )
    AddOutput("醉拳")
    AddOutput("醉拳 暂停")
    SetOutput("醉拳", "0")
    SetOutput("醉拳 暂停", "0")
    self.CalculatedPurifyValue = 0
    self.RJWTimeLeft = 1.5
    self.BOFimeLeft = 3
end
function Rotation:UseBetaRotation()
    return self.HasBetaRotation and IsOptionEnabled("测试版循环")
end
function Rotation:Events()
    BlackOxStatue = {}
    EventFrame:RegisterForSelfCombatEvent(
    function(...)
        DestGUID, DestName, _, _, SpellID = select(8, ...)
        if SpellID == 163177 then
            BlackOxStatue.LastSummon = GetTime()
            BlackOxStatue.UnitID = DestGUID
        end
    end,
    "SPELL_SUMMON"
    )
    EventFrame:RegisterForSelfCombatEvent(
    function(...)
        if select(12, ...) == 115308 and Player:Buff(BlackoutComboBuff) then
            StaggerPause = GetTime()
        end
    end,
    "SPELL_CAST_SUCCESS"
    )
end
function Rotation:Pulse()
    if
    not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() or
    Player:Channeling(ZenMeditation)
    then
        return
    end
    MaxBrewCharges = LightBrewing:Exists() and 4 or 3
    self.CalculatedPurifyValue = self:CalculatePurifyValue()
    SetOutput("醉拳", tostring(Player:Stagger()) .. " / " .. tostring(self.CalculatedPurifyValue))
    if Player:IsStaggerPausing() then
        SetOutput("醉拳 暂停", tostring(Player:StaggerPauseRemains()))
    else
        SetOutput("醉拳 暂停", 0)
    end
    if Target:Exists() and BMPullTime() < 5 then
        self:Opening()
        return
    end
    if GetTime() < Rotation.SpamPrevention then
        return
    end
    Rotation.SpamPrevention = GetTime() + 0.05
    Target = Unit.Target
    local InCombat = Player:IsInCombat()
    if not InCombat then
        self:OutOfCombat()
        return
    end
    if InCombat then
        self:Defensives()
    end
    Target = Player:ReTarget(TigerPalm, false) or Unit.Target
    PurifyingCapped =     PurifyingBrew:Exists() and
    (PurifyingBrew:Charges() == MaxBrewCharges or
    (PurifyingBrew:Charges() == MaxBrewCharges - 1 and PurifyingBrew:Recharge() < 3)) or
    false
    if Target:Exists() then
        Rotations:RefreshUnitTables(Rotation.Identifier)
        self:Interrupts()
        if self:UseBetaRotation() then
            self:OffGCDAbilitiesBeta()
        else
            self:OffGCDAbilities()
        end
        if Player:GlobalCooldown() == 0 then
            if self:UseBetaRotation() then
                self:CombatBeta()
            else
                self:Combat()
            end
        end
    end
end
function Rotation:Opening()
    Player:UsePotions("Agility")
    if
    KegSmash:Exists() and IsOptionEnabled("抢先施放(需DBM插件)") and BMPullTime() < GetSecondOptionValue("抢先施放(需DBM插件)") and
    Target:CanCast(KegSmash)
    then
        Player:StartAttack()
        Target:Cast(KegSmash)
        return
    end
end
function Rotation:Defensives()
    Player:UseHealingItem()
    if
    HealingElixir:Exists() and
    (HealingElixir:Charges() == 2 or (HealingElixir:Charges() == 1 and HealingElixir:Recharge() < 3)) and
    IsOptionEnabled("金创药") and
    Player:HealthPercentage() <= GetOptionValue("金创药") and
    HealingElixir:TimeSinceCast() > 2 and
    Player:CanCast(HealingElixir)
    then
        Player:Cast(HealingElixir)
        HealingElixir.LastCastTime = GetTime()
    end
    if
    DiffuseMagic:Exists() and IsOptionEnabled("散魔功") and Player:HealthPercentage() <= GetOptionValue("散魔功") and
    Player:CanCast(DiffuseMagic)
    then
        Player:Cast(DiffuseMagic)
    end
    if
    DampenHarm:Exists() and IsOptionEnabled("躯不坏") and Player:HealthPercentage() <= GetOptionValue("躯不坏") and
    Player:CanCast(DampenHarm)
    then
        Player:Cast(DampenHarm)
    end
    if
    FortifyingBrew:Exists() and IsOptionEnabled("壮胆酒") and Player:HealthPercentage() <= GetOptionValue("壮胆酒") and
    Player:CanCast(FortifyingBrew)
    then
        Player:Cast(FortifyingBrew)
    end
    if
    GiftOfTheNaaru:Exists() and IsOptionEnabled("纳鲁的赐福") and
    Player:SpecialHealthPercentage() <= GetOptionValue("纳鲁的赐福") and
    Player:CanCast(GiftOfTheNaaru)
    then
        Player:Cast(GiftOfTheNaaru)
        return
    end
    if
    ExpelHarm:Exists() and IsOptionEnabled("移花接木") and ExpelHarm:Count() >= GetOptionValue("移花接木") and
    Player:HealthPercentage() <= GetSecondOptionValue("移花接木") and
    Player:CanCast(ExpelHarm)
    then
        Player:Cast(ExpelHarm)
        return
    end
end
function Rotation:Interrupts()
    Player:UseInterrupt(SpearHandStrike, ArcaneTorrent)
end
function Rotation:OffGCDAbilities()
    if StaggerPauseSingle then
        if Player:Buff(BlackoutComboBuff) and IronskinBrew:Charges() > 0 and IronskinBrew:TimeSinceCast() >= 0.5 then
            Bug("Stagger Pause via StaggerPauseSingle macro.")
            Player:Cast(IronskinBrew)
            IronskinBrew.LastCastTime = GetTime()
            RandomOffGCD = nil
            StaggerPauseSingle = false
            return
        end
        return
    end
    if IsOptionEnabled("自动取消保护之手") and Player:BuffRemainsAny(HandOfProtection) <= 10 - GetOptionValue("自动取消保护之手") then
        RunMacroText("/cancelaura " .. HandOfProtectionName)
    end
    if Provoke:Exists() and Player:TauntManager(Provoke, "嚎镇八方", Target, TauntEnemies, PlayerPet) then
        return
    end
    RandomOffGCD = RandomOffGCD or math.random(35, 115) * 0.01
    if Target:Exists() and TigerPalm:Cooldown() < RandomOffGCD and Player:IsWithinCastRange(Target, TigerPalm) then
        if
        not (BlackoutCombo:Exists() and (GetOptionValue("幻灭连击") == "Keg Smash" or GetOptionValue("幻灭连击") == "自动") and
        Player:Buff(BlackoutComboBuff) and
        KegSmash:Cooldown() < 2.5)
        then
            if
            BlackOxBrew:Exists() and IsOptionEnabled("玄牛酒") and PurifyingBrew:Charges() < 1 and
            PurifyingBrew:Recharge() > GetOptionValue("玄牛酒") and
            Player:CanCast(BlackOxBrew)
            then
                Player:Cast(BlackOxBrew)
                return
            end
            if PurifyingBrew:Charges() >= 1 then
                CurrentStagger = Player:Stagger()
                if PurifyingBrew:Exists() and IsOptionEnabled("活血酒") and PurifyingBrew:TimeSinceCast() >= 5 then
                    Option1 = GetOptionValue("活血酒")
                    if CurrentStagger > Option1 and Player:CanCast(PurifyingBrew) then
                        Bug("Mitigation via Purifying Brew with " .. CurrentStagger .. "%.")
                        PurifyingBrew.LastCastTime = GetTime()
                        Player:Cast(PurifyingBrew)
                        RandomOffGCD = nil
                        return
                    end
                end
                if
                IronskinBrew:Exists() and IsOptionEnabled("铁骨酒") and PurifyingBrew:Charges() >= 2 and
                IronskinBrew:TimeSinceCast() >= 5 and
                not Player:Buff(IronskinBrew)
                then
                    Option1, Option2 = GetOptionValue("铁骨酒"), GetSecondOptionValue("铁骨酒")
                    if
                    Player:RecentDamageTakenPercent(Option2, "Physical") +
                    Player:RecentDamageTakenPercent(Option2, "Spell") >
                    Option1 and Player:CanCast(IronskinBrew)
                    then
                        Bug(
                        "Mitigation via Ironskin Brew with " ..
                        tostring(
                        Player:RecentDamageTakenPercent(Option2, "Physical") +
                        Player:RecentDamageTakenPercent(Option2, "Spell")
                        ) ..
                        " health% damage taken over the last " .. tostring(Option2) .. " seconds."
                        )
                        Player:Cast(IronskinBrew)
                        IronskinBrew.LastCastTime = GetTime()
                        RandomOffGCD = nil
                        return
                    end
                end
            end
            if
            IsOptionEnabled("消耗多余的怒气") and PurifyingCapped and IronskinBrew:Exists() and
            not Player:Buff(IronskinBrew)
            then
                if
                Player:RecentDamageTakenPercent(5, "Physical") + Player:RecentDamageTakenPercent(5, "Spell") > 0 and
                Player:CanCast(IronskinBrew)
                then
                    Bug("Mitigation Dump via Ironskin Brew")
                    IronskinBrew.LastCastTime = GetTime()
                    Player:Cast(IronskinBrew)
                    RandomOffGCD = nil
                    return
                end
            end
            if
            IsOptionEnabled("最大限制使用铁骨酒+玄牛酒") and IronskinBrew:Exists() and BlackOxBrew:Exists() and
            IronskinBrew:TimeSinceCast() > 0.4
            then
                if
                (IronskinBrew:Charges() == 3 or
                (IronskinBrew:Charges() == 2 and IronskinBrew:Recharge() <= GetOptionValue("最大限制使用铁骨酒防止充满"))) or
                (not BlackOxBrew:IsOnCooldown() and IronskinBrew:Charges() > 0) and Player:CanCast(IronskinBrew)
                then
                    Bug("Maximize Ironskin Brew + Black Ox Brew: ISB")
                    IronskinBrew.LastCastTime = GetTime()
                    Player:Cast(IronskinBrew)
                    RandomOffGCD = nil
                    return
                end
                if
                not BlackOxBrew:IsOnCooldown() and IronskinBrew:Charges() < 1 and IronskinBrew:Recharge() > 3 and
                Player:CanCast(BlackOxBrew)
                then
                    Bug("Maximize Ironskin Brew + Black Ox Brew: BoB")
                    Player:Cast(BlackOxBrew)
                    return
                end
            end
            if IsOptionEnabled("最大限制使用铁骨酒") and IronskinBrew:Exists() and IronskinBrew:TimeSinceCast() > 0.4 then
                if
                (IronskinBrew:Charges() == 3 + (LightBrewing:Exists() and 1 or 0) or
                (IronskinBrew:Charges() == 2 + (LightBrewing:Exists() and 1 or 0) and
                IronskinBrew:Recharge() <= GetOptionValue("最大限制使用铁骨酒防止充满"))) and
                Player:CanCast(IronskinBrew)
                then
                    Bug("Maximize Ironskin Brew")
                    IronskinBrew.LastCastTime = GetTime()
                    Player:Cast(IronskinBrew)
                    RandomOffGCD = nil
                    return
                end
            end
        end
    end
end
function Rotation:CalculatePurifyValue()
    if GetOptionValue("Purifying") == "自动" then
        local StaggerOptionValue = GetOptionValue("Stagger Value")
        local ModifierPlayerHealth = GetOptionValue("Mod Player Health")
        local ModifierBlackoutComboActive = GetOptionValue("Mod Blackout Combo")
        local ModifierBrewCharges = GetOptionValue("Mod Brew Charges")
        local ModifierISBRemains = GetOptionValue("Mod ISB Remains")
        local RemainingBrewCharges =         PurifyingBrew:FractionalCharges() +
        (IsOptionEnabled("Mod BoB") and IsOptionEnabled("玄牛酒") and not BlackOxBrew:IsOnCooldown() and 3 or 0)
        local FinalStaggerValue =         StaggerOptionValue *
        (IsOptionEnabled("Mod Player Health") and ((Player:HealthPercentage() / 100) + ModifierPlayerHealth) or 1) *
        (IsOptionEnabled("Mod Blackout Combo") and
        (Player:Buff(BlackoutComboBuff) and 1 + ModifierBlackoutComboActive or 1) or
        1) /
        (IsOptionEnabled("Mod Brew Charges") and ((RemainingBrewCharges) / (ModifierBrewCharges * 5)) or 1) *
        (IsOptionEnabled("Mod ISB Remains") and (ModifierISBRemains - (self:IronskinBrewRemainsFractional() / 3)) or
        1)
        return math.floor(FinalStaggerValue * 10) / 10
    elseif GetOptionValue("Purifying") == "Static" then
        if (PurifyingBrew:FractionalCharges() <= 3 and PurifyingBrew:FractionalCharges() >= 2.85) then
            return GetOptionValue("Purifying Brew 3")
        elseif PurifyingBrew:FractionalCharges() < 3 and PurifyingBrew:FractionalCharges() >= 1.85 then
            return GetOptionValue("Purifying Brew 2")
        elseif PurifyingBrew:Charges() <= 1 then
            return GetOptionValue("Purifying Brew 1")
        end
    end
end
function Rotation:OffGCDAbilitiesBeta()
    if StaggerPauseSingle then
        if Player:Buff(BlackoutComboBuff) and IronskinBrew:Charges() > 0 and IronskinBrew:TimeSinceCast() >= 0.5 then
            Bug("Stagger Pause via StaggerPauseSingle macro.")
            Player:Cast(IronskinBrew)
            IronskinBrew.LastCastTime = GetTime()
            RandomOffGCD = nil
            StaggerPauseSingle = false
            return
        end
        return
    end
    if IsOptionEnabled("自动取消保护之手") and Player:BuffRemainsAny(HandOfProtection) <= 10 - GetOptionValue("自动取消保护之手") then
        RunMacroText("/cancelaura " .. HandOfProtectionName)
    end
    if Provoke:Exists() and Player:TauntManager(Provoke, "嚎镇八方", Target, TauntEnemies, PlayerPet) then
        return
    end
    CurrentStagger = Player:Stagger()
    self.ShouldPurify = CurrentStagger >= self.CalculatedPurifyValue
    RandomOffGCD = RandomOffGCD or math.random(35, 115) * 0.01
    if
    Target:Exists() and Player:IsWithinCastRange(Target, TigerPalm) and IronskinBrew:Exists() and
    IronskinBrew:TimeSinceCast() > 0.4 and
    self:IronskinBrewRemainsFractional() <= GetSecondOptionValue("ISB Maximum Remains")
    then
        if
        (not BlackoutCombo:Exists() or not IsOptionEnabled("No BoC ISB") or
        (IsOptionEnabled("No BoC ISB") and not Player:Buff(BlackoutComboBuff))) and
        Player:CanCast(IronskinBrew)
        then
            Bug("Emergency: Apply ISB. Fractional ISB: " .. self:IronskinBrewRemainsFractional())
            IronskinBrew.LastCastTime = GetTime()
            Player:Cast(IronskinBrew)
            RandomOffGCD = nil
            return
        end
    end
    if
    PurifyingBrew:Exists() and IsOptionEnabled("Purifying") and PurifyingBrew:TimeSinceCast() > 0.4 and
    Player:CanCast(PurifyingBrew)
    then
        if
        (GetOptionValue("Purifying") == "自动" and self.ShouldPurify) or
        (GetOptionValue("Purifying") == "Static" and
        ((IsOptionEnabled("Purifying Brew 3") and
        (PurifyingBrew:FractionalCharges() <= 3 and PurifyingBrew:FractionalCharges() >= 2.85) and
        CurrentStagger >= GetOptionValue("Purifying Brew 3")) or
        (IsOptionEnabled("Purifying Brew 2") and
        (PurifyingBrew:FractionalCharges() < 3 and PurifyingBrew:FractionalCharges() >= 1.85) and
        CurrentStagger >= GetOptionValue("Purifying Brew 2")) or
        (IsOptionEnabled("Purifying Brew 1") and PurifyingBrew:Charges() == 1 and
        CurrentStagger >= GetOptionValue("Purifying Brew 1"))))
        then
            Bug("Mitigation via Purifying Brew with " .. CurrentStagger .. "%.")
            PurifyingBrew.LastCastTime = GetTime()
            Player:Cast(PurifyingBrew)
            RandomOffGCD = nil
            return
        end
    end
    if Target:Exists() and TigerPalm:Cooldown() < RandomOffGCD and Player:IsWithinCastRange(Target, TigerPalm) then
        if
        not (BlackoutCombo:Exists() and (GetOptionValue("幻灭连击") == "Keg Smash" or GetOptionValue("幻灭连击") == "自动") and
        Player:Buff(BlackoutComboBuff) and
        KegSmash:Cooldown() < 2.5)
        then
            if
            BlackOxBrew:Exists() and IsOptionEnabled("玄牛酒") and PurifyingBrew:Charges() < 1 and
            PurifyingBrew:Recharge() > GetOptionValue("玄牛酒") and
            Player:CanCast(BlackOxBrew)
            then
                Player:Cast(BlackOxBrew)
                return
            end
            if
            IronskinBrew:Exists() and not Player:Buff(BlackoutComboBuff) and IronskinBrew:TimeSinceCast() > 0.4 and
            self:IronskinBrewRemainsFractional() <= GetOptionValue("ISB Maximum Remains")
            then
                if
                not Player:Buff(BlackoutComboBuff) and
                (IronskinBrew:Charges() == MaxBrewCharges or
                (IronskinBrew:Charges() == MaxBrewCharges - 1 and IronskinBrew:Recharge() < 5)) and
                Player:CanCast(IronskinBrew)
                then
                    Bug("Apply ISB. Fractional ISB: " .. self:IronskinBrewRemainsFractional())
                    IronskinBrew.LastCastTime = GetTime()
                    Player:Cast(IronskinBrew)
                    RandomOffGCD = nil
                    return
                end
            end
            if
            IsOptionEnabled("最大限制使用铁骨酒+玄牛酒") and IronskinBrew:Exists() and not Player:Buff(BlackoutComboBuff) and
            BlackOxBrew:Exists() and
            IronskinBrew:TimeSinceCast() > 0.4
            then
                if
                (not BlackOxBrew:IsOnCooldown() and IronskinBrew:Charges() > 0 and
                self:IronskinBrewRemainsFractional() <= 2.6) and
                Player:CanCast(IronskinBrew)
                then
                    Bug("Maximize Ironskin Brew + Black Ox Brew: ISB")
                    IronskinBrew.LastCastTime = GetTime()
                    Player:Cast(IronskinBrew)
                    RandomOffGCD = nil
                    return
                end
                if
                not BlackOxBrew:IsOnCooldown() and IronskinBrew:Charges() < 1 and IronskinBrew:Recharge() > 3 and
                Player:CanCast(BlackOxBrew)
                then
                    Bug("Maximize Ironskin Brew + Black Ox Brew: BoB")
                    Player:Cast(BlackOxBrew)
                    return
                end
            end
        end
    end
end
function Rotation:MaximizeISB(CooldownReduction)
    if
    IsOptionEnabled("智能铁骨酒") and (IsOptionEnabled("最大限制使用铁骨酒") or IsOptionEnabled("最大限制使用铁骨酒+玄牛酒")) and
    IronskinBrew:Exists() and
    not Player:Buff(BlackoutComboBuff)
    then
        if
        (IronskinBrew:Charges() == MaxBrewCharges or
        (IronskinBrew:Charges() == MaxBrewCharges - 1 and IronskinBrew:Recharge() <= CooldownReduction)) and
        Player:CanCast(IronskinBrew) and
        IronskinBrew:TimeSinceCast() > 0.4
        then
            Bug("Maximize Ironskin Brew: smart Keg cooldown reduction handler.")
            IronskinBrew.LastCastTime = GetTime()
            Player:Cast(IronskinBrew)
            return
        end
    end
end
function Rotation:MaximizeISBBeta(CooldownReduction)
    if
    IronskinBrew:Exists() and self:IronskinBrewRemainsFractional() <= GetOptionValue("ISB Maximum Remains") and
    not Player:Buff(BlackoutComboBuff)
    then
        if
        (IronskinBrew:Charges() == MaxBrewCharges or
        (IronskinBrew:Charges() == MaxBrewCharges - 1 and IronskinBrew:Recharge() <= CooldownReduction)) and
        Player:CanCast(IronskinBrew) and
        IronskinBrew:TimeSinceCast() > 0.4
        then
            Bug("Maximize Ironskin Brew: smart Keg cooldown reduction handler.")
            IronskinBrew.LastCastTime = GetTime()
            Player:Cast(IronskinBrew)
            return
        end
    end
end
function Player:Stagger()
    if Player:DebuffAny(HeavyStagger) then
        return math.floor(Player:DebuffValue(HeavyStagger) * 2 / Player:MaxHealth() * 10000) / 100
    elseif Player:DebuffAny(ModerateStagger) then
        return math.floor(Player:DebuffValue(ModerateStagger) * 2 / Player:MaxHealth() * 10000) / 100
    elseif Player:DebuffAny(LightStagger) then
        return math.floor(Player:DebuffValue(LightStagger) * 2 / Player:MaxHealth() * 10000) / 100
    else
        return 0
    end
end
function Player:IsStaggerPausing()
    if StaggerPause then
        if StaggerPause + 3 > GetTime() then
            return true
        end
    end
    return false
end
function Player:StaggerPauseRemains()
    return math.floor(((StaggerPause + 3) - GetTime()) * 100) / 100
end
function Rotation:BaseIronskinBrewDuration()
    return (6 + (PotentKickTrait:ArtifactRank() * 0.5))
end
function Rotation:MaximumIronskinBrewDuration()
    return self:BaseIronskinBrewDuration() * 3
end
function Rotation:IronskinBrewRemainsFractional()
    return Player:BuffRemains(IronskinBrewBuff) / self:BaseIronskinBrewDuration()
end
function Rotation:UnitTables()
    ChiBurstUnits = UseAOE() and ChiBurst:Exists() and #Player:UnitsInFrontRectangle(40, 5) or 0
    BreathOfFireUnits = #Player:UnitsInFrontCone(10, 140)
    KegSmashUnits = Target:EnemiesWithinDistance(8, true) or {}
    Enemies_20y = IsOptionEnabled("使用分筋错骨打断") and Player:EnemiesWithinDistance(20, true) or {}
    Enemies_8y = UseAOE() and Player:EnemiesWithinDistance(8, true) or {}
    NumEnemies = #Enemies_8y
    TauntEnemies = Player:EnemiesWithinDistance(30, false)
end
function Rotation:Combat()
    if
    Effuse:Exists() and Player:Standing() > 0.5 and IsOptionEnabled("真气贯通 自己") and
    Player:HealthPercentage() <= GetOptionValue("真气贯通 自己") and
    Player:CanCast(Effuse)
    then
        Player:Cast(Effuse)
        return
    end
    if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        Player:StartAttack()
        SalsalabimsLostTunicEquipped = SalsalabimsLostTunic:IsEquipped(5)
        if Player:IsWithinCastRange(Target, TigerPalm) then
            if StaggerPauseSingle then
                if BlackoutStrike:Exists() and not Player:Buff(BlackoutComboBuff) and Target:CanCast(BlackoutStrike) then
                    Target:Cast(BlackoutStrike)
                    return
                end
            end
            Player:UsePotions("Agility")
            Player:UseTrinkets()
            if CDOptionEnabled("进攻性种族技能") then
                if BloodFury:Exists() and Player:CanCast(BloodFury) then
                    Player:Cast(BloodFury)
                end
                if Berserking:Exists() and Player:CanCast(Berserking) then
                    CastSpellByID(26297, "player")
                end
                if ArcaneTorrent:Exists() and Player:CanCast(ArcaneTorrent) and Player:Energy() < 60 then
                    Player:Cast(ArcaneTorrent)
                end
            end
            if InvokeNiuzao:Exists() and CDOptionEnabled("玄牛砮皂") and Target:CanCast(InvokeNiuzao) then
                Target:Cast(InvokeNiuzao)
                return
            end
        end
        if
        BreathOfFire:Exists() and KegSmash:Cooldown() >= Player:GCD() and Player:DistanceTo(Target) < 10 and
        Target:Debuff(KegSmash) and
        IsOptionEnabled("火焰之息") and
        (BlackoutCombo:Exists() and not Player:Buff(BlackoutCombo) and IsOptionEnabled("幻灭连击(萨萨拉比姆)") and
        SalsalabimsLostTunicEquipped) and
        BreathOfFireUnits >= GetOptionValue("火焰之息") and
        Player:CanCast(BreathOfFire)
        then
            Bug("Breath of Fire - Salsalabim")
            Player:Cast(BreathOfFire)
            return
        end
        if BlackoutCombo:Exists() and (GetOptionValue("幻灭连击") == "Keg Smash" or GetOptionValue("幻灭连击") == "自动") then
            self:MaximizeISB(7)
            if
            BlackoutStrike:Exists() and not Player:Buff(BlackoutComboBuff) and
            (KegSmash:Cooldown() > 3 or KegSmash:Cooldown() < Player:GCD()) and
            Target:CanCast(BlackoutStrike)
            then
                Target:Cast(BlackoutStrike)
                return
            end
            if
            KegSmash:Exists() and not IsOptionEnabled("禁用醉酿投") and
            (Player:Buff(BlackoutComboBuff) or PurifyingCapped or StaggerPauseSingle) and
            Player:DistanceTo(Target) < 20 and
            Target:CanCast(KegSmash)
            then
                Target:Cast(KegSmash)
                return
            end
        else
            self:MaximizeISB(5)
            if
            KegSmash:Exists() and not IsOptionEnabled("禁用醉酿投") and Player:DistanceTo(Target) < 20 and
            Target:CanCast(KegSmash)
            then
                Target:Cast(KegSmash)
                return
            end
        end
        if
        (KegSmash:Cooldown() < 0.5 and not IsOptionEnabled("禁用醉酿投")) or
        (BlackoutCombo:Exists() and (GetOptionValue("幻灭连击") == "Keg Smash" or GetOptionValue("幻灭连击") == "自动") and
        Player:Buff(BlackoutCombo) and
        KegSmash:Cooldown() < 2 and
        not PurifyingCapped)
        then
            return
        end
        if BlackoutCombo:Exists() then
            if
            GetOptionValue("幻灭连击") == "火焰之息" or
            GetOptionValue("幻灭连击") == "自动" and
            not (IsOptionEnabled("幻灭连击(萨萨拉比姆)") and SalsalabimsLostTunicEquipped)
            then
                if BreathOfFire:Exists() and IsOptionEnabled("火焰之息") and BreathOfFireUnits >= GetOptionValue("火焰之息") then
                    if not Player:Buff(BlackoutComboBuff) and Target:CanCast(BlackoutStrike) then
                        Target:Cast(BlackoutStrike)
                        return
                    end
                    if Player:Buff(BlackoutComboBuff) and Player:CanCast(BreathOfFire) then
                        Player:Cast(BreathOfFire)
                        return
                    end
                end
            end
            if GetOptionValue("幻灭连击") == "猛虎掌" or GetOptionValue("幻灭连击") == "自动" then
                self:MaximizeISB(3)
                if
                BlackoutStrike:Exists() and not Player:Buff(BlackoutComboBuff) and
                (Player:Power() >= 45 or not KegSmash:Exists() or KegSmash:Cooldown() > 3) and
                Target:CanCast(BlackoutStrike)
                then
                    Target:Cast(BlackoutStrike)
                    return
                end
                if Player:Buff(BlackoutComboBuff) and Target:CanCast(TigerPalm) then
                    Target:Cast(TigerPalm)
                    return
                end
            end
        end
        if BlackoutStrike:Exists() and Target:CanCast(BlackoutStrike) then
            Target:Cast(BlackoutStrike)
            return
        end
        if
        BreathOfFire:Exists() and Player:IsWithinCastRange(Target, TigerPalm) and Target:Debuff(KegSmash) and
        IsOptionEnabled("火焰之息") and
        (not BlackoutCombo:Exists() or (GetOptionValue("幻灭连击") ~= "火焰之息" and GetOptionValue("幻灭连击") ~= "自动")) and
        BreathOfFireUnits >= GetOptionValue("火焰之息") and
        Player:CanCast(BreathOfFire)
        then
            Player:Cast(BreathOfFire)
            return
        end
        if
        ChiBurst:Exists() and IsOptionEnabled("真气爆裂") and ChiBurstUnits >= GetOptionValue("真气爆裂") and
        Player:CanCast(ChiBurst)
        then
            Player:Cast(ChiBurst)
            return
        end
        if ChiWave:Exists() and Target:CanCast(ChiWave) then
            Target:Cast(ChiWave)
            return
        end
        if
        RushingJadeWind:Exists() and IsOptionEnabled("碧玉疾风") and NumEnemies >= GetOptionValue("碧玉疾风") and
        Player:CanCast(RushingJadeWind)
        then
            Player:Cast(RushingJadeWind)
            return
        end
        if FlamingKeg:Exists() and IsOptionEnabled("爆炸酒桶") and Target:CanCast(FlamingKeg) then
            if Target:CastGroundSpell(FlamingKeg, "爆炸酒桶", 8) then
                return
            end
        end
        self:MaximizeISB(3)
        if
        TigerPalm:Exists() and
        (not BlackoutCombo:Exists() or (GetOptionValue("幻灭连击") ~= "猛虎掌" and GetOptionValue("幻灭连击") ~= "自动") or
        Player:Power() >= 70) and
        (Player:Power() >= 55 or KegSmash:Cooldown() > 3) and
        Target:CanCast(TigerPalm)
        then
            Target:Cast(TigerPalm)
            return
        end
    end
end
function Rotation:CombatBeta()
    if
    Effuse:Exists() and Player:Standing() > 0.5 and IsOptionEnabled("真气贯通 自己") and
    Player:HealthPercentage() <= GetOptionValue("真气贯通 自己") and
    Player:CanCast(Effuse)
    then
        Player:Cast(Effuse)
        return
    end
    if IsOptionEnabled("使用分筋错骨打断") then
        local FarthestUnit, FarthestUnitDistance, ThisUnit = nil, 0, nil
        for i = 1, #Enemies_20y do
            ThisUnit = Enemies_20y[i]
            if
            not ThisUnit:IsDeadOrGhost() and ThisUnit:IsInCombat() and ThisUnit:IsCasting() and
            ThisUnit:IsInterruptible() and
            ThisUnit:CanCast(Paralysis) and
            Player:IsFacing(ThisUnit) and
            Player:CanAttack(ThisUnit) and
            (FarthestUnit == nil or FarthestUnitDistance < Player:DistanceTo(ThisUnit))
            then
                FarthestUnit = ThisUnit
                FarthestUnitDistance = Player:DistanceTo(ThisUnit)
            end
        end
        if
        FarthestUnit ~= nil and
        (not Player:IsWithinCastRange(FarthestUnit, TigerPalm) or not IsOptionEnabled("打断施法进度介于%") or
        SpearHandStrike:IsOnCooldown())
        then
            Bug("Paralysis - Interrupt")
            FarthestUnit:Cast(Paralysis)
            return
        end
    end
    if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        Player:StartAttack()
        SalsalabimsLostTunicEquipped = SalsalabimsLostTunic:IsEquipped(5)
        if Player:IsWithinCastRange(Target, TigerPalm) then
            if StaggerPauseSingle then
                if BlackoutStrike:Exists() and not Player:Buff(BlackoutComboBuff) and Target:CanCast(BlackoutStrike) then
                    Target:Cast(BlackoutStrike)
                    return
                end
            end
            Player:UsePotions("Agility")
            Player:UseTrinkets()
            if CDOptionEnabled("进攻性种族技能") then
                if BloodFury:Exists() and Player:CanCast(BloodFury) then
                    Player:Cast(BloodFury)
                end
                if Berserking:Exists() and Player:CanCast(Berserking) then
                    CastSpellByID(26297, "player")
                end
                if ArcaneTorrent:Exists() and Player:CanCast(ArcaneTorrent) and Player:Energy() < 60 then
                    Player:Cast(ArcaneTorrent)
                end
            end
            if InvokeNiuzao:Exists() and CDOptionEnabled("玄牛砮皂") and Target:CanCast(InvokeNiuzao) then
                Target:Cast(InvokeNiuzao)
                return
            end
        end
        if BlackoutCombo:Exists() and IsOptionEnabled("BoC Offensive") then
            if FlamingKeg:Exists() and IsOptionEnabled("爆炸酒桶") and Target:CanCast(FlamingKeg) then
                if Target:CastGroundSpell(FlamingKeg, "爆炸酒桶", 8) then
                    return
                end
            end
            if
            KegSmash:Exists() and (not Player:Buff(BlackoutComboBuff) or Player:DistanceTo(Target) >= 8) and
            Player:DistanceTo(Target) < 20 and
            (not StormstoutsLastGasp:IsEquipped() or KegSmash:FractionalCharges() >= 2 or
            (KegSmash:FractionalCharges() >= GetOptionValue("Keg Smash Shoulders") and
            (not SalsalabimsLostTunicEquipped or BreathOfFire:IsOnCooldown()))) and
            Target:CanCast(KegSmash)
            then
                self:MaximizeISBBeta(6)
                Bug("High Prio - Keg Smash.")
                Target:Cast(KegSmash)
                return
            end
            if
            RushingJadeWind:Exists() and IsOptionEnabled("碧玉疾风") and NumEnemies >= GetSecondOptionValue("碧玉疾风") and
            Player:BuffRemains(RushingJadeWind) < self.RJWTimeLeft and
            Player:CanCast(RushingJadeWind)
            then
                Bug("Rushing Jade Wind - High Priority")
                Player:Cast(RushingJadeWind)
                return
            end
            if
            BreathOfFire:Exists() and IsOptionEnabled("BoC Breath High Prio") and
            (not Player:Buff(BlackoutComboBuff) or Player:DistanceTo(Target) >= 8) and
            Player:DistanceTo(Target) < 10 and
            BreathOfFireUnits >= GetOptionValue("BoC Breath High Prio") and
            Player:CanCast(BreathOfFire)
            then
                Bug("High Prio AoE - Breath of Fire.")
                Player:Cast(BreathOfFire)
                return
            end
            if
            BreathOfFire:Exists() and Player:EnergyTimeToX(60) >= Player:GCD() and
            (not Player:Buff(BlackoutComboBuff) or Player:DistanceTo(Target) >= 8) and
            Player:DistanceTo(Target) < 10 and
            Target:Debuff(KegSmash) and
            Player:CanCast(BreathOfFire)
            then
                Bug("Filler or Keep debuff - Breath of Fire.")
                Player:Cast(BreathOfFire)
                return
            end
            if not Player:Buff(BlackoutComboBuff) and Target:CanCast(BlackoutStrike) then
                Target:Cast(BlackoutStrike)
                return
            end
            if Player:Buff(BlackoutComboBuff) and Player:Energy() > 55 and Target:CanCast(TigerPalm) then
                self:MaximizeISBBeta(3)
                Target:Cast(TigerPalm)
                return
            end
            if
            BreathOfFire:Exists() and (not Player:Buff(BlackoutComboBuff) or Player:DistanceTo(Target) >= 8) and
            Player:DistanceTo(Target) < 10 and
            BreathOfFireUnits >= 1 and
            Player:CanCast(BreathOfFire)
            then
                Bug("Low Prio - Breath of Fire.")
                Player:Cast(BreathOfFire)
                return
            end
            if
            ChiBurst:Exists() and IsOptionEnabled("真气爆裂") and ChiBurstUnits >= GetOptionValue("真气爆裂") and
            Player:CanCast(ChiBurst)
            then
                Player:Cast(ChiBurst)
                return
            end
            if ChiWave:Exists() and Target:CanCast(ChiWave) then
                Target:Cast(ChiWave)
                return
            end
            if
            RushingJadeWind:Exists() and IsOptionEnabled("碧玉疾风") and NumEnemies >= GetOptionValue("碧玉疾风") and
            Player:CanCast(RushingJadeWind)
            then
                Bug("Rushing Jade Wind - Low Priority")
                Player:Cast(RushingJadeWind)
                return
            end
            if
            RushingJadeWind:Exists() and IsOptionEnabled("Rushing Jade Wind Filler") and
            Player:CanCast(RushingJadeWind)
            then
                Bug("Rushing Jade Wind - Filler")
                Player:Cast(RushingJadeWind)
                return
            end
            return
        end
        if
        BreathOfFire:Exists() and KegSmash:Cooldown() >= Player:GCD() and Player:DistanceTo(Target) < 10 and
        Target:Debuff(KegSmash) and
        IsOptionEnabled("火焰之息") and
        (BlackoutCombo:Exists() and not Player:Buff(BlackoutCombo) and IsOptionEnabled("幻灭连击(萨萨拉比姆)") and
        SalsalabimsLostTunicEquipped) and
        BreathOfFireUnits >= GetOptionValue("火焰之息") and
        Player:CanCast(BreathOfFire)
        then
            Bug("Breath of Fire - Salsalabim")
            Player:Cast(BreathOfFire)
            return
        end
        if BlackoutCombo:Exists() and (GetOptionValue("幻灭连击") == "Keg Smash" or GetOptionValue("幻灭连击") == "自动") then
            self:MaximizeISBBeta(7)
            if
            BlackoutStrike:Exists() and not Player:Buff(BlackoutComboBuff) and
            (KegSmash:Cooldown() > 3 or KegSmash:Cooldown() < Player:GCD()) and
            Target:CanCast(BlackoutStrike)
            then
                Target:Cast(BlackoutStrike)
                return
            end
            if
            KegSmash:Exists() and not IsOptionEnabled("禁用醉酿投") and
            (Player:Buff(BlackoutComboBuff) or PurifyingCapped or StaggerPauseSingle) and
            Player:DistanceTo(Target) < 20 and
            Target:CanCast(KegSmash)
            then
                Target:Cast(KegSmash)
                return
            end
        else
            if
            KegSmash:Exists() and not IsOptionEnabled("禁用醉酿投") and Player:DistanceTo(Target) < 20 and
            (not StormstoutsLastGasp:IsEquipped() or KegSmash:FractionalCharges() >= 1.5) and
            Target:CanCast(KegSmash)
            then
                self:MaximizeISBBeta(5)
                Target:Cast(KegSmash)
                return
            end
        end
        if
        RushingJadeWind:Exists() and IsOptionEnabled("碧玉疾风") and NumEnemies >= GetSecondOptionValue("碧玉疾风") and
        Player:BuffRemains(RushingJadeWind) < self.RJWTimeLeft and
        Player:CanCast(RushingJadeWind)
        then
            Bug("Rushing Jade Wind - High Priority")
            Player:Cast(RushingJadeWind)
            return
        end
        if
        (KegSmash:IsOnCooldown() and KegSmash:Cooldown() < 0.5 and not IsOptionEnabled("禁用醉酿投") and
        (not StormstoutsLastGasp:IsEquipped() or KegSmash:Charges() >= 1)) or
        (BlackoutCombo:Exists() and (GetOptionValue("幻灭连击") == "Keg Smash" or GetOptionValue("幻灭连击") == "自动") and
        Player:Buff(BlackoutCombo) and
        KegSmash:Cooldown() < 2 and
        not PurifyingCapped)
        then
            Bug("Waiting for Keg Smash Cooldown")
            return
        end
        if BlackoutCombo:Exists() then
            if
            GetOptionValue("幻灭连击") == "火焰之息" or
            GetOptionValue("幻灭连击") == "自动" and
            not (IsOptionEnabled("幻灭连击(萨萨拉比姆)") and SalsalabimsLostTunicEquipped)
            then
                if BreathOfFire:Exists() and IsOptionEnabled("火焰之息") and BreathOfFireUnits >= GetOptionValue("火焰之息") then
                    if not Player:Buff(BlackoutComboBuff) and Target:CanCast(BlackoutStrike) then
                        Target:Cast(BlackoutStrike)
                        return
                    end
                    if Player:Buff(BlackoutComboBuff) and Player:CanCast(BreathOfFire) then
                        Player:Cast(BreathOfFire)
                        return
                    end
                end
            end
            if GetOptionValue("幻灭连击") == "猛虎掌" or GetOptionValue("幻灭连击") == "自动" then
                self:MaximizeISBBeta(3)
                if
                BlackoutStrike:Exists() and not Player:Buff(BlackoutComboBuff) and
                (Player:Power() >= 45 or not KegSmash:Exists() or KegSmash:Cooldown() > 3) and
                Target:CanCast(BlackoutStrike)
                then
                    Target:Cast(BlackoutStrike)
                    return
                end
                if Player:Buff(BlackoutComboBuff) and Target:CanCast(TigerPalm) then
                    Target:Cast(TigerPalm)
                    return
                end
            end
        end
        if
        BreathOfFire:Exists() and Player:IsWithinCastRange(Target, TigerPalm) and Target:Debuff(KegSmash) and
        IsOptionEnabled("火焰之息") and
        (not BlackoutCombo:Exists() or (GetOptionValue("幻灭连击") ~= "火焰之息" and GetOptionValue("幻灭连击") ~= "自动")) and
        Player:CanCast(BreathOfFire)
        then
            if BreathOfFireUnits >= GetSecondOptionValue("火焰之息") then
                Bug("Breath of Fire - High Priority")
                Player:Cast(BreathOfFire)
                return
            end
        end
        if
        TigerPalm:Exists() and IsOptionEnabled("Tiger Palm High Energy") and not BlackoutCombo:Exists() and
        Player:Power() >= GetOptionValue("Tiger Palm High Energy") and
        KegSmash:Cooldown() > 1 and
        Target:CanCast(TigerPalm)
        then
            self:MaximizeISBBeta(3)
            Bug("Tiger Palm - High Energy")
            Target:Cast(TigerPalm)
            return
        end
        if BlackoutStrike:Exists() and Target:CanCast(BlackoutStrike) then
            Target:Cast(BlackoutStrike)
            return
        end
        if
        BreathOfFire:Exists() and Player:IsWithinCastRange(Target, TigerPalm) and Target:Debuff(KegSmash) and
        IsOptionEnabled("火焰之息") and
        (not BlackoutCombo:Exists() or (GetOptionValue("幻灭连击") ~= "火焰之息" and GetOptionValue("幻灭连击") ~= "自动")) and
        Player:CanCast(BreathOfFire)
        then
            if
            BreathOfFireUnits >= GetOptionValue("火焰之息") and
            Target:DebuffRemains(BreathOfFireDebuff) <= self.BOFimeLeft
            then
                Bug("Breath of Fire - Low Priority")
                Player:Cast(BreathOfFire)
                return
            end
        end
        if
        ChiBurst:Exists() and IsOptionEnabled("真气爆裂") and ChiBurstUnits >= GetOptionValue("真气爆裂") and
        Player:CanCast(ChiBurst)
        then
            Player:Cast(ChiBurst)
            return
        end
        if ChiWave:Exists() and Target:CanCast(ChiWave) then
            Target:Cast(ChiWave)
            return
        end
        if
        RushingJadeWind:Exists() and IsOptionEnabled("碧玉疾风") and NumEnemies >= GetOptionValue("碧玉疾风") and
        Player:BuffRemains(RushingJadeWind) < self.RJWTimeLeft and
        Player:CanCast(RushingJadeWind)
        then
            Bug("Rushing Jade Wind - Low Priority")
            Player:Cast(RushingJadeWind)
            return
        end
        if FlamingKeg:Exists() and IsOptionEnabled("爆炸酒桶") and Target:CanCast(FlamingKeg) then
            if Target:CastGroundSpell(FlamingKeg, "爆炸酒桶", 8) then
                return
            end
        end
        if
        BreathOfFire:Exists() and KegSmash:Cooldown() >= Player:GCD() and Player:DistanceTo(Target) < 10 and
        Target:Debuff(KegSmash) and
        IsOptionEnabled("火焰之息") and
        (not BlackoutCombo:Exists() or not Player:Buff(BlackoutCombo)) and
        SalsalabimsLostTunicEquipped and
        BreathOfFireUnits >= GetOptionValue("火焰之息") and
        BlackoutStrike:Cooldown() > 0.5 and
        Player:EnergyTimeToMax() >= 2 and
        Player:CanCast(BreathOfFire)
        then
            Bug("Breath of Fire - Salsalabim")
            Player:Cast(BreathOfFire)
            return
        end
        if
        KegSmash:Exists() and not IsOptionEnabled("禁用醉酿投") and StormstoutsLastGasp:IsEquipped() and
        Player:DistanceTo(Target) < 20 and
        KegSmash:Charges() >= 1 and
        Target:CanCast(KegSmash)
        then
            self:MaximizeISBBeta(5)
            Bug("Keg Smash - With Shoulders - Low Priority")
            Target:Cast(KegSmash)
            return
        end
        self:MaximizeISBBeta(3)
        if
        TigerPalm:Exists() and
        (not BlackoutCombo:Exists() or (GetOptionValue("幻灭连击") ~= "猛虎掌" and GetOptionValue("幻灭连击") ~= "自动") or
        Player:Power() >= 70) and
        (Player:Power() >= 55 or KegSmash:Cooldown() > 2) and
        Target:CanCast(TigerPalm)
        then
            Target:Cast(TigerPalm)
            return
        end
        if RushingJadeWind:Exists() and IsOptionEnabled("Rushing Jade Wind Filler") and Player:CanCast(RushingJadeWind) then
            Bug("Rushing Jade Wind - Filler")
            Player:Cast(RushingJadeWind)
            return
        end
    end
end
function Rotation:OutOfCombat()
    if
    Effuse:Exists() and Player:Standing() > 0.5 and IsOptionEnabled("真气贯通 自己") and
    Player:HealthPercentage() <= GetSecondOptionValue("真气贯通 自己") and
    Player:CanCast(Effuse)
    then
        Player:Cast(Effuse)
        return
    end
    if Target:Exists() and IsOptionEnabled("自动进入战斗") then
        if ChiWave:Exists() and Target:CanCast(ChiWave) then
            Target:Cast(ChiWave)
            return
        end
        if KegSmash:Exists() and Player:DistanceTo(Target) < 20 and Target:CanCast(KegSmash) then
            Target:Cast(KegSmash)
            return
        end
        if TigerPalm:Exists() and Target:CanCast(TigerPalm) then
            Target:Cast(TigerPalm)
            return
        end
    end
end
SetRotation(270, {})
local Rotation = Rotations[270]
function Rotation:Initialize()
    Trinket1 = Item(13, false, false, true)
    Trinket2 = Item(14, false, false, true)
    ArcaneTorrent = Spell(129597, false, false, true)
    Berserking = Spell(26297, false, false, true)
    BloodFury = Spell(33697, false, false, true)
    GiftOfTheNaaru = Spell(121093, false, false, true)
    BlackoutKick = Spell(100784, true, true, true)
    ChiBurst = Spell(123986, false, false, false)
    CracklingJadeLightning = Spell(117952, true, true, false)
    DampenHarm = Spell(122278, false, false, true)
    Detox = Spell(115450, false, false, true)
    DiffuseMagic = Spell(122783, false, false, true)
    Effuse = Spell(116694, false, false, false)
    EnvelopingMist = Spell(124682, false, false, false)
    EssenceFont = Spell(191837, false, false, true)
    HealingElixir = Spell(122281, false, false, true)
    InvokeChiJi = Spell(198664, false, false, true)
    LegSweep = Spell(119381, false, false, true)
    LifeCocoon = Spell(116849, false, false, true)
    LifeCyclesEnvelopingMist = Spell(197919)
    LifeCyclesVifvify = Spell(197916)
    ManaTea = Spell(197908, false, false, true)
    Paralysis = Spell(115078, true, false, true)
    Reawaken = Spell(212051, false, false, false)
    RefreshingJadeWind = Spell(196725, false, false, true)
    RenewingMist = Spell(115151, false, false, true)
    RenewingMistBuff = Spell(119611)
    Resuscitate = Spell(115178, false, false, false)
    Revival = Spell(115310, false, false, true)
    RisingSunKick = Spell(107428, true, true, true)
    RisingThunder = Spell(210804)
    SheilunsGift = Spell(205406, false, false, false)
    ShroudOfMist = Spell(214478)
    SoothingMist = Spell(193884)
    SpinningCraneKick = Spell(101546, false, false, true)
    SpiritOfTheCrane = Spell(210802)
    SummonJadeSerpentStatue = Spell(115313, false, false, true)
    TeachingOfTheMonastery = Spell(202090)
    ThunderFocusTea = Spell(116680, false, false, true)
    TigerPalm = Spell(100780, true, true, true)
    UpliftingTrance = Spell(197206)
    Vivify = Spell(116670, false, false, false)
    ZenPulse = Spell(124081, false, false, true)
    SurgeOfMists = Spell(246328)
    AddPage("常规")
    AddPage("治愈")
    AddPage("大技能")
    AddPage("攻/防")
    AddCommonOptions()
    AddPresetOption("GeneralHealer")
    AddSection("治愈", "通用治疗参数", "Yellow")
    AddNewOption(
    "治愈",
    "真气爆裂",
    222,
    true,
    { 3, 1, 25, 1 },
    { 85, 0, 100, 1 },
    "Use when selected number of units are under health threshold." ..
    C.TOOLTIP_VALUE_1 .. "Number of Units." .. C.TOOLTIP_VALUE_2 .. "Health threshold."
    )
    AddNewOption(
    "治愈",
    "真气贯通",
    222,
    true,
    { 80, 0, 100, 1 },
    { 65, 0, 100, 1 },
    "Use Effuse." ..
    C.TOOLTIP_VALUE_1 ..
    "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid."
    )
    AddNewOption("治愈", "真气贯通填充技能", 210, true, nil, nil, "Use Effuse as filler on the Main Tank.")
    AddNewOption(
    "治愈",
    "氤氲之雾",
    222,
    true,
    { 80, 0, 100, 1 },
    { 15, 0, 100, 1 },
    "Use Enveloping Mist." ..
    C.TOOLTIP_VALUE_1 ..
    "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid."
    )
    AddNewOption(
    "治愈",
    "Enveloping Mist T20",
    222,
    true,
    { 90, 0, 100, 1 },
    { 90, 0, 100, 1 },
    "Use Enveloping Mist with T20 buff at high priority." ..
    C.TOOLTIP_VALUE_1 ..
    "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid."
    )
    AddNewOption(
    "治愈",
    "精华之泉",
    222,
    true,
    { 4, 1, 12, 1 },
    { 85, 0, 100, 1 },
    "Use when selected number of units are under health threshold." ..
    C.TOOLTIP_VALUE_1 .. "Number of Units." .. C.TOOLTIP_VALUE_2 .. "Health threshold."
    )
    AddNewOption(
    "治愈",
    "碧玉疾风",
    222,
    true,
    { 3, 1, 6, 1 },
    { 90, 0, 100, 1 },
    "Use before using Essence Font when selected number of units are under health threshold." ..
    C.TOOLTIP_VALUE_1 .. "Number of Units." .. C.TOOLTIP_VALUE_2 .. "Health threshold."
    )
    AddNewOption(
    "治愈",
    "复苏之雾",
    222,
    true,
    { 99, 0, 100, 1 },
    { 95, 0, 100, 1 },
    "Use Renewing Mist." ..
    C.TOOLTIP_VALUE_1 ..
    "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid."
    )
    AddNewOption(
    "治愈",
    "青龙雕像",
    232,
    true,
    { 2, "Between Player And Tanks", "Centered On Raid" },
    { 20, 1, 25, 1 },
    "Use Summon Jade Serpent Statue." ..
    C.TOOLTIP_VALUE_1 ..
    "Choose preferred mode." ..
    C.TOOLTIP_SUBVALUE("Between Player And Tanks") ..
    "Place the Statue between the player and the tanks." ..
    C.TOOLTIP_SUBVALUE("Centered On Raid") ..
    "Place the Statue so that it can reach as many raid members as possible." ..
    C.TOOLTIP_VALUE_2 ..
    "Replace statue if less than this amount of valid healing units can be found around it. This value is built on an average of 25 players. In Example: If you define the value to 20 and you are in a 5 man group, the statue will be placed on at least 4 players and replaced if the statue can reach less than 4 players." ..
    C.TOOLTIP_HINT(
    "Summon Jade Serpent Statue will only be used when the player and at least one tank are standing."
    )
    )
    AddNewOption(
    "治愈",
    "活血术",
    222,
    true,
    { 3, 1, 3, 1 },
    { 90, 0, 100, 1 },
    "Use when selected number of units are under health threshold." ..
    C.TOOLTIP_VALUE_1 .. "Number of Units." .. C.TOOLTIP_VALUE_2 .. "Health threshold."
    )
    AddNewOption(
    "治愈",
    "禅意波",
    222,
    true,
    { 2, 1, 5, 1 },
    { 90, 0, 100, 1 },
    "Use when selected number of enemy units are around Lowest, OffTank or MainTank that is under health threshold." ..
    C.TOOLTIP_VALUE_1 .. "Number of Enemy Units." .. C.TOOLTIP_VALUE_2 .. "Health threshold."
    )
    AddSection("治愈", "触发管理", "Yellow")
    AddNewOption(
    "治愈",
    "生生不息(氤氲之雾)",
    222,
    true,
    { 85, 0, 100, 1 },
    { 25, 0, 100, 1 },
    "Use Enveloping Mist with Life Cycles." ..
    C.TOOLTIP_VALUE_1 ..
    "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid."
    )
    AddNewOption(
    "治愈",
    "生生不息(活血术)",
    222,
    true,
    { 2, 1, 3, 1 },
    { 90, 0, 100, 1 },
    "Use when selected number of units are under health threshold with Life Cycles." ..
    C.TOOLTIP_VALUE_1 .. "Number of Units." .. C.TOOLTIP_VALUE_2 .. "Health threshold."
    )
    AddNewOption(
    "治愈",
    "升腾(活血术)",
    222,
    true,
    { 2, 1, 3, 1 },
    { 90, 0, 100, 1 },
    "Use when selected number of units are under health threshold  with Uplifting Trance." ..
    C.TOOLTIP_VALUE_1 .. "Number of Units." .. C.TOOLTIP_VALUE_2 .. "Health threshold."
    )
    AddNewOption(
    "治愈",
    "紧急治疗",
    222,
    true,
    { 30, 1, 75, 1 },
    { 45, 1, 75, 1 },
    "Heal the tanks or the player as very high priority when their health is critical." ..
    C.TOOLTIP_VALUE_1 .. "Tanks health threshold." .. C.TOOLTIP_VALUE_2 .. "Player health threshold."
    )
    AddSection("治愈", "主动治疗", "Yellow")
    AddNewOption(
    "治愈",
    "治疗目标",
    230,
    false,
    { 1, "已知单位", "任何单位" },
    nil,
    "Heal our current target if it is listed to be healed." ..
    C.TOOLTIP_VALUE ..
    "Choose preferred mode." ..
    C.TOOLTIP_SUBVALUE("已知单位") ..
    "Allow Heal Target to be used only when we are targetting a unit listed for it." ..
    C.TOOLTIP_SUBVALUE("任何单位") .. "Allow Heal Target to be used on any unit."
    )
    AddNewOption(
    "治愈",
    "团队成员Debuffs",
    220,
    true,
    { 40, 0, 100, 1 },
    nil,
    "Use Renewing Mist on Debuffed units." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddNewOption(
    "治愈",
    "坦克Debuffs",
    220,
    true,
    { 50, 0, 100, 1 },
    nil,
    "Use Renewing Mist on Debuffed tanks." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddNewOption(
    "治愈",
    "Topping",
    220,
    true,
    { 100, 0, 100, 1 },
    nil,
    "Use Renewing Mist/Enveloping Mist/Effuse on units to be topped." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddSection("大技能", "大技能", "Yellow")
    AddNewOption(
    "大技能",
    "朱鹤赤精",
    222,
    true,
    { 3, 1, 25, 1 },
    { 55, 0, 100, 1 },
    "Use when selected number of units are under health threshold." ..
    C.TOOLTIP_VALUE_1 .. "Number of Units." .. C.TOOLTIP_VALUE_2 .. "Health threshold."
    )
    AddNewOption(
    "大技能",
    "作茧缚命",
    222,
    true,
    { 20, 0, 100, 1 },
    { 10, 0, 100, 1 },
    "Use Life Cocoon." ..
    C.TOOLTIP_VALUE_1 ..
    "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid."
    )
    AddNewOption(
    "大技能",
    "法力茶",
    232,
    true,
    { 1, "自动", "精华之泉", "活血术" },
    { 90, 1, 100, 1 },
    "Use with the selected spell when it is about to be casted whenever our mana is under threshold." ..
    C.TOOLTIP_VALUE_1 .. "Spell to use with. Auto will use with both." .. C.TOOLTIP_VALUE_2 .. "Mana threshold."
    )
    AddNewOption(
    "大技能",
    "还魂术",
    222,
    true,
    { 3, 1, 25, 1 },
    { 30, 0, 100, 1 },
    "Use when selected number of units are under health threshold." ..
    C.TOOLTIP_VALUE_1 .. "Number of Units." .. C.TOOLTIP_VALUE_2 .. "Health threshold."
    )
    AddNewOption(
    "大技能",
    "神龙之赐",
    222,
    true,
    { 40, 0, 100, 1 },
    { 15, 0, 100, 1 },
    "Use Sheilun's Gift when we have at least three Clouds." ..
    C.TOOLTIP_VALUE_1 ..
    "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid."
    )
    AddNewOption(
    "大技能",
    "雷光聚神茶",
    233,
    true,
    { 5, "None", "无条件使用", "自动", "真气贯通", "氤氲之雾", "精华之泉", "复苏之雾", "活血术" },
    { 6, "None", "真气贯通", "氤氲之雾", "精华之泉", "复苏之雾", "活血术" },
    "Use with the selected spell when it is about to be casted." ..
    C.TOOLTIP_VALUE_1 ..
    "Define Auto to use it whenever with any listed spell. Define to Always to use it whenever it is ready. Select any other spell to only use it with that particular spell whenever it is ready." ..
    C.TOOLTIP_VALUE_2 ..
    "If not set to Auto or Always, select a second spell to use with whenever it is ready." ..
    C.TOOLTIP_HINT(
    "You can define the option to Auto if you want to use with any spells. In other cases, choose the spells you want to be used with it."
    )
    )
    AddNewOption(
    "大技能",
    "雷光聚神茶配合技能",
    133,
    true,
    { 1, "None", "真气贯通", "氤氲之雾", "精华之泉", "复苏之雾", "活血术" },
    { 1, "None", "真气贯通", "氤氲之雾", "精华之泉", "复苏之雾", "活血术" },
    "Choose more spells to use with Thunder Focus Tea. Only usefull if Thunder Focus Tea's first option not set to Auto or Always." ..
    C.TOOLTIP_VALUE_1 ..
    "Third spell to use with Thunder Focus Tea." ..
    C.TOOLTIP_VALUE_2 .. "Fourth spell to use with Thunder Focus Tea."
    )
    AddSection("攻/防", "进攻", "Yellow")
    AddNewOption(
    "攻/防",
    "目标 | 攻击",
    133,
    true,
    { 4, "禁用", "距离最近", "血量最少", "血量最多", "目标附近" },
    { 2, "禁用", "启用" },
    "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target." ..
    C.TOOLTIP_VALUE_1 ..
    C.TOOLTIP_SUBVALUE("距离最近", true) ..
    "Target the closest enemy." ..
    C.TOOLTIP_SUBVALUE("血量最少") ..
    "Target the enemy with the least health remaining." ..
    C.TOOLTIP_SUBVALUE("血量最多") ..
    "Target the enemy with the most health remaining." ..
    C.TOOLTIP_SUBVALUE("目标附近") ..
    "Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining." ..
    C.TOOLTIP_VALUE_2 ..
    "Enable for the automatic usage of /startattack." ..
    C.TOOLTIP_HINT("/startattack is good for melee classes.")
    )
    AddNewOption(
    "攻/防",
    "自动重设目标",
    232,
    true,
    { 1, "保持", "Switch" },
    { 5, 5, 30, 1 },
    "Enable to auto re-target an unit if you target go out the range set and there is an unit in your melee range." ..
    C.TOOLTIP_VALUE_1 ..
    C.TOOLTIP_SUBVALUE("保持", true) ..
    "Cast on the new unit but keep your target the same." ..
    C.TOOLTIP_SUBVALUE("Switch") ..
    "Cast on the new unit and change your target to this unit." ..
    C.TOOLTIP_VALUE_2 .. "Set the range from wich you want to re-target."
    )
    AddSection("攻/防", "织拳设置", "Yellow")
    AddNewOption(
    "攻/防",
    "织拳",
    222,
    true,
    { 80, 0, 100, 1 },
    { 50, 0, 100, 1 },
    "Enables Fistweaving. This will only use Tiger Palm to get the Teaching of the Monastery buff and then Blackout Kick to trigger the mana regeration from Spirit Of The Crane talent." ..
    C.TOOLTIP_VALUE_1 ..
    "Fistweave if our mana is under this threshold." ..
    C.TOOLTIP_VALUE_2 ..
    "Only Fistweave if the Lowest unit have more than this health threshold." ..
    C.TOOLTIP_HINT(
    "Requires Spirit of the Crane talent. This option is not tied to DPS option."
    )
    )
    AddNewOption(
    "攻/防",
    "Monastery Stack",
    120,
    true,
    { 3, 1, 3, 1 },
    nil,
    "Define at what stacks you want to use Blackout Kick to release the Monastery stacks." ..
    C.TOOLTIP_VALUE ..
    "Amount of Monastery stacks." ..
    C.TOOLTIP_HINT("Requires Spirit of the Crane talent. This option is not tied to DPS option.")
    )
    AddNewOption(
    "攻/防",
    "升腾之雷",
    220,
    true,
    { 50, 0, 100, 1 },
    nil,
    "Enables using Rising Sun Kick to reset Thunder Focus Tea cooldown." ..
    C.TOOLTIP_VALUE ..
    "Only use if the Lowest unit have more than this health threshold." ..
    C.TOOLTIP_HINT("Requires Rising Thunder talent. This option is not tied to DPS option.")
    )
    AddSection("攻/防", "伤害输出", "Yellow")
    AddNewOption(
    "攻/防",
    "DPS",
    220,
    false,
    { 95, 0, 100, 1 },
    nil,
    "Enables DPS options." .. C.TOOLTIP_VALUE .. "Will only DPS if the Lowest unit is above DPS health treshold."
    )
    AddNewOption(
    "攻/防",
    "神鹤引项踢",
    220,
    true,
    { 7, 1, 25, 1 },
    nil,
    "Use Spinning Crane Kick in the DPS rotation." ..
    C.TOOLTIP_VALUE ..
    "Amount of units required to be in 12 yards of Player to use." ..
    C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold")
    )
    AddNewOption(
    "攻/防",
    "猛虎掌",
    210,
    true,
    nil,
    nil,
    "Use Tiger Palm in the DPS rotation." ..
    C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold")
    )
    AddNewOption(
    "攻/防",
    "幻灭踢",
    220,
    true,
    { 3, 0, 3, 1 },
    nil,
    "Use Blackout Kick in the DPS rotation." ..
    C.TOOLTIP_VALUE_1 ..
    "Minimum amount of Monastery stacks. (0 = Use even without it.)" ..
    C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold")
    )
    AddNewOption(
    "攻/防",
    "旭日东升踢",
    210,
    true,
    nil,
    nil,
    "Use Rising Sun Kick in the DPS rotation." ..
    C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold")
    )
    AddSection("攻/防", "防御", "Yellow")
    AddNewOption(
    "攻/防",
    "躯不坏",
    220,
    true,
    { 60, 1, 100, 1 },
    nil,
    "Use Dampen Harm." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddNewOption(
    "攻/防",
    "散魔功",
    220,
    true,
    { 60, 1, 100, 1 },
    nil,
    "Use Diffuse Magic." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    if GiftOfTheNaaru:Exists() then
        AddNewOption(
        "攻/防",
        "纳鲁的赐福",
        222,
        true,
        { 45, 0, 100, 1 },
        { 35, 0, 100, 1 },
        "Use Gift Of The Naaru." ..
        C.TOOLTIP_VALUE_1 ..
        "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid."
        )
    end
    AddNewOption(
    "攻/防",
    "治疗物品",
    220,
    true,
    { 35, 1, 95, 1 },
    nil,
    "Use Healing Belt / Healing Pot / Healthstone." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddOutput("|cFF9A2EFE主T:")
    AddOutput("|cFF9A2EFE副T:")
    AddOutput("|cFF9A2EFE最低:")
    AddOutput("|cFF9A2EFE有害效果:")
    SetOutput("|cFF9A2EFE有害效果:", 0)
    ISCL = {
        [Effuse:ID()] = "真气贯通",
        [EnvelopingMist:ID()] = "氤氲之雾",
        [EssenceFont:ID()] = "精华之泉",
        [SheilunsGift:ID()] = "神龙之赐",
        [Vivify:ID()] = "活血术"
    }
    MistDelay, SoothingUnit, SoothingUnitGUID, SoothingUnitHealth = 0, nil, nil, 100
end
function Rotation:Events()
end
function Rotation:Pulse()
    if Player:IsMounted() or Player:InVehicle() or Player:IsEating() or Player:Channeling(EssenceFont) then
        return
    end
    if BMPullTime() < 5 then
        self:Opening()
        return
    end
    if GetTime() < Rotation.SpamPrevention then
        return
    end
    Rotation.SpamPrevention = GetTime() + 0.05
    Target = Unit.Target
    local InCombat = Player:IsInCombat()
    Rotations:RefreshUnitTables(Rotation.Identifier)
    if not InCombat then
        SetOutput("|cFF9A2EFE有害效果:", 0)
        self:OutOfCombat()
        return
    end
    if InCombat then
        self:Defensives()
    end
    Target = Player:ReTarget(CracklingJadeLightning, false) or Unit.Target
    self:Interrupts()
    self:OffGCDAbilities()
    if Player:GlobalCooldown() == 0 then
        self:Combat()
    end
end
function Rotation:Opening()
    Player:UsePotions("智力药水", GetSecondOptionValue("抢先使用药水"))
    if
    Target:Exists() and IsOptionEnabled("抢先施放(需DBM插件)") and
    (GetOptionValue("抢先施放(需DBM插件)") == "无条件使用" or
    (GetOptionValue("抢先施放(需DBM插件)") == "打BOSS使用" and Target:IsBoss()))
    then
        if
        CracklingJadeLightning:Exists() and BMPullTime() < GetSecondOptionValue("抢先施放(需DBM插件)") and
        Target:CanCast(CracklingJadeLightning)
        then
            Target:Cast(CracklingJadeLightning)
            return
        end
    end
end
function Rotation:Defensives()
    Player:UseHealingItem()
    if
    HealingElixir:Exists() and IsOptionEnabled("金创药") and Player:HealthPercentage() <= GetOptionValue("金创药") and
    Player:CanCast(HealingElixir)
    then
        Player:Cast(HealingElixir)
        return
    end
    if
    DiffuseMagic:Exists() and IsOptionEnabled("散魔功") and Player:HealthPercentage() <= GetOptionValue("散魔功") and
    Player:CanCast(DiffuseMagic)
    then
        Player:Cast(DiffuseMagic)
        return
    end
    if
    DampenHarm:Exists() and IsOptionEnabled("躯不坏") and Player:HealthPercentage() <= GetOptionValue("躯不坏") and
    Player:CanCast(DampenHarm)
    then
        Player:Cast(DampenHarm)
        return
    end
    if GiftOfTheNaaru:Exists() and IsOptionEnabled("纳鲁的赐福") then
        if
        MainTank and MainTank:SpecialHealthPercentage() <= GetOptionValue("纳鲁的赐福") and
        MainTank:CanCast(GiftOfTheNaaru)
        then
            MainTank:Cast(GiftOfTheNaaru)
            return
        elseif
        MainTank and OffTank and OffTank:SpecialHealthPercentage() <= GetOptionValue("纳鲁的赐福") and
        OffTank:CanCast(GiftOfTheNaaru)
        then
            OffTank:Cast(GiftOfTheNaaru)
            return
        elseif
        Lowest and Lowest:SpecialHealthPercentage() <= GetSecondOptionValue("纳鲁的赐福") and
        Lowest:CanCast(GiftOfTheNaaru)
        then
            Lowest:Cast(GiftOfTheNaaru)
            return
        end
    end
end
function Rotation:Interrupts()
    Player:UseInterrupt(Paralysis, ArcaneTorrent)
end
function Rotation:OffGCDAbilities()
    if IsOptionEnabled("延时之力药水") and ProlongedPowerUnitsCount >= GetOptionValue("延时之力药水") then
        Player:UsePotions("延时之力药水")
    end
    Player:UsePotions(GetOptionValue("使用法力药水"))
end
Rotation.TanksStatus, Rotation.MainTankTanking, Rotation.OffTankTanking = {
    Main = { IsTanking = GetTime() },
    Off = { IsTanking = GetTime() }
}
function Rotation:RefreshTanksStatus()
    self.TanksStatus = {
        Main = {
            IsTanking = MainTank and MainTank:ThreatSituation() == 3 and GetTime() or self.TanksStatus.Main.IsTanking
        },
        Off = { IsTanking = OffTank and OffTank:ThreatSituation() == 3 and GetTime() or self.TanksStatus.Off.IsTanking }
    }
    self.MainTankTanking = GetTime() - self.TanksStatus.Main.IsTanking < 3 or false
    self.OffTankTanking = GetTime() - self.TanksStatus.Off.IsTanking < 3 or false
end
function Rotation:HealTarget(ThisUnit)
    if ThisUnit:BuffRemains(RenewingMist) < 2 and ThisUnit:CanCast(RenewingMist) then
        ThisUnit:Cast(RenewingMist)
        return
    end
    if not Player:IsMoving() and ThisUnit:CanCast(Effuse) then
        if
        ThisUnit:SpecialHealthPercentage() < 60 and not ThisUnit:Buff(EnvelopingMist) and
        ThisUnit:CanCast(EnvelopingMist)
        then
            ThisUnit:Cast(EnvelopingMist)
            return
        end
        if ThisUnit:SpecialHealthPercentage() < 100 and SoothingUnitGUID ~= ThisUnit:GUID() and ThisUnit:CanCast(Effuse) then
            ThisUnit:Cast(Effuse)
            return
        end
    end
end
function Rotation:FocusTea(FirstOption, SecondOption)
    Option1, Option2 = GetOptionValue("雷光聚神茶"), GetSecondOptionValue("雷光聚神茶")
    Option3, Option4 = GetOptionValue("雷光聚神茶配合技能"), GetSecondOptionValue("雷光聚神茶配合技能")
    if ThunderFocusTea:Exists() and IsOptionEnabled("雷光聚神茶") then
        if
        (Option1 == FirstOption or Option1 == SecondOption or Option2 == SecondOption or Option3 == SecondOption or
        Option4 == SecondOption) and
        Player:CanCast(ThunderFocusTea)
        then
            ThunderFocusTea.LastCastTime = GetTime()
            Player:Cast(ThunderFocusTea)
        end
    end
end
function Rotation:ManaTeaTalent(FirstOption, SecondOption)
    if
    ManaTea:Exists() and IsOptionEnabled("法力茶") and Player:PowerPercentage() <= GetSecondOptionValue("法力茶") and
    (GetOptionValue("法力茶") == FirstOption or GetOptionValue("法力茶") == SecondOption) and
    Player:CanCast(ManaTea)
    then
        Player:Cast(ManaTea)
    end
end
function Rotation:UnitTables()
    HealUnits = Player:HealUnitsAround(100, 40)
    CurrentBadDebuffs = Player:GetRaidDebuffs(HealUnits)
    if CurrentBadDebuffs ~= nil then
        SetOutput("|cFF9A2EFE有害效果:", #CurrentBadDebuffs.Top + #CurrentBadDebuffs.Debuff)
    end
    DispelUnit = Unit.Dispel(HealUnits, Detox)
    MainTank, MainTankTarget, OffTank, OffTankTarget = Unit.GetMainTanks()
    self:RefreshTanksStatus()
    Lowest = Unit.Lowest(HealUnits)
    SetOutput("|cFF9A2EFE最低:", Lowest and Lowest:Name() or "")
    Trinket1Units =     IsOptionEnabled("使用饰品 1") and Trinket1:IsUsableInventory() and
    #Player:HealUnitsAround(GetSecondOptionValue("使用饰品 1"), 40) or
    0
    Trinket2Units =     IsOptionEnabled("使用饰品 2") and Trinket2:IsUsableInventory() and
    #Player:HealUnitsAround(GetSecondOptionValue("使用饰品 2"), 40) or
    0
    RacialsUnits =     IsOptionEnabled("使用种族技能") and
    ((Berserking:Exists() and Player:CanCast(Berserking)) or (BloodFury:Exists() and Player:CanCast(BloodFury))) and
    #Player:HealUnitsAround(GetOptionValue("使用种族技能"), 40) or
    0
    ProlongedPowerUnitsCount =     IsOptionEnabled("延时之力药水") and #Player:HealUnitsAround(GetSecondOptionValue("延时之力药水"), 40) or 0
    Enemies_8y = UseAOE() and Player:EnemiesWithinDistance(8) or {}
    ChiBurstCount =     ChiBurst:Exists() and IsOptionEnabled("真气爆裂") and ChiBurst:Cooldown() < 2 and
    #Player:UnitsInFrontRectangle(40, 5, true, GetSecondOptionValue("真气爆裂")) or
    0
    EssenceFontCount =     EssenceFont:Exists() and IsOptionEnabled("精华之泉") and EssenceFont:Cooldown() < 2 and
    #Player:HealUnitsAround(GetSecondOptionValue("精华之泉"), 25) or
    0
    RefreshingJadeWindCount =     RefreshingJadeWind:Exists() and IsOptionEnabled("碧玉疾风") and RefreshingJadeWind:Cooldown() < 2 and
    #Player:HealUnitsAround(GetSecondOptionValue("碧玉疾风"), 8) or
    0
    InvokeChiJiCount =     InvokeChiJi:Exists() and IsOptionEnabled("朱鹤赤精") and InvokeChiJi:Cooldown() < 2 and
    #Player:HealUnitsAround(GetSecondOptionValue("朱鹤赤精"), 40) or
    0
    JadeSerpentStatueCount =     SummonJadeSerpentStatue:Exists() and IsOptionEnabled("青龙雕像") and SummonJadeSerpentStatue:Cooldown() < 2 and
    Unit.FriendliesNearMushroom(HealUnits, 40) or
    0
    RevivalCount =     Revival:Exists() and IsOptionEnabled("还魂术") and Revival:Cooldown() < 2 and
    #Player:HealUnitsAround(GetSecondOptionValue("还魂术"), 40) or
    0
    if Vivify:Exists() then
        VivifyUnit =         IsOptionEnabled("活血术") and
        Player:BestClusterOfAlliesToHeal(GetOptionValue("活血术"), GetSecondOptionValue("活血术"), 20) or
        nil
        VivifyCyclesUnit =         IsOptionEnabled("生生不息(活血术)") and Player:Buff(LifeCyclesVifvify) and
        Player:BestClusterOfAlliesToHeal(GetOptionValue("生生不息(活血术)"), GetSecondOptionValue("生生不息(活血术)"), 20) or
        nil
        VivifyUpliftingTranceUnit =         IsOptionEnabled("升腾(活血术)") and Player:Buff(UpliftingTrance) and
        Player:BestClusterOfAlliesToHeal(GetOptionValue("升腾(活血术)"), GetSecondOptionValue("升腾(活血术)"), 20) or
        nil
    else
        VivifyUnit = nil
        VivifyCyclesUnit = nil
        VivifyUpliftingTranceUnit = nil
    end
    if ZenPulse:Exists() and ZenPulse:Cooldown() < 2 then
        ZenPulseMainTankCount =         MainTank and MainTank:SpecialHealthPercentage() <= GetSecondOptionValue("禅意波") and
        #MainTank:EnemiesWithinDistance(8, true) or
        0
        ZenPulseOffTankCount =         OffTank and OffTank:SpecialHealthPercentage() <= GetSecondOptionValue("禅意波") and
        #OffTank:EnemiesWithinDistance(8, true) or
        0
        ZenPulseLowestCount =         Lowest and Lowest:SpecialHealthPercentage() <= GetSecondOptionValue("禅意波") and
        #Lowest:EnemiesWithinDistance(8, true) or
        0
    else
        ZenPulseMainTankCount = 0
        ZenPulseOffTankCount = 0
        ZenPulseLowestCount = 0
    end
end
function Rotation:Combat()
    if Target:Exists() and Target:CanCast(TigerPalm) then
        BestTarget = Target
    elseif MainTankTarget and MainTankTarget:CanCast(TigerPalm) then
        BestTarget = MainTankTarget
    elseif OffTankTarget and OffTankTarget:CanCast(TigerPalm) then
        BestTarget = OffTankTarget
    elseif Mouseover:Exists() and Mouseover:CanCast(TigerPalm) then
        BestTarget = Mouseover
    else
        BestTarget = Target
    end
    if Player:IsInCombat() or GetOptionValue("脱离战斗后暂停治疗") == "启用" then
        if CurrentBadDebuffs ~= nil then
            Player:DispelHandler(Detox, "驱散", DispelUnit, CurrentBadDebuffs.Dispel, "高")
        end
        if
        Target:CanCast(Effuse) and IsOptionEnabled("治疗目标") and
        (GetOptionValue("治疗目标") == 2 or
        (Target:ShouldBeHealed() ~= 0 and Target:HealthPercentage() < Target:ShouldBeHealed()))
        then
            self:HealTarget(Target)
            return
        end
        if IsOptionEnabled("Enveloping Mist T20") and Player:BuffRemains(SurgeOfMists) > EnvelopingMist:CastTime() + 0.1 then
            if
            MainTank and not MainTank:Buff(EnvelopingMist) and
            MainTank:SpecialHealthPercentage() <= GetOptionValue("Enveloping Mist T20") and
            MainTank:CanCast(EnvelopingMist)
            then
                self:FocusTea("自动", "氤氲之雾")
                MistDelay, SoothingUnit = GetTime() + EnvelopingMist:CastTime() + 0.3, MainTank
                MainTank:Cast(EnvelopingMist)
                return
            end
            if
            OffTank and not OffTank:Buff(EnvelopingMist) and
            OffTank:SpecialHealthPercentage() <= GetOptionValue("Enveloping Mist T20") and
            OffTank:CanCast(EnvelopingMist)
            then
                self:FocusTea("自动", "氤氲之雾")
                MistDelay, SoothingUnit = GetTime() + EnvelopingMist:CastTime() + 0.3, OffTank
                OffTank:Cast(EnvelopingMist)
                return
            end
            if
            Lowest and not Lowest:Buff(EnvelopingMist) and
            Lowest:SpecialHealthPercentage() <= GetSecondOptionValue("Enveloping Mist T20") and
            Lowest:CanCast(EnvelopingMist)
            then
                self:FocusTea("自动", "氤氲之雾")
                MistDelay, SoothingUnit = GetTime() + EnvelopingMist:CastTime() + 0.3, Lowest
                Lowest:Cast(EnvelopingMist)
                return
            end
        end
    end
    if Player:IsInCombat() or GetSecondOptionValue("脱离战斗后暂停治疗") == "启用" then
        if
        IsOptionEnabled("DPS") and BestTarget and (not Lowest or Lowest:HealthPercentage() >= GetOptionValue("DPS")) and
        (not MainTank or MainTank:HealthPercentage() >= GetOptionValue("DPS")) and
        (not OffTank or OffTank:HealthPercentage() >= GetOptionValue("DPS")) and
        BestTarget:IsInCombat()
        then
            Player:StartAttack()
            if
            TigerPalm:Exists() and SpiritOfTheCrane:Exists() and not Player:Buff(TeachingOfTheMonastery) and
            IsOptionEnabled("猛虎掌") and
            BestTarget:CanCast(TigerPalm)
            then
                BestTarget:Cast(TigerPalm)
                return
            end
            if
            BlackoutKick:Exists() and IsOptionEnabled("幻灭踢") and
            Player:BuffCount(TeachingOfTheMonastery) >= GetOptionValue("幻灭踢") and
            BestTarget:CanCast(BlackoutKick)
            then
                BestTarget:Cast(BlackoutKick)
                return
            end
            if
            SpinningCraneKick:Exists() and #Enemies_8y >= GetOptionValue("神鹤引项踢") and
            Player:CanCast(SpinningCraneKick)
            then
                Player:Cast(SpinningCraneKick)
                return
            end
            if RisingSunKick:Exists() and IsOptionEnabled("旭日东升踢") and BestTarget:CanCast(RisingSunKick) then
                BestTarget:Cast(RisingSunKick)
                return
            end
            if TigerPalm:Exists() and IsOptionEnabled("猛虎掌") and BestTarget:CanCast(TigerPalm) then
                BestTarget:Cast(TigerPalm)
                return
            end
        end
    end
    if Player:IsInCombat() then
        if IsOptionEnabled("使用种族技能") then
            if RacialsUnits >= GetOptionValue("使用种族技能和饰品的单位数量") then
                if BloodFury:Exists() and Player:CanCast(BloodFury) then
                    Player:Cast(BloodFury)
                    return
                end
                if Berserking:Exists() and Player:CanCast(Berserking) then
                    Player:Cast(Berserking)
                    return
                end
                if
                ArcaneTorrent:Exists() and Player:PowerPercentage() < GetOptionValue("使用种族技能") and
                Player:CanCast(ArcaneTorrent)
                then
                    Player:Cast(ArcaneTorrent)
                    return
                end
            end
        end
        if IsOptionEnabled("使用饰品 1") and Trinket1:IsUsableInventory() then
            local Option1, Option2 = GetOptionValue("使用饰品 1"), GetSecondOptionValue("使用饰品 1")
            if
            Option1 == "无条件使用" or (Option1 == "血量" and Trinket1Units >= GetOptionValue("使用种族技能和饰品的单位数量")) or
            (Option1 == "蓝量" and Player:PowerPercentage() < GetSecondOptionValue("使用饰品 1"))
            then
                Trinket1:UseInventory()
            end
        end
        if IsOptionEnabled("使用饰品 2") and Trinket2:IsUsableInventory() then
            local Option1, Option2 = GetOptionValue("使用饰品 2"), GetSecondOptionValue("使用饰品 2")
            if
            Option1 == "无条件使用" or (Option1 == "血量" and Trinket2Units >= GetOptionValue("使用种族技能和饰品的单位数量")) or
            (Option1 == "蓝量" and Player:PowerPercentage() < GetSecondOptionValue("使用饰品 2"))
            then
                Trinket2:UseInventory()
            end
        end
        if
        Revival:Exists() and IsOptionEnabled("还魂术") and RevivalCount >= GetOptionValue("还魂术") and
        Player:CanCast(Revival)
        then
            Player:Cast(Revival)
            return
        end
        if
        InvokeChiJi:Exists() and IsOptionEnabled("朱鹤赤精") and InvokeChiJiCount >= GetOptionValue("朱鹤赤精") and
        Player:CanCast(InvokeChiJi)
        then
            Player:Cast(InvokeChiJi)
            return
        end
        if SheilunsGift:Exists() and IsOptionEnabled("神龙之赐") and SheilunsGift:Count() >= 3 then
            if
            MainTank and MainTank:SpecialHealthPercentage() <= GetOptionValue("神龙之赐") and
            MainTank:CanCast(SheilunsGift)
            then
                MainTank:Cast(SheilunsGift)
                return
            end
            if OffTank and OffTank:SpecialHealthPercentage() <= GetOptionValue("神龙之赐") and OffTank:CanCast(SheilunsGift) then
                OffTank:Cast(SheilunsGift)
                return
            end
            if
            Lowest and Lowest:SpecialHealthPercentage() <= GetSecondOptionValue("神龙之赐") and
            Lowest:CanCast(SheilunsGift)
            then
                Lowest:Cast(SheilunsGift)
                return
            end
        end
        if LifeCocoon:Exists() and IsOptionEnabled("作茧缚命") then
            if
            MainTank and not MainTank:BuffAny(LifeCocoon) and
            MainTank:SpecialHealthPercentage() <= GetOptionValue("作茧缚命") and
            MainTank:CanCast(LifeCocoon)
            then
                MainTank:Cast(LifeCocoon)
                return
            end
            if
            OffTank and not OffTank:Buff(LifeCocoon) and OffTank:SpecialHealthPercentage() <= GetOptionValue("作茧缚命") and
            OffTank:CanCast(LifeCocoon)
            then
                OffTank:Cast(LifeCocoon)
                return
            end
            if
            Lowest and not Lowest:Buff(LifeCocoon) and
            Lowest:SpecialHealthPercentage() <= GetSecondOptionValue("作茧缚命") and
            Lowest:CanCast(LifeCocoon)
            then
                Lowest:Cast(LifeCocoon)
                return
            end
        end
        self:FocusTea("无条件使用")
    end
    if Player:IsInCombat() or GetOptionValue("脱离战斗后暂停治疗") == "启用" then
        if CurrentBadDebuffs ~= nil then
            Player:DispelHandler(Detox, "驱散", DispelUnit, CurrentBadDebuffs.Dispel, "正常")
        end
        if MistDelay < GetTime() and not Player:Channeling(SoothingMist) then
            MistDelay, SoothingUnit, SoothingUnitGUID, SoothingUnitHealth = 0, nil, nil, 100
        end
        if SoothingUnit then
            SoothingUnitGUID = SoothingUnit:GUID()
            SoothingUnitHealth = SoothingUnit:SpecialHealthPercentage()
        else
            SoothingUnitGUID = "No Soothing"
            SoothingUnitHealth = 100
        end
        if IsOptionEnabled("紧急治疗") then
            MainTankHealth = MainTank and MainTank:CanCast(EnvelopingMist) and MainTank:SpecialHealthPercentage() or 100
            OffTankHealth = OffTank and OffTank:CanCast(EnvelopingMist) and OffTank:SpecialHealthPercentage() or 100
            BestTankTarget = MainTankHealth < OffTankHealth and MainTank or OffTank
            if BestTankTarget and BestTankTarget:SpecialHealthPercentage() < GetOptionValue("紧急治疗") then
                if Player:IsMoving() and BestTankTarget:CanCast(RenewingMist) then
                    Bug("Renewing Mist - Tanks Emergency")
                    BestTankTarget:Cast(RenewingMist)
                    return
                elseif not Player:IsMoving() and BestTankTarget:CanCast(EnvelopingMist) then
                    Bug("Enveloping Mist - Tanks Emergency")
                    MistDelay, SoothingUnit = GetTime() + EnvelopingMist:CastTime() + 0.3, BestTankTarget
                    BestTankTarget:Cast(EnvelopingMist)
                    return
                end
            end
            if Player:SpecialHealthPercentage() < GetSecondOptionValue("紧急治疗") then
                if Player:IsMoving() and Player:CanCast(RenewingMist) then
                    Bug("Renewing Mist - Player Emergency")
                    Player:Cast(RenewingMist)
                    return
                elseif not Player:IsMoving() and Player:CanCast(EnvelopingMist) then
                    Bug("Enveloping Mist - Player Emergency")
                    MistDelay, SoothingUnit = GetTime() + EnvelopingMist:CastTime() + 0.3, Player
                    Player:Cast(EnvelopingMist)
                    return
                end
            end
        end
        if
        SummonJadeSerpentStatue:Exists() and IsOptionEnabled("青龙雕像") and #HealUnits > 1 and not Player:IsMoving() and
        Player:CanCast(SummonJadeSerpentStatue)
        then
            if
            JadeSerpentStatueCount < GetSecondOptionValue("青龙雕像") / 25 and
            #HealUnits >= GetSecondOptionValue("青龙雕像") / 25
            then
                if (GetOptionValue("青龙雕像") == "Between Player And Tanks" and (MainTank or OffTank)) then
                    if (MainTank and not MainTank:IsMoving()) or (OffTank and not OffTank:IsMoving()) then
                        TheseHealUnits =                         MainTank and OffTank and { Player, MainTank, OffTank } or MainTank and { Player, MainTank } or
                        OffTank and { Player, OffTank }
                        Player:CastGroundHeal(SummonJadeSerpentStatue, TheseHealUnits)
                        return
                    end
                else
                    if
                    (MainTank and not MainTank:IsMoving()) or (OffTank and not OffTank:IsMoving()) or
                    (not MainTank and not OffTank)
                    then
                        Player:CastGroundHeal(SummonJadeSerpentStatue, HealUnits)
                        return
                    end
                end
            end
        end
        if
        RisingThunder:Exists() and RisingSunKick:Exists() and IsOptionEnabled("升腾之雷") and
        not Player:Buff(ThunderFocusTea) and
        ThunderFocusTea:Cooldown() > 5 and
        (not CurrentBadDebuffs or #CurrentBadDebuffs.Top == 0) and
        BestTarget and
        (not Lowest or Lowest:HealthPercentage() >= GetOptionValue("升腾之雷")) and
        (not MainTank or MainTank:HealthPercentage() >= GetOptionValue("升腾之雷")) and
        (not OffTank or OffTank:HealthPercentage() >= GetOptionValue("升腾之雷")) and
        BestTarget:IsInCombat() and
        BestTarget:CanCast(RisingSunKick)
        then
            BestTarget:Cast(RisingSunKick)
            return
        end
        if
        SpiritOfTheCrane:Exists() and IsOptionEnabled("织拳") and
        (not CurrentBadDebuffs or #CurrentBadDebuffs.Top == 0) and
        Player:PowerPercentage() <= GetOptionValue("织拳") and
        BestTarget and
        (not Lowest or Lowest:HealthPercentage() >= GetSecondOptionValue("织拳")) and
        (not MainTank or MainTank:HealthPercentage() >= GetSecondOptionValue("织拳")) and
        (not OffTank or OffTank:HealthPercentage() >= GetSecondOptionValue("织拳")) and
        BestTarget:IsInCombat()
        then
            if
            BlackoutKick:Exists() and Player:BuffCount(TeachingOfTheMonastery) >= GetOptionValue("Monastery Stack") and
            BestTarget:CanCast(BlackoutKick)
            then
                BlackoutKick.LastCastTime = GetTime()
                BestTarget:Cast(BlackoutKick)
                return
            end
            if TigerPalm:Exists() and BlackoutKick:Exists() and BestTarget:CanCast(TigerPalm) then
                BestTarget:Cast(TigerPalm)
                return
            end
        end
        if RenewingMist:Exists() and IsOptionEnabled("复苏之雾") then
            if
            MainTank and MainTank:SpecialHealthPercentage() < GetOptionValue("复苏之雾") and
            MainTank:BuffRemains(RenewingMistBuff) <= 5 and
            MainTank:CanCast(RenewingMist)
            then
                self:FocusTea("自动", "复苏之雾")
                MainTank:Cast(RenewingMist)
                return
            end
            if
            OffTank and OffTank:SpecialHealthPercentage() < GetOptionValue("复苏之雾") and
            OffTank:BuffRemains(RenewingMistBuff) <= 5 and
            OffTank:CanCast(RenewingMist)
            then
                self:FocusTea("自动", "复苏之雾")
                OffTank:Cast(RenewingMist)
                return
            end
        end
        if EnvelopingMist:Exists() and IsOptionEnabled("氤氲之雾") then
            if
            MainTank and not MainTank:Buff(EnvelopingMist) and
            MainTank:SpecialHealthPercentage() <= GetOptionValue("氤氲之雾") and
            MainTank:CanCast(EnvelopingMist)
            then
                self:FocusTea("自动", "氤氲之雾")
                MistDelay, SoothingUnit = GetTime() + EnvelopingMist:CastTime() + 0.3, MainTank
                MainTank:Cast(EnvelopingMist)
                return
            end
            if
            OffTank and not OffTank:Buff(EnvelopingMist) and
            OffTank:SpecialHealthPercentage() <= GetOptionValue("氤氲之雾") and
            OffTank:CanCast(EnvelopingMist)
            then
                self:FocusTea("自动", "氤氲之雾")
                MistDelay, SoothingUnit = GetTime() + EnvelopingMist:CastTime() + 0.3, OffTank
                OffTank:Cast(EnvelopingMist)
                return
            end
        end
        if EnvelopingMist:Exists() and IsOptionEnabled("生生不息(氤氲之雾)") and Player:Buff(LifeCyclesEnvelopingMist) then
            if
            MainTank and not MainTank:Buff(EnvelopingMist) and
            MainTank:SpecialHealthPercentage() <= GetOptionValue("生生不息(氤氲之雾)") and
            MainTank:CanCast(EnvelopingMist)
            then
                self:FocusTea("自动", "氤氲之雾")
                MistDelay, SoothingUnit = GetTime() + EnvelopingMist:CastTime() + 0.3, MainTank
                MainTank:Cast(EnvelopingMist)
                return
            end
            if
            OffTank and not OffTank:Buff(EnvelopingMist) and
            OffTank:SpecialHealthPercentage() <= GetOptionValue("生生不息(氤氲之雾)") and
            OffTank:CanCast(EnvelopingMist)
            then
                self:FocusTea("自动", "氤氲之雾")
                MistDelay, SoothingUnit = GetTime() + EnvelopingMist:CastTime() + 0.3, OffTank
                OffTank:Cast(EnvelopingMist)
                return
            end
            if
            Lowest and not Lowest:Buff(EnvelopingMist) and
            Lowest:SpecialHealthPercentage() <= GetSecondOptionValue("生生不息(氤氲之雾)") and
            Lowest:CanCast(EnvelopingMist)
            then
                self:FocusTea("自动", "氤氲之雾")
                MistDelay, SoothingUnit = GetTime() + EnvelopingMist:CastTime() + 0.3, Lowest
                Lowest:Cast(EnvelopingMist)
                return
            end
        end
        if
        RefreshingJadeWind:Exists() and IsOptionEnabled("碧玉疾风") and
        RefreshingJadeWindCount >= GetOptionValue("碧玉疾风") and
        Player:CanCast(RefreshingJadeWind)
        then
            Player:Cast(RefreshingJadeWind)
            return
        end
        if EssenceFont:Exists() and IsOptionEnabled("精华之泉") and EssenceFontCount >= GetOptionValue("精华之泉") then
            if Player:Channeling(EssenceFont) then
                return
            else
                if Player:CanCast(EssenceFont) then
                    if Player:IsMoving() then
                        self:FocusTea("自动", "精华之泉")
                    end
                    self:ManaTeaTalent("自动", "精华之泉")
                    Player:Cast(EssenceFont)
                    return
                end
            end
        end
        if Player:IsInCombat() and RenewingMist:Exists() and IsOptionEnabled("复苏之雾") then
            local BestUnit, BestUnitHealth, ThisUnit, ThisUnitHealth, HealthThreshold =             nil,
            100,
            nil,
            nil,
            GetSecondOptionValue("复苏之雾")
            for i = 1, #HealUnits do
                ThisUnit, ThisUnitHealth = HealUnits[i], HealUnits[i]:SpecialHealthPercentage()
                if
                ThisUnitHealth <= HealthThreshold and ThisUnitHealth <= BestUnitHealth and
                ThisUnit:CanCast(RenewingMist) and
                ThisUnit:BuffRemains(RenewingMistBuff) < 3
                then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth
                end
            end
            if BestUnit then
                self:FocusTea("自动", "复苏之雾")
                BestUnit:Cast(RenewingMist)
                return
            end
        end
        if EnvelopingMist:Exists() and IsOptionEnabled("氤氲之雾") then
            if
            Lowest and not Lowest:Buff(EnvelopingMist) and
            Lowest:SpecialHealthPercentage() <= GetSecondOptionValue("氤氲之雾") and
            Lowest:CanCast(EnvelopingMist)
            then
                self:FocusTea("自动", "氤氲之雾")
                MistDelay, SoothingUnit = GetTime() + EnvelopingMist:CastTime() + 0.3, Lowest
                Lowest:Cast(EnvelopingMist)
                return
            end
        end
        if IsOptionEnabled("生生不息(活血术)") and VivifyCyclesUnit and VivifyCyclesUnit:CanCast(Vivify) then
            self:FocusTea("自动", "活血术")
            self:ManaTeaTalent("自动", "活血术")
            MistDelay, SoothingUnit = GetTime() + Vivify:CastTime() + 0.3, VivifyCyclesUnit
            VivifyCyclesUnit:Cast(Vivify)
            return
        end
        if IsOptionEnabled("升腾(活血术)") and VivifyUpliftingTranceUnit and VivifyUpliftingTranceUnit:CanCast(Vivify) then
            self:FocusTea("自动", "活血术")
            self:ManaTeaTalent("自动", "活血术")
            MistDelay, SoothingUnit = GetTime() + Vivify:CastTime() + 0.3, VivifyUpliftingTranceUnit
            VivifyUpliftingTranceUnit:Cast(Vivify)
            return
        end
        if IsOptionEnabled("活血术") and VivifyUnit and VivifyUnit:CanCast(Vivify) then
            self:FocusTea("自动", "活血术")
            self:ManaTeaTalent("自动", "活血术")
            MistDelay, SoothingUnit = GetTime() + Vivify:CastTime() + 0.3, VivifyUnit
            VivifyUnit:Cast(Vivify)
            return
        end
        if
        ChiBurst:Exists() and IsOptionEnabled("真气爆裂") and ChiBurstCount >= GetOptionValue("真气爆裂") and
        Player:CanCast(ChiBurst)
        then
            Player:Cast(ChiBurst)
            return
        end
        if ZenPulse:Exists() and IsOptionEnabled("禅意波") then
            if MainTank and ZenPulseMainTankCount >= GetOptionValue("禅意波") and MainTank:CanCast(ZenPulse) then
                MainTank:Cast(ZenPulse)
                return
            end
            if OffTank and ZenPulseOffTankCount >= GetOptionValue("禅意波") and OffTank:CanCast(ZenPulse) then
                OffTank:Cast(ZenPulse)
                return
            end
            if Lowest and ZenPulseLowestCount >= GetOptionValue("禅意波") and Lowest:CanCast(ZenPulse) then
                Lowest:Cast(ZenPulse)
                return
            end
        end
        if Effuse:Exists() and IsOptionEnabled("真气贯通") and not Player:IsMoving() then
            if
            MainTank and SoothingUnitGUID ~= MainTank:GUID() and
            MainTank:SpecialHealthPercentage() <= GetOptionValue("真气贯通") and
            MainTank:SpecialHealthPercentage() <= SoothingUnitHealth - 15 and
            MainTank:CanCast(Effuse)
            then
                Bug("Effuse - Main Tank")
                self:FocusTea("自动", "真气贯通")
                MistDelay, SoothingUnit = GetTime() + Effuse:CastTime() + 0.3, MainTank
                MainTank:Cast(Effuse)
                return
            end
            if
            OffTank and SoothingUnitGUID ~= OffTank:GUID() and
            OffTank:SpecialHealthPercentage() <= GetOptionValue("真气贯通") and
            OffTank:SpecialHealthPercentage() <= SoothingUnitHealth - 15 and
            OffTank:CanCast(Effuse)
            then
                Bug("Effuse - Offtank")
                self:FocusTea("自动", "真气贯通")
                MistDelay, SoothingUnit = GetTime() + Effuse:CastTime() + 0.3, OffTank
                OffTank:Cast(Effuse)
                return
            end
        end
        if RenewingMist:Exists() and IsOptionEnabled("坦克Debuffs") and CurrentBadDebuffs and #CurrentBadDebuffs.Tanks > 0 then
            local BestUnit, BestUnitHealth = nil, 100
            for i = 1, #CurrentBadDebuffs.Tanks do
                local ThisUnit, ThisUnitHealth =                 CurrentBadDebuffs.Tanks[i],
                CurrentBadDebuffs.Tanks[i]:SpecialHealthPercentage()
                if
                ThisUnit:CanCast(RenewingMist) and not ThisUnit:Buff(RenewingMist) and
                (BestUnit == nil or ThisUnitHealth < BestUnitHealth)
                then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth
                end
            end
            if BestUnit ~= nil and BestUnitHealth < GetOptionValue("坦克Debuffs") then
                self:FocusTea("自动", "复苏之雾")
                Bug("Renewing Mist on " .. BestUnit:Name() .. " to heal tank debuff")
                BestUnit:Cast(RenewingMist)
                return
            end
        end
        if
        RenewingMist:Exists() and IsOptionEnabled("团队成员Debuffs") and CurrentBadDebuffs and
        #CurrentBadDebuffs.Debuff > 0
        then
            local BestUnit, BestUnitHealth = nil, 100
            for i = 1, #CurrentBadDebuffs.Debuff do
                local ThisUnit, ThisUnitHealth =                 CurrentBadDebuffs.Debuff[i],
                CurrentBadDebuffs.Debuff[i]:SpecialHealthPercentage()
                if
                ThisUnit:CanCast(RenewingMist) and not ThisUnit:Buff(RenewingMist) and
                (BestUnit == nil or ThisUnitHealth < BestUnitHealth)
                then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth
                end
            end
            if BestUnit ~= nil and BestUnitHealth < GetOptionValue("团队成员Debuffs") then
                self:FocusTea("自动", "复苏之雾")
                Bug("Renewing Mist on " .. BestUnit:Name() .. " to mitigate debuff")
                BestUnit:Cast(RenewingMist)
                return
            end
        end
        if IsOptionEnabled("Topping") and CurrentBadDebuffs and #CurrentBadDebuffs.Top > 0 then
            local BestUnit, BestUnitHealth = nil, 100
            for i = 1, #CurrentBadDebuffs.Top do
                local ThisUnit, ThisUnitHealth =                 CurrentBadDebuffs.Top[i],
                CurrentBadDebuffs.Top[i]:SpecialHealthPercentage()
                if ThisUnit:CanCast(Effuse) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth
                end
            end
            if BestUnit ~= nil then
                if
                RenewingMist:Exists() and BestUnitHealth <= GetOptionValue("Topping") and
                not BestUnit:Buff(RenewingMist) and
                BestUnit:CanCast(RenewingMist)
                then
                    self:FocusTea("自动", "复苏之雾")
                    Bug("Renewing Mist on " .. BestUnit:Name() .. " to top it")
                    BestUnit:Cast(RenewingMist)
                    return
                end
                if
                EnvelopingMist:Exists() and BestUnitHealth <= GetOptionValue("Topping") and
                not BestUnit:Buff(EnvelopingMist) and
                BestUnit:CanCast(EnvelopingMist)
                then
                    self:FocusTea("自动", "氤氲之雾")
                    Bug("Enveloping Mist on " .. BestUnit:Name() .. " to top it")
                    MistDelay, SoothingUnit = GetTime() + Effuse:CastTime() + 0.3, BestUnit
                    BestUnit:Cast(EnvelopingMist)
                    return
                end
                if
                Effuse:Exists() and SoothingUnitGUID ~= BestUnit:GUID() and
                BestUnitHealth <= GetOptionValue("Topping") and
                BestUnit:CanCast(Effuse)
                then
                    self:FocusTea("自动", "真气贯通")
                    Bug("Effuse on " .. BestUnit:Name() .. " to top it")
                    MistDelay, SoothingUnit = GetTime() + Effuse:CastTime() + 0.3, BestUnit
                    BestUnit:Cast(Effuse)
                    return
                end
            end
        end
        if Effuse:Exists() and IsOptionEnabled("真气贯通") then
            if
            Lowest and SoothingUnitGUID ~= Lowest:GUID() and
            Lowest:SpecialHealthPercentage() <= GetSecondOptionValue("真气贯通") and
            Lowest:SpecialHealthPercentage() <= SoothingUnitHealth - 25 and
            Lowest:CanCast(Effuse)
            then
                Bug("Effuse - Low Prio")
                MistDelay, SoothingUnit = GetTime() + Effuse:CastTime() + 0.3, Lowest
                Lowest:Cast(Effuse)
                return
            end
        end
        if
        Effuse:Exists() and IsOptionEnabled("真气贯通填充技能") and MainTank and self.MainTankTanking and
        SoothingUnitGUID ~= MainTank:GUID() and
        MainTank:CanCast(Effuse)
        then
            Bug("Effuse - Filler")
            MistDelay, SoothingUnit = GetTime() + Effuse:CastTime() + 0.3, MainTank
            MainTank:Cast(Effuse)
            return
        end
        if
        Effuse:Exists() and IsOptionEnabled("真气贯通填充技能") and OffTank and self.OffTankTanking and
        SoothingUnitGUID ~= OffTank:GUID() and
        OffTank:CanCast(Effuse)
        then
            Bug("Effuse - Filler")
            MistDelay, SoothingUnit = GetTime() + Effuse:CastTime() + 0.3, OffTank
            OffTank:Cast(Effuse)
            return
        end
    end
end
function Rotation:OutOfCombat()
    if IsOptionEnabled("Resuscitate") and Unit.ResurrectCycle(Resuscitate) then
        return
    end
    if IsOptionEnabled("脱离战斗后暂停治疗") then
        self:Combat()
    end
end
SetRotation(269, {})
local Rotation = Rotations[269]
function Rotation:Initialize()
    self.HasBetaRotation = true
    ArcaneTorrent = Spell(129597, false, false, true)
    Berserking = Spell(26297, false, false, true)
    BloodFury = Spell(33697, false, false, true)
    GiftOfTheNaaru = Spell(121093, false, false, true)
    QuackingPalm = Spell(107079, false, true, true)
    Ascension = Spell(115396)
    BlackoutKick = Spell(100784, true, true, true)
    BlackoutKickBuff = Spell(116768)
    ChiBurst = Spell(123986, false, false, false)
    ChiWave = Spell(115098, false, true, true)
    ChiWaveSelf = Spell(115098, false, false, true)
    ComboBreaker = Spell(116768, false, false, false)
    CracklingJadeLightning = Spell(117952, true, true, true)
    DampenHarm = Spell(122278, false, false, true)
    Detox = Spell(115450, false, false, true)
    DiffuseMagic = Spell(122783, false, false, true)
    Effuse = Spell(116694, false, false, true)
    EnergizingElixir = Spell(115288, false, false, true)
    FistsOfFury = Spell(113656, true, true, true)
    FlyingSerpentKick = Spell(101545)
    GaleBurst = Spell(195399)
    HealingElixir = Spell(122281, false, false, true)
    HitCombo = Spell(196741)
    InvokeXuen = Spell(123904, false, true, true)
    MarkOfTheCrane = Spell(228287)
    Paralysis = Spell(115078, false, true, true)
    PowerStrikes = Spell(121817)
    PressurePoint = Spell(247255)
    Resuscitate = Spell(115178, false, false, true, true)
    RisingSunKick = Spell(107428, true, true, true)
    RushingJadeWind = Spell(116847, false, false, true)
    Serenity = Spell(152173, false, false, true)
    SpearHandStrike = Spell(116705, true, true, true)
    SpinningCraneKick = Spell(101546, false, false, true)
    StrikeOfTheWindlord = Spell(205320, true, true, true)
    StormEarthAndFire = Spell(137639, false, true, true)
    StormEarthAndFireFixate = Spell(221771, false, true, true)
    TigerPalm = Spell(100780, true, true, true)
    TouchOfDeath = Spell(115080, true, true, true)
    TouchOfKarma = Spell(122470, true, true, true)
    WhirlingDragonPunch = Spell(152175, false, false, true)
    DrinkingHornCover = Item(137097)
    HiddenMastersForbiddenTouch = Item(137057)
    KatsuosEclipse = Item(137029)
    ConvergenceOfFates = Item(140806)
    TheEmperorsCapacitor = Item(144239)
    TheEmperorsCapacitorBuff = Spell(235054)
    CJLWithTheEmperorsCapacitor = false
    PowerOfAThousandCranes = Spell(195269)
    AddPage("常规")
    AddPage("进攻")
    AddPage("防御")
    AddPage("附加")
    if self.HasBetaRotation then
        AddNewOption(
        "常规",
        "测试版循环",
        210,
        true,
        nil,
        nil,
        "Use the lastest updated combat routine. May not be as optimized and can contain error regarding execution!"
        )
    end
    AddCommonOptions()
    AddPresetOption("常规", "Melee", nil, true)
    AddNewOption("常规", "分筋错骨打断施法", 210, false, nil, nil, "Enable to also use Paralysis to interrupt.")
    if QuackingPalm:Exists() then
        AddNewOption("常规", "震山掌打断施法", 210, false, nil, nil, "Enable to also use Paralysis to interrupt.")
    end
    AddPresetOption("进攻")
    AddSection("进攻", "大技能", "Yellow")
    AddPresetOption("Cooldown", "豪能酒", 1)
    AddPresetOption(
    "Cooldown",
    "怒雷破",
    1,
    { 1, 1, 10, 1 },
    "Amount of units that needs to be in 9 yards in front of player to use."
    )
    AddNewOption(
    "进攻",
    "怒雷破血量",
    120,
    true,
    { 3, 1, 100, 0.1 },
    nil,
    "Minimum Health of the current target (in millions) to use Fist of Fury. Does not apply to dummies or Boss1 unit."
    )
    AddPresetOption("Cooldown", "白虎下凡")
    AddPresetOption("Cooldown", "屏气凝神")
    AddPresetOption(
    "Cooldown",
    "风火雷电",
    nil,
    { 1, "Assist", "正常" },
    "Choose if you want the Storm, Earth, and Fire to assist you or not."
    )
    AddNewOption(
    "进攻",
    "近战范围风火雷电",
    210,
    true,
    nil,
    nil,
    "Use Storm, Earth and Fire and Serenity only when in melee range."
    )
    AddPresetOption(
    "Cooldown",
    "风领主之击",
    1,
    { 1, 1, 10, 1 },
    "Amount of units that needs to be in 9 yards in front of player to use."
    )
    AddPresetOption(
    "Cooldown",
    "轮回之触",
    nil,
    { 10, 0, 50, 0.5 },
    "Minimum amount of health (in millions) the unit must have."
    )
    AddPresetOption(
    "Cooldown",
    "升龙霸",
    1,
    { 1, 1, 10, 1 },
    "Amount of units that needs to be in 5 yards around player to use."
    )
    AddSection("进攻", "能力", "Yellow")
    AddNewOption(
    "进攻",
    "真气爆裂",
    220,
    true,
    { 1, 1, 5, 1 },
    nil,
    "Use Chi Burst." ..
    C.TOOLTIP_VALUE ..
    "Minimum number of units that needs to be in a 40 yards long 10 yards wide path in front of Player to use Chi Burst." ..
    C.TOOLTIP_HINT(
    "We need to be standing for at least 0.5s before it can happen and it is low priority."
    )
    )
    AddNewOption(
    "进攻",
    "真气波",
    220,
    true,
    { 1, 1, 10, 1 },
    nil,
    "Use Chi Wave" .. C.TOOLTIP_VALUE .. "Minimum number of units that needs to be in a 40 yards "
    )
    AddNewOption(
    "进攻",
    "碎玉闪电",
    220,
    true,
    { 1.3, 0.3, 3, 0.1 },
    nil,
    "Use Cracling Jade Lightning while not moving and not in melee range." ..
    C.TOOLTIP_VALUE .. "Set the minimum standing time to start using it."
    )
    AddNewOption(
    "进攻",
    "连招填充",
    130,
    true,
    { 1, "自动", "碎玉闪电", "Flying Serpent Kick", "猛虎掌" },
    nil,
    "Use a Filler to prevent losing Hit Combo after Blackout Kick while we have already too much Chi to use Tiger Palm." ..
    C.TOOLTIP_VALUE ..
    "Choose the spell you would like to use as filler." ..
    C.TOOLTIP_HINT(
    "Auto will use Flying Serpent Kick if it is ready or Crackling Jade Lightning otherwise. Tiger Palm will always be used as fallback when we are moving or Flying Serpent Kick is on cooldown."
    )
    )
    AddNewOption(
    "进攻",
    "多重神鹤印记",
    222,
    true,
    { 12, 1, 20, 1 },
    { 0, 0, 25, 0.1 },
    "Enable Tiger Palm, Blackout Kick and Rising Sun Kick Cycle for Mark of the Cranes debuffs." ..
    C.TOOLTIP_VALUE_1 ..
    "Amount of dots to apply." .. C.TOOLTIP_VALUE_2 .. "Minimum health (in million) to apply."
    )
    AddNewOption(
    "进攻",
    "皇帝的容电皮甲",
    230,
    true,
    { 2, "无条件使用", "大技能用法" },
    nil,
    "Crackling Jade Lightning with The Emperor's Capacitor buff when at max charges." ..
    C.TOOLTIP_VALUE_1 ..
    C.TOOLTIP_SUBVALUE("无条件使用", true) ..
    "Will use the ability even if CDs are disabled." ..
    C.TOOLTIP_SUBVALUE("大技能用法") .. "Will only use the ability if CDs are enabled."
    )
    AddPresetOption("防御")
    AddSection("防御", "能力", "Yellow")
    AddNewOption(
    "防御",
    "真气贯通 自己",
    222,
    true,
    { 30, 1, 100, 1 },
    { 80, 1, 100, 1 },
    "Use Effuse on ourself." ..
    C.TOOLTIP_VALUE_1 ..
    "Health threshold while In Combat." .. C.TOOLTIP_VALUE_2 .. "Health threshold while Out of Combat."
    )
    AddNewOption(
    "防御",
    "业报之触",
    220,
    true,
    { 70, 0, 100, 1 },
    nil,
    "Use Touch Of Karma." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddSection("防御", "大技能", "Yellow")
    AddNewOption(
    "防御",
    "躯不坏",
    220,
    true,
    { 35, 0, 100, 1 },
    nil,
    "Use Dampen Harm." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddNewOption(
    "防御",
    "散魔功",
    220,
    true,
    { 35, 0, 100, 1 },
    nil,
    "Use Diffuse Magic." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddNewOption(
    "防御",
    "金创药",
    220,
    true,
    { 35, 0, 100, 1 },
    nil,
    "Use Healing Elixir." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddSection("附加", "神鹤引项踢", "Yellow")
    AddNewOption(
    "附加",
    "优先施放神鹤引项踢",
    210,
    false,
    nil,
    nil,
    "Enables the use of Spinning Crane Kick over other abilities if it's going to do more more damage." ..
    C.TOOLTIP_HINT("Only for experienced user who know what they are doing !")
    )
    AddNewOption(
    "附加",
    "神鹤引项踢 > 幻灭踢",
    120,
    nil,
    { 500, 0, 2000, 1 },
    nil,
    "Use Spinning Crane Kick above Blackout Kick if SCK % goes above given value." ..
    C.TOOLTIP_VALUE .. "% at which SCK replaces BoK."
    )
    AddNewOption(
    "附加",
    "神鹤引项踢 > 旭日东升踢",
    120,
    nil,
    { 796, 0, 2000, 1 },
    nil,
    "Use Spinning Crane Kick above Rising Sun Kick if SCK % goes above given value." ..
    C.TOOLTIP_VALUE .. "% at which SCK replaces RSK."
    )
    RegisterCommand(
    "fsk",
    function()
        if FlyingSerpentKick:Exists() then
            if ShouldFlyingSerpentKick == true then
                ShouldFlyingSerpentKick = false
                Bug("Flying Serpent Kick Queue Canceled")
            else
                ShouldFlyingSerpentKick = true
                Bug("Flying Serpent Kick Queued")
            end
        else
            Bug("You do not have Flying Serpent Kick.")
        end
    end
    )
    ClassColor = "|c" .. _G["RAID_CLASS_COLORS"]["MONK"]["colorStr"]
    AddOutput(ClassColor .. "神鹤引项踢伤害提升")
    SetOutput(ClassColor .. "神鹤引项踢伤害提升", "0%")
end
function Rotation:UseBetaRotation()
    return self.HasBetaRotation and IsOptionEnabled("测试版循环")
end
function Rotation:Events()
    local MasteryComboTriggers = {
        [100780] = "猛虎掌",
        [100784] = "幻灭踢",
        [101546] = "神鹤引项踢",
        [107428] = "旭日东升踢",
        [113656] = "Fists Of Fury",
        [115080] = "轮回之触",
        [115098] = "真气波",
        [116847] = "碧玉疾风",
        [117952] = "碎玉闪电",
        [123986] = "真气爆裂",
        [152175] = "升龙霸",
        [205320] = "风领主之击"
    }
    EventFrame:RegisterForSelfCombatEvent(
    function(...)
        if GetSpecialization() == 3 then
            SpellID = select(12, ...)
            if MasteryComboTriggers[SpellID] then
                Bug("Combo triggered by " .. tostring(MasteryComboTriggers[SpellID]) .. ".")
                LastComboSpellID = SpellID
            end
            if SpellID == 101545 and FlyingSerpentKickQueued then
                Player:Cast(Spell(115057))
                FlyingSerpentKickQueued = false
                ShouldFlyingSerpentKick = false
            end
        end
    end,
    "SPELL_CAST_SUCCESS"
    )
    EventFrame:RegisterForEvent(
    function(...)
        if GetSpecialization() == 3 then
            SpellID = select(5, ...)
            if SpellID == 115057 then
                Bug("Combo triggered by Flying Serpent Kick.")
                LastComboSpellID = SpellID
            end
        end
    end,
    "UNIT_SPELLCAST_SUCCEEDED"
    )
    EventFrame:RegisterForEvent(
    function(...)
        if GetSpecialization() == 3 then
            SourceGUID, _, _, _, SpellID = ...
            if SourceGUID == "player" and SpellID == 117952 then
                Bug("CJL Channel Stop.")
                CJLWithTheEmperorsCapacitor = false
            end
        end
    end,
    "UNIT_SPELLCAST_CHANNEL_STOP"
    )
end
function Rotation:Pulse()
    if Player:Channeling(CracklingJadeLightning) and Player:IsWithinCastRange(Target, TigerPalm) then
        if CJLWithTheEmperorsCapacitor then
            return
        end
        SpellStopCasting()
        return
    end
    if
    Player:Channeling(FistsOfFury) and
    (Player:HasHero() or not StrikeOfTheWindlordEnemies or StrikeOfTheWindlordEnemies < 3) and
    Player:Buff(Serenity) and
    Player:IsWithinCastRange(Target, RisingSunKick) and
    HasT20_4Pc and
    Target:CanCast(RisingSunKick)
    then
        SpellStopCasting()
        return
    end
    if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
        return
    end
    if Target:Exists() and BMPullTime() < 5 then
        self:Opening()
        return
    end
    if GetTime() < Rotation.SpamPrevention then
        return
    end
    Rotation.SpamPrevention = GetTime() + 0.05
    Target = Unit.Target
    local InCombat = Player:IsInCombat()
    if not InCombat then
        self:OutOfCombat()
        return
    end
    if InCombat then
        self:Defensives()
    end
    Target = Player:ReTarget(TigerPalm, false) or Unit.Target
    if Target:Exists() then
        Rotations:RefreshUnitTables(Rotation.Identifier)
        self:Interrupts()
        if
        IsOptionEnabled("开怪技能") and
        (GetOptionValue("开怪技能") == "无条件使用" or (GetOptionValue("开怪技能") == "打BOSS使用" and Target:IsBoss()) or
        (GetOptionValue("开怪技能") == "大技能用法" and CooldownsAllowed())) and
        not OpenerEnded
        then
            self:Opener()
            return
        elseif CombatTime() > 10 then
            OpenerEnded = true
        end
        self:OffGCDAbilities()
        if Player:GlobalCooldown() == 0 then
            if self:UseBetaRotation() then
                self:CombatBeta()
            else
                self:Combat()
            end
        end
    end
end
function Rotation:Opening()
    Player:UsePotions("Agility")
    if
    IsOptionEnabled("抢先施放(需DBM插件)") and
    (GetOptionValue("抢先施放(需DBM插件)") == "无条件使用" or
    (GetOptionValue("抢先施放(需DBM插件)") == "打BOSS使用" and Target:IsBoss()))
    then
        if BMPullTime() < GetSecondOptionValue("抢先施放(需DBM插件)") then
            Player:StartAttack()
        end
        if
        ChiWaveSelf:Exists() and BMPullTime() < GetSecondOptionValue("抢先施放(需DBM插件)") + 16.5 and
        BMPullTime() > GetSecondOptionValue("抢先施放(需DBM插件)") + 15 and
        LastComboSpellID ~= ChiWaveSelf:ID() and
        Player:DistanceTo(Target) > 26 and
        Player:CanCast(ChiWaveSelf)
        then
            Player:Cast(ChiWaveSelf)
            return
        end
        if
        FlyingSerpentKick:Exists() and
        (BMPullTime() < GetSecondOptionValue("抢先施放(需DBM插件)") + 2 or
        (Player:BuffRemains(HitCombo) > 0.5 and Player:BuffRemains(HitCombo) < 1.25)) and
        LastComboSpellID ~= FlyingSerpentKick:ID() and
        Player:CanCast(FlyingSerpentKick)
        then
            self:FlyingSerpentKickMacro()
            return
        end
        if ChiWave:Exists() and BMPullTime() < GetSecondOptionValue("抢先施放(需DBM插件)") and Target:CanCast(ChiWave) then
            Target:Cast(ChiWave)
            return
        end
    end
end
function Rotation:Opener()
    self.ChoosenOpener = nil
    if Serenity:Exists() and EnergizingElixir:Exists() then
        self.ChoosenOpener = {
            [1] = { EnergizingElixir, Player, true },
            [2] = { TouchOfDeath, Target, true },
            [3] = { Serenity, Player, true },
            [4] = { "Trinkets" },
            [5] = { "Racials", { BloodFury, Berserking } },
            [6] = { RisingSunKick, Target, Player:Chi() >= 2 or Player:Buff(Serenity), not Player:Buff(Serenity) },
            [7] = { StrikeOfTheWindlord, Target, Player:Chi() >= 2 or Player:Buff(Serenity), not Player:Buff(Serenity) },
            [8] = {
                FistsOfFury,
                Target,
                Player:Chi() >= 3 - (KatsuosEclipse:IsEquipped(8) and 1 or 0) or Player:Buff(Serenity),
                not Player:Buff(Serenity)
            },
            [9] = { RisingSunKick, Target, Player:Chi() >= 2 or Player:Buff(Serenity), not Player:Buff(Serenity) },
            [10] = { SpinningCraneKick, Player, Player:Chi() >= 3 or Player:Buff(Serenity), not Player:Buff(Serenity) },
            [11] = { BlackoutKick, Target, Player:Chi() >= 1 or Player:Buff(Serenity), not Player:Buff(Serenity) },
            [12] = { RisingSunKick, Target, Player:Chi() >= 2 or Player:Buff(Serenity), not Player:Buff(Serenity) },
            [13] = "Serenity+EE Opener"
        }
    end
    if Serenity:Exists() and EnergizingElixir:Exists() and KatsuosEclipse:IsEquipped(8) and HasT20_4Pc then
        self.ChoosenOpener = {
            [1] = { TigerPalm, Target, true },
            [2] = { FistsOfFury, Target, true },
            [3] = { TouchOfDeath, Target, true },
            [4] = { Serenity, Player, true },
            [5] = { "Trinkets" },
            [6] = { "Racials", { BloodFury, Berserking } },
            [7] = { RisingSunKick, Target, Player:Chi() >= 2 or Player:Buff(Serenity) ~= nil, not Player:Buff(Serenity) },
            [8] = {
                StrikeOfTheWindlord,
                Target,
                Player:Chi() >= 2 or Player:Buff(Serenity) ~= nil,
                not Player:Buff(Serenity)
            },
            [9] = {
                FistsOfFury,
                Target,
                Player:Chi() >= 3 - (KatsuosEclipse:IsEquipped(8) and 1 or 0) or Player:Buff(Serenity) ~= nil,
                not Player:Buff(Serenity)
            },
            [10] = { RisingSunKick, Target, Player:Chi() >= 2 or Player:Buff(Serenity) ~= nil, not Player:Buff(Serenity) },
            [11] = {
                SpinningCraneKick,
                Player,
                Player:Chi() >= 3 or Player:Buff(Serenity) ~= nil,
                not Player:Buff(Serenity)
            },
            [12] = { BlackoutKick, Target, Player:Chi() >= 1 or Player:Buff(Serenity) ~= nil, not Player:Buff(Serenity) },
            [13] = { RisingSunKick, Target, Player:Chi() >= 2 or Player:Buff(Serenity) ~= nil, not Player:Buff(Serenity) },
            [14] = "Serenity+EE Opener"
        }
    end
    if Serenity:Exists() and EnergizingElixir:Exists() and HasT20_4Pc then
        self.ChoosenOpener = {
            [1] = { EnergizingElixir, Player, true },
            [2] = { TigerPalm, Target, true },
            [3] = { FistsOfFury, Target, true },
            [4] = { TouchOfDeath, Target, true },
            [5] = { Serenity, Player, true },
            [6] = { "Trinkets" },
            [7] = { "Racials", { BloodFury, Berserking } },
            [8] = { RisingSunKick, Target, Player:Chi() >= 2 or Player:Buff(Serenity) ~= nil, not Player:Buff(Serenity) },
            [9] = {
                StrikeOfTheWindlord,
                Target,
                Player:Chi() >= 2 or Player:Buff(Serenity) ~= nil,
                not Player:Buff(Serenity)
            },
            [10] = {
                FistsOfFury,
                Target,
                Player:Chi() >= 3 - (KatsuosEclipse:IsEquipped(8) and 1 or 0) or Player:Buff(Serenity) ~= nil,
                not Player:Buff(Serenity)
            },
            [11] = { RisingSunKick, Target, Player:Chi() >= 2 or Player:Buff(Serenity) ~= nil, not Player:Buff(Serenity) },
            [12] = {
                SpinningCraneKick,
                Player,
                Player:Chi() >= 3 or Player:Buff(Serenity) ~= nil,
                not Player:Buff(Serenity)
            },
            [13] = { BlackoutKick, Target, Player:Chi() >= 1 or Player:Buff(Serenity) ~= nil, not Player:Buff(Serenity) },
            [14] = { RisingSunKick, Target, Player:Chi() >= 2 or Player:Buff(Serenity) ~= nil, not Player:Buff(Serenity) },
            [15] = "Serenity+EE Opener"
        }
    end
    if Serenity:Exists() and not EnergizingElixir:Exists() then
        self.ChoosenOpener = {
            [1] = { TigerPalm, Target, Player:Energy() >= 50 },
            [2] = { TouchOfDeath, Target, true },
            [3] = { Serenity, Player, true },
            [4] = { "Trinkets" },
            [5] = { "Racials", { ArcaneTorrent, BloodFury, Berserking } },
            [6] = { RisingSunKick, Target, Player:Chi() >= 2 or Player:Buff(Serenity), not Player:Buff(Serenity) },
            [7] = { StrikeOfTheWindlord, Target, Player:Chi() >= 2 or Player:Buff(Serenity), not Player:Buff(Serenity) },
            [8] = {
                FistsOfFury,
                Target,
                Player:Chi() >= 3 - (KatsuosEclipse:IsEquipped(8) and 1 or 0) or Player:Buff(Serenity),
                not Player:Buff(Serenity)
            },
            [9] = { RisingSunKick, Target, Player:Chi() >= 2 or Player:Buff(Serenity), not Player:Buff(Serenity) },
            [10] = { SpinningCraneKick, Player, Player:Chi() >= 3 or Player:Buff(Serenity), not Player:Buff(Serenity) },
            [11] = { BlackoutKick, Target, Player:Chi() >= 1 or Player:Buff(Serenity), not Player:Buff(Serenity) },
            [12] = { RisingSunKick, Target, Player:Chi() >= 2 or Player:Buff(Serenity), not Player:Buff(Serenity) },
            [13] = "Serenity Opener"
        }
    end
    if WhirlingDragonPunch:Exists() and EnergizingElixir:Exists() then
        self.ChoosenOpener = {
            [1] = { TigerPalm, Target, Player:Energy() >= 50 },
            [2] = { TouchOfDeath, Target, true },
            [3] = { StormEarthAndFire, Target, true },
            [4] = { "Trinkets" },
            [5] = { "Racials", { ArcaneTorrent, BloodFury, Berserking } },
            [6] = { RisingSunKick, Target, Player:Chi() >= 2 },
            [7] = { EnergizingElixir, Player, true },
            [8] = { StrikeOfTheWindlord, Target, Player:Chi() >= 2 },
            [9] = { FistsOfFury, Target, Player:Chi() >= 3 - (KatsuosEclipse:IsEquipped(8) and 1 or 0) },
            [10] = { TigerPalm, Target, Player:Energy() >= 50 },
            [11] = { WhirlingDragonPunch, Player, RisingSunKick:IsOnCooldown() and FistsOfFury:IsOnCooldown() },
            [12] = { RisingSunKick, Target, Player:Chi() >= 2 },
            [13] = "WDP+EE Opener"
        }
    end
    if WhirlingDragonPunch:Exists() and PowerStrikes:Exists() then
        self.ChoosenOpener = {
            [1] = { TigerPalm, Target, Player:Energy() >= 50 },
            [2] = { TouchOfDeath, Target, true },
            [3] = { StormEarthAndFire, Target, true },
            [4] = { "Trinkets" },
            [5] = { "Racials", { ArcaneTorrent, BloodFury, Berserking } },
            [6] = { TigerPalm, Target, Player:Energy() >= 50 },
            [7] = { StrikeOfTheWindlord, Target, Player:Chi() >= 2 },
            [8] = { FistsOfFury, Target, Player:Chi() >= 3 - (KatsuosEclipse:IsEquipped(8) and 1 or 0) },
            [9] = { TigerPalm, Target, Player:Energy() >= 50 },
            [10] = { RisingSunKick, Target, Player:Chi() >= 2 },
            [11] = { WhirlingDragonPunch, Player, RisingSunKick:IsOnCooldown() and FistsOfFury:IsOnCooldown() },
            [12] = { TigerPalm, Target, Player:Energy() >= 50 },
            [13] = "WDP+PS Opener"
        }
    end
    if self.ChoosenOpener ~= nil then
        OpenerParser(self.ChoosenOpener)
    else
        Bug("Invalid Talents combination, Opener will not be used.")
        OpenerEnded = true
    end
end
function Rotation:Defensives()
    Player:UseHealingItem()
    if
    HealingElixir:Exists() and IsOptionEnabled("金创药") and Player:HealthPercentage() <= GetOptionValue("金创药") and
    Player:CanCast(HealingElixir)
    then
        Player:Cast(HealingElixir)
        return
    end
    if
    DampenHarm:Exists() and IsOptionEnabled("躯不坏") and Player:HealthPercentage() <= GetOptionValue("躯不坏") and
    Player:CanCast(DampenHarm)
    then
        Player:Cast(DampenHarm)
        return
    end
    if
    DiffuseMagic:Exists() and IsOptionEnabled("散魔功") and Player:HealthPercentage() <= GetOptionValue("散魔功") and
    Player:CanCast(DiffuseMagic)
    then
        Player:Cast(DiffuseMagic)
        return
    end
    if
    TouchOfKarma:Exists() and IsOptionEnabled("业报之触") and Player:HealthPercentage() <= GetOptionValue("业报之触") and
    Target:CanCast(TouchOfKarma)
    then
        Target:Cast(TouchOfKarma)
        return
    end
    if
    GiftOfTheNaaru:Exists() and IsOptionEnabled("纳鲁的赐福") and Player:HealthPercentage() <= GetOptionValue("纳鲁的赐福") and
    Player:CanCast(GiftOfTheNaaru)
    then
        Player:Cast(GiftOfTheNaaru)
        return
    end
end
function Rotation:Interrupts()
    Player:UseInterrupt(SpearHandStrike, ArcaneTorrent)
    if
    IsOptionEnabled("分筋错骨打断施法") and (not SpearHandStrike:Exists() or SpearHandStrike:IsOnCooldown()) and
    (not ArcaneTorrent:Exists() or not IsOptionEnabled("Arcane Torrent Interrupt") or
    ArcaneTorrent:IsOnCooldown()) and
    Paralysis:Exists()
    then
        Player:UseInterrupt(Paralysis, nil)
    end
    if
    IsOptionEnabled("震山掌打断施法") and (not SpearHandStrike:Exists() or SpearHandStrike:IsOnCooldown()) and
    (not ArcaneTorrent:Exists() or not IsOptionEnabled("Arcane Torrent Interrupt") or
    ArcaneTorrent:IsOnCooldown()) and
    (not Paralysis:Exists() or not IsOptionEnabled("分筋错骨打断施法") or Paralysis:IsOnCooldown()) and
    QuackingPalm:Exists()
    then
        Player:UseInterrupt(QuackingPalm, nil)
    end
end
function Rotation:OffGCDAbilities()
    if
    StormEarthAndFire:Exists() and (GetSecondOptionValue("风火雷电") == "Assist" or not UseAOE()) and
    StormEarthAndFire:TimeSinceCast() > 1 and
    StormEarthAndFire:TimeSinceCast() < 15 and
    Target:Exists() and
    StormEarthAndFireTargetGUID ~= Target:GUID() and
    Target:CanCast(StormEarthAndFireFixate)
    then
        Bug("Storm, Earth, and Fire - Assist.")
        StormEarthAndFireTargetGUID = Target:GUID()
        Target:Cast(StormEarthAndFireFixate)
    end
end
function Rotation:Cooldowns()
    if InvokeXuen:Exists() and CDOptionEnabled("白虎下凡") and Target:CanCast(InvokeXuen) then
        Target:Cast(InvokeXuen)
        return
    end
    Player:UseTrinkets()
    if CDOptionEnabled("进攻性种族技能") then
        if BloodFury:Exists() and Player:CanCast(BloodFury) then
            Player:Cast(BloodFury)
        end
        if Berserking:Exists() and Player:CanCast(Berserking) then
            Player:Cast(Berserking)
        end
        if
        ArcaneTorrent:Exists() and not StormEarthAndFire:Exists() and ChiMax - Chi >= 1 and
        Player:CanCast(ArcaneTorrent)
        then
            Player:Cast(ArcaneTorrent)
        end
    end
    if
    TouchOfDeath:Exists() and CDOptionEnabled("轮回之触") and not TouchOfDeath:IsOnCooldown() and
    LastComboSpellID ~= TouchOfDeath:ID()
    then
        TouchOfDeathMinHealth = GetSecondOptionValue("轮回之触") * 1000000
        if Target:Health() > TouchOfDeathMinHealth and not Target:Debuff(TouchOfDeath) and Target:CanCast(TouchOfDeath) then
            Target:Cast(TouchOfDeath)
            return
        else
            local ThisUnit
            for i = 1, #Enemies_5y do
                ThisUnit = Enemies_5y[i]
                if
                ThisUnit:Health() > TouchOfDeathMinHealth and not ThisUnit:Debuff(TouchOfDeath) and
                ThisUnit:CanCast(TouchOfDeath)
                then
                    ThisUnit:Cast(TouchOfDeath)
                    return
                end
            end
        end
    end
end
function Rotation:FlyingSerpentKickMacro()
    if Player:CanCast(FlyingSerpentKick) then
        FlyingSerpentKickQueued = true
        Player:Cast(FlyingSerpentKick)
        return
    end
end
function Rotation:UnitTables()
    ChiBurstUnits = UseAOE() and ChiBurst:Exists() and #Player:UnitsInFrontRectangle(40, 5) or 0
    StrikeOfTheWindlordEnemies = UseAOE() and #Player:UnitsInFrontCone(9, 140) or 0
    Enemies_40y = UseAOE() and Player:EnemiesWithinDistance(40, true) or {}
    ChiWaveUnits = #Enemies_40y
    Enemies_8y = UseAOE() and Player:FilterEnemiesByDistance(Enemies_40y, 8, true) or {}
    Enemies_5y = UseAOE() and Player:FilterEnemiesByDistance(Enemies_8y, 5, false) or {}
    MarkOfTheCranesCount = UseAOE() and #Player:FilterEnemiesByDebuff(Enemies_8y, MarkOfTheCrane) or 0
    MarkOfTheCraneUnit = Unit.DotCycle(Enemies_5y, TigerPalm, MarkOfTheCrane, 20, "多重神鹤印记")
    if not UseAOE() and Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        Enemies_5y = Player:IsWithinCastRange(Target, TigerPalm) and { Target } or Enemies_5y
        Enemies_8y = Player:DistanceTo(Target) <= 8 and { Target } or Enemies_8y
        StrikeOfTheWindlordEnemies = #Player:UnitsInFrontCone(9, 140) > 0 and 1 or 0
        ChiWaveUnits = #Enemies_5y
    end
end
function Rotation:Combat()
    if
    Effuse:Exists() and Player:Standing() > 0.5 and IsOptionEnabled("真气贯通 自己") and
    Player:HealthPercentage() <= GetOptionValue("真气贯通 自己") and
    Player:CanCast(Effuse)
    then
        Player:Cast(Effuse)
        return
    end
    ChiMax, Chi, EnergyRegen, EnergyTimeToMax =     Player:ChiMax(),
    Player:Chi(),
    Player:EnergyRegen(),
    Player:EnergyTimeToMax()
    ConvergenceOfFatesEquipped = ConvergenceOfFates:IsEquipped(13, 14)
    if ShouldFlyingSerpentKick then
        self:FlyingSerpentKickMacro()
    end
    if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        Player:StartAttack()
        TargetHealth = not Target:IsDummy() and not Target:GUID() == Boss1:GUID() and Target:Health() or 200000000
        FistOfFuryHealth = GetOptionValue("怒雷破血量") * 1000000
        SpinningCraneKickDamage =         IsOptionEnabled("优先施放神鹤引项踢") and
        (133.3 * 1.08 * (1 + (PowerOfAThousandCranes:ArtifactRank() / 30)) * (1 + (MarkOfTheCranesCount * 0.4)) *
        #Enemies_8y) or
        0
        SetOutput(ClassColor .. "神鹤引项踢伤害提升", SpinningCraneKickDamage .. "%")
        SerenityCooldown = Serenity:Exists() and CDOptionEnabled("屏气凝神") and Serenity:Cooldown() or 100
        FistsOfFuryCooldown =         FistsOfFury:Exists() and CDOptionEnabled("怒雷破") and
        StrikeOfTheWindlordEnemies >= GetSecondOptionValue("怒雷破") and
        FistsOfFury:Cooldown() or
        0
        if Player:Buff(Serenity) or Player:Buff(StormEarthAndFire) or Player:HasHero() then
            Player:UsePotions("Agility")
        end
        if
        (SerenityCooldown == 0 or Player:Buff(Serenity)) and
        (not IsOptionEnabled("近战范围风火雷电") or
        (IsOptionEnabled("近战范围风火雷电") and Player:IsWithinCastRange(Target, TigerPalm)))
        then
            self:Cooldowns()
            if Player:CanCast(Serenity) then
                Player:Cast(Serenity)
                return
            end
            if
            StrikeOfTheWindlord:Exists() and CDOptionEnabled("风领主之击") and
            StrikeOfTheWindlordEnemies >= GetSecondOptionValue("风领主之击") and
            Target:CanCast(StrikeOfTheWindlord)
            then
                Target:Cast(StrikeOfTheWindlord)
                return
            end
            if
            SpinningCraneKick:Exists() and IsOptionEnabled("优先施放神鹤引项踢") and
            SpinningCraneKickDamage >= GetOptionValue("神鹤引项踢 > 旭日东升踢") and
            Player:Chi() >= 3 and
            LastComboSpellID ~= SpinningCraneKick:ID() and
            Player:CanCast(SpinningCraneKick)
            then
                Bug("Spinning Crane Kick > RSK with " .. SpinningCraneKickDamage .. "% Damage")
                Player:Cast(SpinningCraneKick)
                return
            end
            if
            RisingSunKick:Exists() and #Enemies_8y < 3 and LastComboSpellID ~= RisingSunKick:ID() and
            Target:CanCast(RisingSunKick)
            then
                if IsOptionEnabled("多重神鹤印记") and MarkOfTheCraneUnit then
                    Bug("Rising Sun Kick Cycle to apply Mark Of The Crane")
                    MarkOfTheCraneUnit:Cast(RisingSunKick)
                    return
                elseif Target:CanCast(RisingSunKick) then
                    Target:Cast(RisingSunKick)
                    return
                end
            end
            if
            FistsOfFury:Exists() and CDOptionEnabled("怒雷破") and TargetHealth >= FistOfFuryHealth and
            StrikeOfTheWindlordEnemies >= GetSecondOptionValue("怒雷破") and
            Target:CanCast(FistsOfFury)
            then
                Bug("Fist of Fury - Serenity")
                Target:Cast(FistsOfFury)
                return
            end
            if
            RisingSunKick:Exists() and #Enemies_8y >= 3 and LastComboSpellID ~= RisingSunKick:ID() and
            Target:CanCast(RisingSunKick)
            then
                if IsOptionEnabled("多重神鹤印记") and MarkOfTheCraneUnit then
                    Bug("Rising Sun Kick Cycle to apply Mark Of The Crane")
                    MarkOfTheCraneUnit:Cast(RisingSunKick)
                    return
                elseif Target:CanCast(RisingSunKick) then
                    Target:Cast(RisingSunKick)
                    return
                end
            end
            if
            SpinningCraneKick:Exists() and IsOptionEnabled("优先施放神鹤引项踢") and
            SpinningCraneKickDamage >= GetOptionValue("神鹤引项踢 > 幻灭踢") and
            Player:Chi() >= 3 and
            LastComboSpellID ~= SpinningCraneKick:ID() and
            Player:CanCast(SpinningCraneKick)
            then
                Bug("Spinning Crane Kick > BoK with " .. SpinningCraneKickDamage .. "% Damage")
                Player:Cast(SpinningCraneKick)
                return
            end
            if BlackoutKick:Exists() and LastComboSpellID ~= BlackoutKick:ID() and Target:CanCast(BlackoutKick) then
                if IsOptionEnabled("多重神鹤印记") and MarkOfTheCraneUnit then
                    Bug("Blackout Kick Cycle to apply Mark Of The Crane")
                    MarkOfTheCraneUnit:Cast(BlackoutKick)
                    return
                elseif Target:CanCast(BlackoutKick) then
                    Target:Cast(BlackoutKick)
                    return
                end
            end
            if RushingJadeWind:Exists() and LastComboSpellID ~= RushingJadeWind:ID() and Player:CanCast(RushingJadeWind) then
                Player:Cast(RushingJadeWind)
                return
            end
            return
        end
        if
        ((not Serenity:Exists() and DrinkingHornCover:IsEquipped(9) and
        ((FistsOfFuryCooldown <= 1 and Chi >= 3) or Player:Buff(StormEarthAndFire) or
        StormEarthAndFire:Charges() >= 2)) or
        (not Serenity:Exists() and not DrinkingHornCover:IsEquipped(9) and
        (((StrikeOfTheWindlord:Cooldown() <= 14 or not StrikeOfTheWindlord:Exists()) and
        FistsOfFury:Cooldown() <= 6 and
        RisingSunKick:Cooldown() <= 6) or
        Player:Buff(StormEarthAndFire)))) and
        (not IsOptionEnabled("近战范围风火雷电") or
        (IsOptionEnabled("近战范围风火雷电") and Player:IsWithinCastRange(Target, TigerPalm)))
        then
            if
            TigerPalm:Exists() and ChiMax - Chi > 1 and LastComboSpellID ~= TigerPalm:ID() and
            Target:CanCast(TigerPalm)
            then
                if IsOptionEnabled("多重神鹤印记") and MarkOfTheCraneUnit then
                    Bug("Tiger Palm Cycle to apply Mark Of The Crane")
                    MarkOfTheCraneUnit:Cast(TigerPalm)
                    return
                elseif Target:CanCast(TigerPalm) then
                    Target:Cast(TigerPalm)
                    return
                end
            end
            if
            ArcaneTorrent:Exists() and IsOptionEnabled("进攻性种族技能") and ChiMax - Chi >= 1 and
            Player:EnergyTimeToMax() >= 0.5 and
            Player:CanCast(ArcaneTorrent)
            then
                Player:Cast(ArcaneTorrent)
            end
            self:Cooldowns()
            StormEarthAndFireCooldown =             StormEarthAndFire:Exists() and not Serenity:Exists() and CDOptionEnabled("风火雷电") and
            StormEarthAndFire:Cooldown() or
            100
            if
            StormEarthAndFire:Exists() and not Serenity:Exists() and CDOptionEnabled("风火雷电") and
            StormEarthAndFire:TimeSinceCast() > 16
            then
                if
                not Player:Buff(StormEarthAndFire) and
                ((TouchOfDeath:Cooldown() <= 8 or TouchOfDeath:Cooldown() > 85) or
                StormEarthAndFire:Charges() == 2 or
                (FistsOfFury:Cooldown() <= 1 and Chi >= 3))
                then
                    StormEarthAndFireTargetGUID = nil
                    StormEarthAndFire.LastCastTime = GetTime()
                    Target:Cast(StormEarthAndFire)
                    return
                end
            end
            if
            FistsOfFury:Exists() and CDOptionEnabled("怒雷破") and TargetHealth >= FistOfFuryHealth and
            StormEarthAndFire:TimeSinceCast() > 1 and
            StrikeOfTheWindlordEnemies >= GetSecondOptionValue("怒雷破") and
            Target:CanCast(FistsOfFury)
            then
                Bug("Fist of Fury - SEF")
                Target:Cast(FistsOfFury)
                return
            end
            if RisingSunKick:Exists() and not LastComboSpellID ~= RisingSunKick:ID() and Target:CanCast(RisingSunKick) then
                if IsOptionEnabled("多重神鹤印记") and MarkOfTheCraneUnit then
                    Bug("Rising Sun Kick Cycle to apply Mark Of The Crane")
                    MarkOfTheCraneUnit:Cast(RisingSunKick)
                    return
                elseif Target:CanCast(RisingSunKick) then
                    Target:Cast(RisingSunKick)
                    return
                end
            end
        end
        self:Cooldowns()
        if
        EnergizingElixir:Exists() and CDOptionEnabled("豪能酒") and Player:Power() < Player:PowerMax() and Chi <= 1 and
        Player:CanCast(EnergizingElixir)
        then
            Player:Cast(EnergizingElixir)
            return
        end
        if
        ArcaneTorrent:Exists() and IsOptionEnabled("进攻性种族技能") and ChiMax - Chi >= 1 and
        Player:EnergyTimeToMax() >= 0.5 and
        Player:CanCast(ArcaneTorrent)
        then
            Player:Cast(ArcaneTorrent)
        end
        if
        StrikeOfTheWindlord:Exists() and CDOptionEnabled("风领主之击") and
        StrikeOfTheWindlordEnemies >= GetSecondOptionValue("风领主之击") and
        Target:CanCast(StrikeOfTheWindlord)
        then
            if
            (ConvergenceOfFatesEquipped and Serenity:Exists() and SerenityCooldown >= 10) or
            (ConvergenceOfFatesEquipped and not Serenity:Exists()) or
            (not ConvergenceOfFatesEquipped)
            then
                Target:Cast(StrikeOfTheWindlord)
                return
            end
        end
        if
        FistsOfFury:Exists() and CDOptionEnabled("怒雷破") and TargetHealth >= FistOfFuryHealth and
        StrikeOfTheWindlordEnemies >= GetSecondOptionValue("怒雷破") and
        StormEarthAndFire:TimeSinceCast() > 1 and
        Target:CanCast(FistsOfFury)
        then
            if
            (ConvergenceOfFatesEquipped and Serenity:Exists() and SerenityCooldown >= 5) or
            (ConvergenceOfFatesEquipped and not Serenity:Exists()) or
            (not ConvergenceOfFatesEquipped)
            then
                Bug("Fist of Fury - With Convergence of Faith")
                Target:Cast(FistsOfFury)
                return
            end
        end
        if
        TigerPalm:Exists() and LastComboSpellID ~= TigerPalm:ID() and Player:Energy() >= 90 and Chi <= 3 and
        Player:Buff(StormEarthAndFire) and
        Target:CanCast(TigerPalm)
        then
            if IsOptionEnabled("多重神鹤印记") and MarkOfTheCraneUnit then
                Bug("Tiger Palm Cycle to apply Mark Of The Crane")
                MarkOfTheCraneUnit:Cast(TigerPalm)
                return
            elseif Target:CanCast(TigerPalm) then
                Target:Cast(TigerPalm)
                return
            end
        end
        if
        SpinningCraneKick:Exists() and IsOptionEnabled("优先施放神鹤引项踢") and
        SpinningCraneKickDamage >= GetOptionValue("神鹤引项踢 > 旭日东升踢") and
        Player:Chi() >= 3 and
        LastComboSpellID ~= SpinningCraneKick:ID() and
        Player:CanCast(SpinningCraneKick)
        then
            Bug("Spinning Crane Kick > RSK with " .. SpinningCraneKickDamage .. "% Damage")
            Player:Cast(SpinningCraneKick)
            return
        end
        if RisingSunKick:Exists() and Target:CanCast(RisingSunKick) then
            if
            (ConvergenceOfFatesEquipped and Serenity:Exists() and SerenityCooldown >= 2) or
            (ConvergenceOfFatesEquipped and not Serenity:Exists()) or
            (not ConvergenceOfFatesEquipped)
            then
                if IsOptionEnabled("多重神鹤印记") and MarkOfTheCraneUnit then
                    Bug("Rising Sun Kick Cycle to apply Mark Of The Crane")
                    MarkOfTheCraneUnit:Cast(RisingSunKick)
                    return
                elseif Target:CanCast(RisingSunKick) then
                    Target:Cast(RisingSunKick)
                    return
                end
            end
        end
        if
        WhirlingDragonPunch:Exists() and not Target:IsMoving() and CDOptionEnabled("升龙霸") and
        #Enemies_8y >= GetSecondOptionValue("升龙霸") and
        Player:CanCast(WhirlingDragonPunch)
        then
            Player:Cast(WhirlingDragonPunch)
            return
        end
        if
        CracklingJadeLightning:Exists() and IsOptionEnabled("皇帝的容电皮甲") and
        (CooldownsAllowed() or GetOptionValue("皇帝的容电皮甲") == "无条件使用") and
        not Player:IsMoving() and
        TheEmperorsCapacitor:IsEquipped(5) and
        Player:BuffCount(TheEmperorsCapacitorBuff) >= 19 and
        LastComboSpellID ~= CracklingJadeLightning:ID() and
        Target:CanCast(CracklingJadeLightning)
        then
            Bug("Crackling Jade Lightning - The Emperor's Capacitor")
            CJLWithTheEmperorsCapacitor = true
            Target:Cast(CracklingJadeLightning)
            return
        end
        if
        SpinningCraneKick:Exists() and (#Enemies_8y >= 3 or (SpinningCraneKick:Count() >= 3 and UseAOE())) and
        LastComboSpellID ~= SpinningCraneKick:ID() and
        Player:CanCast(SpinningCraneKick)
        then
            Player:Cast(SpinningCraneKick)
            return
        end
        if
        RushingJadeWind:Exists() and ChiMax - Chi > 1 and LastComboSpellID ~= RushingJadeWind:ID() and
        Player:CanCast(RushingJadeWind)
        then
            Player:Cast(RushingJadeWind)
            return
        end
        if
        SpinningCraneKick:Exists() and IsOptionEnabled("优先施放神鹤引项踢") and
        SpinningCraneKickDamage >= GetOptionValue("神鹤引项踢 > 幻灭踢") and
        Player:Chi() >= 3 and
        LastComboSpellID ~= SpinningCraneKick:ID() and
        Player:CanCast(SpinningCraneKick)
        then
            Bug("Spinning Crane Kick > BoK with " .. SpinningCraneKickDamage .. "% Damage")
            Player:Cast(SpinningCraneKick)
            return
        end
        if
        BlackoutKick:Exists() and (Chi > 1 or Player:Buff(BlackoutKickBuff)) and
        LastComboSpellID ~= BlackoutKick:ID() and
        Target:CanCast(BlackoutKick)
        then
            if IsOptionEnabled("多重神鹤印记") and MarkOfTheCraneUnit then
                Bug("Blackout Kick Cycle to apply Mark Of The Crane")
                MarkOfTheCraneUnit:Cast(BlackoutKick)
                return
            elseif Target:CanCast(BlackoutKick) then
                Target:Cast(BlackoutKick)
                return
            end
        end
        if
        ChiWave:Exists() and IsOptionEnabled("真气波") and ChiWaveUnits >= GetOptionValue("真气波") and
        EnergyTimeToMax > 2.25 and
        Target:CanCast(ChiWave)
        then
            Target:Cast(ChiWave)
            return
        end
        if
        ChiBurst:Exists() and IsOptionEnabled("真气爆裂") and Player:Standing() >= 0.2 and
        ChiBurstUnits >= GetOptionValue("真气爆裂") and
        EnergyTimeToMax > 2.25 and
        Player:CanCast(ChiBurst)
        then
            Player:Cast(ChiBurst)
            return
        end
        if TigerPalm:Exists() and LastComboSpellID ~= TigerPalm:ID() and Target:CanCast(TigerPalm) then
            if IsOptionEnabled("多重神鹤印记") and MarkOfTheCraneUnit then
                Bug("Tiger Palm Cycle to apply Mark Of The Crane")
                MarkOfTheCraneUnit:Cast(TigerPalm)
                return
            elseif Target:CanCast(TigerPalm) then
                Target:Cast(TigerPalm)
                return
            end
        end
        if Chi <= 1 and EnergyTimeToMax < 1.5 and LastComboSpellID == TigerPalm:ID() then
            if ChiWave:Exists() and (GetOptionValue("连招填充") == "自动" or GetOptionValue("连招填充") == "真气波") then
                if LastComboSpellID ~= ChiWave:ID() and Target:CanCast(ChiWave) then
                    Bug("Hang Prevention - Chi Wave")
                    Target:Cast(ChiWave)
                    return
                end
            end
            if ChiBurst:Exists() and (GetOptionValue("连招填充") == "自动") then
                if LastComboSpellID ~= ChiBurst:ID() and Target:CanCast(ChiBurst) then
                    Bug("Hang Prevention - Chi Burst")
                    Target:Cast(ChiBurst)
                    return
                end
            end
            if
            FlyingSerpentKick:Exists() and
            (GetOptionValue("连招填充") == "自动" or GetOptionValue("连招填充") == "Flying Serpent Kick")
            then
                if LastComboSpellID ~= FlyingSerpentKick:ID() and Player:CanCast(FlyingSerpentKick) then
                    Bug("Hang Prevention - Flying Serpent Kick")
                    self:FlyingSerpentKickMacro()
                    return
                end
            end
            if
            CracklingJadeLightning:Exists() and not Player:IsMoving() and
            (GetOptionValue("连招填充") == "自动" or GetOptionValue("连招填充") == "碎玉闪电" or
            GetOptionValue("连招填充") == "猛虎掌")
            then
                if LastComboSpellID ~= CracklingJadeLightning:ID() and Target:CanCast(CracklingJadeLightning) then
                    Bug("Hang Prevention - Crackling Jade Lightning")
                    Target:Cast(CracklingJadeLightning)
                    return
                end
            end
        end
        if
        IsOptionEnabled("碎玉闪电") and not Player:IsWithinCastRange(Target, TigerPalm) and
        not Player:Channeling(CracklingJadeLightning) and
        Player:Standing() >= GetOptionValue("碎玉闪电") and
        Target:CanCast(CracklingJadeLightning)
        then
            Target:Cast(CracklingJadeLightning)
            return
        end
    end
end
function Rotation:CombatBeta()
    if
    Effuse:Exists() and Player:Standing() > 0.5 and IsOptionEnabled("真气贯通 自己") and
    Player:HealthPercentage() <= GetOptionValue("真气贯通 自己") and
    Player:CanCast(Effuse)
    then
        Player:Cast(Effuse)
        return
    end
    ChiMax, Chi, EnergyRegen, EnergyTimeToMax =     Player:ChiMax(),
    Player:Chi(),
    Player:EnergyRegen(),
    Player:EnergyTimeToMax()
    ConvergenceOfFatesEquipped = ConvergenceOfFates:IsEquipped(13, 14)
    if ShouldFlyingSerpentKick then
        self:FlyingSerpentKickMacro()
    end
    if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        Player:StartAttack()
        TargetHealth = not Target:IsDummy() and not Target:GUID() == Boss1:GUID() and Target:Health() or 200000000
        FistOfFuryHealth = GetOptionValue("怒雷破血量") * 1000000
        SpinningCraneKickDamage =         IsOptionEnabled("优先施放神鹤引项踢") and
        (133.3 * 1.08 * (1 + (PowerOfAThousandCranes:ArtifactRank() / 30)) * (1 + (MarkOfTheCranesCount * 0.4)) *
        #Enemies_8y) or
        0
        SetOutput(ClassColor .. "神鹤引项踢伤害提升", SpinningCraneKickDamage .. "%")
        SerenityCooldown = Serenity:Exists() and CDOptionEnabled("屏气凝神") and Serenity:Cooldown() or 100
        FistsOfFuryCooldown =         FistsOfFury:Exists() and CDOptionEnabled("怒雷破") and
        StrikeOfTheWindlordEnemies >= GetSecondOptionValue("怒雷破") and
        FistsOfFury:Cooldown() or
        0
        if Player:Buff(Serenity) or Player:Buff(StormEarthAndFire) or Player:HasHero() then
            Player:UsePotions("Agility")
        end
        if
        (SerenityCooldown == 0 or Player:Buff(Serenity)) and
        (not IsOptionEnabled("近战范围风火雷电") or
        (IsOptionEnabled("近战范围风火雷电") and Player:IsWithinCastRange(Target, TigerPalm)))
        then
            if
            TigerPalm:Exists() and LastComboSpellID ~= TigerPalm:ID() and Player:Energy() >= 90 and Chi < 1 and
            not Player:Buff(Serenity) and
            Target:CanCast(TigerPalm)
            then
                if IsOptionEnabled("多重神鹤印记") and MarkOfTheCraneUnit then
                    Bug("Tiger Palm Cycle to apply Mark Of The Crane")
                    MarkOfTheCraneUnit:Cast(TigerPalm)
                    return
                elseif Target:CanCast(TigerPalm) then
                    Target:Cast(TigerPalm)
                    return
                end
            end
            self:Cooldowns()
            if Player:CanCast(Serenity) then
                Player:Cast(Serenity)
                return
            end
            if
            SpinningCraneKick:Exists() and IsOptionEnabled("优先施放神鹤引项踢") and
            SpinningCraneKickDamage >= GetOptionValue("神鹤引项踢 > 旭日东升踢") and
            Player:Chi() >= 3 and
            LastComboSpellID ~= SpinningCraneKick:ID() and
            Player:CanCast(SpinningCraneKick)
            then
                Bug("Spinning Crane Kick > RSK with " .. SpinningCraneKickDamage .. "% Damage")
                Player:Cast(SpinningCraneKick)
                return
            end
            if
            RisingSunKick:Exists() and #Enemies_8y < 3 and LastComboSpellID ~= RisingSunKick:ID() and
            Target:CanCast(RisingSunKick)
            then
                if IsOptionEnabled("多重神鹤印记") and MarkOfTheCraneUnit then
                    Bug("Rising Sun Kick Cycle to apply Mark Of The Crane")
                    MarkOfTheCraneUnit:Cast(RisingSunKick)
                    return
                elseif Target:CanCast(RisingSunKick) then
                    Target:Cast(RisingSunKick)
                    return
                end
            end
            if
            StrikeOfTheWindlord:Exists() and CDOptionEnabled("风领主之击") and
            StrikeOfTheWindlordEnemies >= GetSecondOptionValue("风领主之击") and
            Target:CanCast(StrikeOfTheWindlord)
            then
                Target:Cast(StrikeOfTheWindlord)
                return
            end
            if
            BlackoutKick:Exists() and LastComboSpellID ~= BlackoutKick:ID() and
            ((LastComboSpellID == StrikeOfTheWindlord:ID() or LastComboSpellID == FistsOfFury:ID()) and
            (#Enemies_8y < 2 or MarkOfTheCranesCount >= 2)) and
            Target:CanCast(BlackoutKick)
            then
                if IsOptionEnabled("多重神鹤印记") and MarkOfTheCraneUnit then
                    Bug("Blackout Kick Cycle to apply Mark Of The Crane")
                    MarkOfTheCraneUnit:Cast(BlackoutKick)
                    return
                elseif Target:CanCast(BlackoutKick) then
                    Target:Cast(BlackoutKick)
                    return
                end
            end
            if
            FistsOfFury:Exists() and CDOptionEnabled("怒雷破") and TargetHealth >= FistOfFuryHealth and
            StrikeOfTheWindlordEnemies >= GetSecondOptionValue("怒雷破") and
            Target:CanCast(FistsOfFury)
            then
                if
                ((DrinkingHornCover:IsEquipped(9) and Player:BuffRemains(PressurePoint) <= 2 and HasT20_2Pc) and
                (RisingSunKick:Cooldown() > 1 or StrikeOfTheWindlordEnemies > 1)) or
                ((not DrinkingHornCover:IsEquipped(9) or Player:HasHero() or Player:BuffRemains(Serenity) < 1) and
                (RisingSunKick:Cooldown() > 1 or StrikeOfTheWindlordEnemies > 1))
                then
                    Bug("Fist of Fury - Serenity")
                    Target:Cast(FistsOfFury)
                    return
                end
            end
            if
            SpinningCraneKick:Exists() and #Enemies_8y >= 3 and LastComboSpellID ~= SpinningCraneKick:ID() and
            Player:CanCast(SpinningCraneKick)
            then
                Player:Cast(SpinningCraneKick)
                return
            end
            if
            RisingSunKick:Exists() and #Enemies_8y >= 3 and LastComboSpellID ~= RisingSunKick:ID() and
            Target:CanCast(RisingSunKick)
            then
                if IsOptionEnabled("多重神鹤印记") and MarkOfTheCraneUnit then
                    Bug("Rising Sun Kick Cycle to apply Mark Of The Crane")
                    MarkOfTheCraneUnit:Cast(RisingSunKick)
                    return
                elseif Target:CanCast(RisingSunKick) then
                    Target:Cast(RisingSunKick)
                    return
                end
            end
            if
            SpinningCraneKick:Exists() and IsOptionEnabled("优先施放神鹤引项踢") and
            SpinningCraneKickDamage >= GetOptionValue("神鹤引项踢 > 幻灭踢") and
            Player:Chi() >= 3 and
            LastComboSpellID ~= SpinningCraneKick:ID() and
            Player:CanCast(SpinningCraneKick)
            then
                Bug("Spinning Crane Kick > BoK with " .. SpinningCraneKickDamage .. "% Damage")
                Player:Cast(SpinningCraneKick)
                return
            end
            if BlackoutKick:Exists() and LastComboSpellID ~= BlackoutKick:ID() and Target:CanCast(BlackoutKick) then
                if IsOptionEnabled("多重神鹤印记") and MarkOfTheCraneUnit then
                    Bug("Blackout Kick Cycle to apply Mark Of The Crane")
                    MarkOfTheCraneUnit:Cast(BlackoutKick)
                    return
                elseif Target:CanCast(BlackoutKick) then
                    Target:Cast(BlackoutKick)
                    return
                end
            end
            if RushingJadeWind:Exists() and LastComboSpellID ~= RushingJadeWind:ID() and Player:CanCast(RushingJadeWind) then
                Player:Cast(RushingJadeWind)
                return
            end
            return
        end
        if
        ((not Serenity:Exists() and (Player:Buff(StormEarthAndFire) or StormEarthAndFire:Charges() >= 2)) or
        (not Serenity:Exists() and DrinkingHornCover:IsEquipped(9) and
        (((StrikeOfTheWindlord:Cooldown() <= 18 or not StrikeOfTheWindlord:Exists()) and
        FistsOfFury:Cooldown() <= 12 and
        Chi >= 3 and
        RisingSunKick:Cooldown() <= 1) or
        (not CDOptionEnabled("轮回之触") or (TouchOfDeath:Cooldown() <= 8 or TouchOfDeath:Cooldown() > 112)) or
        Player:Buff(StormEarthAndFire))) or
        (not Serenity:Exists() and not DrinkingHornCover:IsEquipped(9) and
        (((StrikeOfTheWindlord:Cooldown() <= 14 or not StrikeOfTheWindlord:Exists()) and
        FistsOfFury:Cooldown() <= 6 and
        Chi >= 3 and
        RisingSunKick:Cooldown() <= 1) or
        (not CDOptionEnabled("轮回之触") or (TouchOfDeath:Cooldown() <= 8 or TouchOfDeath:Cooldown() > 112)) or
        Player:Buff(StormEarthAndFire)))) and
        (not IsOptionEnabled("近战范围风火雷电") or
        (IsOptionEnabled("近战范围风火雷电") and Player:IsWithinCastRange(Target, TigerPalm)))
        then
            if TigerPalm:Exists() and Chi < 1 and LastComboSpellID ~= TigerPalm:ID() and Target:CanCast(TigerPalm) then
                if IsOptionEnabled("多重神鹤印记") and MarkOfTheCraneUnit then
                    Bug("Tiger Palm Cycle to apply Mark Of The Crane")
                    MarkOfTheCraneUnit:Cast(TigerPalm)
                    return
                elseif Target:CanCast(TigerPalm) then
                    Target:Cast(TigerPalm)
                    return
                end
            end
            if
            ArcaneTorrent:Exists() and ChiMax - Chi >= 1 and Player:EnergyTimeToMax() >= 0.5 and
            Player:CanCast(ArcaneTorrent)
            then
                Player:Cast(ArcaneTorrent)
            end
            self:Cooldowns()
            StormEarthAndFireCooldown =             StormEarthAndFire:Exists() and not Serenity:Exists() and CDOptionEnabled("风火雷电") and
            StormEarthAndFire:Cooldown() or
            100
            if
            StormEarthAndFire:Exists() and not Player:Buff(StormEarthAndFire) and not Serenity:Exists() and
            CDOptionEnabled("风火雷电") and
            StormEarthAndFire:TimeSinceCast() > 16
            then
                StormEarthAndFireTargetGUID = nil
                StormEarthAndFire.LastCastTime = GetTime()
                Target:Cast(StormEarthAndFire)
                return
            end
        end
        self:Cooldowns()
        if
        EnergizingElixir:Exists() and CDOptionEnabled("豪能酒") and Chi <= 1 and
        (not RisingSunKick:IsOnCooldown() or
        (StrikeOfTheWindlord:Exists() and not StrikeOfTheWindlord:IsOnCooldown()) or
        Player:Energy() < 50) and
        Player:CanCast(EnergizingElixir)
        then
            Player:Cast(EnergizingElixir)
            return
        end
        if
        ArcaneTorrent:Exists() and ChiMax - Chi >= 1 and Player:EnergyTimeToMax() >= 0.5 and
        Player:CanCast(ArcaneTorrent)
        then
            Player:Cast(ArcaneTorrent)
        end
        if
        TigerPalm:Exists() and LastComboSpellID ~= TigerPalm:ID() and Player:EnergyTimeToMax() <= 0.5 and
        ChiMax - Chi >= 2 and
        Target:CanCast(TigerPalm)
        then
            if IsOptionEnabled("多重神鹤印记") and MarkOfTheCraneUnit then
                Bug("Tiger Palm Cycle to apply Mark Of The Crane")
                MarkOfTheCraneUnit:Cast(TigerPalm)
                return
            elseif Target:CanCast(TigerPalm) then
                Target:Cast(TigerPalm)
                return
            end
        end
        if
        StrikeOfTheWindlord:Exists() and CDOptionEnabled("风领主之击") and
        StrikeOfTheWindlordEnemies >= GetSecondOptionValue("风领主之击") and
        Target:CanCast(StrikeOfTheWindlord)
        then
            if (not Serenity:Exists() or SerenityCooldown >= 10) then
                Target:Cast(StrikeOfTheWindlord)
                return
            end
        end
        if RisingSunKick:Exists() and Target:CanCast(RisingSunKick) then
            if ((Chi >= 3 and Player:Energy() >= 40) or Chi >= 5) and (not Serenity:Exists() or SerenityCooldown >= 6) then
                if IsOptionEnabled("多重神鹤印记") and MarkOfTheCraneUnit then
                    Bug("Rising Sun Kick Cycle to apply Mark Of The Crane")
                    MarkOfTheCraneUnit:Cast(RisingSunKick)
                    return
                elseif Target:CanCast(RisingSunKick) then
                    Target:Cast(RisingSunKick)
                    return
                end
            end
        end
        if
        FistsOfFury:Exists() and CDOptionEnabled("怒雷破") and TargetHealth >= FistOfFuryHealth and
        StrikeOfTheWindlordEnemies >= GetSecondOptionValue("怒雷破") and
        StormEarthAndFire:TimeSinceCast() > 1 and
        Target:CanCast(FistsOfFury)
        then
            if
            (Serenity:Exists() and not DrinkingHornCover:IsEquipped(9) and SerenityCooldown >= 5 and
            EnergyTimeToMax > 2) or
            (Serenity:Exists() and DrinkingHornCover:IsEquipped(9) and
            (SerenityCooldown >= 15 or SerenityCooldown <= 4) and
            EnergyTimeToMax > 2) or
            (not Serenity:Exists() and EnergyTimeToMax > 2)
            then
                Bug("Fist of Fury")
                Target:Cast(FistsOfFury)
                return
            end
        end
        if
        SpinningCraneKick:Exists() and IsOptionEnabled("优先施放神鹤引项踢") and
        SpinningCraneKickDamage >= GetOptionValue("神鹤引项踢 > 旭日东升踢") and
        Player:Chi() >= 3 and
        LastComboSpellID ~= SpinningCraneKick:ID() and
        Player:CanCast(SpinningCraneKick)
        then
            Bug("Spinning Crane Kick > RSK with " .. SpinningCraneKickDamage .. "% Damage")
            Player:Cast(SpinningCraneKick)
            return
        end
        if RisingSunKick:Exists() and Target:CanCast(RisingSunKick) then
            if (not Serenity:Exists() or SerenityCooldown >= 5) then
                if IsOptionEnabled("多重神鹤印记") and MarkOfTheCraneUnit then
                    Bug("Rising Sun Kick Cycle to apply Mark Of The Crane")
                    MarkOfTheCraneUnit:Cast(RisingSunKick)
                    return
                elseif Target:CanCast(RisingSunKick) then
                    Target:Cast(RisingSunKick)
                    return
                end
            end
        end
        if
        WhirlingDragonPunch:Exists() and not Target:IsMoving() and CDOptionEnabled("升龙霸") and
        #Enemies_8y >= GetSecondOptionValue("升龙霸") and
        Player:CanCast(WhirlingDragonPunch)
        then
            Player:Cast(WhirlingDragonPunch)
            return
        end
        if
        CracklingJadeLightning:Exists() and IsOptionEnabled("皇帝的容电皮甲") and
        (CooldownsAllowed() or GetOptionValue("皇帝的容电皮甲") == "无条件使用") and
        not Player:IsMoving() and
        TheEmperorsCapacitor:IsEquipped(5) and
        ((Player:BuffCount(TheEmperorsCapacitorBuff) >= 19 and EnergyTimeToMax > 3) or
        (Player:BuffCount(TheEmperorsCapacitorBuff) >= 14 and Serenity:Exists() and SerenityCooldown < 13 and
        EnergyTimeToMax > 3)) and
        LastComboSpellID ~= CracklingJadeLightning:ID() and
        Target:CanCast(CracklingJadeLightning)
        then
            Bug("Crackling Jade Lightning - The Emperor's Capacitor")
            CJLWithTheEmperorsCapacitor = true
            Target:Cast(CracklingJadeLightning)
            return
        end
        if
        SpinningCraneKick:Exists() and (#Enemies_8y >= 3 or (SpinningCraneKick:Count() >= 3 and UseAOE())) and
        LastComboSpellID ~= SpinningCraneKick:ID() and
        Player:CanCast(SpinningCraneKick)
        then
            Player:Cast(SpinningCraneKick)
            return
        end
        if
        RushingJadeWind:Exists() and ChiMax - Chi > 1 and LastComboSpellID ~= RushingJadeWind:ID() and
        Player:CanCast(RushingJadeWind)
        then
            Player:Cast(RushingJadeWind)
            return
        end
        if
        SpinningCraneKick:Exists() and IsOptionEnabled("优先施放神鹤引项踢") and
        SpinningCraneKickDamage >= GetOptionValue("神鹤引项踢 > 幻灭踢") and
        Player:Chi() >= 3 and
        LastComboSpellID ~= SpinningCraneKick:ID() and
        Player:CanCast(SpinningCraneKick)
        then
            Bug("Spinning Crane Kick > BoK with " .. SpinningCraneKickDamage .. "% Damage")
            Player:Cast(SpinningCraneKick)
            return
        end
        if
        BlackoutKick:Exists() and
        ((Chi > 1 or Player:Buff(BlackoutKickBuff) or
        (EnergizingElixir:Exists() and CDOptionEnabled("豪能酒") and
        EnergizingElixir:Cooldown() < FistsOfFuryCooldown)) and
        ((RisingSunKick:Cooldown() > 1 and
        (not StrikeOfTheWindlord:Exists() or StrikeOfTheWindlord:Cooldown() > 1) or
        Chi > 2) and
        (FistsOfFuryCooldown > 1 or Chi > 3) or
        LastComboSpellID == TigerPalm:ID())) and
        LastComboSpellID ~= BlackoutKick:ID() and
        Target:CanCast(BlackoutKick)
        then
            if IsOptionEnabled("多重神鹤印记") and MarkOfTheCraneUnit then
                Bug("Blackout Kick Cycle to apply Mark Of The Crane")
                MarkOfTheCraneUnit:Cast(BlackoutKick)
                return
            elseif Target:CanCast(BlackoutKick) then
                Target:Cast(BlackoutKick)
                return
            end
        end
        if
        ChiWave:Exists() and IsOptionEnabled("真气波") and ChiWaveUnits >= GetOptionValue("真气波") and
        EnergyTimeToMax > 1 and
        Target:CanCast(ChiWave)
        then
            Target:Cast(ChiWave)
            return
        end
        if
        ChiBurst:Exists() and IsOptionEnabled("真气爆裂") and Player:Standing() >= 0.2 and
        ChiBurstUnits >= GetOptionValue("真气爆裂") and
        EnergyTimeToMax > 1 and
        Player:CanCast(ChiBurst)
        then
            Player:Cast(ChiBurst)
            return
        end
        if
        TigerPalm:Exists() and LastComboSpellID ~= TigerPalm:ID() and (ChiMax - Chi >= 2 or EnergyTimeToMax < 1) and
        Target:CanCast(TigerPalm)
        then
            if IsOptionEnabled("多重神鹤印记") and MarkOfTheCraneUnit then
                Bug("Tiger Palm Cycle to apply Mark Of The Crane")
                MarkOfTheCraneUnit:Cast(TigerPalm)
                return
            elseif Target:CanCast(TigerPalm) then
                Target:Cast(TigerPalm)
                return
            end
        end
        if Chi <= 1 and EnergyTimeToMax < 1.5 and LastComboSpellID == TigerPalm:ID() then
            if ChiWave:Exists() and (GetOptionValue("连招填充") == "自动" or GetOptionValue("连招填充") == "真气波") then
                if LastComboSpellID ~= ChiWave:ID() and Target:CanCast(ChiWave) then
                    Bug("Hang Prevention - Chi Wave")
                    Target:Cast(ChiWave)
                    return
                end
            end
            if ChiBurst:Exists() and (GetOptionValue("连招填充") == "自动") then
                if LastComboSpellID ~= ChiBurst:ID() and Target:CanCast(ChiBurst) then
                    Bug("Hang Prevention - Chi Burst")
                    Target:Cast(ChiBurst)
                    return
                end
            end
            if
            FlyingSerpentKick:Exists() and
            (GetOptionValue("连招填充") == "自动" or GetOptionValue("连招填充") == "Flying Serpent Kick")
            then
                if LastComboSpellID ~= FlyingSerpentKick:ID() and Player:CanCast(FlyingSerpentKick) then
                    Bug("Hang Prevention - Flying Serpent Kick")
                    self:FlyingSerpentKickMacro()
                    return
                end
            end
            if
            CracklingJadeLightning:Exists() and not Player:IsMoving() and
            (GetOptionValue("连招填充") == "自动" or GetOptionValue("连招填充") == "碎玉闪电" or
            GetOptionValue("连招填充") == "猛虎掌")
            then
                if LastComboSpellID ~= CracklingJadeLightning:ID() and Target:CanCast(CracklingJadeLightning) then
                    Bug("Hang Prevention - Crackling Jade Lightning")
                    Target:Cast(CracklingJadeLightning)
                    return
                end
            end
        end
        if
        IsOptionEnabled("碎玉闪电") and not Player:IsWithinCastRange(Target, TigerPalm) and
        not Player:Channeling(CracklingJadeLightning) and
        Player:Standing() >= GetOptionValue("碎玉闪电") and
        Target:CanCast(CracklingJadeLightning)
        then
            Target:Cast(CracklingJadeLightning)
            return
        end
    end
end
function Rotation:OutOfCombat()
    SetOutput(ClassColor .. "神鹤引项踢伤害提升", "0%")
    if
    Effuse:Exists() and Player:Standing() > 0.5 and IsOptionEnabled("真气贯通 自己") and
    Player:HealthPercentage() <= GetSecondOptionValue("真气贯通 自己") and
    Player:CanCast(Effuse)
    then
        Player:Cast(Effuse)
        return
    end
    if Target:Exists() and IsOptionEnabled("自动进入战斗") then
        if ChiWave:Exists() and Target:CanCast(ChiWave) then
            Target:Cast(ChiWave)
            return
        end
        if TigerPalm:Exists() and Target:CanCast(TigerPalm) then
            Target:Cast(TigerPalm)
            return
        end
        if
        IsOptionEnabled("碎玉闪电") and not Player:IsWithinCastRange(Target, TigerPalm) and
        not Player:Channeling(CracklingJadeLightning) and
        Player:Standing() >= GetOptionValue("碎玉闪电") and
        Target:CanCast(CracklingJadeLightning)
        then
            Target:Cast(CracklingJadeLightning)
            return
        end
    end
end
SetRotation(65, {})
local Rotation = Rotations[65]
function Rotation:Initialize()
    Trinket1 = Item(13, false, false, true)
    Trinket2 = Item(14, false, false, true)
    ArcaneTorrent = Spell(155145, false, false, true)
    AuraMastery = Spell(31821, false, false, true)
    AuraOfSacrifice = Spell(183416)
    AvengingWrath = Spell(31842, false, false, true)
    BeaconOfFaith = Spell(156910, false, false, true)
    BeaconOfLight = Spell(53563, false, false, true)
    BeaconOfTheLightbringer = Spell(197446)
    BeaconOfVirtue = Spell(200025, false, false, false)
    BestowFaith = Spell(223306, false, false, true)
    BlessingOfFreedom = Spell(1044, false, false, true)
    BlessingOfSacrifice = Spell(6940, false, false, true)
    BlessingOfProtection = Spell(1022, false, false, true)
    BlindingLight = Spell(115750, false, false, true)
    Cleanse = Spell(4987, false, false, true)
    Clemency = Spell(105922)
    CrusadersMight = Spell(196926)
    DivineProtection = Spell(498, false, false, true)
    DivinePurpose = Spell(197646)
    DivinePurposeDawn = Spell(216413)
    DivinePurposeShock = Spell(216411)
    DivineShield = Spell(642, false, false, true)
    FistOfJustice = Spell(105593, false, true, true)
    FlashOfLight = Spell(19750, false, false, false)
    Forbearance = Spell(25771)
    GiftOfTheNaaru = Spell(59547, false, false, true)
    HammerOfJustice = Spell(853, false, true, true)
    HolyAvenger = Spell(105809)
    HolyLight = Spell(82326, false, false, false)
    HolyPrismHeal = Spell(114165, false, false, true)
    HolyPrismDamage = Spell(114165, true, true, true)
    HolyShock = Spell(20473, false, false, true)
    HolyShockDamage = Spell(20473, true, true, true)
    InfusionOfLight = Spell(54149, false, false, true)
    JudgmentOfLight = Spell(183778)
    JudgmentOfLightDebuff = Spell(196941)
    LayOnHands = Spell(633, false, false, true)
    LightOfDawn = Spell(85222, false, false, false)
    LightOfTheMartyr = Spell(183998, false, false, true)
    LightsHammer = Spell(114158, false, false, true)
    MaraadsDyingBreathBuff = Spell(234862)
    Redemption = Spell(7328, false, false, true, true)
    RuleOfLaw = Spell(214202, false, false, true)
    SanctifiedWrath = Spell(53376)
    SapSoul = Spell(200904)
    TyrsDeliverance = Spell(200652, false, false, false)
    Consecration = Spell(26573, false, false, true)
    CrusaderStrike = Spell(35395, true, true, true)
    HammerOfWrath = Spell(24275, true, true, true)
    Judgment = Spell(20271, true, true, true)
    JudgmentDebuff = Spell(214222)
    Rebuke = Spell(96231, true, true, true)
    AddPage("常规")
    AddPage("治愈")
    AddPage("大技能")
    AddPage("攻/防")
    AddCommonOptions()
    AddPresetOption("GeneralHealer")
    AddSection("常规", { "辅助", "效用" }, "Yellow")
    AddNewOption(
    "常规",
    { "避免治疗道标单位", "避免治疗道标" },
    222,
    true,
    { 50, 1, 100, 1 },
    { 90, 1, 100, 1 },
    {
        "Prevent direct heals on the beacon units unless their life is lower than the first value or the lowest non beacon unit's health is higher than the second value." ..
        C.TOOLTIP_VALUE_1 ..
        "Allow Healing the beacons if their health is under this value." ..
        C.TOOLTIP_VALUE_2 ..
        "Allow healing the Beacons if the lowest non-beacon unit's health is higher than this value.",
        "除非他们的生命低于第一个值，否则在信标单元上防止直接治疗，否则最低的非信标单位的健康状况高于第二个值。" ..
        C.TOOLTIP_VALUE_1 .. "如果他们的健康在这个价值之下，可以治愈信标。" .. C.TOOLTIP_VALUE_2 .. "如果最低的非信标单位的健康状况高于此值，则可以修复信标。"
    }
    )
    AddNewOption(
    "常规",
    { "道标(圣光 +信仰)", "道标 (圣光 + 信仰)" },
    230,
    true,
    {
        3,
        { "焦点 + 自己", "焦点 + 播放机" },
        { "主坦 + 焦点", "主油箱 + 焦点" },
        { "主坦 + 副坦", "主油箱 + 关罐" },
        { "主坦 + 自己", "主油箱 + 播放机" },
        { "副坦 + 焦点", "关罐 + 焦点" },
        { "副坦 + 自己", "关罐 + 播放机" },
        { "自己 + 焦点", "播放机 + 焦点" }
    },
    nil,
    {
        "Use Beacons handlers." ..
        C.TOOLTIP_VALUE_1 ..
        "Define the two preferred units to use Beacons. If Beacon of Faith is not talented, Only the first unit will have a Beacon and the second unit will be the first fallback. Main and Off refers to the Tanks as they are displayed in the status frame." ..
        C.TOOLTIP_HINT(
        "If option is enabled but a valid target cannot be found to match the selection, the Beacon will fall back to the next unit in the priority. The priorities are: Main Tank, Off Tank, Focus, Player."
        ),
        "使用信仰处理器。" ..
        C.TOOLTIP_VALUE_1 ..
        "定义要使用的两个首选单位信仰。如果信仰道标没有天赋，只有第一个单位会有一个道标第二个单位将是第一个回退。主油箱和关罐指的是在状态框中显示的坦克。" ..
        C.TOOLTIP_HINT("如果启用了选项，但找不到与选择相匹配的有效目标道标将优先考虑下一个单位。优先事项是：主坦克，关罐，焦点，球员。")
    }
    )
    AddNewOption(
    "常规",
    { "制裁之锤", "制裁之锤" },
    210,
    true,
    nil,
    nil,
    { "Use Hammer of Justice to stun non-boss casting units", "使用制裁之锤砸非老板铸造单位。" }
    )
    AddSection("治愈", { "通用治疗参数", "普通治疗门槛" }, "Yellow")
    AddPresetOption("DirectHealingTankRaid", "治愈", { "赋予信仰", "赋予信仰" }, true, { 70, 0, 100, 1 }, { 50, 0, 100, 1 })
    AddNewOption(
    "治愈",
    { "赋予信仰目标选择", "赋予信仰单元" },
    232,
    true,
    { 1, { "焦点", "焦点" }, { "玩家", "播放机" }, { "坦克", "坦克" } },
    { 50, 0, 100, 1 },
    {
        "Use Bestow Faith on a specific unit on Cooldown." ..
        C.TOOLTIP_VALUE_1 ..
        "Unit we want to cast Bestow Faith on." ..
        C.TOOLTIP_VALUE_2 .. "Health threshold to cast on specific unit.",
        "使用赋予信仰在冷却时的具体单位。" .. C.TOOLTIP_VALUE_1 .. "我们要投的单位赋予信仰上。" .. C.TOOLTIP_VALUE_2 .. "健康阈值投放在特定单位。"
    }
    )
    AddPresetOption("DirectHealingSingle", "治愈", { "圣光闪现", "圣光闪现" }, true, { 50, 0, 100, 1 })
    AddPresetOption("DirectHealingSingle", "治愈", { "圣光术", "圣光术" }, true, { 90, 0, 100, 1 })
    AddPresetOption("DirectHealingSingle", "治愈", { "神圣震击", "神圣震击" }, true, { 95, 0, 100, 1 })
    AddNewOption(
    "治愈",
    { "无条件施放神圣震击", "神圣震击总是" },
    220,
    false,
    { 90, 1, 100, 1 },
    nil,
    {
        "Use Holy Shock on the lowest health friendly or on enemy if everyone is over health threshold." ..
        C.TOOLTIP_VALUE .. "Only use on units that are under this health threshold.",
        "使用神圣震击如果每个人都超过健康阈值，最低的健康或敌人。" .. C.TOOLTIP_VALUE .. "仅适用于该健康阈值以下的单位。"
    }
    )
    AddPresetOption("AoEHealingUnitsHealth", "治愈", { "神圣棱镜", "神圣棱镜" }, true, { 4, 1, 5, 1 }, { 80, 0, 100, 1 })
    AddNewOption(
    "治愈",
    { "圣光灌注", "圣光灌注" },
    232,
    false,
    { 2, { "圣光闪现", "圣光闪现" }, { "圣光术", "圣光术" } },
    { 55, 1, 100, 1 },
    {
        "Enable to define a favorite spell to use with Infusion of Light procs. Disable to let the profile work as usual regardless of procs." ..
        C.TOOLTIP_VALUE_1 ..
        "Choose which spell you want to use with Infusion of Light procs." ..
        C.TOOLTIP_VALUE_2 ..
        "Use Flash of Light instead of Holy Light when the Lowest unit's health is lower than this value." ..
        C.TOOLTIP_HINT("You can lower the second value to 0 to always use Holy Light."),
        "启用以定义与之配合使用的最喜欢的法术圣光灌注特效。禁用以使配置文件正常工作，无论如何特效。" ..
        C.TOOLTIP_VALUE_1 ..
        "选择您要使用的拼写圣光灌注特效。" ..
        C.TOOLTIP_VALUE_2 .. "使用圣光闪现代替圣光术当最低单位的健康状况低于此值时。" .. C.TOOLTIP_HINT("您可以将第二个值降低为0以始终使用圣光术。")
    }
    )
    AddNewOption(
    "治愈",
    "IoL Alternative",
    210,
    true,
    nil,
    nil,
    "Use an additional condition for Infusion Of Light in healing routine."
    )
    AddNewOption(
    "治愈",
    "IoL Holy Light",
    120,
    true,
    { 96, 0, 100, 1 },
    nil,
    "Under % health the lowest unit needs to be to use Holy Light with Infusion of Light. (Only works with IoL Alternative enabled)"
    )
    AddPresetOption("AoEHealingUnitsHealth", "治愈", { "圣光之锤", "圣光之锤" }, true, { 3, 1, 10, 1 }, { 70, 0, 100, 1 })
    AddPresetOption("AoEHealingUnitsHealth", "治愈", { "黎明之光", "黎明之光" }, true, { 3, 1, 6, 1 }, { 92, 0, 100, 1 })
    AddNewOption(
    "治愈",
    { "殉道者之光", "殉道者之光" },
    222,
    true,
    { 40, 0, 100, 1 },
    { 25, 0, 100, 1 },
    {
        "Always use Light Of The Martyr." ..
        C.TOOLTIP_VALUE_1 ..
        "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid.",
        "永远使用烈士的光来治愈。" .. C.TOOLTIP_VALUE_1 .. "在坦克上使用的门槛。" .. C.TOOLTIP_VALUE_2 .. "突袭使用的门槛。"
    }
    )
    AddNewOption(
    "治愈",
    { "橙披 殉道者之光", "殉道者之光披风" },
    222,
    true,
    { 40, 0, 100, 1 },
    { 25, 0, 100, 1 },
    {
        "Use Light Of The Martyr with Maraad's Dying Breath buff." ..
        C.TOOLTIP_VALUE_1 ..
        "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid.",
        "使用玛尔拉德的临终之息会的。" .. C.TOOLTIP_VALUE_1 .. "在坦克上使用的门槛。" .. C.TOOLTIP_VALUE_2 .. "突袭使用的门槛。"
    }
    )
    AddNewOption(
    "治愈",
    { "移动 殉道者之光", "殉道者之光动" },
    222,
    true,
    { 40, 0, 100, 1 },
    { 25, 0, 100, 1 },
    {
        "Use Light Of The Martyr while moving." ..
        C.TOOLTIP_VALUE_1 ..
        "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid.",
        "殉道者之光移动时。" .. C.TOOLTIP_VALUE_1 .. "在坦克上使用的门槛。" .. C.TOOLTIP_VALUE_2 .. "突袭使用的门槛。"
    }
    )
    AddNewOption(
    "治愈",
    { "殉道者之光选项", "殉道者之光选项" },
    120,
    true,
    { 55, 0, 100, 1 },
    nil,
    {
        "More Light Of The Martyr options." .. C.TOOLTIP_VALUE_1 .. "Player minimum Health threshold.",
        "更多殉道者之光选项。" .. C.TOOLTIP_VALUE_1 .. "玩家最低健康阈值。"
    }
    )
    AddNewOption(
    "治愈",
    { "紧急治疗", "紧急治疗" },
    222,
    true,
    { 30, 1, 75, 1 },
    { 45, 1, 75, 1 },
    {
        "Heal the tanks or the player as very high priority when their health is critical." ..
        C.TOOLTIP_VALUE_1 .. "Tanks health threshold." .. C.TOOLTIP_VALUE_2 .. "Player health threshold.",
        "在健康状况至关重要的时候，坦克或玩家的治疗非常重要。" .. C.TOOLTIP_VALUE_1 .. "坦克健康阈值。" .. C.TOOLTIP_VALUE_2 .. "玩家健康阈值。"
    }
    )
    AddSection("治愈", { "主动治疗", "积极治疗" }, "Yellow")
    AddNewOption(
    "治愈",
    { "治疗目标", "治疗目标" },
    230,
    false,
    { 1, { "已知单位", "已知单位" }, { "任何单位", "任何单位" } },
    nil,
    {
        "Heal our current target if it is listed to be healed." ..
        C.TOOLTIP_VALUE ..
        "Choose preferred mode." ..
        C.TOOLTIP_SUBVALUE("已知单位") ..
        "Allow Heal Target to be used only when we are targetting a unit listed for it." ..
        C.TOOLTIP_SUBVALUE("任何单位") .. "Allow Heal Target to be used on any unit.",
        "治愈目前的治疗目标，如果被列入治疗。" ..
        C.TOOLTIP_VALUE ..
        "选择首选模式。" ..
        C.TOOLTIP_SUBVALUE("已知单位") ..
        "只有当我们定位列出的单位时，才能使用治疗目标。" .. C.TOOLTIP_SUBVALUE("任何单位") .. "允许治疗目标在任何单位使用。"
    }
    )
    AddNewOption(
    "治愈",
    { "团队成员Debuffs", "袭击败坏" },
    220,
    true,
    { 30, 0, 100, 1 },
    nil,
    {
        "Use Holy Shock/Flash of Light on Debuffed units." .. C.TOOLTIP_VALUE .. "Health threshold.",
        "使用 神圣震击/圣光闪现 在不好的光环的单位。" .. C.TOOLTIP_VALUE .. "健康阈值。"
    }
    )
    AddNewOption(
    "治愈",
    { "坦克Debuffs", "坦克破坏" },
    220,
    true,
    { 50, 0, 100, 1 },
    nil,
    {
        "Use Holy Shock/Flash of Light on Debuffed tanks." .. C.TOOLTIP_VALUE .. "Health threshold.",
        "使用 神圣震击/圣光闪现 坦克与坏的光环。" .. C.TOOLTIP_VALUE .. "健康阈值。"
    }
    )
    AddNewOption(
    "治愈",
    { "Topping Heal", "顶部治疗" },
    220,
    true,
    { 100, 0, 100, 1 },
    nil,
    {
        "Use Holy Shock/Flash of Light on units to be topped." .. C.TOOLTIP_VALUE .. "Health threshold.",
        "使用 神圣震击/圣光闪现 在单位上排名第一。" .. C.TOOLTIP_VALUE .. "健康阈值。"
    }
    )
    AddSection("大技能", { "大技能", "冷却时间" }, "Yellow")
    AddPresetOption("AoEHealingUnitsHealth", "大技能", { "光环掌握", "光环掌握" }, true, { 3, 1, 25, 1 }, { 80, 0, 100, 1 })
    AddPresetOption("AoEHealingUnitsHealth", "大技能", { "复仇之怒", "复仇之怒" }, true, { 3, 1, 25, 1 }, { 60, 0, 100, 1 })
    AddNewOption(
    "大技能",
    { "复仇之怒 坦克", "复仇之怒坦克" },
    220,
    true,
    { 35, 0, 100, 1 },
    nil,
    {
        "Use when a Tank health fall under health threshold." .. C.TOOLTIP_VALUE .. "Health threshold.",
        "当坦克健康状况处于健康阈值以下时使用。" .. C.TOOLTIP_VALUE .. "健康阈值。"
    }
    )
    AddPresetOption("AoEHealingUnitsHealth", "大技能", { "美德道标", "美德道标" }, true, { 3, 1, 5, 1 }, { 90, 0, 100, 1 })
    AddNewOption(
    "大技能",
    { "美德道标循环", "美德道标回转" },
    210,
    false,
    nil,
    nil,
    {
        "Enable this option to priorize Holy Prism > Light of Dawn > Holy Shock > Flash of Light during Beacon of Virtue.",
        "启用此选项以确定优先级神圣棱镜>黎明之光>神圣震击>圣光闪现中美德道标"
    }
    )
    AddNewOption(
    "大技能",
    { "错开技能冷却", "不要重覆冷却时间" },
    210,
    false,
    nil,
    nil,
    {
        "Enable this option to prevent the rotation from overlapping Cooldowns. While this is enabled, Avenging Wrath, Holy Avenger and Tyr's Deliverance will never be used at the same time.",
        "启用此选项以防止旋转重复冷却时间。虽然这是启用，复仇之怒，神圣复仇者和提尔的拯救将永远不会同时使用。"
    }
    )
    AddPresetOption("AoEHealingUnitsHealth", "大技能", { "神圣复仇者", "神圣复仇者" }, true, { 3, 1, 25, 1 }, { 70, 0, 100, 1 })
    AddPresetOption("DirectHealingTankRaid", "治愈", { "圣疗术", "圣疗术" }, true, { 25, 0, 100, 1 }, { 15, 0, 100, 1 })
    AddNewOption(
    "大技能",
    { "律法之责", "律法之则" },
    222,
    false,
    { 4, 1, 25, 1 },
    { 80, 0, 100, 1 },
    {
        "Use when selected number of units are under health threshold. It will also be used without health checks if we have two charges." ..
        C.TOOLTIP_VALUE_1 ..
        "Number of Units." ..
        C.TOOLTIP_VALUE_2 ..
        "Health threshold." ..
        C.TOOLTIP_HINT("This will not be used if Rule Of Law Sync is enabled."),
        "当选择的单位数目在健康阈值以下时使用。如果我们有两项费用，也不会使用健康检查。" ..
        C.TOOLTIP_VALUE_1 .. "单位数。" .. C.TOOLTIP_VALUE_2 .. "健康阈值。" .. C.TOOLTIP_HINT("如果不会使用律法之则同步启用。")
    }
    )
    AddNewOption(
    "大技能",
    { "同步律法之责", "律法之则同步" },
    210,
    true,
    nil,
    nil,
    {
        "Enable this option to sync Rule of Law with Light of Dawn everytime it is available." ..
        C.TOOLTIP_HINT("Rule of Law with Health option will not be used while this is enabled."),
        "启用此选项进行同步律法之则同黎明之光每次都可用。" .. C.TOOLTIP_HINT("律法之则在启用此选项时，将不会使用“健康”选项。")
    }
    )
    AddPresetOption("AoEHealingUnitsHealth", "大技能", { "提尔的拯救", "提尔的拯救" }, true, { 3, 1, 25, 1 }, { 80, 0, 100, 1 })
    AddSection("大技能", { "祝福", "祝福" }, "Yellow")
    AddNewOption(
    "大技能",
    { "保护祝福", "保护祝福" },
    232,
    true,
    { 3, { "任何人", "任何人" }, { "任何人除了坦克", "任何人除了坦克" }, { "治疗师", "治疗师" } },
    { 30, 1, 100, 1 },
    {
        "Use Blessing of Protection on a unit that has threath on it." ..
        C.TOOLTIP_VALUE_1 ..
        "Select if you want to use Blessing of Protection on Anyone, Anyone Except Tanks or only on Healers." ..
        C.TOOLTIP_VALUE_2 .. "Health threshold.",
        "使用保护祝福对一个对它有威胁的单位。" .. C.TOOLTIP_VALUE_1 .. "选择是否要使用保护祝福任何人，任何人除了坦克或只有治疗者。" .. C.TOOLTIP_VALUE_2 .. "健康阈值。"
    }
    )
    AddNewOption(
    "大技能",
    { "牺牲祝福", "牺牲祝福" },
    222,
    true,
    { 50, 0, 100, 1 },
    { 75, 30, 100, 1 },
    {
        "Use Blessing of Sacrifice." ..
        C.TOOLTIP_VALUE_1 .. "Unit Health threshold." .. C.TOOLTIP_VALUE_2 .. "Player minimum Health threshold.",
        "使用牺牲祝福。" .. C.TOOLTIP_VALUE_1 .. "单位健康阈值。" .. C.TOOLTIP_VALUE_2 .. "玩家最低健康阈值。"
    }
    )
    AddNewOption(
    "大技能",
    { "牺牲祝福选项", "牺牲祝福选项" },
    133,
    true,
    { 2, { "任何单位", "任何单位" }, { "坦克", "只有坦克" } },
    { 2, { "禁用", "残" }, { "启用", "启用" } },
    {
        "More Blessing of Sacrifice options." ..
        C.TOOLTIP_VALUE_1 ..
        "Which units should we consider valid for Blessing of Sacrifice." ..
        C.TOOLTIP_VALUE_2 .. "Enable to sync Divine Protection with Blessing of Sacrifice.",
        "更多牺牲祝福选项。" .. C.TOOLTIP_VALUE_1 .. "我们认为哪些单位是有效的牺牲祝福。" .. C.TOOLTIP_VALUE_2 .. "启用同步功能圣佑术同牺牲祝福。"
    }
    )
    AddSection("攻/防", "伤害输出", "Yellow")
    AddNewOption(
    "攻/防",
    { "DPS", "损伤" },
    223,
    true,
    { 95, 0, 100, 1 },
    { 1, "高", "Low" },
    {
        "Enables DPS options." ..
        C.TOOLTIP_VALUE_1 ..
        "Will only DPS if the Lowest unit is above DPS health treshold." ..
        C.TOOLTIP_VALUE_1 ..
        "High - Use as high priority when value 1 health condition is true. Low - As as last option if no healing condtions are met.",
        "启用损坏选项。" .. C.TOOLTIP_VALUE_1 .. "如果最低单位高于伤害健康阈值，则只会损坏。"
    }
    )
    AddNewOption(
    "攻/防",
    { "奉献", "奉献" },
    222,
    true,
    { 2, 1, 10, 1 },
    { 1, 1, 10, 1 },
    {
        "Use Consecration." ..
        C.TOOLTIP_VALUE_1 ..
        "Amount of units that needs to be within 8 yards of Player to use as High Priority." ..
        C.TOOLTIP_VALUE_2 ..
        "Amount of units that needs to be within 8 yards of Player to use as Low Priority." ..
        C.TOOLTIP_HINT(
        "Only used when the Lowest unit's health is higher than the DPS health threshold"
        ),
        "使用奉献。" ..
        C.TOOLTIP_VALUE_1 ..
        "需要在使用高优先级的玩家8码范围内的单位数量。" ..
        C.TOOLTIP_VALUE_2 .. "需要在使用低优先级的玩家8码范围内的单位数量。" .. C.TOOLTIP_HINT("仅当最低单位的健康状况高于伤害健康阈值时才使用。")
    }
    )
    AddPresetOption("HealerOffensive", { "十字军打击", "十字军打击" })
    AddNewOption(
    "攻/防",
    { "神圣棱镜 输出", "损伤神圣棱镜" },
    222,
    true,
    { 3, 1, 5, 1 },
    { 100, 1, 100, 1 },
    {
        "Use Holy Prism on Player." ..
        C.TOOLTIP_VALUE_1 ..
        "Amount of units that needs to be within 15 yards of Player to use.." ..
        C.TOOLTIP_VALUE_2 ..
        "Health Threshold to use on player." ..
        C.TOOLTIP_HINT(
        "Only used when the Lowest unit's health is higher than the DPS health threshold"
        ),
        "使用神圣棱镜在玩家身上。" ..
        C.TOOLTIP_VALUE_1 ..
        "需要在使用者15码范围内的单位数量。" ..
        C.TOOLTIP_VALUE_2 .. "运动员使用健康阈值。" .. C.TOOLTIP_HINT("仅当最低单位的健康状况高于伤害健康阈值时才使用。")
    }
    )
    AddPresetOption("HealerOffensive", { "神圣震击 输出", "神圣震击损伤" })
    AddNewOption(
    "攻/防",
    { "圣光之锤 输出", "圣光之锤损伤" },
    222,
    true,
    { 3, 1, 10, 1 },
    { 100, 1, 100, 1 },
    {
        "Use Light's Hammer on Player." ..
        C.TOOLTIP_VALUE_1 ..
        "Amount of units that needs to be within 10 yards of Player to use.." ..
        C.TOOLTIP_VALUE_2 ..
        "Health Threshold to use on player." ..
        C.TOOLTIP_HINT(
        "Only used when the Lowest unit's health is higher than the DPS health threshold"
        ),
        "使用圣光之锤在玩家身上。" ..
        C.TOOLTIP_VALUE_1 ..
        "需要在10码以内的玩家使用的单位数量。" ..
        C.TOOLTIP_VALUE_2 .. "运动员使用健康阈值。" .. C.TOOLTIP_HINT("仅当最低单位的健康状况高于伤害健康阈值时才使用。")
    }
    )
    AddPresetOption("HealerOffensive", { "审判", "审判" })
    AddSection("攻/防", { "攻击时治疗", "进攻治疗" }, "Yellow")
    AddNewOption(
    "攻/防",
    { "十字军之力", "十字军之力" },
    230,
    true,
    { 1, { "自动", "汽车" }, { "高优先级", "高优先" }, { "低优先级", "低优先级" } },
    nil,
    {
        "Use Crusader Strike to lower remaining Cooldown on Holy Shock and Light of Dawn." ..
        C.TOOLTIP_VALUE_1 ..
        "Select High Priority to do this very soon in the rotation or Low Priority to use as filler. Auto will use as High Priority if we have two charges of Crusader Strike and as Low Priority if we have only one charge." ..
        C.TOOLTIP_HINT("This will be used regardless of Offensive DPS settings."),
        "使用十字军打击降低剩下的冷却时间神圣震击和黎明之光。" ..
        C.TOOLTIP_VALUE_1 ..
        "选择高优先级，尽快在旋转或低优先级中使用作为填充。如果我们有两项费用，汽车将会高度重视十字军打击如果我们只收取一笔费用，则优先级低。" ..
        C.TOOLTIP_HINT("无论损坏设置如何，都将使用此操作。")
    }
    )
    AddNewOption(
    "攻/防",
    { "圣光审判", "圣光审判" },
    233,
    true,
    { 1, { "自动", "汽车" }, { "焦点", "焦点" }, { "主坦", "主坦克" }, { "副坦", "关罐" }, { "目标", "目标" } },
    { 1, { "高优先级", "高优先" }, { "低优先级", "低优先级" } },
    {
        "Use Judgment to apply Judgment of Light." ..
        C.TOOLTIP_VALUE_1 ..
        "Select which unit you want to apply Judgment of Light on." ..
        C.TOOLTIP_SUBVALUE("自动") ..
        "Auto will apply Judgment of Light following this priority: Main Tank Target, Off Tank Target, Focus, Target. It will attempt to put it on different target if priority target is already debuffed." ..
        C.TOOLTIP_VALUE_2 ..
        "Select High Priority to do this very soon in the rotation or Low Priority to use as filler." ..
        C.TOOLTIP_HINT("This will be used regardless of Offensive DPS settings."),
        "使用审判申请圣光审判。" ..
        C.TOOLTIP_VALUE_1 ..
        "选择要应用的单位。" ..
        C.TOOLTIP_SUBVALUE("汽车") ..
        "自动将按照以下优先事项应用光的判断：主坦克目标，关闭坦克目标，重点，目标。 如果优先级目标已经被减少，它将尝试将其放在不同的目标上。" ..
        C.TOOLTIP_VALUE_2 .. "选择高优先级，尽快在旋转或低优先级中用作填充。" .. C.TOOLTIP_HINT("无论损坏设置如何，都将使用此操作。")
    }
    )
    AddNewOption(
    "攻/防",
    { "圣光审判 周期", "圣光审判周期" },
    222,
    true,
    { 6, 1, 10, 1 },
    { 3, 0, 25, 0.1 },
    {
        "Use Judgment Of Light Cycle." ..
        C.TOOLTIP_VALUE_1 ..
        "Amount of debuffs to apply." .. C.TOOLTIP_VALUE_2 .. "Minimum health (in million) to apply.",
        "使用圣光审判周期。" .. C.TOOLTIP_VALUE_1 .. "最高使用量。" .. C.TOOLTIP_VALUE_2 .. "最低健康（百万元）申请。"
    }
    )
    AddSection("攻/防", { "防御", "防御性" }, "Yellow")
    AddNewOption(
    "攻/防",
    { "圣佑术", "圣佑术" },
    220,
    true,
    { 50, 1, 100, 1 },
    nil,
    { "Use Divine Protection." .. C.TOOLTIP_VALUE .. "Health threshold.", "使用圣佑术。" .. C.TOOLTIP_VALUE .. "健康阈值。" }
    )
    AddNewOption(
    "攻/防",
    { "圣盾术", "圣盾术" },
    220,
    true,
    { 20, 1, 100, 1 },
    nil,
    { "Use Divine Shield." .. C.TOOLTIP_VALUE .. "Health threshold.", "使用圣盾术。" .. C.TOOLTIP_VALUE .. "健康阈值。" }
    )
    if GiftOfTheNaaru:Exists() then
        AddNewOption(
        "攻/防",
        { "纳鲁的赐福", "纳鲁的赐福" },
        222,
        true,
        { 65, 0, 100, 1 },
        { 55, 0, 100, 1 },
        {
            "Use Gift Of The Naaru." ..
            C.TOOLTIP_VALUE_1 ..
            "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid.",
            "使用纳鲁的赐福。" .. C.TOOLTIP_VALUE_1 .. "在坦克上使用的门槛。" .. C.TOOLTIP_VALUE_2 .. "突袭使用的门槛。"
        }
        )
    end
    AddNewOption(
    "攻/防",
    { "治疗物品", "治疗项目" },
    220,
    true,
    { 35, 1, 95, 1 },
    nil,
    { "Health Percentage to use Healthstone / Healing Potion.", "健康百分比使用治疗石/治疗药水。" }
    )
    AddOutput("|cFF9A2EFE主T:")
    AddOutput("|cFF9A2EFE副T:")
    AddOutput("|cFF9A2EFE最低:")
    AddOutput("|cFF9A2EFE有害效果:")
    SetOutput("|cFF9A2EFE有害效果:", 0)
    AddOutput("|cFF9A2EFE黎明之光单位:")
    SetOutput("|cFF9A2EFE黎明之光单位:", 0)
    ISCL = {[FlashOfLight:ID()] = "Flash of Light", [HolyLight:ID()] = "圣光术" }
end
function Rotation:Events()
    local SpellID
    self.TyrsDeliveranceCasted, self.AvengingWrathCasted, self.HolyAvengerCasted = 0, 0, 0
    EventFrame:RegisterForSelfCombatEvent(
    function(...)
        SpellID = select(12, ...)
        if SpellID == 200652 then
            Bug("Casted Tyr's Deliverance.")
            self.TyrsDeliveranceCasted = GetTime() + 7
        end
        if SpellID == 31842 then
            Bug("Casted Avenging Wrath.")
            self.AvengingWrathCasted = GetTime() + 22
        end
        if SpellID == 105809 then
            Bug("Casted Holy Avenger.")
            self.HolyAvengerCasted = GetTime() + 17
        end
        if SpellID == 200025 then
            Bug("Casted Beacon of Virtue.")
            BeaconOfVirtue.LastCastTime = GetTime()
        end
    end,
    "SPELL_CAST_SUCCESS"
    )
end
function Rotation:Pulse()
    if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
        return
    end
    if BMPullTime() < 5 then
        self:Opening()
        return
    end
    if GetTime() < Rotation.SpamPrevention then
        return
    end
    Rotation.SpamPrevention = GetTime() + 0.05
    Target = Unit.Target
    local InCombat = Player:IsInCombat()
    Rotations:RefreshUnitTables(Rotation.Identifier)
    if Player:Debuff(SapSoul) then
        if
        MainTank and MainTank:Exists() and MainTank:GUID() ~= Player:GUID() and
        MainTank:SpecialHealthPercentage() < 90 and
        MainTank:CanCast(LightOfTheMartyr)
        then
            MainTank:Cast(LightOfTheMartyr)
            return
        end
        if
        Lowest and Lowest:Exists() and Lowest:GUID() ~= Player:GUID() and Lowest:SpecialHealthPercentage() < 90 and
        Lowest:CanCast(LightOfTheMartyr)
        then
            Lowest:Cast(LightOfTheMartyr)
            return
        end
        if MainTank and MainTank:Exists() and MainTank:GUID() ~= Player:GUID() and MainTank:CanCast(LightOfTheMartyr) then
            MainTank:Cast(LightOfTheMartyr)
            return
        end
    end
    if not InCombat then
        SetOutput("|cFF9A2EFE有害效果:", 0)
        self:OutOfCombat()
        return
    end
    if InCombat then
        self:Defensives()
    end
    Target = Player:ReTarget(Judgment, false) or Unit.Target
    self:Interrupts()
    self:OffGCDAbilities()
    if Player:GlobalCooldown() == 0 then
        self:Combat()
    end
end
function Rotation:Opening()
    Player:UsePotions("智力药水", GetSecondOptionValue("抢先使用药水"))
    if
    Target:Exists() and IsOptionEnabled("抢先施放(需DBM插件)") and
    (GetOptionValue("抢先施放(需DBM插件)") == "无条件使用" or
    (GetOptionValue("抢先施放(需DBM插件)") == "打BOSS使用" and Target:IsBoss()))
    then
        if Judgment:Exists() and BMPullTime() < GetSecondOptionValue("抢先施放(需DBM插件)") and Target:CanCast(Judgment) then
            Target:Cast(Judgment)
            return
        end
    end
end
function Rotation:Interrupts()
    Player:UseInterrupt(nil, ArcaneTorrent)
end
function Rotation:OffGCDAbilities()
    if IsOptionEnabled("延时之力药水") and ProlongedPowerUnitsCount >= GetOptionValue("延时之力药水") then
        Player:UsePotions("延时之力药水")
    end
    Player:UsePotions(GetOptionValue("使用法力药水"))
end
function Rotation:Defensives()
    Player:UseHealingItem()
    if
    DivineProtection:Exists() and IsOptionEnabled("圣佑术") and Player:CanCast(DivineProtection) and
    Player:SpecialHealthPercentage() <= GetOptionValue("圣佑术")
    then
        Player:Cast(DivineProtection)
    end
    if
    DivineShield:Exists() and IsOptionEnabled("圣盾术") and Player:CanCast(DivineShield) and
    Player:SpecialHealthPercentage() <= GetOptionValue("圣盾术") and
    not Player:DebuffAny(Forbearance)
    then
        Player:Cast(DivineShield)
        return
    end
    if
    GiftOfTheNaaru:Exists() and IsOptionEnabled("纳鲁的赐福") and
    Player:SpecialHealthPercentage() <= GetOptionValue("纳鲁的赐福") and
    Player:CanCast(GiftOfTheNaaru)
    then
        Player:Cast(GiftOfTheNaaru)
        return
    end
end
Rotation.TanksStatus, Rotation.MainTankTanking, Rotation.OffTankTanking = {
    Main = { IsTanking = GetTime() },
    Off = { IsTanking = GetTime() }
}
function Rotation:RefreshTanksStatus()
    self.TanksStatus = {
        Main = {
            IsTanking = MainTank and MainTank:ThreatSituation() == 3 and GetTime() or self.TanksStatus.Main.IsTanking
        },
        Off = { IsTanking = OffTank and OffTank:ThreatSituation() == 3 and GetTime() or self.TanksStatus.Off.IsTanking }
    }
    self.MainTankTanking = GetTime() - self.TanksStatus.Main.IsTanking < 3 or false
    self.OffTankTanking = GetTime() - self.TanksStatus.Off.IsTanking < 3 or false
end
function Rotation:HealTarget(ThisUnit)
    if HolyShock:Exists() and ThisUnit:CanCast(HolyShock) then
        Bug("Heal Target - Holy Shock")
        ThisUnit:Cast(HolyShock)
        return
    end
    if FlashOfLight:Exists() and ThisUnit:CanCast(FlashOfLight) then
        Bug("Heal Target - Flash of Light")
        ThisUnit:Cast(FlashOfLight)
        return
    end
end
function Rotation:BeaconsHandler()
    if not BeaconOfVirtue:Exists() and IsOptionEnabled("道标(圣光 +信仰)") then
        self.InvertBeacons, self.BeaconOfLightFallBack, self.BeaconOfFaithFallBack = nil, false, false
        if BeaconOfLight:Exists() and not BeaconOfLight:IsOnCooldown() then
            self.BeaconOption = GetOptionValue("道标(圣光 +信仰)")
            if self.BeaconOption == "焦点 + 自己" then
                self.Unit1, self.Unit2, self.Unit3, self.Unit4 = Focus, Player, MainTank, OffTank
            elseif self.BeaconOption == "主坦 + 焦点" then
                self.Unit1, self.Unit2, self.Unit3, self.Unit4 = MainTank, Focus, OffTank, Player
            elseif self.BeaconOption == "主坦 + 副坦" then
                self.Unit1, self.Unit2, self.Unit3, self.Unit4 = MainTank, OffTank, Focus, Player
            elseif self.BeaconOption == "主坦 + 自己" then
                self.Unit1, self.Unit2, self.Unit3, self.Unit4 = MainTank, Player, Focus, OffTank
            elseif self.BeaconOption == "副坦 + 焦点" then
                self.Unit1, self.Unit2, self.Unit3, self.Unit4 = OffTank, Focus, MainTank, Player
            elseif self.BeaconOption == "副坦 + 自己" then
                self.Unit1, self.Unit2, self.Unit3, self.Unit4 = OffTank, Player, MainTank, Focus
            elseif self.BeaconOption == "自己 + 焦点" then
                self.Unit1, self.Unit2, self.Unit3, self.Unit4 = Player, Focus, MainTank, OffTank
            end
            if self.Unit1 and self.Unit1:CanCast(FlashOfLight) then
                self.InvertBeacons = self.Unit1:Buff(BeaconOfFaith)
                if not self.InvertBeacons and not self.Unit1:Buff(BeaconOfLight) and self.Unit1:CanCast(BeaconOfLight) then
                    Bug("Beacon of Light - self.Unit1 (Normal)")
                    self.Unit1:Cast(BeaconOfLight)
                    return
                end
            else
                self.BeaconOfLightFallBack = true
            end
            if BeaconOfFaith:Exists() then
                if self.Unit2 and self.Unit2:CanCast(FlashOfLight) then
                    if self.InvertBeacons then
                        if not self.Unit2:Buff(BeaconOfLight) and self.Unit2:CanCast(BeaconOfLight) then
                            Bug("Beacon of Light - self.Unit2 (Invert Beacons)")
                            self.Unit2:Cast(BeaconOfLight)
                            return
                        end
                    else
                        if
                        not self.Unit2:Buff(BeaconOfFaith) and not self.Unit2:Buff(BeaconOfLight) and
                        self.Unit2:CanCast(BeaconOfFaith)
                        then
                            Bug("Beacon of Faith - self.Unit2 (Normal)")
                            self.Unit2:Cast(BeaconOfFaith)
                            return
                        end
                    end
                else
                    self.BeaconOfFaithFallBack = true
                end
            else
                if self.Unit2 and self.Unit2:CanCast(FlashOfLight) then
                    if self.BeaconOfLightFallBack then
                        if self.Unit2:Buff(BeaconOfLight) then
                            self.BeaconOfLightFallBack = false
                        else
                            if not self.Unit2:Buff(BeaconOfLight) and self.Unit2:CanCast(BeaconOfLight) then
                                self.BeaconOfLightFallBack = false
                                Bug("Beacon of Light - self.Unit2 (Fall Back)")
                                self.Unit2:Cast(BeaconOfLight)
                                return
                            end
                        end
                    end
                end
            end
            if self.Unit3 and self.Unit3:CanCast(FlashOfLight) then
                if self.BeaconOfLightFallBack then
                    if self.Unit3:Buff(BeaconOfLight) then
                        self.BeaconOfLightFallBack = false
                    else
                        if
                        not self.Unit3:Buff(BeaconOfLight) and not self.Unit3:Buff(BeaconOfFaith) and
                        self.Unit3:CanCast(BeaconOfLight)
                        then
                            self.BeaconOfLightFallBack = false
                            Bug("Beacon of Light - self.Unit3 (Fall Back)")
                            self.Unit3:Cast(BeaconOfLight)
                            return
                        end
                    end
                end
                if self.BeaconOfFaithFallBack then
                    if self.Unit3:Buff(BeaconOfFaith) then
                        self.BeaconOfFaithFallBack = false
                    else
                        if
                        not self.Unit3:Buff(BeaconOfFaith) and not self.Unit3:Buff(BeaconOfLight) and
                        self.Unit3:CanCast(BeaconOfFaith)
                        then
                            self.BeaconOfFaithFallBack = false
                            Bug("Beacon of Faith - self.Unit3 (Fall Back)")
                            self.Unit3:Cast(BeaconOfFaith)
                            return
                        end
                    end
                end
            end
            if self.Unit4 and self.Unit4:CanCast(FlashOfLight) then
                if self.BeaconOfLightFallBack then
                    if
                    not self.Unit4:Buff(BeaconOfLight) and not self.Unit4:Buff(BeaconOfFaith) and
                    self.Unit4:CanCast(BeaconOfLight)
                    then
                        self.BeaconOfLightFallBack = false
                        Bug("Beacon of Light - self.Unit4 (Fall Back)")
                        self.Unit4:Cast(BeaconOfLight)
                        return
                    end
                end
                if self.BeaconOfFaithFallBack then
                    if
                    not self.Unit4:Buff(BeaconOfFaith) and not self.Unit4:Buff(BeaconOfLight) and
                    self.Unit4:CanCast(BeaconOfFaith)
                    then
                        self.BeaconOfLightFallBack = false
                        Bug("Beacon of Faith - self.Unit4 (Fall Back)")
                        self.Unit4:Cast(BeaconOfFaith)
                        return
                    end
                end
            end
        end
    end
end
function Rotation:JudgmentOfLightHandler(Priority)
    if
    JudgmentOfLight:Exists() and IsOptionEnabled("圣光审判") and not self:SacrificeAuraActive() and
    not Judgment:IsOnCooldown() and
    (GetSecondOptionValue("圣光审判") == "高优先级" or Priority ~= "高")
    then
        Option1 = GetOptionValue("圣光审判")
        if Option1 == "自动" or Option1 == "主坦" then
            if
            MainTankTarget and MainTankTarget:Exists() and not MainTankTarget:Debuff(JudgmentOfLightDebuff) and
            MainTankTarget:CanCast(Judgment)
            then
                Bug("Judgment Of Light - Main Tank Target")
                MainTankTarget:Cast(Judgment)
                return
            end
        end
        if Option1 == "自动" or Option1 == "副坦" then
            if
            OffTankTarget and OffTankTarget:Exists() and not OffTankTarget:Debuff(JudgmentOfLightDebuff) and
            OffTankTarget:CanCast(Judgment)
            then
                Bug("Judgment Of Light - Off Tank Target")
                OffTankTarget:Cast(Judgment)
                return
            end
        end
        if Option1 == "自动" or Option1 == "焦点" then
            if Focus and Focus:Exists() and not Focus:Debuff(JudgmentOfLightDebuff) and Focus:CanCast(Judgment) then
                Bug("Judgment Of Light - Focus")
                Focus:Cast(Judgment)
                return
            end
        end
        if Option1 == "自动" or Option1 == "目标" then
            if Target and Target:Exists() and not Target:Debuff(JudgmentOfLightDebuff) and Target:CanCast(Judgment) then
                Bug("Judgment Of Light - Target")
                Target:Cast(Judgment)
                return
            end
        end
        if IsOptionEnabled("圣光审判 周期") and JudgmentOfLightUnit and JudgmentOfLightUnit:CanCast(Judgment) then
            Bug("Judgment Of Light - Cycle")
            JudgmentOfLightUnit:Cast(Judgment)
            return
        end
    end
end
function Rotation:CrusadersMightHandler(Priority)
    if
    CrusaderStrike:Exists() and CrusadersMight:Exists() and IsOptionEnabled("十字军之力") and
    not CrusaderStrike:IsOnCooldown() and
    (HolyShock:IsOnCooldown() or LightOfDawn:IsOnCooldown())
    then
        if
        GetOptionValue("十字军之力") == "高优先级" or Priority == "Low" or
        (GetOptionValue("十字军之力") == "自动" and
        (Priority == "高" and
        (CrusaderStrike:Charges() >= 2 or
        CrusaderStrike:Charges() >= 1 and CrusaderStrike:Recharge() < 1)))
        then
            if BestTarget and BestTarget:CanCast(CrusaderStrike) then
                Bug("Crusader Strike - Crusader's Might " .. Priority .. " Priority")
                BestTarget:Cast(CrusaderStrike)
                return
            end
        end
    end
end
function Rotation:CanUseCooldowns()
    if IsOptionEnabled("错开技能冷却") then
        return self.AvengingWrathCasted < GetTime() and self.TyrsDeliveranceCasted < GetTime() and
        self.HolyAvengerCasted < GetTime() or
        false
    else
        return true
    end
end
function Rotation:FindBeaconedUnits(HealUnits)
    local ThisUnit = nil
    self.BeaconOfLightUnit, self.BeaconOfFaithUnit = nil, nil
    if not BeaconOfVirtue:Exists() then
        if BeaconOfFaith:Exists() then
            for i = 1, #HealUnits do
                ThisUnit = HealUnits[i]
                if self.BeaconOfLightUnit == nil and ThisUnit:Buff(BeaconOfLight) then
                    self.BeaconOfLightUnit = ThisUnit
                elseif BeaconOfFaith:Exists() and self.BeaconOfFaithUnit == nil and ThisUnit:Buff(BeaconOfFaith) then
                    self.BeaconOfFaithUnit = ThisUnit
                end
            end
        else
            for i = 1, #HealUnits do
                ThisUnit = HealUnits[i]
                if self.BeaconOfLightUnit == nil and ThisUnit:Buff(BeaconOfLight) then
                    self.BeaconOfLightUnit = ThisUnit
                end
            end
        end
    end
end
function Rotation:UseInfusionOfLight()
    if IsOptionEnabled("圣光灌注") and IsOptionEnabled("IoL Alternative") and Player:Buff(InfusionOfLight) and Lowest then
        local ThisSpell
        ThisSpell =         GetOptionValue("圣光灌注") == "圣光术" and Lowest:SpecialHealthPercentage() > GetSecondOptionValue("圣光灌注") and
        Lowest:SpecialHealthPercentage() <= GetOptionValue("IoL Holy Light") and
        HolyLight
        ThisSpell =         (GetOptionValue("圣光灌注") == "圣光术" or GetOptionValue("圣光灌注") == "圣光闪现") and
        Lowest:SpecialHealthPercentage() <= GetSecondOptionValue("圣光灌注") and
        FlashOfLight or
        ThisSpell
        if ThisSpell and Lowest:CanCast(ThisSpell) then
            Lowest:Cast(ThisSpell)
            Bug("Use InfusionOfLight with: " .. ThisSpell:Name())
            return true
        end
    end
    return false
end
function Rotation:SacrificeAuraActive()
    if AuraOfSacrifice:Exists() and Player:Buff(AuraMastery) then
        return true
    end
    return false
end
function Rotation:UnitTables()
    HealUnits = Player:HealUnitsAround(100, 40)
    CurrentBadDebuffs = Player:GetRaidDebuffs(HealUnits)
    if CurrentBadDebuffs ~= nil then
        SetOutput("|cFF9A2EFE有害效果:", #CurrentBadDebuffs.Top + #CurrentBadDebuffs.Debuff)
    end
    DispelUnit = Unit.Dispel(HealUnits, Cleanse)
    MainTank, MainTankTarget, OffTank, OffTankTarget = Unit.GetMainTanks()
    self:RefreshTanksStatus()
    if
    IsOptionEnabled("避免治疗道标单位") and
    (GetNumGroupMembers() > 0 and (not BeaconOfFaith:Exists() or GetNumGroupMembers() > 2))
    then
        self:FindBeaconedUnits(HealUnits)
        LowestBeaconsIncluded = Unit.Lowest(HealUnits)
        LowestBeaconsExcluded = Unit.Lowest(HealUnits, self.BeaconOfLightUnit, self.BeaconOfFaithUnit)
        if
        LowestBeaconsIncluded and LowestBeaconsExcluded and
        LowestBeaconsIncluded:SpecialHealthPercentage() < LowestBeaconsExcluded:SpecialHealthPercentage() and
        (LowestBeaconsIncluded:SpecialHealthPercentage() < GetOptionValue("避免治疗道标单位") or
        LowestBeaconsExcluded:SpecialHealthPercentage() > GetSecondOptionValue("避免治疗道标单位"))
        then
            Lowest = LowestBeaconsIncluded
        else
            Lowest = LowestBeaconsExcluded
        end
    else
        Lowest = Unit.Lowest(HealUnits)
    end
    SetOutput("|cFF9A2EFE最低:", Lowest and Lowest:Name() or "")
    Trinket1Units =     IsOptionEnabled("使用饰品 1") and Trinket1:IsUsableInventory() and
    #Player:HealUnitsAround(GetSecondOptionValue("使用饰品 1"), 40) or
    0
    Trinket2Units =     IsOptionEnabled("使用饰品 2") and Trinket2:IsUsableInventory() and
    #Player:HealUnitsAround(GetSecondOptionValue("使用饰品 2"), 40) or
    0
    ProlongedPowerUnitsCount =     IsOptionEnabled("延时之力药水") and #Player:HealUnitsAround(GetSecondOptionValue("延时之力药水"), 40) or 0
    AuraMasteryUnits =     AuraMastery:Exists() and not AuraMastery:IsOnCooldown() and
    #Player:HealUnitsAround(GetSecondOptionValue("光环掌握"), 10) or
    0
    AvengingWrathUnits =     AvengingWrath:Exists() and not AvengingWrath:IsOnCooldown() and
    #Player:HealUnitsAround(GetSecondOptionValue("复仇之怒"), 40) or
    0
    BeaconOfVirtueUnit =     BeaconOfVirtue:Exists() and IsOptionEnabled("美德道标") and
    Player:BestClusterOfAlliesToHeal(GetOptionValue("美德道标"), GetSecondOptionValue("美德道标"), 30) or
    nil
    Enemies_30y = Player:EnemiesWithinDistance(30)
    Enemies_15y = HolyPrismDamage:Exists() and Player:FilterEnemiesByDistance(Enemies_30y, 15, true) or {}
    Enemies_10y = Player:FilterEnemiesByDistance(Enemies_30y, 10)
    Enemies_8y = Player:FilterEnemiesByDistance(Enemies_30y, 8, true)
    HolyAvengerUnits =     HolyAvenger:Exists() and not HolyAvenger:IsOnCooldown() and
    #Player:HealUnitsAround(GetSecondOptionValue("神圣复仇者"), 40) or
    0
    HolyPrismUnitsTarget =     HolyPrismDamage:Exists() and not HolyPrismDamage:IsOnCooldown() and Target and Target:CanCast(HolyPrismDamage) and
    #Target:HealUnitsAround(GetSecondOptionValue("神圣棱镜"), 15) or
    0
    HolyPrismUnitsMainTank =     HolyPrismDamage:Exists() and not HolyPrismDamage:IsOnCooldown() and MainTankTarget and
    MainTankTarget:CanCast(HolyPrismDamage) and
    #MainTankTarget:HealUnitsAround(GetSecondOptionValue("神圣棱镜"), 15) or
    0
    HolyPrismUnitsOffTank =     HolyPrismDamage:Exists() and not HolyPrismDamage:IsOnCooldown() and OffTankTarget and
    OffTankTarget:CanCast(HolyPrismDamage) and
    #OffTankTarget:HealUnitsAround(GetSecondOptionValue("神圣棱镜"), 15) or
    0
    JudgmentOfLightUnit =     JudgmentOfLight:Exists() and not Judgment:IsOnCooldown() and
    Unit.DotCycle(Enemies_30y, Judgment, JudgmentOfLightDebuff, 40, "圣光审判 周期", false, true) or
    nil
    HasRuleOfLaw =     RuleOfLaw:Exists() and IsOptionEnabled("同步律法之责") and (not RuleOfLaw:IsOnCooldown() or Player:Buff(RuleOfLaw)) or
    Player:Buff(RuleOfLaw)
    if HasRuleOfLaw and BeaconOfTheLightbringer:Exists() then
        LoDRadius, LoDRange = 9, 27
    elseif HasRuleOfLaw and not BeaconOfTheLightbringer:Exists() then
        LoDRadius, LoDRange = 7.5, 22.5
    elseif not HasRuleOfLaw and BeaconOfTheLightbringer:Exists() then
        LoDRadius, LoDRange = 6.5, 19.5
    else
        LoDRadius, LoDRange = 5, 15
    end
    LightOfDawnUnitsFrontalUnits =     LightOfDawn:Exists() and
    Player:UnitsInFrontCone(
    LoDRange,
    90,
    true,
    Player:Buff(DivinePurposeDawn) and 95 or GetSecondOptionValue("黎明之光")
    ) or
    {}
    LightOfDawnUnitsAroundPlayer =     LightOfDawn:Exists() and
    Player:HealUnitsAround(Player:Buff(DivinePurposeDawn) and 95 or GetSecondOptionValue("黎明之光"), LoDRadius) or
    {}
    LightOfDawnUnits = #Unit.MergeUnitsTables(LightOfDawnUnitsFrontalUnits, LightOfDawnUnitsAroundPlayer)
    if LightsHammer:Exists() and IsOptionEnabled("圣光之锤") and not LightsHammer:IsOnCooldown() then
        LightsHammerCount, LightsHammerUnits = Player:BestGroundHealUnits(HealUnits, GetSecondOptionValue("圣光之锤"), 10)
    else
        LightsHammerCount, LightsHammerUnits = 0, {}
    end
    SetOutput("|cFF9A2EFE黎明之光单位:", tostring(LightOfDawnUnits))
    RuleOfLawUnits =     RuleOfLaw:Exists() and not IsOptionEnabled("同步律法之责") and not RuleOfLaw:IsOnCooldown() and
    #Player:HealUnitsAround(GetSecondOptionValue("律法之责"), 60) or
    0
    TyrsDeliveranceUnits =     TyrsDeliverance:Exists() and not TyrsDeliverance:IsOnCooldown() and
    #Player:HealUnitsAround(GetSecondOptionValue("提尔的拯救"), 40) or
    0
end
function Rotation:Combat()
    if Target:Exists() and Target:CanCast(CrusaderStrike) then
        BestTarget = Target
    elseif MainTankTarget and MainTankTarget:CanCast(CrusaderStrike) then
        BestTarget = MainTankTarget
    elseif OffTankTarget and OffTankTarget:CanCast(CrusaderStrike) then
        BestTarget = OffTankTarget
    elseif Mouseover:Exists() and Mouseover:CanCast(CrusaderStrike) then
        BestTarget = Mouseover
    elseif MainTankTarget and MainTankTarget:CanCast(Judgment) then
        BestTarget = MainTankTarget
    elseif OffTankTarget and OffTankTarget:CanCast(Judgment) then
        BestTarget = OffTankTarget
    else
        BestTarget = Target
    end
    if CurrentBadDebuffs ~= nil then
        Player:DispelHandler(Cleanse, "驱散", DispelUnit, CurrentBadDebuffs.Dispel, "高")
    end
    if (Player:IsInCombat() or GetSecondOptionValue("脱离战斗后暂停治疗") == "启用") then
        if
        HammerOfJustice:Exists() and IsOptionEnabled("制裁之锤") and
        (not BeaconOfVirtue:Exists() or BeaconOfVirtue:TimeSinceCast() > 8) and
        not HammerOfJustice:IsOnCooldown()
        then
            for i = 1, #Enemies_10y do
                ThisUnit = Enemies_10y[i]
                if
                not ThisUnit:IsBoss() and not ThisUnit:IsDeadOrGhost() and ThisUnit:IsInCombat() and
                ThisUnit:CanCast(HammerOfJustice) and
                ThisUnit:IsCasting() and
                Player:CanAttack(ThisUnit)
                then
                    Bug("Hammer Of Justice - Interrupt ")
                    ThisUnit:Cast(HammerOfJustice)
                    return
                end
            end
        end
    end
    if Player:IsInCombat() or GetSecondOptionValue("脱离战斗后暂停治疗") == "启用" then
        self:JudgmentOfLightHandler("高")
        if BestTarget then
            if
            IsOptionEnabled("DPS") and GetSecondOptionValue("DPS") == "高" and
            (not Lowest or Lowest:HealthPercentage() >= GetOptionValue("DPS")) and
            BestTarget:IsInCombat()
            then
                Player:StartAttack()
                if
                Consecration:Exists() and IsOptionEnabled("奉献") and not Player:IsMoving() and
                #Enemies_8y >= GetOptionValue("奉献") and
                Player:CanCast(Consecration)
                then
                    Bug("DPS - Consecration - High Priority")
                    Player:Cast(Consecration)
                    return
                end
                if
                HolyPrismHeal:Exists() and IsOptionEnabled("神圣棱镜 输出") and #Enemies_15y >= GetOptionValue("神圣棱镜 输出") and
                Player:SpecialHealthPercentage() <= GetSecondOptionValue("神圣棱镜 输出") and
                Player:CanCast(HolyPrismHeal)
                then
                    Bug("DPS - Holy Prism")
                    Player:Cast(HolyPrismHeal)
                    return
                end
                if
                LightsHammer:Exists() and IsOptionEnabled("圣光之锤 输出") and not Player:IsMoving() and not IsFalling() and
                #Enemies_10y >= GetOptionValue("圣光之锤 输出") and
                Player:SpecialHealthPercentage() <= GetSecondOptionValue("圣光之锤 输出") and
                Player:CanCast(LightsHammer)
                then
                    Bug("DPS - Light's Hammer")
                    Player:Cast(LightsHammer)
                    return
                end
                if Judgment:Exists() and IsOptionEnabled("审判") and BestTarget:CanCast(Judgment) then
                    Bug("DPS - Judgment")
                    BestTarget:Cast(Judgment)
                    return
                end
                if HolyShockDamage:Exists() and IsOptionEnabled("神圣震击 输出") and BestTarget:CanCast(HolyShockDamage) then
                    Bug("DPS - Holy Shock")
                    BestTarget:Cast(HolyShockDamage)
                    return
                end
                if
                CrusaderStrike:Exists() and IsOptionEnabled("Crusader Strike") and
                (CrusaderStrike:Charges() == 2 or BestTarget:Debuff(JudgmentDebuff) or
                (CrusaderStrike:Charges() >= 1 and CrusaderStrike:Recharge() < 3)) and
                BestTarget:CanCast(CrusaderStrike)
                then
                    Bug("DPS - Crusader Strike")
                    BestTarget:Cast(CrusaderStrike)
                    return
                end
                if
                Consecration:Exists() and IsOptionEnabled("奉献") and not Player:IsMoving() and
                #Enemies_8y >= GetSecondOptionValue("奉献") and
                Player:CanCast(Consecration)
                then
                    Bug("DPS - Consecration - Low Priority")
                    Player:Cast(Consecration)
                    return
                end
            end
        end
    end
    if CooldownsAllowed() and Player:IsInCombat() then
        if IsOptionEnabled("使用种族技能") then
            if
            ArcaneTorrent:Exists() and Player:PowerPercentage() < GetOptionValue("使用种族技能") and
            Player:CanCast(ArcaneTorrent)
            then
                Player:Cast(ArcaneTorrent)
                return
            end
        end
        if IsOptionEnabled("使用饰品 1") and Trinket1:IsUsableInventory() then
            local Option1, Option2 = GetOptionValue("使用饰品 1"), GetSecondOptionValue("使用饰品 1")
            if
            Option1 == "无条件使用" or (Option1 == "血量" and Trinket1Units >= GetOptionValue("使用种族技能和饰品的单位数量")) or
            (Option1 == "蓝量" and Player:PowerPercentage() < GetSecondOptionValue("使用饰品 1"))
            then
                Trinket1:UseInventory()
            end
        end
        if IsOptionEnabled("使用饰品 2") and Trinket2:IsUsableInventory() then
            local Option1, Option2 = GetOptionValue("使用饰品 2"), GetSecondOptionValue("使用饰品 2")
            if
            Option1 == "无条件使用" or (Option1 == "血量" and Trinket2Units >= GetOptionValue("使用种族技能和饰品的单位数量")) or
            (Option1 == "蓝量" and Player:PowerPercentage() < GetSecondOptionValue("使用饰品 2"))
            then
                Trinket2:UseInventory()
            end
        end
        if
        RuleOfLaw:Exists() and not IsOptionEnabled("同步律法之责") and IsOptionEnabled("律法之责") and
        RuleOfLaw:TimeSinceCast() >= 10 and
        (RuleOfLawUnits >= GetOptionValue("律法之责") or RuleOfLaw:Charges() >= 2) and
        Player:CanCast(RuleOfLaw)
        then
            RuleOfLaw.LastCastTime = GetTime()
            Player:Cast(RuleOfLaw)
        end
        if AvengingWrath:Exists() and Player:CanCast(AvengingWrath) and self:CanUseCooldowns() then
            if IsOptionEnabled("复仇之怒") and AvengingWrathUnits >= GetOptionValue("复仇之怒") then
                Bug("Avenging Wrath - Normal")
                Player:Cast(AvengingWrath)
                return
            elseif
            IsOptionEnabled("复仇之怒 坦克") and
            ((MainTank and MainTank:SpecialHealthPercentage() < GetOptionValue("复仇之怒 坦克")) or
            (OffTank and OffTank:SpecialHealthPercentage() < GetOptionValue("复仇之怒 坦克")))
            then
                Bug("Avenging Wrath - Tanks")
                Player:Cast(AvengingWrath)
                return
            end
        end
        if
        HolyAvenger:Exists() and IsOptionEnabled("神圣复仇者") and HolyAvengerUnits >= GetOptionValue("神圣复仇者") and
        self:CanUseCooldowns() and
        Player:CanCast(HolyAvenger)
        then
            Player:Cast(HolyAvenger)
            return
        end
        if
        AuraMastery:Exists() and IsOptionEnabled("光环掌握") and AuraMasteryUnits >= GetOptionValue("光环掌握") and
        Player:CanCast(AuraMastery)
        then
            Player:Cast(AuraMastery)
        end
        if LayOnHands:Exists() and IsOptionEnabled("圣疗术") then
            if
            MainTank and MainTank:SpecialHealthPercentage() < GetOptionValue("圣疗术") and
            not MainTank:DebuffAny(Forbearance) and
            MainTank:CanCast(LayOnHands)
            then
                Bug("Lay On Hands - MainTank")
                MainTank:Cast(LayOnHands)
                return
            end
            if
            OffTank and OffTank:SpecialHealthPercentage() < GetOptionValue("圣疗术") and
            not OffTank:DebuffAny(Forbearance) and
            OffTank:CanCast(LayOnHands)
            then
                Bug("Lay On Hands - OffTank")
                OffTank:Cast(LayOnHands)
                return
            end
            if
            Lowest and Lowest:SpecialHealthPercentage() < GetSecondOptionValue("圣疗术") and
            not Lowest:DebuffAny(Forbearance) and
            Lowest:CanCast(LayOnHands)
            then
                Bug("Lay On Hands - Lowest")
                Lowest:Cast(LayOnHands)
                return
            end
        end
        if
        BlessingOfSacrifice:Exists() and IsOptionEnabled("牺牲祝福") and
        Player:SpecialHealthPercentage() >= GetSecondOptionValue("牺牲祝福")
        then
            local function DivineProtectionHandler()
                if GetSecondOptionValue("牺牲祝福选项") == "启用" and Player:CanCast(DivineProtection) then
                    Player:Cast(DivineProtection)
                end
            end
            if
            MainTank and MainTank:SpecialHealthPercentage() <= GetOptionValue("牺牲祝福") and
            not MainTank:BuffAny(BlessingOfFreedom) and
            not MainTank:BuffAny(BlessingOfProtection) and
            not MainTank:BuffAny(BlessingOfSacrifice) and
            MainTank:CanCast(BlessingOfSacrifice)
            then
                DivineProtectionHandler()
                Bug("Blessing Of Sacrifice - MainTank")
                MainTank:Cast(BlessingOfSacrifice)
                return
            end
            if
            OffTank and OffTank:SpecialHealthPercentage() <= GetOptionValue("牺牲祝福") and
            not OffTank:BuffAny(BlessingOfFreedom) and
            not OffTank:BuffAny(BlessingOfProtection) and
            not OffTank:BuffAny(BlessingOfSacrifice) and
            OffTank:CanCast(BlessingOfSacrifice)
            then
                DivineProtectionHandler()
                Bug("Blessing Of Sacrifice - OffTank")
                OffTank:Cast(BlessingOfSacrifice)
                return
            end
            if
            GetOptionValue("牺牲祝福") == "任何单位" and Lowest and
            Lowest:SpecialHealthPercentage() <= GetOptionValue("牺牲祝福") and
            not Lowest:BuffAny(BlessingOfFreedom) and
            not Lowest:BuffAny(BlessingOfProtection) and
            not Lowest:BuffAny(BlessingOfSacrifice) and
            Lowest:CanCast(BlessingOfSacrifice)
            then
                DivineProtectionHandler()
                Bug("Blessing Of Sacrifice - OffTank")
                Lowest:Cast(BlessingOfSacrifice)
                return
            end
        end
        if IsOptionEnabled("保护祝福") and not BlessingOfProtection:IsOnCooldown() then
            Option1, Option2 = GetOptionValue("保护祝福"), GetSecondOptionValue("保护祝福")
            for i = 1, #HealUnits do
                ThisUnit = HealUnits[i]
                if ThisUnit:ThreatSituation() == 3 and not ThisUnit:DebuffAny(Forbearance) then
                    if
                    (Option1 == "任何人" or (Option1 == "任何人除了坦克" and not ThisUnit:IsTank()) or
                    (Option1 == "治疗师" and ThisUnit:IsHealer())) and
                    ThisUnit:SpecialHealthPercentage() <= Option2 and
                    ThisUnit:CanCast(BlessingOfProtection)
                    then
                        Bug("Blessing of Protection on " .. ThisUnit:Name())
                        ThisUnit:Cast(BlessingOfProtection)
                        return
                    end
                end
            end
        end
        if
        TyrsDeliverance:Exists() and IsOptionEnabled("提尔的拯救") and self:CanUseCooldowns() and
        TyrsDeliveranceUnits >= GetOptionValue("提尔的拯救") and
        Player:CanCast(TyrsDeliverance)
        then
            Player:Cast(TyrsDeliverance)
            return
        end
        self:BeaconsHandler()
        if BeaconOfVirtue:Exists() and IsOptionEnabled("美德道标") then
            if BeaconOfVirtueUnit and BeaconOfVirtueUnit:CanCast(BeaconOfVirtue) then
                BeaconOfVirtue.LastCastTime = GetTime()
                BeaconOfVirtueUnit:Cast(BeaconOfVirtue)
                return
            end
        end
    end
    if Player:IsInCombat() or GetOptionValue("脱离战斗后暂停治疗") == "启用" then
        if CurrentBadDebuffs ~= nil then
            Player:DispelHandler(Cleanse, "驱散", DispelUnit, CurrentBadDebuffs.Dispel, "正常")
        end
        if
        Target:CanCast(FlashOfLight) and IsOptionEnabled("治疗目标") and
        (GetOptionValue("治疗目标") == "任何单位" or
        (Target:ShouldBeHealed() ~= 0 and Target:HealthPercentage() < Target:ShouldBeHealed()))
        then
            self:HealTarget(Target)
        end
        if IsOptionEnabled("紧急治疗") then
            MainTankHealth = MainTank and MainTank:CanCast(FlashOfLight) and MainTank:SpecialHealthPercentage() or 100
            OffTankHealth = OffTank and OffTank:CanCast(FlashOfLight) and OffTank:SpecialHealthPercentage() or 100
            BestTankTarget = MainTankHealth < OffTankHealth and MainTank or OffTank
            if BestTankTarget and BestTankTarget:SpecialHealthPercentage() < GetOptionValue("紧急治疗") then
                if BestTankTarget:CanCast(HolyShock) then
                    Bug("Holy Shock - Tanks Emergency")
                    BestTankTarget:Cast(HolyShock)
                    return
                elseif not Player:IsMoving() then
                    Bug("Flash of Light - Tanks Emergency")
                    BestTankTarget:Cast(FlashOfLight)
                    return
                end
            end
            if Player:SpecialHealthPercentage() < GetSecondOptionValue("紧急治疗") then
                if Player:CanCast(HolyShock) then
                    Bug("Holy Shock - Player Emergency")
                    Player:Cast(HolyShock)
                    return
                elseif not Player:IsMoving() then
                    Bug("Flash of Light - Player Emergency")
                    Player:Cast(FlashOfLight)
                    return
                end
            end
        end
        if IsOptionEnabled("美德道标循环") and BeaconOfVirtue:Exists() and BeaconOfVirtue:TimeSinceCast() < 8 then
            if HolyPrismDamage:Exists() and IsOptionEnabled("神圣棱镜") then
                local BestPrismUnits =                 HolyPrismUnitsTarget >= HolyPrismUnitsMainTank and HolyPrismUnitsTarget >= HolyPrismUnitsOffTank and
                HolyPrismUnitsTarget or
                HolyPrismUnitsMainTank > HolyPrismUnitsTarget and HolyPrismUnitsMainTank >= HolyPrismUnitsOffTank and
                HolyPrismUnitsMainTank or
                HolyPrismUnitsOffTank > HolyPrismUnitsTarget and HolyPrismUnitsOffTank >= HolyPrismUnitsMainTank and
                HolyPrismUnitsOffTank
                if BestPrismUnits >= GetOptionValue("神圣棱镜") then
                    if HolyPrismUnitsTarget >= BestPrismUnits then
                        Target:Cast(HolyPrismDamage)
                        return
                    elseif MainTankTarget and HolyPrismUnitsMainTank >= BestPrismUnits then
                        MainTankTarget:Cast(HolyPrismDamage)
                        return
                    elseif OffTankTarget and HolyPrismUnitsOffTank >= BestPrismUnits then
                        OffTankTarget:Cast(HolyPrismDamage)
                        return
                    end
                end
            end
            if
            LightOfDawn:Exists() and IsOptionEnabled("黎明之光") and
            (LightOfDawnUnits >= GetOptionValue("黎明之光") or
            (Player:Buff(DivinePurposeDawn) and Player:BuffRemains(DivinePurposeDawn) < 3)) and
            Player:CanCast(LightOfDawn)
            then
                if RuleOfLaw:Exists() and IsOptionEnabled("同步律法之责") and Player:CanCast(RuleOfLaw) then
                    Bug("Rule of Law - Divine Purpose")
                    Player:Cast(RuleOfLaw)
                end
                Bug("Light of Dawn - Divine Purpose")
                Player:Cast(LightOfDawn)
                return
            end
            if HolyShock:Exists() and IsOptionEnabled("神圣震击") then
                if
                MainTank and MainTank:SpecialHealthPercentage() <= GetOptionValue("神圣震击") and
                MainTank:CanCast(HolyShock)
                then
                    MainTank:Cast(HolyShock)
                    return
                elseif
                OffTank and OffTank:SpecialHealthPercentage() <= GetOptionValue("神圣震击") and
                OffTank:CanCast(HolyShock)
                then
                    OffTank:Cast(HolyShock)
                    return
                elseif
                Lowest and Lowest:SpecialHealthPercentage() <= GetOptionValue("神圣震击") and Lowest:CanCast(HolyShock)
                then
                    Lowest:Cast(HolyShock)
                    return
                end
            end
            if FlashOfLight:Exists() and IsOptionEnabled("圣光闪现") then
                ThisSpell =                 Player:Buff(InfusionOfLight) and IsOptionEnabled("圣光灌注") and GetOptionValue("圣光灌注") == "圣光术" and
                Lowest and
                Lowest:SpecialHealthPercentage() > GetSecondOptionValue("圣光灌注") and
                HolyLight or
                FlashOfLight
                if Lowest and Lowest:SpecialHealthPercentage() <= GetOptionValue("圣光闪现") and Lowest:CanCast(ThisSpell) then
                    Lowest:Cast(ThisSpell)
                    return
                end
            end
        end
        if
        LightOfDawn:Exists() and Player:Buff(DivinePurposeDawn) and IsOptionEnabled("黎明之光") and
        (LightOfDawnUnits >= GetOptionValue("黎明之光") or Player:BuffRemains(DivinePurposeDawn) < 3) and
        Player:CanCast(LightOfDawn)
        then
            if RuleOfLaw:Exists() and IsOptionEnabled("同步律法之责") and Player:CanCast(RuleOfLaw) then
                Bug("Rule of Law - Divine Purpose")
                Player:Cast(RuleOfLaw)
            end
            Bug("Light of Dawn - Divine Purpose")
            Player:Cast(LightOfDawn)
            return
        end
        if
        HolyShock:Exists() and Player:Buff(DivinePurposeShock) and IsOptionEnabled("神圣震击") and
        Player:BuffRemains(DivinePurposeShock) < 3
        then
            if MainTank and MainTank:SpecialHealthPercentage() <= 95 and MainTank:CanCast(HolyShock) then
                MainTank:Cast(HolyShock)
                return
            elseif OffTank and OffTank:SpecialHealthPercentage() <= 95 and OffTank:CanCast(HolyShock) then
                OffTank:Cast(HolyShock)
                return
            elseif Lowest and Lowest:SpecialHealthPercentage() <= 95 and Lowest:CanCast(HolyShock) then
                Lowest:Cast(HolyShock)
                return
            end
        end
        if
        LightOfDawn:Exists() and IsOptionEnabled("黎明之光") and LightOfDawnUnits >= GetOptionValue("黎明之光") and
        Player:CanCast(LightOfDawn)
        then
            if RuleOfLaw:Exists() and IsOptionEnabled("同步律法之责") and Player:CanCast(RuleOfLaw) then
                Bug("Rule of Law - Normal")
                Player:Cast(RuleOfLaw)
            end
            Bug("Light of Dawn - Normal")
            Player:Cast(LightOfDawn)
            return
        end
        if self:UseInfusionOfLight() then
            return
        end
        if HolyShock:Exists() and IsOptionEnabled("无条件施放神圣震击") and Player:IsInCombat() and not HolyShock:IsOnCooldown() then
            BestUnit, BestUnitHealth = nil, GetOptionValue("无条件施放神圣震击")
            if MainTank and MainTank:SpecialHealthPercentage() < BestUnitHealth and MainTank:CanCast(HolyShock) then
                BestUnit, BestUnitHealth = MainTank, MainTank:SpecialHealthPercentage()
            elseif OffTank and OffTank:SpecialHealthPercentage() < BestUnitHealth and OffTank:CanCast(HolyShock) then
                BestUnit, BestUnitHealth = OffTank, OffTank:SpecialHealthPercentage()
            elseif Lowest and Lowest:SpecialHealthPercentage() < BestUnitHealth and Lowest:CanCast(HolyShock) then
                BestUnit, BestUnitHealth = Lowest, Lowest:SpecialHealthPercentage()
            end
            if BestUnit then
                Bug("Holy Shock Always on " .. BestUnit:Name())
                BestUnit:Cast(HolyShock)
                return
            elseif BestTarget and BestTarget:CanCast(HolyShockDamage) then
                Bug("Holy Shock Always on " .. BestTarget:Name())
                BestTarget:Cast(HolyShockDamage)
                return
            else
                if MainTank and MainTank:CanCast(HolyShock) then
                    Bug("Holy Shock Always on " .. MainTank:Name())
                    MainTank:Cast(HolyShock)
                    return
                elseif OffTank and OffTank:CanCast(HolyShock) then
                    Bug("Holy Shock Always on " .. OffTank:Name())
                    OffTank:Cast(HolyShock)
                    return
                elseif Lowest and Lowest:CanCast(HolyShock) then
                    Bug("Holy Shock Always on " .. Lowest:Name())
                    Lowest:Cast(HolyShock)
                    return
                end
            end
        end
        if HolyPrismDamage:Exists() and IsOptionEnabled("神圣棱镜") then
            local BestPrismUnits =             HolyPrismUnitsTarget >= HolyPrismUnitsMainTank and HolyPrismUnitsTarget >= HolyPrismUnitsOffTank and
            HolyPrismUnitsTarget or
            HolyPrismUnitsMainTank > HolyPrismUnitsTarget and HolyPrismUnitsMainTank >= HolyPrismUnitsOffTank and
            HolyPrismUnitsMainTank or
            HolyPrismUnitsOffTank > HolyPrismUnitsTarget and HolyPrismUnitsOffTank >= HolyPrismUnitsMainTank and
            HolyPrismUnitsOffTank
            if BestPrismUnits >= GetOptionValue("神圣棱镜") then
                if HolyPrismUnitsTarget >= BestPrismUnits then
                    Target:Cast(HolyPrismDamage)
                    return
                elseif MainTankTarget and HolyPrismUnitsMainTank >= BestPrismUnits then
                    MainTankTarget:Cast(HolyPrismDamage)
                    return
                elseif OffTankTarget and HolyPrismUnitsOffTank >= BestPrismUnits then
                    OffTankTarget:Cast(HolyPrismDamage)
                    return
                end
            end
        end
        if HolyShock:Exists() and IsOptionEnabled("神圣震击") then
            if MainTank and MainTank:SpecialHealthPercentage() <= GetOptionValue("神圣震击") and MainTank:CanCast(HolyShock) then
                MainTank:Cast(HolyShock)
                return
            elseif
            OffTank and OffTank:SpecialHealthPercentage() <= GetOptionValue("神圣震击") and OffTank:CanCast(HolyShock)
            then
                OffTank:Cast(HolyShock)
                return
            elseif Lowest and Lowest:SpecialHealthPercentage() <= GetOptionValue("神圣震击") and Lowest:CanCast(HolyShock) then
                Lowest:Cast(HolyShock)
                return
            end
        end
        if
        LightOfTheMartyr:Exists() and
        (not BeaconOfVirtue:Exists() or BeaconOfVirtue:TimeSinceCast() > 8 or Player:IsMoving() or
        Player:BuffAny(MaraadsDyingBreathBuff)) and
        Player:HealthPercentage() >= GetOptionValue("殉道者之光选项")
        then
            if IsOptionEnabled("殉道者之光") then
                if
                MainTank and MainTank:SpecialHealthPercentage() <= GetOptionValue("殉道者之光") and
                MainTank:GUID() ~= Player:GUID() and
                MainTank:CanCast(LightOfTheMartyr)
                then
                    MainTank:Cast(LightOfTheMartyr)
                    return
                elseif
                OffTank and OffTank:SpecialHealthPercentage() <= GetOptionValue("殉道者之光") and
                OffTank:GUID() ~= Player:GUID() and
                OffTank:CanCast(LightOfTheMartyr)
                then
                    OffTank:Cast(LightOfTheMartyr)
                    return
                elseif
                Lowest and Lowest:SpecialHealthPercentage() <= GetSecondOptionValue("殉道者之光") and
                Lowest:GUID() ~= Player:GUID() and
                Lowest:CanCast(LightOfTheMartyr)
                then
                    Lowest:Cast(LightOfTheMartyr)
                    return
                end
            end
            if IsOptionEnabled("橙披 殉道者之光") and Player:BuffAny(MaraadsDyingBreathBuff) then
                if
                MainTank and MainTank:SpecialHealthPercentage() <= GetOptionValue("橙披 殉道者之光") and
                MainTank:GUID() ~= Player:GUID() and
                MainTank:CanCast(LightOfTheMartyr)
                then
                    MainTank:Cast(LightOfTheMartyr)
                    return
                elseif
                OffTank and OffTank:SpecialHealthPercentage() <= GetOptionValue("橙披 殉道者之光") and
                OffTank:GUID() ~= Player:GUID() and
                OffTank:CanCast(LightOfTheMartyr)
                then
                    OffTank:Cast(LightOfTheMartyr)
                    return
                elseif
                Lowest and Lowest:SpecialHealthPercentage() <= GetSecondOptionValue("橙披 殉道者之光") and
                Lowest:GUID() ~= Player:GUID() and
                Lowest:CanCast(LightOfTheMartyr)
                then
                    Lowest:Cast(LightOfTheMartyr)
                    return
                end
            end
            if IsOptionEnabled("移动 殉道者之光") and Player:IsMoving() then
                if
                MainTank and MainTank:SpecialHealthPercentage() <= GetOptionValue("移动 殉道者之光") and
                MainTank:GUID() ~= Player:GUID() and
                MainTank:CanCast(LightOfTheMartyr)
                then
                    MainTank:Cast(LightOfTheMartyr)
                    return
                elseif
                OffTank and OffTank:SpecialHealthPercentage() <= GetOptionValue("移动 殉道者之光") and
                OffTank:GUID() ~= Player:GUID() and
                OffTank:CanCast(LightOfTheMartyr)
                then
                    OffTank:Cast(LightOfTheMartyr)
                    return
                elseif
                Lowest and Lowest:SpecialHealthPercentage() <= GetSecondOptionValue("移动 殉道者之光") and
                Lowest:GUID() ~= Player:GUID() and
                Lowest:CanCast(LightOfTheMartyr)
                then
                    Lowest:Cast(LightOfTheMartyr)
                    return
                end
            end
        end
        if
        BestowFaith:Exists() and IsOptionEnabled("赋予信仰目标选择") and not self:SacrificeAuraActive() and
        (not BeaconOfVirtue:Exists() or BeaconOfVirtue:TimeSinceCast() > 8 or Player:IsMoving()) and
        not BestowFaith:IsOnCooldown()
        then
            BestUnit =             GetOptionValue("赋予信仰目标选择") == "焦点" and Focus or GetOptionValue("赋予信仰目标选择") == "Player" and Player or
            GetOptionValue("赋予信仰目标选择") == "Tanks" and
            ((self.MainTankTanking and MainTank) or (self.OffTankTanking and OffTank) or MainTank) or
            nil
            if
            BestUnit and BestUnit:SpecialHealthPercentage() <= GetSecondOptionValue("赋予信仰目标选择") and
            BestUnit:CanCast(BestowFaith)
            then
                BestUnit:Cast(BestowFaith)
                return
            end
        end
        if
        BestowFaith:Exists() and IsOptionEnabled("赋予信仰") and not self:SacrificeAuraActive() and
        (not BeaconOfVirtue:Exists() or BeaconOfVirtue:TimeSinceCast() > 8 or Player:IsMoving()) and
        not BestowFaith:IsOnCooldown()
        then
            if
            MainTank and MainTank:SpecialHealthPercentage() <= GetOptionValue("赋予信仰") and
            MainTank:CanCast(BestowFaith)
            then
                MainTank:Cast(BestowFaith)
                return
            elseif
            OffTank and OffTank:SpecialHealthPercentage() <= GetOptionValue("赋予信仰") and OffTank:CanCast(BestowFaith)
            then
                OffTank:Cast(BestowFaith)
                return
            elseif
            Lowest and Lowest:SpecialHealthPercentage() <= GetSecondOptionValue("赋予信仰") and
            Lowest:CanCast(BestowFaith)
            then
                Lowest:Cast(BestowFaith)
                return
            end
        end
        self:CrusadersMightHandler("高")
        if LightsHammer:Exists() and LightsHammerCount >= GetOptionValue("圣光之锤") and Player:CanCast(LightsHammer) then
            Player:CastGroundHeal(LightsHammer, LightsHammerUnits)
            return
        end
        if
        (Player:IsInCombat() or GetSecondOptionValue("脱离战斗后暂停治疗") == "启用") and
        (not BeaconOfVirtue:Exists() or BeaconOfVirtue:TimeSinceCast() > 8 or Player:IsMoving())
        then
            self:JudgmentOfLightHandler("Low")
        end
        if FlashOfLight:Exists() and IsOptionEnabled("圣光闪现") then
            ThisSpell =             Player:Buff(InfusionOfLight) and IsOptionEnabled("圣光灌注") and GetOptionValue("圣光灌注") == "圣光术" and Lowest and
            Lowest:SpecialHealthPercentage() > GetSecondOptionValue("圣光灌注") and
            HolyLight or
            FlashOfLight
            if Lowest and Lowest:SpecialHealthPercentage() <= GetOptionValue("圣光闪现") and Lowest:CanCast(ThisSpell) then
                Lowest:Cast(ThisSpell)
                return
            end
        end
        if IsOptionEnabled("坦克Debuffs") and CurrentBadDebuffs and #CurrentBadDebuffs.Tanks > 0 then
            local BestUnit, BestUnitHealth = nil, 100
            local BestHoTUnit, BestHoTUnitHealth = nil, 100
            for i = 1, #CurrentBadDebuffs.Tanks do
                local ThisUnit, ThisUnitHealth =                 CurrentBadDebuffs.Tanks[i],
                CurrentBadDebuffs.Tanks[i]:SpecialHealthPercentage()
                if ThisUnit:CanCast(FlashOfLight) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth
                end
                if ThisUnit:CanCast(FlashOfLight) and (BestHoTUnit == nil or ThisUnitHealth < BestHoTUnitHealth) then
                    BestHoTUnit, BestHoTUnitHealth = ThisUnit, ThisUnitHealth
                end
            end
            if IsOptionEnabled("坦克Debuffs") and BestUnit ~= nil and BestUnitHealth < GetOptionValue("坦克Debuffs") then
                if BestUnit:CanCast(HolyShock) then
                    BestUnit:Cast(HolyShock)
                    Bug("Holy Shock on " .. BestUnit:Name() .. " to heal debuff")
                    return
                end
                if BestUnit:CanCast(FlashOfLight) then
                    BestUnit:Cast(FlashOfLight)
                    Bug("Flash Of Light on " .. BestUnit:Name() .. " to heal debuff")
                    return
                end
            end
        end
        if IsOptionEnabled("团队成员Debuffs") and CurrentBadDebuffs and #CurrentBadDebuffs.Debuff > 0 then
            local BestUnit, BestUnitHealth = nil, 100
            local BestHoTUnit, BestHoTUnitHealth = nil, 100
            for i = 1, #CurrentBadDebuffs.Debuff do
                local ThisUnit, ThisUnitHealth =                 CurrentBadDebuffs.Debuff[i],
                CurrentBadDebuffs.Debuff[i]:SpecialHealthPercentage()
                if ThisUnit:CanCast(FlashOfLight) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth
                end
                if ThisUnit:CanCast(FlashOfLight) and (BestHoTUnit == nil or ThisUnitHealth < BestHoTUnitHealth) then
                    BestHoTUnit, BestHoTUnitHealth = ThisUnit, ThisUnitHealth
                end
            end
            if IsOptionEnabled("团队成员Debuffs") and BestUnit ~= nil and BestUnitHealth < GetOptionValue("团队成员Debuffs") then
                if BestUnit:CanCast(HolyShock) then
                    BestUnit:Cast(HolyShock)
                    Bug("Holy Shock on " .. BestUnit:Name() .. " to heal debuff")
                    return
                end
                if BestUnit:CanCast(FlashOfLight) then
                    BestUnit:Cast(FlashOfLight)
                    Bug("Flash Of Light on " .. BestUnit:Name() .. " to heal debuff")
                    return
                end
            end
        end
        if IsOptionEnabled("Topping Heal") and CurrentBadDebuffs and #CurrentBadDebuffs.Top > 0 then
            local BestUnit, BestUnitHealth = nil, 100
            for i = 1, #CurrentBadDebuffs.Top do
                local ThisUnit, ThisUnitHealth =                 CurrentBadDebuffs.Top[i],
                CurrentBadDebuffs.Top[i]:SpecialHealthPercentage()
                if ThisUnit:CanCast(FlashOfLight) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth
                end
            end
            if BestUnit ~= nil then
                if BestUnitHealth <= GetOptionValue("Topping Heal") then
                    if BestUnit:CanCast(HolyShock) then
                        BestUnit:Cast(HolyShock)
                        Bug("Holy Shock on " .. BestUnit:Name() .. " to top it")
                        return
                    elseif BestUnit:CanCast(FlashOfLight) then
                        BestUnit:Cast(FlashOfLight)
                        Bug("Flash Of Light on " .. BestUnit:Name() .. " to top it")
                        return
                    end
                end
            end
        end
        self:CrusadersMightHandler("Low")
        if HolyLight:Exists() and IsOptionEnabled("圣光术") then
            ThisSpell =             Player:Buff(InfusionOfLight) and IsOptionEnabled("圣光灌注") and
            (GetOptionValue("圣光灌注") == "圣光闪现" or
            Lowest and Lowest:SpecialHealthPercentage() < GetSecondOptionValue("圣光灌注")) and
            FlashOfLight or
            HolyLight
            if Lowest and Lowest:SpecialHealthPercentage() <= GetOptionValue("圣光术") and Lowest:CanCast(ThisSpell) then
                Lowest:Cast(ThisSpell)
                return
            end
        end
    end
    if Player:IsInCombat() or GetSecondOptionValue("脱离战斗后暂停治疗") == "启用" then
        self:JudgmentOfLightHandler("高")
        if BestTarget then
            if IsOptionEnabled("DPS") and GetSecondOptionValue("DPS") == "Low" and BestTarget:IsInCombat() then
                Player:StartAttack()
                if
                Consecration:Exists() and IsOptionEnabled("奉献") and not Player:IsMoving() and
                #Enemies_8y >= GetOptionValue("奉献") and
                Player:CanCast(Consecration)
                then
                    Bug("DPS - Consecration - High Priority")
                    Player:Cast(Consecration)
                    return
                end
                if
                HolyPrismHeal:Exists() and IsOptionEnabled("神圣棱镜 输出") and #Enemies_15y >= GetOptionValue("神圣棱镜 输出") and
                Player:SpecialHealthPercentage() <= GetSecondOptionValue("神圣棱镜 输出") and
                Player:CanCast(HolyPrismHeal)
                then
                    Bug("DPS - Holy Prism")
                    Player:Cast(HolyPrismHeal)
                    return
                end
                if
                LightsHammer:Exists() and IsOptionEnabled("圣光之锤 输出") and not Player:IsMoving() and not IsFalling() and
                #Enemies_10y >= GetOptionValue("圣光之锤 输出") and
                Player:SpecialHealthPercentage() <= GetSecondOptionValue("圣光之锤 输出") and
                Player:CanCast(LightsHammer)
                then
                    Bug("DPS - Light's Hammer")
                    Player:Cast(LightsHammer)
                    return
                end
                if Judgment:Exists() and IsOptionEnabled("审判") and BestTarget:CanCast(Judgment) then
                    Bug("DPS - Judgment")
                    BestTarget:Cast(Judgment)
                    return
                end
                if HolyShockDamage:Exists() and IsOptionEnabled("神圣震击 输出") and BestTarget:CanCast(HolyShockDamage) then
                    Bug("DPS - Holy Shock")
                    BestTarget:Cast(HolyShockDamage)
                    return
                end
                if
                CrusaderStrike:Exists() and IsOptionEnabled("Crusader Strike") and
                (CrusaderStrike:Charges() == 2 or BestTarget:Debuff(JudgmentDebuff) or
                (CrusaderStrike:Charges() >= 1 and CrusaderStrike:Recharge() < 3)) and
                BestTarget:CanCast(CrusaderStrike)
                then
                    Bug("DPS - Crusader Strike")
                    BestTarget:Cast(CrusaderStrike)
                    return
                end
                if
                Consecration:Exists() and IsOptionEnabled("奉献") and not Player:IsMoving() and
                #Enemies_8y >= GetSecondOptionValue("奉献") and
                Player:CanCast(Consecration)
                then
                    Bug("DPS - Consecration - Low Priority")
                    Player:Cast(Consecration)
                    return
                end
            end
        end
    end
end
function Rotation:OutOfCombat()
    if IsOptionEnabled("自动进入战斗") and Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        local EngageSpell = Judgment
        if EngageSpell:Exists() and Target:CanCast(EngageSpell) then
            Target:Cast(EngageSpell)
            return
        end
    end
    if IsOptionEnabled("脱离战斗后暂停治疗") then
        self:Combat()
    end
end
SetRotation(66, {})
local Rotation = Rotations[66]
function Rotation:Initialize()
    ArcaneTorrent = Spell(155145, false, false, true)
    GiftOfTheNaaru = Spell(59547, false, false, true)
    AegisOfLight = Spell(204150)
    ArdentDefender = Spell(31850, false, false, true)
    AvengersShield = Spell(31935, true, true, true)
    AvengingWrath = Spell(31884, false, false, true)
    BastionOfLight = Spell(204035, false, false, true)
    BlessedHammer = Spell(204019, true, true, true)
    BlessingOfProtection = Spell(1022, false, false, true)
    BlessingOfSacrifice = Spell(6940, false, false, true)
    BlessingOfSpellWarding = Spell(204018, false, false, true)
    CleanseToxins = Spell(213644, false, false, true)
    ConsecratedHammer = Spell(203785)
    Consecration = Spell(26573, false, false, true)
    DivineShield = Spell(642, false, false, true)
    DivineShieldName = GetSpellInfo(642)
    EyeOfTyr = Spell(209202, false, false, true)
    FinalStand = Spell(204077)
    FlashOfLight = Spell(19750, false, false, false)
    Forbearance = Spell(25771)
    GuardianOfAncientKings = Spell(86659, false, false, true)
    HammerOfJustice = Spell(853, false, true, true)
    HammerOfTheRighteous = Spell(53595, true, true, true)
    HandOfReckoning = Spell(62124, false, true, true)
    HandOfTheProtector = Spell(213652, false, false, true)
    Judgment = Spell(20271, true, true, true)
    LayOnHands = Spell(633, false, false, true)
    LightOfTheProtector = Spell(184092, false, false, true)
    Rebuke = Spell(96231, true, true, true)
    Redemption = Spell(7328, false, false, false, true)
    Seraphim = Spell(152262)
    ShieldOfTheRighteous = Spell(53600, true, true, true)
    ShieldOfTheRighteousBuff = Spell(132403)
    HandOfProtection = Spell(1022, false, false, true)
    HandOfProtectionName = GetSpellInfo(1022)
    SaruansResolve = Item(144275)
    AddPage("常规")
    AddPage("进攻")
    AddPage("防御")
    AddPage("物品")
    AddCommonOptions()
    AddPresetOption("常规")
    AddPresetOption("TankingFeatures", { "清算之手", "推算手" })
    AddPresetOption("进攻")
    AddSection("进攻", { "大技能", "酷唐斯" }, "Yellow")
    AddPresetOption("Cooldown", { "复仇之怒", "复仇之怒" })
    AddPresetOption("Cooldown", { "炽天使", "炽天使" }, nil, { 90, 1, 100, 1 }, { "Health threshold.", "健康阈值。" })
    AddSection("进攻", { "能力", "能力" }, "Yellow")
    AddNewOption(
    "进攻",
    { "复仇者之盾", "复仇者之盾" },
    130,
    true,
    { 4, { "禁用", "禁用" }, { "只有打断", "仅中断" }, { "正常", "正常" }, { "最佳", "最佳" } },
    nil,
    {
        "Choose Avenger's Shield mode." ..
        C.TOOLTIP_VALUE ..
        C.TOOLTIP_SUBVALUE("禁用", true) ..
        "Never use Avenger's Shield." ..
        C.TOOLTIP_SUBVALUE("只有打断") ..
        "Use on the farthest unit that is casting as high priority." ..
        C.TOOLTIP_SUBVALUE("正常") ..
        "Use normally in the rotation but not for interrupts." ..
        C.TOOLTIP_SUBVALUE("最佳") ..
        "Use on the farthest unit that is casting as high priority. If there is no unit casting, use normally in the rotation.",
        "选择复仇者的盾牌模式。" ..
        C.TOOLTIP_VALUE ..
        C.TOOLTIP_SUBVALUE("禁用", true) ..
        "不要使用复仇者之盾。" ..
        C.TOOLTIP_SUBVALUE("仅中断") ..
        "在最高级别的最高单位上使用。" ..
        C.TOOLTIP_SUBVALUE("正常") ..
        "在旋转中正常使用，但不用于中断。" ..
        C.TOOLTIP_SUBVALUE("最佳") .. "在最高级别的最高单位上使用。 如果没有单元铸造，则在旋转中正常使用。"
    }
    )
    AddNewOption(
    "进攻",
    { "祝福之锤", "祝福之锤" },
    220,
    true,
    { 3, 1, 10, 1 },
    nil,
    {
        "Use Blessed Hammer." ..
        C.TOOLTIP_VALUE ..
        "Amount of units that needs to be in range." ..
        C.TOOLTIP_HINT(
        "Last charge will always be used before capping even if unit count is lower than the chosen value."
        ),
        "使用祝福之锤。" .. C.TOOLTIP_VALUE .. "需要在范围内的单位数量。" .. C.TOOLTIP_HINT("即使单位数低于所选值，上次充电将始终在加盖之前使用。")
    }
    )
    AddNewOption(
    "进攻",
    { "奉献", "奉献" },
    220,
    true,
    { 1, 1, 10, 1 },
    nil,
    {
        "Use Consecration." .. C.TOOLTIP_VALUE .. "Amount of units that needs to be in range.",
        "使用奉献。" .. C.TOOLTIP_VALUE .. "需要在范围内的单位数量。"
    }
    )
    AddNewOption(
    "进攻",
    { "提尔之眼", "提尔之眼" },
    220,
    true,
    { 100, 1, 100, 1 },
    nil,
    {
        "Use Eye Of Tyr." .. C.TOOLTIP_VALUE .. "Health threshold." .. C.TOOLTIP_HINT("Set to 100 to use Always."),
        "使用提尔之眼。" .. C.TOOLTIP_VALUE .. "健康阈值。" .. C.TOOLTIP_HINT("设置为100以使用始终。")
    }
    )
    AddNewOption(
    "进攻",
    { "正义之锤", "正义之锤" },
    220,
    true,
    { 3, 1, 10, 1 },
    nil,
    {
        "Use Hammer of the Righteous." ..
        C.TOOLTIP_VALUE ..
        "Amount of units that needs to be in range." ..
        C.TOOLTIP_HINT(
        "Last charge will always be used before capping even if unit count is lower than the chosen value."
        ),
        "使用正义之锤。" .. C.TOOLTIP_VALUE .. "需要在范围内的单位数量。" .. C.TOOLTIP_HINT("即使单位数低于所选值，上次充电将始终在加盖之前使用。")
    }
    )
    AddPresetOption("防御")
    AddSection("防御", { "大技能", "酷唐斯" }, "Yellow")
    AddNewOption(
    "防御",
    { "炽热防御者", "炽热防御者" },
    220,
    true,
    { 20, 1, 100, 1 },
    nil,
    { "Use Ardent Defender." .. C.TOOLTIP_VALUE .. "Health threshold.", "使用炽热防御者。" .. C.TOOLTIP_VALUE .. "健康阈值。" }
    )
    AddNewOption(
    "防御",
    { "圣光壁垒", "圣光壁垒" },
    220,
    true,
    { 3, 0, 10, 0.5 },
    nil,
    {
        "Use Bastion Of Light when we do not have remaining Shield Of The Righteous charges." ..
        C.TOOLTIP_VALUE_1 ..
        "Minimum amount of seconds which Shield Of Righteous has to recharge. E.g. 3 means it will not use Bastion Of Light if Shield Of Righteous has less than 3 seconds to recharge.",
        "当我们没有剩下的正义的盾牌时，使用光的堡垒。" .. C.TOOLTIP_VALUE_1 .. "正义盾击需要充电的最小秒数。 例如。 3意味着如果正义盾击不到3秒钟就可以使用圣光壁垒t。"
    }
    )
    AddNewOption(
    "防御",
    { "破咒祝福", "破咒祝福" },
    222,
    true,
    { 40, 1, 100, 1 },
    { 10, 1, 10, 1 },
    {
        "Use Blessing Of Spellwarding when we are receiving Spell Damage." ..
        C.TOOLTIP_VALUE_1 ..
        "Health percentage lost via Spell Damage." ..
        C.TOOLTIP_VALUE_2 ..
        "Time Lapse in seconds." ..
        C.TOOLTIP_HINT("Use when you lose Value 1% of health over Value 2 amount of time."),
        "当我们收到法术伤害时，请使用祝福。" ..
        C.TOOLTIP_VALUE_1 ..
        "通过法术伤害损失健康百分比。" .. C.TOOLTIP_VALUE_2 .. "时间以秒为单位。" .. C.TOOLTIP_HINT("使用当您失去价值1％的健康超过价值2的时间。")
    }
    )
    AddNewOption(
    "防御",
    { "决一死战", "决一死战" },
    220,
    true,
    { 20, 1, 100, 1 },
    nil,
    {
        "Use Divine Shield when under health threshold and talented into Final Stand." ..
        C.TOOLTIP_VALUE .. "Health threshold.",
        "在健康阈值下使用神盾，有才能进入终场。" .. C.TOOLTIP_VALUE .. "健康阈值。"
    }
    )
    AddNewOption(
    "防御",
    { "远古列王守卫", "远古列王守卫" },
    220,
    true,
    { 30, 1, 100, 1 },
    nil,
    {
        "Use Guardian of Ancient Kings." .. C.TOOLTIP_VALUE .. "Health threshold.",
        "使用远古列王守卫。" .. C.TOOLTIP_VALUE .. "健康阈值。"
    }
    )
    AddNewOption(
    "防御",
    { "圣疗术", "圣疗术" },
    220,
    true,
    { 25, 1, 100, 1 },
    nil,
    {
        "Use Lay on Hands on Player." .. C.TOOLTIP_VALUE .. "Health threshold.",
        "使用圣疗术对你自己。" .. C.TOOLTIP_VALUE .. "健康阈值。"
    }
    )
    AddNewOption(
    "防御",
    { "在炽热防御者时不放圣疗", "圣疗术炽热防御者" },
    210,
    true,
    nil,
    nil,
    { "Don't use Lay on Hands on Player if Ardent Defender buff is up.", "如果炽热防御者魔法增益上升，请勿在玩家使用圣疗术。" }
    )
    AddSection("防御", { "能力", "能力" }, "Yellow")
    AddNewOption(
    "防御",
    { "圣光闪现(自己)", "圣光闪现在你身上" },
    222,
    true,
    { 30, 1, 100, 1 },
    { 80, 1, 100, 1 },
    {
        "Use Flash Of Light on ourself." ..
        C.TOOLTIP_VALUE_1 ..
        "Health threshold while In Combat." .. C.TOOLTIP_VALUE_2 .. "Health threshold while Out of Combat.",
        "使用闪光灯自己。" .. C.TOOLTIP_VALUE_1 .. "健康阈值在作战" .. C.TOOLTIP_VALUE_2 .. "健康阈值，而不在战斗。"
    }
    )
    AddNewOption(
    "防御",
    { "守护者之手", "守护者之手" },
    220,
    true,
    { 60, 1, 100, 1 },
    nil,
    {
        "Use Hand Of The Protector on self." .. C.TOOLTIP_VALUE .. "Health threshold.",
        "使用保护者的手对自己。" .. C.TOOLTIP_VALUE .. "健康阈值。"
    }
    )
    AddNewOption(
    "防御",
    { "守护者之手(队友)", "守护者之手在盟友身上" },
    222,
    true,
    { 45, 1, 100, 1 },
    { 70, 1, 100, 1 },
    {
        "Use Hand Of The Protector on allies in group or raid." ..
        C.TOOLTIP_VALUE_1 ..
        "Health threshold for ally to use on." ..
        C.TOOLTIP_VALUE_2 ..
        "Health threshold for you to use on ally. If you are below this value you will not use Hand Of The Protector on allies, but save it for yourself.",
        "保护者使用手中的盟友或袭击。" ..
        C.TOOLTIP_VALUE_1 ..
        "健康门槛用于盟友使用。" .. C.TOOLTIP_VALUE_2 .. "健康阈值为您使用盟友。 如果你低于这个值，你不会在盟友上使用“保护者之手”，而是为自己保存。"
    }
    )
    AddNewOption(
    "防御",
    { "守护之光", "守护之光" },
    220,
    true,
    { 60, 1, 100, 1 },
    nil,
    {
        "Use Light Of The Protector." .. C.TOOLTIP_VALUE .. "Health threshold.",
        "使用守护之光。" .. C.TOOLTIP_VALUE .. "健康阈值。"
    }
    )
    AddNewOption(
    "防御",
    { "正义盾击", "正义盾击" },
    232,
    true,
    { 2, { "正常", "正常" }, { "防止上限", "防止上盖" } },
    { 40, 1, 100, 1 },
    {
        "Use Shield of the Righteous." ..
        C.TOOLTIP_VALUE_1 ..
        C.TOOLTIP_SUBVALUE("正常", true) ..
        "Only use when health is lower than threshold." ..
        C.TOOLTIP_SUBVALUE("防止上限", true) ..
        "Use automatically as soon as we are at max charges." ..
        C.TOOLTIP_VALUE_2 .. "Health threshold to use.",
        "使用正义盾击。" ..
        C.TOOLTIP_VALUE_1 ..
        C.TOOLTIP_SUBVALUE("正常", true) ..
        "仅在健康状况低于阈值时使用。" ..
        C.TOOLTIP_SUBVALUE("防止上盖", true) .. "一旦我们收取最高费用即可自动使用。" .. C.TOOLTIP_VALUE_2 .. "健康阈值。"
    }
    )
    AddNewOption(
    "防御",
    { "正义盾击防止上限", "正义盾击帽防止" },
    120,
    true,
    { 3, 0, 6, 0.5 },
    nil,
    {
        "Use Shield of the Righteous X seconds before capping, when using Prevent Capping option." ..
        C.TOOLTIP_VALUE_1 .. "Seconds before Shield charges cap. 0 means only use when at 3 charges.",
        "使用防护帽选项时，使用正义之盾X秒。" .. C.TOOLTIP_VALUE_1 .. "盾之前的秒数上限。 0表示仅在3次充电时使用。"
    }
    )
    AddSection("物品", { "撒鲁安的决心", "撒鲁安的决心" }, "Yellow")
    AddNewOption(
    "物品",
    { "使用撒鲁安的决心(橙头)选项", "使用撒鲁安的决心选项" },
    210,
    true,
    nil,
    nil,
    {
        "Use the options listed below for Hand and Light Of The Protector usage when Saruans Resolve is equipped. You still have to enabled the options to use the spells in Defensive section, only the values are ignored and these ones in here are used instead. Charge 2 = you have two charges. Charge 1 = you only have 1 charge left.",
        "当安装撒鲁安的决心时，请使用下列列出的“手和光保护器”使用方法。 您仍然必须启用在防御部分中使用法术的选项，只会忽略这些值，并使用这些值。 收费2 =您有两笔费用。 收费1 =您只剩1个费用。"
    }
    )
    AddNewOption(
    "物品",
    { "守护之光充能", "守护之光收费" },
    122,
    true,
    { 60, 1, 100, 1 },
    { 65, 1, 100, 1 },
    {
        "Use Light Of The Protector." ..
        C.TOOLTIP_VALUE_1 ..
        "Health threshold with 1 charge left." ..
        C.TOOLTIP_VALUE_2 .. "Health threshold with 2 charges left.",
        "使用守护之光。" .. C.TOOLTIP_VALUE_1 .. "健康门槛值为1次。" .. C.TOOLTIP_VALUE_2 .. "健康门槛值为2。"
    }
    )
    AddNewOption(
    "物品",
    { "守护者之手充能", "守护者之手费" },
    122,
    true,
    { 60, 1, 100, 1 },
    { 65, 1, 100, 1 },
    {
        "Use Hand Of The Protector on self." ..
        C.TOOLTIP_VALUE_1 ..
        "Health threshold with 1 charge left." ..
        C.TOOLTIP_VALUE_2 .. "Health threshold with 2 charges left.",
        "使用保护者的手对自己。" .. C.TOOLTIP_VALUE_1 .. "健康门槛值为1次。" .. C.TOOLTIP_VALUE_2 .. "健康门槛值为2。"
    }
    )
    AddNewOption(
    "物品",
    { "守护者之手充能1层(队友)", "守护者之手盟友1" },
    122,
    true,
    { 45, 1, 100, 1 },
    { 75, 1, 100, 1 },
    {
        "Use Hand Of The Protector on allies in group or raid with 1 charge." ..
        C.TOOLTIP_VALUE_1 ..
        "Health threshold for ally to use on." ..
        C.TOOLTIP_VALUE_2 ..
        "Health threshold for you to use on ally. If you are below this value you will not use Hand Of The Protector on allies, but save it for yourself.",
        "使用手中的保护者在盟友或集体攻击与1收费。" ..
        C.TOOLTIP_VALUE_1 ..
        "健康门槛用于盟友使用。" .. C.TOOLTIP_VALUE_2 .. "健康阈值为您使用盟友。 如果你低于这个值，你不会在盟友上使用“保护者之手”，而是为自己保存。"
    }
    )
    AddNewOption(
    "物品",
    { "守护者之手充能2层(队友)", "守护者之手盟友2" },
    122,
    true,
    { 55, 1, 100, 1 },
    { 70, 1, 100, 1 },
    {
        "Use Hand Of The Protector on allies in group or raid with 2 charges." ..
        C.TOOLTIP_VALUE_1 ..
        "Health threshold for ally to use on." ..
        C.TOOLTIP_VALUE_2 ..
        "Health threshold for you to use on ally. If you are below this value you will not use Hand Of The Protector on allies, but save it for yourself.",
        "使用手中的保护者在盟友或团队或袭击与2费用。" ..
        C.TOOLTIP_VALUE_1 ..
        "健康门槛用于盟友使用。" .. C.TOOLTIP_VALUE_2 .. "健康阈值为您使用盟友。 如果你低于这个值，你不会在盟友上使用“保护者之手”，而是为自己保存。"
    }
    )
    RegisterCommand(
    "bubblecancel",
    function()
        if DivineShield:Exists() then
            if BubbleCancel == true then
                BubbleCancel = false
                Bug("Remove debuff with Divine Shield Canceled")
            elseif DivineShield:Cooldown() < 2 and not Player:DebuffAny(Forbearance) then
                BubbleCancel = true
                Bug("Remove debuff with Divine Shield Queued")
            else
                Bug("Divine Shield on Cooldown or you still have Forbearance on you.")
            end
        else
            Bug("You don't have Divine Shield.")
        end
    end
    )
    RegisterCommand(
    "bubbletaunt",
    function()
        if DivineShield:Exists() and HandOfReckoning:Exists() then
            if BubbleTaunt == true then
                BubbleTaunt = false
                Bug("Bubble Taunt Canceled")
            elseif
            DivineShield:Cooldown() < 2 and HandOfReckoning:Cooldown() < 2 and not Player:DebuffAny(Forbearance)
            then
                BubbleTaunt = true
                Bug("Bubble Taunt Queued")
            else
                Bug("Divine Shield or Taunt on Cooldown or you still have Forbearance on you.")
            end
        else
            Bug("You don't have Divine Shield or Hand Of Reckoning.")
        end
    end
    )
end
function Rotation:Events()
end
function Rotation:Pulse()
    if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
        return
    end
    if Target:Exists() and BMPullTime() < 5 then
        self:Opening()
        return
    end
    if GetTime() < Rotation.SpamPrevention then
        return
    end
    Rotation.SpamPrevention = GetTime() + 0.05
    Target = Unit.Target
    local InCombat = Player:IsInCombat()
    if not InCombat then
        self:OutOfCombat()
        return
    end
    if InCombat then
        self:Defensives()
    end
    Target = Player:ReTarget(ShieldOfTheRighteous, false) or Unit.Target
    if Target:Exists() then
        Rotations:RefreshUnitTables(Rotation.Identifier)
        self:Interrupts()
        self:OffGCDAbilities()
        if Player:GlobalCooldown() == 0 then
            self:Combat()
        end
    end
end
function Rotation:Opening()
    Player:UsePotions("力量药水")
    if
    IsOptionEnabled("抢先施放(需DBM插件)") and
    (GetOptionValue("抢先施放(需DBM插件)") == "无条件使用" or
    (GetOptionValue("抢先施放(需DBM插件)") == "打BOSS使用" and Target:IsBoss()))
    then
        if
        AvengersShield:Exists() and BMPullTime() < GetSecondOptionValue("抢先施放(需DBM插件)") and
        Target:CanCast(AvengersShield)
        then
            Player:StartAttack()
            Target:Cast(AvengersShield)
            return
        end
    end
end
function Rotation:Defensives()
    Player:UseHealingItem()
    if
    GuardianOfAncientKings:Exists() and IsOptionEnabled("远古列王守卫") and CooldownsAllowed() and
    Player:HealthPercentage() <= GetOptionValue("远古列王守卫") and
    Player:CanCast(GuardianOfAncientKings)
    then
        Player:Cast(GuardianOfAncientKings)
    end
    if
    ArdentDefender:Exists() and IsOptionEnabled("炽热防御者") and CooldownsAllowed() and
    Player:HealthPercentage() <= GetOptionValue("炽热防御者") and
    Player:CanCast(ArdentDefender)
    then
        Player:Cast(ArdentDefender)
    end
    if
    GiftOfTheNaaru:Exists() and IsOptionEnabled("纳鲁的赐福") and CooldownsAllowed() and
    Player:SpecialHealthPercentage() <= GetOptionValue("纳鲁的赐福") and
    Player:CanCast(GiftOfTheNaaru)
    then
        Player:Cast(GiftOfTheNaaru)
        return
    end
end
function Rotation:Interrupts()
    Player:UseInterrupt(Rebuke, ArcaneTorrent)
end
function Rotation:OffGCDAbilities()
    if BubbleCancel and Player:Buff(DivineShield) then
        RunMacroText("/cancelaura " .. DivineShieldName)
        BubbleCancel = false
    end
    if BubbleTaunt and BubbleTauntHasTaunted and HandOfReckoning:TimeSinceCast() > 2.8 and Player:Buff(DivineShield) then
        RunMacroText("/cancelaura " .. DivineShieldName)
        BubbleTaunt = false
        BubbleTauntHasTaunted = false
    end
    if IsOptionEnabled("自动取消保护之手") and Player:BuffRemainsAny(HandOfProtection) <= 10 - GetOptionValue("自动取消保护之手") then
        RunMacroText("/cancelaura " .. HandOfProtectionName)
    end
    if HandOfReckoning:Exists() and Player:TauntManager(HandOfReckoning, "清算之手", Target, TauntEnemies, nil) then
        return
    end
    if
    BastionOfLight:Exists() and IsOptionEnabled("圣光壁垒") and CooldownsAllowed() and
    ShieldOfTheRighteous:Charges() == 0 and
    ShieldOfTheRighteous:Recharge() > GetOptionValue("圣光壁垒") and
    Player:CanCast(BastionOfLight)
    then
        Player:Cast(BastionOfLight)
        return
    end
    if
    Seraphim:Exists() and CDOptionEnabled("炽天使") and Player:IsWithinCastRange(Target, ShieldOfTheRighteous) and
    Player:HealthPercentage() <= GetSecondOptionValue("炽天使") and
    Player:CanCast(Seraphim)
    then
        Player:Cast(Seraphim)
        return
    end
    if
    ShieldOfTheRighteous:Exists() and IsOptionEnabled("正义盾击") and Seraphim:Exists() and
    ShieldOfTheRighteous:TimeSinceCast() > 2 and
    Player:BuffRemains(ShieldOfTheRighteousBuff) < 1
    then
        if
        ShieldOfTheRighteous:Charges() == 3 or (ShieldOfTheRighteous:FractionalCharges() > 2.5) or
        Player:HealthPercentage() <= GetSecondOptionValue("正义盾击")
        then
            if
            ShieldOfTheRighteous:Charges() == 3 or
            (ShieldOfTheRighteous:FractionalCharges() > 2.75 and Seraphim:Cooldown() > 3)
            then
                if Target:CanCast(ShieldOfTheRighteous) then
                    ShieldOfTheRighteous.LastCastTime = GetTime()
                    Target:Cast(ShieldOfTheRighteous)
                    return
                end
            end
        end
    end
    if not IsOptionEnabled("使用撒鲁安的决心(橙头)选项") or not SaruansResolve:IsEquipped(1) then
        if
        not HandOfTheProtector:Exists() and LightOfTheProtector:Exists() and IsOptionEnabled("守护之光") and
        Player:HealthPercentage() <= GetOptionValue("守护之光") and
        Player:CanCast(LightOfTheProtector) and
        LightOfTheProtector:TimeSinceCast() > 0.5
        then
            LightOfTheProtector.LastCastTime = GetTime()
            Player:Cast(LightOfTheProtector)
            return
        end
        if
        HandOfTheProtector:Exists() and IsOptionEnabled("守护者之手") and
        Player:HealthPercentage() <= GetOptionValue("守护者之手") and
        Player:CanCast(HandOfTheProtector) and
        HandOfTheProtector:TimeSinceCast() > 0.5
        then
            HandOfTheProtector.LastCastTime = GetTime()
            Player:Cast(HandOfTheProtector)
            return
        end
        if
        HandOfTheProtector:Exists() and IsOptionEnabled("守护者之手(队友)") and
        Player:HealthPercentage() >= GetSecondOptionValue("守护者之手(队友)") and
        HandOfTheProtector:TimeSinceCast() > 0.5
        then
            Lowest = Unit.Lowest(HealUnits)
            if
            Lowest and Lowest:HealthPercentage() <= GetOptionValue("守护者之手(队友)") and
            Lowest:CanCast(HandOfTheProtector)
            then
                Bug("Using Hand Of The Protector on: " .. Lowest:Name())
                HandOfTheProtector.LastCastTime = GetTime()
                Lowest:Cast(HandOfTheProtector)
                return
            end
        end
    else
        if
        not HandOfTheProtector:Exists() and LightOfTheProtector:Exists() and IsOptionEnabled("守护之光") and
        LightOfTheProtector:TimeSinceCast() > 0.5 and
        ((LightOfTheProtector:Charges() == 1 and Player:HealthPercentage() <= GetOptionValue("守护之光充能")) or
        (LightOfTheProtector:Charges() == 2 and Player:HealthPercentage() <= GetSecondOptionValue("守护之光充能"))) and
        Player:CanCast(LightOfTheProtector)
        then
            LightOfTheProtector.LastCastTime = GetTime()
            Player:Cast(LightOfTheProtector)
            return
        end
        if
        HandOfTheProtector:Exists() and IsOptionEnabled("守护者之手") and HandOfTheProtector:TimeSinceCast() > 0.5 and
        ((HandOfTheProtector:Charges() == 1 and Player:HealthPercentage() <= GetOptionValue("守护者之手充能")) or
        (HandOfTheProtector:Charges() == 2 and Player:HealthPercentage() <= GetSecondOptionValue("守护者之手充能"))) and
        Player:CanCast(HandOfTheProtector)
        then
            HandOfTheProtector.LastCastTime = GetTime()
            Player:Cast(HandOfTheProtector)
            return
        end
        if
        HandOfTheProtector:Exists() and IsOptionEnabled("守护者之手(队友)") and
        ((HandOfTheProtector:Charges() == 1 and
        Player:HealthPercentage() >= GetSecondOptionValue("守护者之手充能1层(队友)")) or
        (HandOfTheProtector:Charges() == 2 and
        Player:HealthPercentage() >= GetSecondOptionValue("守护者之手充能2层(队友)"))) and
        HandOfTheProtector:TimeSinceCast() > 0.5
        then
            Lowest = Unit.Lowest(HealUnits)
            if
            Lowest and
            ((HandOfTheProtector:Charges() == 1 and Lowest:HealthPercentage() <= GetOptionValue("守护者之手充能1层(队友)")) or
            (HandOfTheProtector:Charges() == 2 and
            Lowest:HealthPercentage() <= GetOptionValue("守护者之手充能2层(队友)"))) and
            Lowest:CanCast(HandOfTheProtector)
            then
                Bug("Using Hand Of The Protector on: " .. Lowest:Name())
                HandOfTheProtector.LastCastTime = GetTime()
                Lowest:Cast(HandOfTheProtector)
                return
            end
        end
    end
    if
    ShieldOfTheRighteous:Exists() and IsOptionEnabled("正义盾击") and not Seraphim:Exists() and
    ShieldOfTheRighteous:TimeSinceCast() > 1 and
    ((Player:HealthPercentage() <= GetSecondOptionValue("正义盾击") and
    Player:BuffRemains(ShieldOfTheRighteousBuff) < 1) or
    (GetOptionValue("正义盾击") == "防止上限" and
    (ShieldOfTheRighteous:Charges() == 3 or
    (ShieldOfTheRighteous:Charges() == 2 and
    ShieldOfTheRighteous:Recharge() < GetOptionValue("正义盾击防止上限"))))) and
    Target:CanCast(ShieldOfTheRighteous)
    then
        ShieldOfTheRighteous.LastCastTime = GetTime()
        Target:Cast(ShieldOfTheRighteous)
        return
    end
end
function Rotation:UnitTables()
    TauntEnemies = Player:EnemiesWithinDistance(30, false)
    Enemies_30y = UseAOE() and TauntEnemies or {}
    Enemies_8y = UseAOE() and Player:EnemiesWithinDistance(8, false) or {}
    TargetEnemies_8y = UseAOE() and Target:EnemiesWithinDistance(8, true) or {}
    NumEnemies = #Enemies_8y
    HealUnits = IsOptionEnabled("守护者之手(队友)") and Player:HealUnitsAround(100, 40) or {}
end
function Rotation:Combat()
    if DivineShield:Exists() and BubbleCancel == true then
        if DivineShield:Cooldown() > 5 then
            BubbleCancel = false
        else
            if not Player:DebuffAny(Forbearance) and Player:CanCast(DivineShield) then
                Player:Cast(DivineShield)
                return
            end
        end
    end
    if
    DivineShield:Exists() and HandOfReckoning:Exists() and BubbleTaunt == true and not BubbleTauntHasTaunted and
    Target:Exists() and
    not Target:IsDeadOrGhost() and
    Player:CanAttack(Target)
    then
        if HandOfReckoning:Exists() and Target:CanCast(HandOfReckoning) then
            Target:Cast(HandOfReckoning)
            HandOfReckoning.LastCastTime = GetTime()
            BubbleTauntHasTaunted = true
        end
        if not Player:DebuffAny(Forbearance) and Player:CanCast(DivineShield) then
            Player:Cast(DivineShield)
            return
        end
    end
    if
    FlashOfLight:Exists() and Player:Standing() > 0.5 and IsOptionEnabled("圣光闪现(自己)") and
    Player:HealthPercentage() <= GetOptionValue("圣光闪现(自己)") and
    Player:CanCast(FlashOfLight)
    then
        Player:Cast(FlashOfLight)
        return
    end
    if
    FinalStand:Exists() and IsOptionEnabled("决一死战") and CooldownsAllowed() and
    Player:HealthPercentage() < GetOptionValue("决一死战") and
    not Player:DebuffAny(Forbearance) and
    Player:CanCast(DivineShield)
    then
        Player:Cast(DivineShield)
        return
    end
    if
    LayOnHands:Exists() and IsOptionEnabled("圣疗术") and CooldownsAllowed() and not Player:DebuffAny(Forbearance) and
    Player:HealthPercentage() <= GetOptionValue("圣疗术") and
    (not IsOptionEnabled("在炽热防御者时不放圣疗") or (IsOptionEnabled("在炽热防御者时不放圣疗") and not Player:Buff(ArdentDefender))) and
    Player:CanCast(LayOnHands)
    then
        Player:Cast(LayOnHands)
        return
    end
    if
    BlessingOfSpellWarding:Exists() and IsOptionEnabled("破咒祝福") and CooldownsAllowed() and
    not Player:DebuffAny(Forbearance)
    then
        local Option1, Option2 = GetOptionValue("破咒祝福"), GetSecondOptionValue("破咒祝福")
        if Player:RecentDamageTakenPercent(Option2, "Spell") > Option1 and Player:CanCast(BlessingOfSpellWarding) then
            Player:Cast(BlessingOfSpellWarding)
            return
        end
    end
    if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        Player:StartAttack()
        if (GetOptionValue("复仇者之盾") == "最佳" or GetOptionValue("复仇者之盾") == "只有打断") and not AvengersShield:IsOnCooldown() then
            local FartestUnit, FartestUnitDistance, ThisUnit = nil, 0, nil
            for i = 1, #Enemies_30y do
                ThisUnit = Enemies_30y[i]
                if
                not ThisUnit:IsDeadOrGhost() and ThisUnit:IsInCombat() and ThisUnit:IsCasting() and
                ThisUnit:IsInterruptible() and
                ThisUnit:CanCast(AvengersShield) and
                Player:CanAttack(ThisUnit) and
                (FartestUnit == nil or FartestUnitDistance < Player:DistanceTo(ThisUnit))
                then
                    FartestUnit = ThisUnit
                    FartestUnitDistance = Player:DistanceTo(ThisUnit)
                end
            end
            if FartestUnit ~= nil then
                Bug("Avenger's Shield - Interrupt")
                FartestUnit:Cast(AvengersShield)
                return
            end
        end
        if Player:IsWithinCastRange(Target, ShieldOfTheRighteous) then
            Player:UsePotions("力量药水")
            Player:UseTrinkets()
            if AvengingWrath:Exists() and CDOptionEnabled("复仇之怒") and Player:CanCast(AvengingWrath) then
                Player:Cast(AvengingWrath)
                return
            end
            if
            Seraphim:Exists() and CDOptionEnabled("炽天使") and
            Player:HealthPercentage() <= GetSecondOptionValue("炽天使") and
            Player:CanCast(Seraphim)
            then
                Player:Cast(Seraphim)
                return
            end
        end
        if
        EyeOfTyr:Exists() and IsOptionEnabled("提尔之眼") and Player:HealthPercentage() <= GetOptionValue("提尔之眼") and
        Player:IsWithinCastRange(Target, ShieldOfTheRighteous) and
        Player:CanCast(EyeOfTyr)
        then
            Player:Cast(EyeOfTyr)
            return
        end
        if
        AvengersShield:Exists() and (GetOptionValue("复仇者之盾") == "正常" or GetOptionValue("复仇者之盾") == "最佳") and
        Target:CanCast(AvengersShield)
        then
            Target:Cast(AvengersShield)
            return
        end
        if
        Consecration:Exists() and not Player:IsMoving() and IsOptionEnabled("奉献") and
        NumEnemies >= GetOptionValue("奉献") and
        Player:IsWithinCastRange(Target, ShieldOfTheRighteous) and
        Player:CanCast(Consecration)
        then
            Player:Cast(Consecration)
            return
        end
        if Judgment:Exists() and Target:CanCast(Judgment) then
            Target:Cast(Judgment)
            return
        end
        if
        HammerOfTheRighteous:Exists() and not BlessedHammer:Exists() and IsOptionEnabled("正义之锤") and
        (#TargetEnemies_8y >= GetOptionValue("正义之锤") or
        (ConsecratedHammer:Exists() or HammerOfTheRighteous:Charges() == 2 or
        (HammerOfTheRighteous:FractionalCharges() > 1.6))) and
        Target:CanCast(HammerOfTheRighteous)
        then
            Target:Cast(HammerOfTheRighteous)
            return
        end
        if
        BlessedHammer:Exists() and IsOptionEnabled("祝福之锤") and
        Player:IsWithinCastRange(Target, ShieldOfTheRighteous) and
        (NumEnemies >= GetOptionValue("祝福之锤") or
        (BlessedHammer:Charges() == 3 or BlessedHammer:FractionalCharges() > 2.7)) and
        Target:CanCast(HammerOfTheRighteous)
        then
            Target:Cast(HammerOfTheRighteous)
            return
        end
    end
end
function Rotation:OutOfCombat()
    if
    FlashOfLight:Exists() and Player:Standing() > 0.5 and IsOptionEnabled("圣光闪现(自己)") and
    Player:HealthPercentage() <= GetSecondOptionValue("圣光闪现(自己)") and
    Player:CanCast(FlashOfLight)
    then
        Player:Cast(FlashOfLight)
        return
    end
    if
    not HandOfTheProtector:Exists() and LightOfTheProtector:Exists() and IsOptionEnabled("守护之光") and
    Player:HealthPercentage() <= GetOptionValue("守护之光") and
    Player:CanCast(LightOfTheProtector) and
    LightOfTheProtector:TimeSinceCast() > 0.5
    then
        LightOfTheProtector.LastCastTime = GetTime()
        Player:Cast(LightOfTheProtector)
        return
    end
    if
    HandOfTheProtector:Exists() and IsOptionEnabled("守护者之手") and
    Player:HealthPercentage() <= GetOptionValue("守护者之手") and
    Player:CanCast(HandOfTheProtector) and
    HandOfTheProtector:TimeSinceCast() > 0.5
    then
        HandOfTheProtector.LastCastTime = GetTime()
        Player:Cast(HandOfTheProtector)
        return
    end
    if IsOptionEnabled("自动进入战斗") then
        if AvengersShield:Exists() and Target:CanCast(AvengersShield) then
            Target:Cast(AvengersShield)
            return
        end
        if Judgment:Exists() and Target:CanCast(Judgment) then
            Target:Cast(Judgment)
            return
        end
    end
end
SetRotation(70, {})
local Rotation = Rotations[70]
function Rotation:Initialize()
    self.HasBetaRotation = true
    ArcaneTorrent = Spell(155145, false, false, true)
    GiftOfTheNaaru = Spell(59542, false, false, true)
    AshesToAshes = Spell(179546)
    DivineTempest = Spell(186773)
    AvengingWrath = Spell(31884, false, false, true)
    BladeOfJustice = Spell(184575, true, true, true)
    BladeOfWrath = Spell(231832, true, true, true)
    BlessingOfProtection = Spell(1022, false, false, true)
    CleanseToxins = Spell(213644, false, false, true)
    Consecration = Spell(205228, false, false, true)
    Crusade = Spell(231895, false, false, true)
    CrusaderStrike = Spell(35395, true, true, true)
    DivineHammer = Spell(198034, false, false, true)
    DivineIntervention = Spell(213313)
    DivinePurpose = Spell(223819)
    DivineShield = Spell(642, false, false, true)
    DivineStorm = Spell(53385, false, false, true)
    ExecutionSentence = Spell(213757, true, true, true)
    EyeForAnEye = Spell(205191, false, false, true)
    FlashOfLight = Spell(19750, false, false, false)
    Forbearance = Spell(25771)
    GreaterBlessingOfKings = Spell(203538, false, false, true)
    GreaterBlessingOfMight = Spell(203528, false, false, true)
    GreaterBlessingOfWisdom = Spell(203539, false, false, true)
    GreaterJudgment = Spell(218178)
    HammerOfJustice = Spell(853, false, true, true)
    HandOfHindrance = Spell(183218, true, true, true)
    HandOfReckoning = Spell(62124, false, true, true)
    Judgment = Spell(20271, true, true, true)
    JudgmentDebuff = Spell(197277)
    JusticarsVengeance = Spell(215661, true, true, true)
    LayOnHands = Spell(633, false, false, true)
    Rebuke = Spell(96231, true, true, true)
    Redemption = Spell(7328, false, false, false, true)
    ShieldOfVengeance = Spell(184662, false, false, true)
    TemplarsVerdict = Spell(85256, true, true, true)
    TheFiresOfJustice = Spell(203316)
    TheFiresOfJusticeBuff = Spell(209785)
    VirtuesBlade = Spell(202271)
    WakeOfAshes = Spell(205273, false, false, true)
    WordOfGlory = Spell(210191, false, false, true)
    Zeal = Spell(217020, true, true, true)
    FelCrazedRage = Spell(225141)
    ConvergenceOfFates = Item(140806)
    DraughtOfSouls = Item(140808)
    WhisperOfTheNathrezim = Item(137020)
    LiadrinsFuryUnleashed = Item(137048)
    LiadrinsFuryUnleashedBuff = Spell(208410)
    WhisperOfTheNathrezimBuff = Spell(207633)
    ScarletInquisitorsExpurgationBuff = Spell(248289)
    JusticeGaze = Item(137065, { 1 })
    AddPage("常规")
    AddPage("进攻")
    AddPage("防御")
    if self.HasBetaRotation then
        AddNewOption(
        "常规",
        "测试版循环",
        210,
        true,
        nil,
        nil,
        "Use the lastest updated combat routine. May not be as optimized and can contain error regarding execution!"
        )
    end
    AddCommonOptions()
    AddPresetOption("常规", "Melee", nil, true)
    AddSection("常规", { "辅助", "效用" }, "Yellow")
    AddNewOption(
    "常规",
    { "强效祝福", "更大的祝福" },
    210,
    true,
    nil,
    nil,
    { "Apply Greater Blessings on ourself while not in combat.", "在不在战斗中对自己施加更大的祝福。" }
    )
    AddPresetOption("进攻")
    AddSection("进攻", { "大技能", "冷却时间" }, "Yellow")
    AddPresetOption(
    "Cooldown",
    { "复仇之怒", "复仇之怒" },
    nil,
    { 10, 1, 30, 1 },
    { "Minimum Time To Die of the current target to use.", "目前使用目标的最短时间。" }
    )
    AddPresetOption("Cooldown", { "征伐", "征伐" })
    AddPresetOption(
    "Cooldown",
    { "灰烬觉醒", "灰烬觉醒" },
    nil,
    { 1, 1, 10, 1 },
    { "Amount of units that needs to be in range.", "需要在范围内的单位数量。" }
    )
    AddSection("进攻", { "能力", "能力" }, "Yellow")
    AddNewOption(
    "进攻",
    { "奉献", "奉献" },
    220,
    true,
    { 1, 1, 10, 1 },
    nil,
    {
        "Use Consecration." .. C.TOOLTIP_VALUE .. "Amount of units that needs to be in range.",
        "使用奉献。" .. C.TOOLTIP_VALUE .. "需要在范围内的单位数量。"
    }
    )
    AddNewOption(
    "进攻",
    { "神圣风暴", "神圣风暴" },
    220,
    true,
    { 2, 1, 10, 1 },
    nil,
    {
        "Use Divine Storm." .. C.TOOLTIP_VALUE .. "Amount of units that needs to be in range.",
        "使用神的风暴。" .. C.TOOLTIP_VALUE .. "需要在范围内的单位数量。"
    }
    )
    AddNewOption(
    "进攻",
    { "处决宣判(T)", "处决宣判" },
    220,
    true,
    { 7, 7, 20, 1 },
    nil,
    {
        "Use Execution Sentence." ..
        C.TOOLTIP_VALUE .. "Minimum Time to Die to use Execution Sentence on our target.",
        "使用执行句。" .. C.TOOLTIP_VALUE .. "在我们的目标上停止使用执行句的最短时间。"
    }
    )
    AddPresetOption("防御")
    AddSection("防御", { "大技能", "冷却时间" }, "Yellow")
    AddNewOption(
    "防御",
    { "圣盾术", "圣盾术" },
    220,
    true,
    { 20, 1, 100, 1 },
    nil,
    { "Use Divine Shield." .. C.TOOLTIP_VALUE .. "Health threshold.", "使用神盾。" .. C.TOOLTIP_VALUE .. "健康阈值。" }
    )
    AddNewOption(
    "防御",
    { "以眼还眼", "以眼还眼" },
    220,
    true,
    { 40, 1, 100, 1 },
    nil,
    { "Use Eye For An Eye." .. C.TOOLTIP_VALUE .. "Health threshold.", "使用眼睛的眼睛。" .. C.TOOLTIP_VALUE .. "健康阈值。" }
    )
    AddNewOption(
    "防御",
    { "复仇审判官(治疗自己)", "审判官复仇愈合" },
    220,
    false,
    { 40, 1, 100, 1 },
    nil,
    {
        "Use Justicar's Vengeance to Heal ourself." .. C.TOOLTIP_VALUE .. "Health threshold.",
        "使用法官复仇治愈你自己。" .. C.TOOLTIP_VALUE .. "健康阈值。"
    }
    )
    AddNewOption(
    "防御",
    { "圣疗术", "圣疗术" },
    220,
    true,
    { 25, 0, 100, 1 },
    nil,
    {
        "Use Lay on Hands on Player." .. C.TOOLTIP_VALUE .. "Health threshold.",
        "使用手上的玩家。" .. C.TOOLTIP_VALUE .. "健康阈值。"
    }
    )
    AddNewOption(
    "防御",
    { "复仇之盾", "复仇之盾" },
    220,
    true,
    { 50, 1, 100, 1 },
    nil,
    { "Use Shield Of Vengeance." .. C.TOOLTIP_VALUE .. "Health threshold.", "使用复仇之盾。" .. C.TOOLTIP_VALUE .. "健康阈值。" }
    )
    AddNewOption(
    "防御",
    { "荣耀圣令", "荣耀圣令" },
    220,
    true,
    { 40, 1, 100, 1 },
    nil,
    { "Use Word Of Glory." .. C.TOOLTIP_VALUE .. "Health threshold.", "使用荣耀之道。" .. C.TOOLTIP_VALUE .. "健康阈值。" }
    )
    AddSection("防御", { "能力", "能力" }, "Yellow")
    AddNewOption(
    "防御",
    { "圣光闪现(自己)", "圣光闪现自" },
    222,
    true,
    { 30, 1, 100, 1 },
    { 80, 1, 100, 1 },
    {
        "Use Flash Of Light on ourself." ..
        C.TOOLTIP_VALUE_1 ..
        "Health threshold while In Combat." .. C.TOOLTIP_VALUE_2 .. "Health threshold while Out of Combat.",
        "使用圣光闪现对你自己。" .. C.TOOLTIP_VALUE_1 .. "健康阈值在作战。" .. C.TOOLTIP_VALUE_2 .. "健康阈值，而不在战斗。"
    }
    )
end
function Rotation:UseBetaRotation()
    return self.HasBetaRotation and IsOptionEnabled("测试版循环")
end
function Rotation:Events()
end
function Rotation:Pulse()
    if
    not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() or
    Player:Buff(FelCrazedRage)
    then
        return
    end
    if Target:Exists() and BMPullTime() < 5 then
        self:Opening()
        return
    end
    if GetTime() < Rotation.SpamPrevention then
        return
    end
    Rotation.SpamPrevention = GetTime() + 0.05
    Target = Unit.Target
    local InCombat = Player:IsInCombat()
    if not InCombat then
        self:OutOfCombat()
        if not IsOptionEnabled("自动进入战斗") then
            return
        end
    end
    if InCombat then
        self:Defensives()
    end
    Target = Player:ReTarget(CrusaderStrike, false) or Unit.Target
    if Target:Exists() then
        Rotations:RefreshUnitTables(Rotation.Identifier)
        self:Interrupts()
        if
        IsOptionEnabled("开怪技能") and
        (GetOptionValue("开怪技能") == "无条件使用" or (GetOptionValue("开怪技能") == "打BOSS使用" and Target:IsBoss()) or
        (GetOptionValue("开怪技能") == "大技能用法" and CooldownsAllowed())) and
        not OpenerEnded
        then
            self:Opener()
            return
        elseif CombatTime() > 10 then
            OpenerEnded = true
        end
        self:OffGCDAbilities()
        if Player:GlobalCooldown() == 0 then
            if self:UseBetaRotation() then
                self:CombatBeta()
            else
                self:Combat()
            end
        end
    end
end
function Rotation:Opener()
    self.ChoosenOpener = nil
    if LiadrinsFuryUnleashed:IsEquipped(11, 12) then
        self.ChoosenOpener = {
            [1] = {
                BladeOfJustice,
                Target,
                not DivineHammer:Exists() and Player:IsWithinCastRange(Target, BladeOfJustice)
            },
            [2] = { DivineHammer, Player, DivineHammer:Exists() and Player:IsWithinCastRange(Target, CrusaderStrike) },
            [3] = { Judgment, Target, true },
            [4] = { BladeOfJustice, Target, not DivineHammer:Exists() },
            [5] = { DivineHammer, Player, DivineHammer:Exists() },
            [6] = { Crusade, Player, true },
            [7] = { AvengingWrath, Player, not Crusade:Exists() },
            [8] = { ExecutionSentence, Target, true },
            [9] = { TemplarsVerdict, Target, not ExecutionSentence:Exists() and not TemplarsVerdict:NeedsResources() },
            [10] = { WakeOfAshes, Player, Player:DistanceTo(Target) < 12 },
            [11] = { TemplarsVerdict, Target, not TemplarsVerdict:NeedsResources() },
            [12] = { Zeal, Target, not ArcaneTorrent:Exists() or ArcaneTorrent:IsOnCooldown() },
            [13] = {
                CrusaderStrike,
                Target,
                not Zeal:Exists() and (not ArcaneTorrent:Exists() or ArcaneTorrent:IsOnCooldown())
            },
            [14] = { ArcaneTorrent, Player, Player:IsWithinCastRange(Target, CrusaderStrike) },
            [15] = {
                TemplarsVerdict,
                Target,
                ArcaneTorrent:Exists() and ArcaneTorrent:IsOnCooldown() and not TemplarsVerdict:NeedsResources()
            },
            [16] = { TemplarsVerdict, Target, not TemplarsVerdict:NeedsResources() },
            [17] = "Normal Opener"
        }
    else
        self.ChoosenOpener = {
            [1] = {
                BladeOfJustice,
                Target,
                not DivineHammer:Exists() and Player:IsWithinCastRange(Target, BladeOfJustice)
            },
            [2] = { DivineHammer, Player, DivineHammer:Exists() and Player:IsWithinCastRange(Target, CrusaderStrike) },
            [3] = { Zeal, Target, Player:IsWithinCastRange(Target, Zeal) },
            [4] = { CrusaderStrike, Target, not Zeal:Exists() and Player:IsWithinCastRange(Target, CrusaderStrike) },
            [5] = { Judgment, Target, true },
            [6] = { BladeOfJustice, Target, not DivineHammer:Exists() },
            [7] = { DivineHammer, Player, DivineHammer:Exists() },
            [8] = { Zeal, Target, Player:HolyPower() < 3 },
            [9] = { CrusaderStrike, Target, not Zeal:Exists() and Player:HolyPower() < 3 },
            [10] = { Crusade, Player, true },
            [11] = { AvengingWrath, Player, not Crusade:Exists() },
            [12] = { ExecutionSentence, Target, true },
            [13] = { TemplarsVerdict, Target, not ExecutionSentence:Exists() and not TemplarsVerdict:NeedsResources() },
            [14] = { WakeOfAshes, Player, Player:DistanceTo(Target) < 12 },
            [15] = { TemplarsVerdict, Target, not TemplarsVerdict:NeedsResources() },
            [16] = { Zeal, Target, not ArcaneTorrent:Exists() or ArcaneTorrent:IsOnCooldown() },
            [17] = {
                CrusaderStrike,
                Target,
                not Zeal:Exists() and (not ArcaneTorrent:Exists() or ArcaneTorrent:IsOnCooldown())
            },
            [18] = { ArcaneTorrent, Player, Player:IsWithinCastRange(Target, CrusaderStrike) },
            [19] = { TemplarsVerdict, Target, not TemplarsVerdict:NeedsResources() },
            [20] = "Normal Opener"
        }
    end
    if self.ChoosenOpener ~= nil then
        OpenerParser(self.ChoosenOpener)
    else
        Bug("Invalid Talents combination, Opener will not be used.")
        OpenerEnded = true
    end
end
function Rotation:Opening()
    Player:UsePotions("力量药水")
    if
    IsOptionEnabled("抢先施放(需DBM插件)") and
    (GetOptionValue("抢先施放(需DBM插件)") == "无条件使用" or
    (GetOptionValue("抢先施放(需DBM插件)") == "打BOSS使用" and Target:IsBoss()))
    then
        if BMPullTime() < GetSecondOptionValue("抢先施放(需DBM插件)") then
            Player:StartAttack()
            if BladeOfJustice:Exists() and not DivineHammer:Exists() and Target:CanCast(BladeOfJustice) then
                Target:Cast(BladeOfJustice)
                return
            end
            if
            DivineHammer:Exists() and Player:IsWithinCastRange(Target, CrusaderStrike) and
            Player:CanCast(DivineHammer)
            then
                Player:Cast(DivineHammer)
                return
            end
            if Judgment:Exists() and Target:CanCast(Judgment) then
                Target:Cast(Judgment)
                return
            end
        end
    end
end
function Rotation:Defensives()
    Player:UseHealingItem()
    if
    DivineShield:Exists() and not DivineIntervention:Exists() and IsOptionEnabled("圣盾术") and
    Player:HealthPercentage() <= GetOptionValue("圣盾术") and
    Player:CanCast(DivineShield)
    then
        Player:Cast(DivineShield)
        return
    end
    if
    EyeForAnEye:Exists() and IsOptionEnabled("以眼还眼") and Player:HealthPercentage() <= GetOptionValue("以眼还眼") and
    Player:CanCast(EyeForAnEye)
    then
        Player:Cast(EyeForAnEye)
        return
    end
    if
    ShieldOfVengeance:Exists() and IsOptionEnabled("复仇之盾") and Player:HealthPercentage() <= GetOptionValue("复仇之盾") and
    Player:CanCast(ShieldOfVengeance)
    then
        Player:Cast(ShieldOfVengeance)
        return
    end
    if
    WordOfGlory:Exists() and IsOptionEnabled("荣耀圣令") and Player:HolyPower() >= 3 and
    Player:HealthPercentage() <= GetOptionValue("荣耀圣令") and
    Player:CanCast(WordOfGlory)
    then
        Player:Cast(WordOfGlory)
        return
    end
    if
    IsOptionEnabled("圣疗术") and Player:HealthPercentage() < GetOptionValue("圣疗术") and
    not Player:DebuffAny(Forbearance) and
    Player:CanCast(LayOnHands)
    then
        Bug("Lay On Hands - Player")
        Player:Cast(LayOnHands)
        return
    end
    ShouldJusticarsVengeance =     JusticarsVengeance:Exists() and IsOptionEnabled("复仇审判官(治疗自己)") and
    Player:HealthPercentage() <= GetOptionValue("复仇审判官(治疗自己)")
    if
    ShouldJusticarsVengeance and (Player:HolyPower() >= 5 or Player:Buff(DivinePurpose)) and
    Target:CanCast(JusticarsVengeance)
    then
        Target:Cast(JusticarsVengeance)
        return
    end
    if
    GiftOfTheNaaru:Exists() and IsOptionEnabled("纳鲁的赐福") and Player:HealthPercentage() <= GetOptionValue("纳鲁的赐福") and
    Player:CanCast(GiftOfTheNaaru)
    then
        Player:Cast(GiftOfTheNaaru)
        return
    end
end
function Rotation:Interrupts()
    if Player:CanAttack(Target) then
        Player:UseInterrupt(Rebuke, ArcaneTorrent)
    end
end
function Rotation:OffGCDAbilities()
end
function Rotation:UnitTables()
    onlyPlayers = false
    if Target:IsPlayer() then
        onlyPlayers = true
    end
    WakeOfAshesUnits =     UseAOE() and WakeOfAshes:Exists() and IsOptionEnabled("灰烬觉醒") and
    #Player:UnitsInFrontCone(10, 140, false, 0, onlyPlayers) or
    0
    Enemies_8y = UseAOE() and Player:EnemiesWithinDistance(8, true, false, onlyPlayers) or {}
    DivineTempestUnits =     UseAOE() and DivineTempest:ArtifactEnabled() and #Player:UnitsInFrontCone(20, 110, false, 0, onlyPlayers) or 0
    DivineStormUnitsInCone =     UseAOE() and DivineTempest:ArtifactEnabled() and #Player:UnitsInFrontCone(8, 110, false, 0, onlyPlayers) or 0
    NumEnemies = #Enemies_8y
    AoEUnits = NumEnemies + DivineTempestUnits - DivineStormUnitsInCone
end
function Rotation:Combat()
    GCDMax, HolyPower = Player:GCD(), Player:HolyPower()
    if
    FlashOfLight:Exists() and Player:Standing() > 0.5 and IsOptionEnabled("圣光闪现(自己)") and
    Player:HealthPercentage() <= GetOptionValue("圣光闪现(自己)") and
    Player:CanCast(FlashOfLight)
    then
        Player:Cast(FlashOfLight)
        return
    end
    if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        Player:StartAttack()
        WakeOfAshesEnabled =         WakeOfAshes:Exists() and IsOptionEnabled("灰烬觉醒") and
        (GetOptionValue("灰烬觉醒") == "无条件使用" or CooldownsAllowed()) or
        false
        if
        WakeOfAshesEnabled and WakeOfAshesUnits >= GetSecondOptionValue("灰烬觉醒") and CombatTime() < 10 and
        (HolyPower <= 1 or not AshesToAshes:ArtifactEnabled()) and
        Player:CanCast(WakeOfAshes)
        then
            Player:Cast(WakeOfAshes)
            return
        end
        PVPBurstHPStacking =         Target:IsPlayer() and AvengingWrath:Exists() and IsOptionEnabled("复仇之怒") and
        not AvengingWrath:IsOnCooldown()
        wrathValue = Target:IsPlayer() and 5 or 0
        if Player:IsWithinCastRange(Target, CrusaderStrike) then
            DraughtEquipped = DraughtOfSouls:IsEquipped(13, 14)
            DraughtUsable =             (DraughtEquipped == 13 and GetOptionValue("饰品: 1 | 2") ~= "禁用" and
            (CooldownsAllowed() or GetOptionValue("饰品: 1 | 2") == "无条件使用")) or
            (DraughtEquipped == 14 and GetSecondOptionValue("饰品: 1 | 2") ~= "禁用" and
            (CooldownsAllowed() or GetSecondOptionValue("饰品: 1 | 2") == "无条件使用"))
            if
            DraughtEquipped and DraughtUsable and not DraughtOfSouls:IsOnCooldown() and
            (Player:Buff(AvengingWrath) or Player:BuffCount(Crusade) >= 15 or
            (Crusade:Cooldown() > 20 and not Player:Buff(Crusade)))
            then
                Player:UseItem(DraughtOfSouls)
            end
            if not (DraughtOfSouls:IsEquipped(13, 14) or DraughtOfSouls:IsOnCooldown()) then
                Player:UseTrinkets()
            end
            if
            ArcaneTorrent:Exists() and HolyPower < 5 and (Player:Buff(Crusade) or Player:Buff(AvengingWrath)) and
            WakeOfAshes:IsOnCooldown() and
            Player:CanCast(ArcaneTorrent)
            then
                Player:Cast(ArcaneTorrent)
                return
            end
            if
            AvengingWrath:Exists() and not Crusade:Exists() and CDOptionEnabled("复仇之怒") and
            Target:TimeToDie() >= GetSecondOptionValue("复仇之怒") and
            HolyPower >= wrathValue and
            Player:CanCast(AvengingWrath)
            then
                Player:Cast(AvengingWrath)
                return
            end
            CrusadeEnabled = Crusade:Exists() and CDOptionEnabled("征伐")
            ExecutionSentenceEnabled = ExecutionSentence:Exists() and IsOptionEnabled("处决宣判(T)")
            holyPowerValue = LiadrinsFuryUnleashed:IsEquipped(11, 12) and 4 or 5
            if CrusadeEnabled and HolyPower >= holyPowerValue and Player:CanCast(Crusade) then
                Player:Cast(Crusade)
                return
            end
            Player:UsePotions("力量药水")
        end
        DivineStormEnabled = DivineStorm:Exists() and IsOptionEnabled("神圣风暴")
        if not PVPBurstHPStacking then
            if not Target:Debuff(JudgmentDebuff) and Judgment:Cooldown() > 2 and HolyPower == 5 then
                if DivineStormEnabled and AoEUnits >= GetOptionValue("神圣风暴") and Player:CanCast(DivineStorm) then
                    Player:Cast(DivineStorm)
                    return
                else
                    if JusticarsVengeance:Exists() and Target:IsPlayer() and Target:CanCast(JusticarsVengeance) then
                        Target:Cast(JusticarsVengeance)
                        return
                    elseif Target:CanCast(TemplarsVerdict) then
                        Target:Cast(TemplarsVerdict)
                        return
                    end
                end
            end
            if
            ExecutionSentence:Exists() and IsOptionEnabled("处决宣判(T)") and HolyPower >= 3 and
            Target:TimeToDie() >= GetOptionValue("处决宣判(T)") and
            (AoEUnits <= 3 and
            (Judgment:Cooldown() < GCDMax * 4.65 or Target:DebuffRemains(JudgmentDebuff) > GCDMax * 4.66) and
            (not Crusade:Exists() or Crusade:Cooldown() > GCDMax * 2)) and
            Target:CanCast(ExecutionSentence)
            then
                Target:Cast(ExecutionSentence)
                return
            end
            if
            not ShouldJusticarsVengeance and DivineStormEnabled and Target:Debuff(JudgmentDebuff) and
            AoEUnits >= GetOptionValue("神圣风暴") and
            Player:Buff(DivinePurpose) and
            Player:BuffRemains(DivinePurpose) < GCDMax * 2 and
            Player:CanCast(DivineStorm)
            then
                Player:Cast(DivineStorm)
                return
            end
            if
            not ShouldJusticarsVengeance and DivineStormEnabled and Target:Debuff(JudgmentDebuff) and
            AoEUnits >= GetOptionValue("神圣风暴") and
            HolyPower >= 5 and
            Player:Buff(DivinePurpose) and
            Player:CanCast(DivineStorm)
            then
                Player:Cast(DivineStorm)
                return
            end
            if
            not ShouldJusticarsVengeance and DivineStormEnabled and Target:Debuff(JudgmentDebuff) and
            AoEUnits >= GetOptionValue("神圣风暴") and
            HolyPower >= 3 and
            Player:Buff(Crusade) and
            (Player:BuffCount(Crusade) < 15 or Player:HasHero()) and
            Player:CanCast(DivineStorm)
            then
                Player:Cast(DivineStorm)
                return
            end
            if
            not ShouldJusticarsVengeance and DivineStormEnabled and Target:Debuff(JudgmentDebuff) and
            AoEUnits >= GetOptionValue("神圣风暴") and
            HolyPower >= 5 and
            (not Crusade:Exists() or not CrusadeEnabled or Crusade:Cooldown() > GCDMax * 3) and
            Player:CanCast(DivineStorm)
            then
                Player:Cast(DivineStorm)
                return
            end
            if
            not ShouldJusticarsVengeance and TemplarsVerdict:Exists() and Target:Debuff(JudgmentDebuff) and
            HolyPower >= 5 and
            Player:Buff(DivinePurpose) and
            Player:BuffRemains(DivinePurpose) < GCDMax * 2
            then
                if JusticarsVengeance:Exists() and Target:CanCast(JusticarsVengeance) then
                    Target:Cast(JusticarsVengeance)
                    return
                elseif not JusticarsVengeance:Exists() and Target:CanCast(TemplarsVerdict) then
                    Target:Cast(TemplarsVerdict)
                    return
                end
            end
            if
            not ShouldJusticarsVengeance and TemplarsVerdict:Exists() and Target:Debuff(JudgmentDebuff) and
            HolyPower >= 5 and
            Player:Buff(DivinePurpose)
            then
                if JusticarsVengeance:Exists() and Target:CanCast(JusticarsVengeance) then
                    Target:Cast(JusticarsVengeance)
                    return
                elseif not JusticarsVengeance:Exists() and Target:CanCast(TemplarsVerdict) then
                    Target:Cast(TemplarsVerdict)
                    return
                end
            end
            if
            not ShouldJusticarsVengeance and TemplarsVerdict:Exists() and Target:Debuff(JudgmentDebuff) and
            HolyPower >= 3 and
            Player:Buff(Crusade) and
            (Player:BuffCount(Crusade) < 15 or Player:HasHero()) and
            Target:CanCast(TemplarsVerdict)
            then
                Target:Cast(TemplarsVerdict)
                return
            end
            if
            not ShouldJusticarsVengeance and TemplarsVerdict:Exists() and Target:Debuff(JudgmentDebuff) and
            HolyPower >= 5 and
            (not Crusade:Exists() or not CrusadeEnabled or Crusade:Cooldown() > GCDMax * 3) and
            (not ExecutionSentenceEnabled or ExecutionSentence:Cooldown() > GCDMax) and
            Target:CanCast(TemplarsVerdict)
            then
                if JusticarsVengeance:Exists() and Target:IsPlayer() and Target:CanCast(JusticarsVengeance) then
                    Target:Cast(JusticarsVengeance)
                    return
                elseif Target:CanCast(TemplarsVerdict) then
                    Target:Cast(TemplarsVerdict)
                    return
                end
            end
            if
            not ShouldJusticarsVengeance and DivineStormEnabled and Target:Debuff(JudgmentDebuff) and HolyPower >= 3 and
            AoEUnits >= GetOptionValue("神圣风暴") and
            ((WakeOfAshes:Exists() and WakeOfAshes:Cooldown() < GCDMax * 2) or
            (Player:Buff(WhisperOfTheNathrezimBuff) and
            Player:BuffRemains(WhisperOfTheNathrezimBuff) < GCDMax)) and
            (not Crusade:Exists() or not CrusadeEnabled or Crusade:Cooldown() > GCDMax * 4) and
            Player:CanCast(DivineStorm)
            then
                Player:Cast(DivineStorm)
                return
            end
            if
            not ShouldJusticarsVengeance and TemplarsVerdict:Exists() and Target:Debuff(JudgmentDebuff) and
            HolyPower >= 3 and
            ((WakeOfAshes:Exists() and WakeOfAshes:Cooldown() < GCDMax * 2) or
            (Player:Buff(WhisperOfTheNathrezimBuff) and
            Player:BuffRemains(WhisperOfTheNathrezimBuff) < GCDMax)) and
            (not Crusade:Exists() or not CrusadeEnabled or Crusade:Cooldown() > GCDMax * 4) and
            Target:CanCast(TemplarsVerdict)
            then
                Target:Cast(TemplarsVerdict)
                return
            end
        end
        if
        Judgment:Exists() and Target:Debuff(ExecutionSentence) and
        Target:DebuffRemains(ExecutionSentence) < GCDMax * 2 and
        Target:DebuffRemains(JudgmentDebuff) < GCDMax * 2 and
        Target:CanCast(Judgment)
        then
            Target:Cast(Judgment)
            return
        end
        if
        WakeOfAshesEnabled and
        (GetSecondOptionValue("灰烬觉醒") == 1 or WakeOfAshesUnits >= GetSecondOptionValue("灰烬觉醒")) and
        (HolyPower == 0 or not AshesToAshes:ArtifactEnabled() or
        (HolyPower == 1 and
        ((not DivineHammer:Exists() and (BladeOfJustice:Cooldown() > GCDMax or Target:IsPlayer())) or
        (DivineHammer:Exists() and DivineHammer:Cooldown() > GCDMax))) or
        (HolyPower == 2 and
        ((Zeal:Exists() and Zeal:FractionalCharges() <= 0.65) or
        (not Zeal:Exists() and CrusaderStrike:FractionalCharges() <= 0.65)))) and
        Player:IsWithinCastRange(Target, CrusaderStrike) and
        Player:CanCast(WakeOfAshes)
        then
            Player:Cast(WakeOfAshes)
            return
        end
        if
        DivineHammer:Exists() and HolyPower <= 3 and Player:Buff(WhisperOfTheNathrezimBuff) and
        Player:BuffRemains(WhisperOfTheNathrezimBuff) > GCDMax and
        Player:BuffRemains(WhisperOfTheNathrezimBuff) < GCDMax * 3 and
        Target:Debuff(JudgmentDebuff) and
        Target:DebuffRemains(JudgmentDebuff) > GCDMax * 2 and
        Player:DistanceTo(Target) <= 8 and
        Player:CanCast(DivineHammer)
        then
            Player:Cast(DivineHammer)
            return
        end
        if not DivineHammer:Exists() and HolyPower <= 3 and Target:CanCast(BladeOfJustice) then
            Target:Cast(BladeOfJustice)
            return
        end
        if Zeal:Exists() and Zeal:FractionalCharges() > 1.8 and HolyPower <= 4 and Target:CanCast(Zeal) then
            Target:Cast(Zeal)
            return
        end
        if
        CrusaderStrike:Exists() and not Zeal:Exists() and CrusaderStrike:FractionalCharges() > 1.8 and
        HolyPower <= 4 and
        Target:CanCast(CrusaderStrike)
        then
            Target:Cast(CrusaderStrike)
            return
        end
        if
        DivineHammer:Exists() and
        (HolyPower <= 2 or
        (HolyPower <= 3 and
        ((Zeal:Exists() and Zeal:FractionalCharges() <= 1.34) or
        (not Zeal:Exists() and CrusaderStrike:FractionalCharges() <= 1.34)))) and
        Player:DistanceTo(Target) <= 8 and
        Player:CanCast(DivineHammer)
        then
            Player:Cast(DivineHammer)
            return
        end
        if PVPBurstHPStacking then
            if HolyPower >= 5 and CooldownsAllowed() and Target:CanCast(Judgment) then
                Target:Cast(Judgment)
                return
            end
        elseif Judgment:Exists() and Target:CanCast(Judgment) then
            Target:Cast(Judgment)
            return
        end
        if
        Consecration:Exists() and IsOptionEnabled("奉献") and NumEnemies >= GetOptionValue("奉献") and
        Player:IsWithinCastRange(Target, CrusaderStrike) and
        Player:CanCast(Consecration)
        then
            Player:Cast(Consecration)
            return
        end
        if not PVPBurstHPStacking then
            if
            not ShouldJusticarsVengeance and DivineStormEnabled and Target:Debuff(JudgmentDebuff) and
            AoEUnits >= GetOptionValue("神圣风暴") and
            Player:Buff(DivinePurpose) and
            Player:CanCast(DivineStorm)
            then
                Player:Cast(DivineStorm)
                return
            end
            if
            not ShouldJusticarsVengeance and DivineStormEnabled and Target:Debuff(JudgmentDebuff) and
            AoEUnits >= GetOptionValue("神圣风暴") and
            Player:Buff(TheFiresOfJusticeBuff) and
            (not Crusade:Exists() or not CrusadeEnabled or Crusade:Cooldown() > GCDMax * 3) and
            Player:CanCast(DivineStorm)
            then
                Player:Cast(DivineStorm)
                return
            end
            if
            not ShouldJusticarsVengeance and DivineStormEnabled and Target:Debuff(JudgmentDebuff) and
            AoEUnits >= GetOptionValue("神圣风暴") and
            (HolyPower >= 4 or
            (((Zeal:Exists() and Zeal:FractionalCharges() <= 1.34) or
            (not Zeal:Exists() and CrusaderStrike:FractionalCharges() <= 1.34)) and
            ((not DivineHammer:Exists() and BladeOfJustice:Cooldown() > GCDMax) or
            (DivineHammer:Exists() and DivineHammer:Cooldown() > GCDMax)))) and
            (not Crusade:Exists() or not CrusadeEnabled or Crusade:Cooldown() > GCDMax * 4) and
            Player:CanCast(DivineStorm)
            then
                Player:Cast(DivineStorm)
                return
            end
            if
            not ShouldJusticarsVengeance and TemplarsVerdict:Exists() and Target:Debuff(JudgmentDebuff) and
            Player:Buff(DivinePurpose)
            then
                if JusticarsVengeance:Exists() and Target:CanCast(JusticarsVengeance) then
                    Target:Cast(JusticarsVengeance)
                    return
                elseif not JusticarsVengeance:Exists() and Target:CanCast(TemplarsVerdict) then
                    Target:Cast(TemplarsVerdict)
                    return
                end
            end
            if
            not ShouldJusticarsVengeance and TemplarsVerdict:Exists() and Target:Debuff(JudgmentDebuff) and
            Player:Buff(TheFiresOfJusticeBuff) and
            (not Crusade:Exists() or not CrusadeEnabled or Crusade:Cooldown() > GCDMax * 3) and
            Target:CanCast(TemplarsVerdict)
            then
                Target:Cast(TemplarsVerdict)
                return
            end
            if
            not ShouldJusticarsVengeance and TemplarsVerdict:Exists() and Target:Debuff(JudgmentDebuff) and
            (HolyPower >= 4 or
            ((Zeal:Exists() and Zeal:FractionalCharges() <= 1.34) or
            (not Zeal:Exists() and CrusaderStrike:FractionalCharges() <= 1.34))) and
            (not Crusade:Exists() or not CrusadeEnabled or Crusade:Cooldown() > GCDMax * 4) and
            (not ExecutionSentenceEnabled or ExecutionSentence:Cooldown() > GCDMax * 2) and
            Target:CanCast(TemplarsVerdict)
            then
                Target:Cast(TemplarsVerdict)
                return
            end
        end
        if Zeal:Exists() and HolyPower <= 4 and Target:CanCast(Zeal) then
            Target:Cast(Zeal)
            return
        end
        if CrusaderStrike:Exists() and not Zeal:Exists() and HolyPower <= 4 and Target:CanCast(CrusaderStrike) then
            Target:Cast(CrusaderStrike)
            return
        end
        if not PVPBurstHPStacking then
            if
            not ShouldJusticarsVengeance and DivineStormEnabled and Target:Debuff(JudgmentDebuff) and
            AoEUnits >= GetOptionValue("神圣风暴") and
            (not Crusade:Exists() or not CrusadeEnabled or Crusade:Cooldown() > GCDMax * 5) and
            Player:CanCast(DivineStorm)
            then
                Player:Cast(DivineStorm)
                return
            end
            if
            not ShouldJusticarsVengeance and TemplarsVerdict:Exists() and Target:Debuff(JudgmentDebuff) and
            HolyPower >= 3 and
            (not Crusade:Exists() or not CrusadeEnabled or Crusade:Cooldown() > GCDMax * 5) and
            Target:CanCast(TemplarsVerdict)
            then
                Target:Cast(TemplarsVerdict)
                return
            end
        end
    end
end
function Rotation:CombatBeta()
    GCDMax, HolyPower = Player:GCD(), Player:HolyPower()
    if
    FlashOfLight:Exists() and Player:Standing() > 0.5 and IsOptionEnabled("圣光闪现(自己)") and
    Player:HealthPercentage() <= GetOptionValue("圣光闪现(自己)") and
    Player:CanCast(FlashOfLight)
    then
        Player:Cast(FlashOfLight)
        return
    end
    if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        Player:StartAttack()
        WakeOfAshesEnabled =         WakeOfAshes:Exists() and IsOptionEnabled("灰烬觉醒") and
        (GetOptionValue("灰烬觉醒") == "无条件使用" or CooldownsAllowed()) or
        false
        if
        WakeOfAshesEnabled and WakeOfAshesUnits >= GetSecondOptionValue("灰烬觉醒") and CombatTime() < 10 and
        (HolyPower <= 1 or not AshesToAshes:ArtifactEnabled()) and
        Player:CanCast(WakeOfAshes)
        then
            Player:Cast(WakeOfAshes)
            return
        end
        PVPBurstHPStacking =         Target:IsPlayer() and AvengingWrath:Exists() and IsOptionEnabled("复仇之怒") and
        not AvengingWrath:IsOnCooldown()
        wrathValue = Target:IsPlayer() and 5 or 0
        if Player:IsWithinCastRange(Target, CrusaderStrike) then
            DraughtEquipped = DraughtOfSouls:IsEquipped(13, 14)
            DraughtUsable =             (DraughtEquipped == 13 and GetOptionValue("饰品: 1 | 2") ~= "禁用" and
            (CooldownsAllowed() or GetOptionValue("饰品: 1 | 2") == "无条件使用")) or
            (DraughtEquipped == 14 and GetSecondOptionValue("饰品: 1 | 2") ~= "禁用" and
            (CooldownsAllowed() or GetSecondOptionValue("饰品: 1 | 2") == "无条件使用"))
            if
            DraughtEquipped and DraughtUsable and not DraughtOfSouls:IsOnCooldown() and
            (Player:Buff(AvengingWrath) or Player:BuffCount(Crusade) >= 15 or
            (Crusade:Cooldown() > 20 and not Player:Buff(Crusade)))
            then
                Player:UseItem(DraughtOfSouls)
            end
            if not (DraughtOfSouls:IsEquipped(13, 14) or DraughtOfSouls:IsOnCooldown()) then
                Player:UseTrinkets()
            end
            if
            ArcaneTorrent:Exists() and HolyPower < 5 and (Player:Buff(Crusade) or Player:Buff(AvengingWrath)) and
            WakeOfAshes:IsOnCooldown() and
            Player:CanCast(ArcaneTorrent)
            then
                Player:Cast(ArcaneTorrent)
                return
            end
            if
            AvengingWrath:Exists() and not Crusade:Exists() and CDOptionEnabled("复仇之怒") and
            Target:TimeToDie() >= GetSecondOptionValue("复仇之怒") and
            HolyPower >= wrathValue and
            Player:CanCast(AvengingWrath)
            then
                Player:Cast(AvengingWrath)
                return
            end
            CrusadeEnabled = Crusade:Exists() and CDOptionEnabled("征伐")
            ExecutionSentenceEnabled = ExecutionSentence:Exists() and IsOptionEnabled("处决宣判(T)")
            holyPowerValue = LiadrinsFuryUnleashed:IsEquipped(11, 12) and 4 or 5
            if CrusadeEnabled and HolyPower >= holyPowerValue and Player:CanCast(Crusade) then
                Player:Cast(Crusade)
                return
            end
            Player:UsePotions("力量药水")
        end
        DivineStormEnabled = DivineStorm:Exists() and IsOptionEnabled("神圣风暴")
        if not PVPBurstHPStacking then
            if not Target:Debuff(JudgmentDebuff) and Judgment:Cooldown() > 2 and HolyPower == 5 then
                if DivineStormEnabled and AoEUnits >= GetOptionValue("神圣风暴") and Player:CanCast(DivineStorm) then
                    Player:Cast(DivineStorm)
                    return
                else
                    if JusticarsVengeance:Exists() and Target:IsPlayer() and Target:CanCast(JusticarsVengeance) then
                        Target:Cast(JusticarsVengeance)
                        return
                    elseif Target:CanCast(TemplarsVerdict) then
                        Target:Cast(TemplarsVerdict)
                        return
                    end
                end
            end
            if
            ExecutionSentence:Exists() and IsOptionEnabled("处决宣判(T)") and HolyPower >= 3 and
            Target:TimeToDie() >= GetOptionValue("处决宣判(T)") and
            (AoEUnits <= 3 and
            (Judgment:Cooldown() < GCDMax * 4.5 or Target:DebuffRemains(JudgmentDebuff) > GCDMax * 4.5)) and
            Target:CanCast(ExecutionSentence)
            then
                Target:Cast(ExecutionSentence)
                return
            end
            DSCastable =             AoEUnits >= GetOptionValue("神圣风暴") or
            (Player:BuffCount(ScarletInquisitorsExpurgationBuff) >= 29 and
            (Player:Buff(AvengingWrath) or (Player:Buff(Crusade) and Player:BuffCount(Crusade) >= 15) or
            (Crusade:Cooldown() > 15 and not Player:Buff(Crusade)) or
            AvengingWrath:Cooldown() > 15))
            if
            not ShouldJusticarsVengeance and DivineStormEnabled and Target:Debuff(JudgmentDebuff) and DSCastable and
            Player:Buff(DivinePurpose) and
            Player:BuffRemains(DivinePurpose) < GCDMax * 2 and
            Player:CanCast(DivineStorm)
            then
                Player:Cast(DivineStorm)
                return
            end
            if
            not ShouldJusticarsVengeance and DivineStormEnabled and Target:Debuff(JudgmentDebuff) and DSCastable and
            HolyPower >= 5 and
            Player:Buff(DivinePurpose) and
            Player:CanCast(DivineStorm)
            then
                Player:Cast(DivineStorm)
                return
            end
            if
            not ShouldJusticarsVengeance and DivineStormEnabled and Target:Debuff(JudgmentDebuff) and
            AoEUnits >= GetOptionValue("神圣风暴") and
            HolyPower >= 3 and
            ((Player:Buff(Crusade) and Player:BuffCount(Crusade) < 15) or Player:Buff(LiadrinsFuryUnleashedBuff)) and
            Player:CanCast(DivineStorm)
            then
                Player:Cast(DivineStorm)
                return
            end
            if
            not ShouldJusticarsVengeance and DivineStormEnabled and Target:Debuff(JudgmentDebuff) and DSCastable and
            HolyPower >= 5 and
            Player:CanCast(DivineStorm)
            then
                Player:Cast(DivineStorm)
                return
            end
            if
            not ShouldJusticarsVengeance and TemplarsVerdict:Exists() and Target:Debuff(JudgmentDebuff) and
            HolyPower >= 5 and
            Player:Buff(DivinePurpose) and
            Player:BuffRemains(DivinePurpose) < GCDMax * 2
            then
                if JusticarsVengeance:Exists() and Target:CanCast(JusticarsVengeance) then
                    Target:Cast(JusticarsVengeance)
                    return
                elseif not JusticarsVengeance:Exists() and Target:CanCast(TemplarsVerdict) then
                    Target:Cast(TemplarsVerdict)
                    return
                end
            end
            if
            not ShouldJusticarsVengeance and TemplarsVerdict:Exists() and Target:Debuff(JudgmentDebuff) and
            HolyPower >= 5 and
            Player:Buff(DivinePurpose)
            then
                if JusticarsVengeance:Exists() and Target:CanCast(JusticarsVengeance) then
                    Target:Cast(JusticarsVengeance)
                    return
                elseif not JusticarsVengeance:Exists() and Target:CanCast(TemplarsVerdict) then
                    Target:Cast(TemplarsVerdict)
                    return
                end
            end
            if
            not ShouldJusticarsVengeance and TemplarsVerdict:Exists() and Target:Debuff(JudgmentDebuff) and
            HolyPower >= 3 and
            ((Player:Buff(Crusade) and Player:BuffCount(Crusade) < 15) or Player:Buff(LiadrinsFuryUnleashedBuff)) and
            Target:CanCast(TemplarsVerdict)
            then
                Target:Cast(TemplarsVerdict)
                return
            end
            if
            not ShouldJusticarsVengeance and TemplarsVerdict:Exists() and Target:Debuff(JudgmentDebuff) and
            HolyPower >= 5 and
            Target:CanCast(TemplarsVerdict)
            then
                Target:Cast(TemplarsVerdict)
                return
            end
            if
            not ShouldJusticarsVengeance and DivineStormEnabled and Target:Debuff(JudgmentDebuff) and DSCastable and
            ((WakeOfAshesEnabled and WakeOfAshes:Cooldown() < GCDMax * 2) or
            (Player:Buff(WhisperOfTheNathrezimBuff) and
            Player:BuffRemains(WhisperOfTheNathrezimBuff) < GCDMax * 1.5)) and
            Player:CanCast(DivineStorm)
            then
                Player:Cast(DivineStorm)
                return
            end
            if
            not ShouldJusticarsVengeance and TemplarsVerdict:Exists() and Target:Debuff(JudgmentDebuff) and
            ((WakeOfAshesEnabled and WakeOfAshes:Cooldown() < GCDMax * 2) or
            (Player:Buff(WhisperOfTheNathrezimBuff) and
            Player:BuffRemains(WhisperOfTheNathrezimBuff) < GCDMax * 1.5)) and
            Target:CanCast(TemplarsVerdict)
            then
                Target:Cast(TemplarsVerdict)
                return
            end
        end
        if
        Judgment:Exists() and Target:Debuff(ExecutionSentence) and
        Target:DebuffRemains(ExecutionSentence) < GCDMax * 2 and
        Target:DebuffRemains(JudgmentDebuff) < GCDMax * 2 and
        Target:CanCast(Judgment)
        then
            Target:Cast(Judgment)
            return
        end
        if
        Consecration:Exists() and IsOptionEnabled("奉献") and NumEnemies >= GetOptionValue("奉献") and
        ((not DivineHammer:Exists() and BladeOfJustice:Cooldown() > GCDMax * 2) or
        (DivineHammer:Exists() and DivineHammer:Cooldown() > GCDMax * 2)) and
        Player:IsWithinCastRange(Target, CrusaderStrike) and
        Player:CanCast(Consecration)
        then
            Player:Cast(Consecration)
            return
        end
        if
        WakeOfAshesEnabled and
        (GetSecondOptionValue("灰烬觉醒") == 1 or WakeOfAshesUnits >= GetSecondOptionValue("灰烬觉醒")) and
        (HolyPower == 0 or not AshesToAshes:ArtifactEnabled() or
        (HolyPower == 1 and
        ((not DivineHammer:Exists() and (BladeOfJustice:Cooldown() > GCDMax or Target:IsPlayer())) or
        (DivineHammer:Exists() and DivineHammer:Cooldown() > GCDMax))) or
        (HolyPower == 2 and
        ((Zeal:Exists() and Zeal:FractionalCharges() <= 0.65) or
        (not Zeal:Exists() and CrusaderStrike:FractionalCharges() <= 0.65)))) and
        Player:IsWithinCastRange(Target, CrusaderStrike) and
        Player:CanCast(WakeOfAshes)
        then
            Player:Cast(WakeOfAshes)
            return
        end
        if not DivineHammer:Exists() and HolyPower <= 3 - (HasT20_4Pc and 1 or 0) and Target:CanCast(BladeOfJustice) then
            Target:Cast(BladeOfJustice)
            return
        end
        if
        DivineHammer:Exists() and HolyPower <= 3 - (HasT20_4Pc and 1 or 0) and Player:DistanceTo(Target) <= 8 and
        Player:CanCast(DivineHammer)
        then
            Player:Cast(DivineHammer)
            return
        end
        if PVPBurstHPStacking then
            if HolyPower >= 5 and CooldownsAllowed() and Target:CanCast(Judgment) then
                Target:Cast(Judgment)
                return
            end
        elseif Judgment:Exists() and Target:CanCast(Judgment) then
            Target:Cast(Judgment)
            return
        end
        if
        Zeal:Exists() and Zeal:FractionalCharges() > 1.65 and HolyPower <= 4 and
        ((not DivineHammer:Exists() and BladeOfJustice:Cooldown() > GCDMax * 2) or
        (DivineHammer:Exists() and DivineHammer:Cooldown() > GCDMax * 2)) and
        Target:DebuffRemains(JudgmentDebuff) > GCDMax and
        Target:CanCast(Zeal)
        then
            Target:Cast(Zeal)
            return
        end
        if
        CrusaderStrike:Exists() and not Zeal:Exists() and
        CrusaderStrike:FractionalCharges() > 1.65 - (TheFiresOfJustice:Exists() and 0.25 or 0) and
        HolyPower <= 4 and
        ((not DivineHammer:Exists() and BladeOfJustice:Cooldown() > GCDMax * 2) or
        (DivineHammer:Exists() and DivineHammer:Cooldown() > GCDMax * 2)) and
        Target:DebuffRemains(JudgmentDebuff) > GCDMax and
        Target:CanCast(CrusaderStrike)
        then
            Target:Cast(CrusaderStrike)
            return
        end
        if
        Consecration:Exists() and IsOptionEnabled("奉献") and NumEnemies >= GetOptionValue("奉献") and
        Player:IsWithinCastRange(Target, CrusaderStrike) and
        Player:CanCast(Consecration)
        then
            Player:Cast(Consecration)
            return
        end
        if not PVPBurstHPStacking then
            if
            not ShouldJusticarsVengeance and DivineStormEnabled and Target:Debuff(JudgmentDebuff) and DSCastable and
            Player:Buff(DivinePurpose) and
            Player:CanCast(DivineStorm)
            then
                Player:Cast(DivineStorm)
                return
            end
            if
            not ShouldJusticarsVengeance and DivineStormEnabled and Target:Debuff(JudgmentDebuff) and DSCastable and
            Player:Buff(TheFiresOfJusticeBuff) and
            Player:CanCast(DivineStorm)
            then
                Player:Cast(DivineStorm)
                return
            end
            if
            not ShouldJusticarsVengeance and DivineStormEnabled and Target:Debuff(JudgmentDebuff) and DSCastable and
            Player:CanCast(DivineStorm)
            then
                Player:Cast(DivineStorm)
                return
            end
            if
            not ShouldJusticarsVengeance and TemplarsVerdict:Exists() and Target:Debuff(JudgmentDebuff) and
            Player:Buff(DivinePurpose)
            then
                if JusticarsVengeance:Exists() and Target:CanCast(JusticarsVengeance) then
                    Target:Cast(JusticarsVengeance)
                    return
                elseif not JusticarsVengeance:Exists() and Target:CanCast(TemplarsVerdict) then
                    Target:Cast(TemplarsVerdict)
                    return
                end
            end
            if
            not ShouldJusticarsVengeance and TemplarsVerdict:Exists() and Target:Debuff(JudgmentDebuff) and
            Player:Buff(TheFiresOfJusticeBuff) and
            Target:CanCast(TemplarsVerdict)
            then
                Target:Cast(TemplarsVerdict)
                return
            end
            if
            not ShouldJusticarsVengeance and TemplarsVerdict:Exists() and Target:Debuff(JudgmentDebuff) and
            (not ExecutionSentenceEnabled or ExecutionSentence:Cooldown() > GCDMax * 2) and
            Target:CanCast(TemplarsVerdict)
            then
                Target:Cast(TemplarsVerdict)
                return
            end
            if
            HammerOfJustice:Exists() and JusticeGaze:IsEquipped() and Target:HealthPercentage() > 75 and
            HolyPower <= 4 and
            Target:CanCast(HammerOfJustice)
            then
                Target:Cast(HammerOfJustice)
                return
            end
        end
        if Zeal:Exists() and HolyPower <= 4 and Target:CanCast(Zeal) then
            Target:Cast(Zeal)
            return
        end
        if CrusaderStrike:Exists() and not Zeal:Exists() and HolyPower <= 4 and Target:CanCast(CrusaderStrike) then
            Target:Cast(CrusaderStrike)
            return
        end
    end
end
function Rotation:OutOfCombat()
    if IsOptionEnabled("强效祝福") then
        if
        GreaterBlessingOfKings:Exists() and Player:BuffRemains(GreaterBlessingOfKings) < 300 and
        Player:CanCast(GreaterBlessingOfKings)
        then
            Player:Cast(GreaterBlessingOfKings)
            return
        end
        if
        GreaterBlessingOfWisdom:Exists() and Player:BuffRemains(GreaterBlessingOfWisdom) < 300 and
        Player:CanCast(GreaterBlessingOfWisdom)
        then
            Player:Cast(GreaterBlessingOfWisdom)
            return
        end
        if
        GreaterBlessingOfMight:Exists() and Player:BuffRemains(GreaterBlessingOfMight) < 300 and
        Player:CanCast(GreaterBlessingOfMight)
        then
            Player:Cast(GreaterBlessingOfMight)
            return
        end
    end
    if
    FlashOfLight:Exists() and Player:Standing() > 0.5 and IsOptionEnabled("圣光闪现(自己)") and
    Player:HealthPercentage() <= GetSecondOptionValue("圣光闪现(自己)") and
    Player:CanCast(FlashOfLight)
    then
        Player:Cast(FlashOfLight)
        return
    end
    if IsOptionEnabled("自动进入战斗") and Judgment:Exists() and Target:CanCast(Judgment) then
        Target:Cast(Judgment)
        return
    end
end
SetRotation(256, {})
local Rotation = Rotations[256]
function Rotation:Initialize()
    Trinket1 = Item(13, false, false, true)
    Trinket2 = Item(14, false, false, true)
    ArcaneTorrent = Spell(232633, false, false, true)
    Berserking = Spell(26297, false, false, true)
    BloodFury = Spell(33702, false, false, true)
    GiftOfTheNaaru = Spell(59544, false, false, true)
    AngelicFeather = Spell(121536, false, false, true)
    AngelicFeatherBuff = Spell(121557, false, false, true)
    Atonement = Spell(194384, false, false, true)
    Barrier = Spell(62618, false, false, true)
    BodyAndSoul = Spell(64129)
    BodyAndSoulBuff = Spell(65081)
    ClarityOfWill = Spell(152118, false, false, false)
    DispelMagic = Spell(528, false, false, true)
    DivineStar = Spell(110744, true, false, true)
    Evangelism = Spell(246287, false, false, true)
    Fade = Spell(586, false, false, true)
    Halo = Spell(120517, false, false, true)
    Innervate = Spell(29166)
    LightsWrath = Spell(207946, true, true, false)
    MassDispel = Spell(32375, false, false, true)
    Mindbender = Spell(123040, false, true, true)
    Pain = Spell(589, false, true, true)
    PainSuppression = Spell(33206, false, false, true)
    PenanceDamage = Spell(47540, true, true, true)
    PenanceHeal = Spell(47540, false, false, true)
    Plea = Spell(200829, false, false, true)
    PowerInfusion = Spell(10060, false, false, true)
    Purify = Spell(527, false, false, true)
    PurgeTheWicked = Spell(204197, true, true, true)
    PurgeTheWickedDebuff = Spell(204213, false, true, true)
    Radiance = Spell(194509, false, false, false)
    Rapture = Spell(47536, false, false, true)
    Resurrection = Spell(2006, false, false, false, true)
    Schism = Spell(214621, true, true, false)
    ShadowCovenant = Spell(204065, false, false, false)
    Shadowfiend = Spell(34433, true, true, true)
    ShadowMend = Spell(186263, false, false, true)
    Shield = Spell(17, false, false, true)
    ShieldDiscipline = Spell(197045)
    Smite = Spell(585, true, true, false)
    Solace = Spell(129250, true, true, true)
    ThePenitent = Spell(200347, false, false, true)
    AddPage("常规")
    AddPage("治愈")
    AddPage("大技能")
    AddPage("攻/防")
    AddCommonOptions()
    AddPresetOption("GeneralHealer")
    AddSection("常规", "移动", "Yellow")
    AddNewOption(
    "常规",
    "天堂之羽",
    220,
    true,
    { 1.5, 0, 10, 0.1 },
    nil,
    "Use Angelic Feather on player." ..
    C.TOOLTIP_VALUE .. "Time to wait when you start moving to use it.(In seconds)"
    )
    AddNewOption(
    "常规",
    "身心合一",
    220,
    true,
    { 1.5, 0, 10, 0.1 },
    nil,
    "Use Power Word: Shield on player for Body and Soul." ..
    C.TOOLTIP_VALUE .. "Time to wait when you start moving to use it.(In seconds)"
    )
    AddSection("治愈", "通用治疗参数", "Yellow")
    AddNewOption(
    "治愈",
    "交替 治疗与伤害",
    220,
    true,
    { 1, 0, 5, 1 },
    nil,
    "Apply Atonements and heal alternatively. Set the value to how many atonement you want to use before going back to doing damage."
    )
    AddNewOption(
    "治愈",
    "救赎",
    222,
    true,
    { 95, 0, 100, 1 },
    { 95, 0, 100, 1 },
    "Apply Atonement using Power Word: Shield, Plea and Power Word: Radiance." ..
    C.TOOLTIP_VALUE_1 ..
    "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid."
    )
    AddNewOption(
    "治愈",
    "救赎 恳求",
    222,
    true,
    { 5, 1, 10, 1 },
    { 40, 0, 100, 1 },
    "Apply Atonement using Plea." ..
    C.TOOLTIP_VALUE_1 ..
    "Maximum Atonements before we avoid using Plea as it becomes too expensive." ..
    C.TOOLTIP_VALUE_2 .. "Threshold to use Plea regardless of Atonement count."
    )
    AddNewOption(
    "治愈",
    "意志洞悉",
    222,
    true,
    { 200, 0, 400, 1 },
    { 30, 0, 100, 1 },
    "Apply Clarity of Will on the tanking tanks." ..
    C.TOOLTIP_VALUE_1 .. "Maximum Overshield." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid."
    )
    AddNewOption(
    "治愈",
    "神圣之星",
    222,
    true,
    { 3, 1, 25, 1 },
    { 90, 0, 100, 1 },
    "Use Divine Star." ..
    C.TOOLTIP_VALUE_1 ..
    "Amount of units that needs to be under threshold." ..
    C.TOOLTIP_VALUE_2 .. "Threshold health under which the units must be."
    )
    if GiftOfTheNaaru:Exists() then
        AddNewOption(
        "治愈",
        "纳鲁的赐福",
        222,
        true,
        { 40, 0, 100, 1 },
        { 25, 0, 100, 1 },
        "Use Gift Of The Naaru." ..
        C.TOOLTIP_VALUE_1 ..
        "Threshold to use on the Tanks." ..
        C.TOOLTIP_VALUE_2 ..
        "Threshold to use on the Raid." .. C.TOOLTIP_HINT("Requires The Penitent talent.")
        )
    end
    AddNewOption(
    "治愈",
    "光晕",
    222,
    true,
    { 5, 1, 25, 1 },
    { 90, 0, 100, 1 },
    "Use Halo." ..
    C.TOOLTIP_VALUE_1 ..
    "Amount of units that needs to be under threshold." ..
    C.TOOLTIP_VALUE_2 .. "Threshold health under which the units must be."
    )
    AddNewOption(
    "治愈",
    "苦修 治疗",
    222,
    true,
    { 60, 0, 100, 1 },
    { 40, 0, 100, 1 },
    "Use Penance to heal." ..
    C.TOOLTIP_VALUE_1 ..
    "Threshold to use on the Tanks." ..
    C.TOOLTIP_VALUE_2 ..
    "Threshold to use on the Raid." .. C.TOOLTIP_HINT("Requires The Penitent talent.")
    )
    AddNewOption(
    "治愈",
    "真言术：耀",
    222,
    true,
    { 3, 1, 25, 1 },
    { 70, 0, 100, 1 },
    "Use Power Word: Radiance." ..
    C.TOOLTIP_VALUE_1 ..
    "Amount of units that needs to be under threshold." ..
    C.TOOLTIP_VALUE_2 .. "Threshold health under which the units must be."
    )
    AddNewOption(
    "治愈",
    "暗影盟约",
    222,
    true,
    { 4, 1, 25, 1 },
    { 85, 0, 100, 1 },
    "Use Shadow Covenant." ..
    C.TOOLTIP_VALUE_1 ..
    "Amount of units that needs to be under threshold." ..
    C.TOOLTIP_VALUE_2 .. "Threshold health under which the units must be."
    )
    AddNewOption(
    "治愈",
    "暗影愈合",
    222,
    true,
    { 65, 0, 100, 1 },
    { 50, 0, 100, 1 },
    "Use Shadow Mend as low priority." ..
    C.TOOLTIP_VALUE_1 ..
    "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid."
    )
    AddNewOption(
    "治愈",
    "暗影愈合 紧急",
    222,
    true,
    { 35, 0, 100, 1 },
    { 25, 0, 100, 1 },
    "Use Shadow Mend." ..
    C.TOOLTIP_VALUE_1 ..
    "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid."
    )
    AddSection("治愈", "主动治疗", "Yellow")
    AddNewOption(
    "治愈",
    "治疗目标",
    220,
    true,
    { 1, 1, 2, 1 },
    nil,
    "Heal our current target if it is listed to be healed. Define Healing mode: 1-Known Units/2-Any Target"
    )
    AddNewOption(
    "治愈",
    "Debuff",
    220,
    true,
    { 90, 0, 100, 1 },
    nil,
    "Manage Debuffed units" .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddNewOption(
    "治愈",
    "Expiration",
    220,
    true,
    { 90, 0, 100, 1 },
    nil,
    "Help units that have debuffs that explode on expiration to survive" .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddNewOption(
    "治愈",
    "智能上盾",
    220,
    true,
    { 80, 0, 100, 1 },
    nil,
    "Use Shield on Debuffs that prevent healing on units under specified value" ..
    C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddNewOption(
    "治愈",
    "速度",
    220,
    true,
    { 100, 0, 100, 1 },
    nil,
    "Buff players so that they can run quicker" .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddNewOption(
    "治愈",
    "坦克",
    220,
    true,
    { 40, 0, 100, 1 },
    nil,
    "Buff/Save tanks that have important debuffs" .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddNewOption(
    "治愈",
    "Topping",
    220,
    true,
    { 95, 0, 100, 1 },
    nil,
    "Top players to 100 hp to remove bad debuffs" .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddSection("大技能", "大技能", "Yellow")
    AddNewOption(
    "大技能",
    "福音",
    222,
    true,
    { 4, 1, 20, 1 },
    { 80, 0, 100, 1 },
    "Use when selected number of units with Atonement are under health threshold." ..
    C.TOOLTIP_VALUE_1 .. "Number of Units." .. C.TOOLTIP_VALUE_2 .. "Health threshold."
    )
    AddNewOption(
    "大技能",
    "痛苦压制",
    222,
    true,
    { 30, 0, 100, 1 },
    { 15, 0, 100, 1 },
    "Use Pain Suppression." ..
    C.TOOLTIP_VALUE_1 ..
    "Health threshold to use on Tanks." ..
    C.TOOLTIP_VALUE_2 .. "Health threshold to use on any Raid members."
    )
    AddNewOption(
    "大技能",
    "能量灌注",
    222,
    true,
    { 3, 1, 25, 1 },
    { 50, 0, 100, 1 },
    "Use Power Infusion." ..
    C.TOOLTIP_VALUE_1 ..
    "Amount of units that needs to be under threshold." ..
    C.TOOLTIP_VALUE_2 .. "Threshold health under which the units must be."
    )
    AddNewOption(
    "大技能",
    "真言术：障",
    222,
    true,
    { 3, 1, 25, 1 },
    { 40, 0, 100, 1 },
    "Use Power Word: Barrier." ..
    C.TOOLTIP_VALUE_1 ..
    "Amount of units that needs to be under threshold." ..
    C.TOOLTIP_VALUE_2 .. "Threshold health under which the units must be."
    )
    AddNewOption(
    "大技能",
    "全神贯注",
    222,
    true,
    { 4, 1, 25, 1 },
    { 60, 1, 100, 1 },
    "Use Rapture." ..
    C.TOOLTIP_VALUE_1 ..
    "Amount of units that needs to be under threshold." ..
    C.TOOLTIP_VALUE_2 .. "Threshold health under which the units must be."
    )
    AddNewOption(
    "大技能",
    "全神贯注护盾周期",
    233,
    true,
    { 1, "禁用", "启用" },
    { 1, "禁用", "启用" },
    "Apply Atonement via Power Word: Shield to as many units as we can during Rapture." ..
    C.TOOLTIP_VALUE_1 ..
    "Choose if you want to use Rapture cycle when we got Innervate from a Druid." ..
    C.TOOLTIP_VALUE_2 .. "Systematically use Schism and Light's Wrath after a Rapture Cycle."
    )
    AddNewOption(
    "攻/防",
    "优先DPS目标",
    210,
    true,
    nil,
    nil,
    "Find the most appropriate unit to cast on. Priority will be on the Schism unit. It will also find any unit with Purge the Wicked for Penance if the Best Target and Schism unit does not have it."
    )
    AddSection("攻/防", "伤害输出", "Yellow")
    AddNewOption(
    "攻/防",
    "Damage For Healing",
    222,
    true,
    { 80, 0, 100, 1 },
    { 100, 0, 100, 1 },
    C.TOOLTIP_VALUE_1 ..
    "Keep doing damage regardless of Lowest health threshold as long as our mana is above this threshold." ..
    C.TOOLTIP_VALUE_2 ..
    "Only use damaging abilities when the Lowest unit's health is under this threshold. Set this roughly the same as Plea threshold to avoid doing damaging abilities when it is not needed and save mana for when it is really needed."
    )
    AddNewOption(
    "攻/防",
    "神圣之星 输出",
    220,
    true,
    { 3, 1, 25, 1 },
    nil,
    "Use Divine Star." ..
    C.TOOLTIP_VALUE ..
    "Amount of enemies that needs to be in the effect area." ..
    C.TOOLTIP_HINT(
    "The calculation will also include enemies and also units that need healing from the Healing counterpart options."
    )
    )
    AddNewOption(
    "攻/防",
    "光晕 输出",
    220,
    true,
    { 3, 1, 25, 1 },
    nil,
    "Use Halo." ..
    C.TOOLTIP_VALUE ..
    "Amount of enemies that needs to be in the effect area." ..
    C.TOOLTIP_HINT(
    "The calculation will also include enemies and also units that need healing from the Healing counterpart options."
    )
    )
    AddNewOption("攻/防", "苦修", 210, true, nil, nil, "Use Penance in the DPS rotation.")
    AddNewOption("攻/防", "真言术：慰", 210, true, { 1, "高", "正常" }, { 80, 1, 100, 1 }, "Use Power Word: Solace.")
    AddNewOption("攻/防", "净化邪恶", 210, true, nil, nil, "Use Purge The Wicked in the DPS rotation.")
    AddNewOption("攻/防", "教派分歧", 210, true, nil, nil, "Use Schism in the DPS rotation.")
    AddNewOption("攻/防", "暗言术：痛", 210, true, nil, nil, "Use Shadow Word: Pain in the DPS rotation.")
    AddNewOption("攻/防", "惩击", 210, true, nil, nil, "Use Smite in the DPS rotation.")
    AddSection("攻/防", "大技能", "Yellow")
    AddNewOption(
    "攻/防",
    "圣光之怒",
    222,
    true,
    { 3, 1, 15, 1 },
    { 80, 0, 100, 1 },
    "Use Light's Wrath." ..
    C.TOOLTIP_VALUE_1 ..
    "Amount of units that needs to be under threshold." ..
    C.TOOLTIP_VALUE_2 .. "Threshold health under which the units must be."
    )
    AddNewOption(
    "攻/防",
    "对坦克施放圣光之怒",
    222,
    true,
    { 1, 1, 5, 1 },
    { 80, 0, 100, 1 },
    "Use Light's Wrath to save the Tanks." ..
    C.TOOLTIP_VALUE_1 ..
    "Minimum amount of Atoned Units." ..
    C.TOOLTIP_VALUE_2 .. "Threshold health under which the Tank must be."
    )
    AddNewOption("攻/防", "摧心魔", 220, true, { 80, 0, 100, 1 }, nil, "Mana treshold to use Mindbender.")
    AddNewOption(
    "攻/防",
    "暗影魔",
    222,
    true,
    { 3, 1, 25, 1 },
    { 80, 0, 100, 1 },
    "Use Shadowfiend." ..
    C.TOOLTIP_VALUE_1 ..
    "Amount of units that needs to be under threshold." ..
    C.TOOLTIP_VALUE_2 .. "Threshold health under which the units must be."
    )
    AddSection("攻/防", "防御", "Yellow")
    AddNewOption(
    "攻/防",
    "治疗物品",
    220,
    true,
    { 35, 1, 95, 1 },
    nil,
    "Use Healing Belt / Healing Pot / Healthstone." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddNewOption(
    "攻/防",
    "渐隐术",
    220,
    true,
    { 50, 1, 100, 1 },
    nil,
    "Use Divine Protection." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddOutput("|cFF9A2EFE主T:")
    AddOutput("|cFF9A2EFE副T:")
    AddOutput("|cFF9A2EFE最低:")
    AddOutput("|cFF9A2EFE有害效果:")
    SetOutput("|cFF9A2EFE有害效果:", 0)
    AddOutput("|cFFFFDE73救赎:")
    SetOutput("|cFFFFDE73救赎:", 0)
    ISCL = {[ClarityOfWill:ID()] = "Clarity of Will", [ShadowMend:ID()] = "暗影愈合", [ShadowCovenant:ID()] = "暗影盟约" }
    self.LightsWrathAfterRapture = 0
    self.AlternateDamage = 0
    RegisterCommand(
    "testcancelbymacro",
    function()
        if CancelByMacro then
            CancelByMacro = false
            print("Disabled Cancel by macro after using Core Cast")
        else
            CancelByMacro = true
            print("Enabled Cancel by macro after using Core Cast")
        end
    end
    )
    RegisterCommand(
    "testwithmacro",
    function()
        if TestWithMacro then
            TestWithMacro = false
            print("Disabled Using direct macros")
        else
            TestWithMacro = true
            print("Enabled Using direct macros")
        end
    end
    )
end
function Rotation:Events()
end
function Rotation:Pulse()
    if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
        return
    end
    if BMPullTime() < 5 then
        self:Opening()
        return
    end
    if GetTime() < Rotation.SpamPrevention then
        return
    end
    Rotation.SpamPrevention = GetTime() + 0.05
    Target = Unit.Target
    local InCombat = Player:IsInCombat()
    Rotations:RefreshUnitTables(Rotation.Identifier)
    if not InCombat then
        SetOutput("|cFF9A2EFE有害效果:", 0)
        self:OutOfCombat()
        return
    end
    if InCombat then
        self:Defensives()
    end
    Target = Player:ReTarget(Smite, false) or Unit.Target
    self:Interrupts()
    self:OffGCDAbilities()
    if Player:GlobalCooldown() == 0 then
        self:Combat()
    end
end
function Rotation:Opening()
    Player:UsePotions("智力药水", GetSecondOptionValue("抢先使用药水"))
    if
    Target:Exists() and IsOptionEnabled("抢先施放(需DBM插件)") and
    (GetOptionValue("抢先施放(需DBM插件)") == "无条件使用" or
    (GetOptionValue("抢先施放(需DBM插件)") == "打BOSS使用" and Target:IsBoss()))
    then
        if Smite:Exists() and BMPullTime() < GetSecondOptionValue("抢先施放(需DBM插件)") and Target:CanCast(Smite) then
            Target:Cast(Smite)
            return
        end
    end
end
function Rotation:Interrupts()
    Player:UseInterrupt(nil, ArcaneTorrent)
end
function Rotation:OffGCDAbilities()
    if IsOptionEnabled("延时之力药水") and ProlongedPowerUnitsCount >= GetOptionValue("延时之力药水") then
        Player:UsePotions("延时之力药水")
    end
    Player:UsePotions(GetOptionValue("使用法力药水"))
end
function Rotation:Defensives()
    Player:UseHealingItem()
    if GetNumGroupMembers() >= 2 then
        if IsOptionEnabled("渐隐术") and Player:ThreatSituation() == 3 and Player:CanCast(Fade) then
            Player:Cast(Fade)
            return
        end
    else
        if Shield:Exists() and Player:SpecialHealthPercentage() <= 80 and Player:CanCast(Shield) then
            Player:Cast(Shield)
            return
        end
    end
end
Rotation.TanksStatus, Rotation.MainTankTanking, Rotation.OffTankTanking = {
    Main = { IsTanking = GetTime() },
    Off = { IsTanking = GetTime() }
}
function Rotation:RefreshTanksStatus()
    self.TanksStatus = {
        Main = {
            IsTanking = MainTank and MainTank:ThreatSituation() == 3 and GetTime() or self.TanksStatus.Main.IsTanking
        },
        Off = { IsTanking = OffTank and OffTank:ThreatSituation() == 3 and GetTime() or self.TanksStatus.Off.IsTanking }
    }
    self.MainTankTanking = GetTime() - self.TanksStatus.Main.IsTanking < 3 or false
    self.OffTankTanking = GetTime() - self.TanksStatus.Off.IsTanking < 3 or false
end
function Rotation:HealTarget(ThisUnit)
    if ThePenitent:Exists() and ThisUnit:CanCast(PenanceHeal) then
        ThisUnit:Cast(PenanceHeal)
        return
    end
    if not Player:IsMoving() and ThisUnit:CanCast(ShadowMend) then
        ThisUnit:Cast(ShadowMend)
        return
    end
    if ThisUnit:CanCast(Shield) then
        ThisUnit:Cast(Shield)
        return
    end
end
function Rotation:Overshield()
    if ClarityOfWill:Exists() and not Player:IsMoving() and IsOptionEnabled("意志洞悉") then
        self.OvershieldUnits = { MainTank, OffTank }
        for i = 1, #self.OvershieldUnits do
            local ThisUnit = self.OvershieldUnits[i]
            if
            ThisUnit and ThisUnit:CanCast(ClarityOfWill) and
            (not ThisUnit:Buff(ClarityOfWill) or
            (ThisUnit:Buff(ClarityOfWill) and
            ((GetNumbersForBuff(ThisUnit, ClarityOfWill)[1] * 1 < GetOptionValue("意志洞悉") * 1000 and
            GetNumbersForBuff(ThisUnit, ClarityOfWill)[1] * 1 < ThisUnit:MaxHealth() / 2.5) or
            ThisUnit:BuffRemains(ClarityOfWill) < 4.5)))
            then
                ThisUnit:Cast(ClarityOfWill)
                return
            end
        end
    end
end
function Rotation:DPSHandler(Comment)
    self.AlternateDamage = 0
    if
    Player:ManaPercentage() >= GetOptionValue("Damage For Healing") and
    (Lowest and Lowest:HealthPercentage() <= GetSecondOptionValue("Damage For Healing")) or
    (CurrentBadDebuffs and #CurrentBadDebuffs.Top > 0)
    then
        if
        DivineStar:Exists() and IsOptionEnabled("神圣之星 输出") and
        DivineStarEnemies + DivineStarUnits >= GetOptionValue("神圣之星 输出") and
        Player:CanCast(DivineStar)
        then
            Bug("DPS - Divine Star " .. Comment)
            Player:Cast(DivineStar)
            return
        end
        if
        Halo:Exists() and IsOptionEnabled("光晕 输出") and HaloEnemies + HaloUnits >= GetOptionValue("光晕 输出") and
        Player:CanCast(Halo)
        then
            Bug("DPS - Halo " .. Comment)
            Player:Cast(Halo)
            return
        end
        if Schism:Exists() and IsOptionEnabled("教派分歧") and BestTarget:CanCast(Schism) then
            Bug("DPS - Schism " .. Comment)
            BestTarget:Cast(Schism)
            return
        end
        if Solace:Exists() and IsOptionEnabled("真言术：慰") and BestTarget:CanCast(Solace) then
            Bug("DPS - Solace " .. Comment)
            BestTarget:Cast(Solace)
            return
        end
        if
        not PurgeTheWicked:Exists() and Pain:Exists() and IsOptionEnabled("暗言术：痛") and
        BestTarget:DebuffRemains(Pain) < 5.4 and
        BestTarget:TimeToDie() > 8 and
        BestTarget:CanCast(Pain)
        then
            Bug("DPS - Shadow Word: Pain " .. Comment)
            BestTarget:Cast(Pain)
            return
        end
        if PurgeTheWicked:Exists() and IsOptionEnabled("净化邪恶") then
            if not (BestPenanceUnit and BestPenanceUnit:Debuff(PurgeTheWickedDebuff)) then
                if not BestTarget:Debuff(PurgeTheWickedDebuff) and BestTarget:CanCast(PurgeTheWicked) then
                    Bug("DPS - Purge The Wicked " .. Comment)
                    BestTarget:Cast(PurgeTheWicked)
                    return
                end
            end
        end
        if PenanceDamage:Exists() and IsOptionEnabled("苦修") and BestTarget:CanCast(PenanceDamage) then
            if BestDPSUnit and BestDPSUnit:Debuff(Schism) and BestDPSUnit:CanCast(PenanceDamage) then
                Bug("DPS - Penance Damage on Schism Unit with Purge the Wicked " .. Comment)
                BestDPSUnit:Cast(PenanceDamage)
                return
            elseif BestPenanceUnit and BestPenanceUnit:CanCast(PenanceDamage) then
                Bug("DPS - Penance Damage on Purge the Wicked Unit" .. Comment)
                BestPenanceUnit:Cast(PenanceDamage)
                return
            elseif BestTarget and BestTarget:CanCast(PenanceDamage) then
                Bug("DPS - Penance Damage on Best Target" .. Comment)
                BestTarget:Cast(PenanceDamage)
                return
            end
        end
        if Smite:Exists() and IsOptionEnabled("惩击") and BestTarget:CanCast(Smite) then
            Bug("DPS - Smite " .. Comment)
            BestTarget:Cast(Smite)
            return
        end
    end
end
function Rotation:AngelicFeatherHandler()
    if TestWithMacro then
        RunMacroText("/cast [@player] " .. AngelicFeather:Name())
        RunMacroText("/stopspelltarget")
        Bug("Casted Angelic Feather using Test Macro")
    else
        Player:Cast(AngelicFeather)
        return
    end
end
function Rotation:UnitTables()
    HealUnits = Player:HealUnitsAround(100, 40)
    CurrentBadDebuffs = Player:GetRaidDebuffs(HealUnits)
    if CurrentBadDebuffs ~= nil then
        SetOutput("|cFF9A2EFE有害效果:", #CurrentBadDebuffs.Top + #CurrentBadDebuffs.Debuff)
    end
    DispelUnit = Unit.Dispel(HealUnits, Purify)
    MainTank, MainTankTarget, OffTank, OffTankTarget = Unit.GetMainTanks()
    self:RefreshTanksStatus()
    Lowest = Unit.Lowest(HealUnits)
    SetOutput("|cFF9A2EFE最低:", Lowest and Lowest:Name() or "")
    Trinket1Units =     IsOptionEnabled("使用饰品 1") and Trinket1:IsUsableInventory() and
    #Player:HealUnitsAround(GetSecondOptionValue("使用饰品 1"), 40) or
    0
    Trinket2Units =     IsOptionEnabled("使用饰品 2") and Trinket2:IsUsableInventory() and
    #Player:HealUnitsAround(GetSecondOptionValue("使用饰品 2"), 40) or
    0
    RacialsUnits =     IsOptionEnabled("使用种族技能") and
    ((Berserking:Exists() and Player:CanCast(Berserking)) or (BloodFury:Exists() and Player:CanCast(BloodFury))) and
    #Player:HealUnitsAround(GetOptionValue("使用种族技能"), 40) or
    0
    ProlongedPowerUnitsCount =     IsOptionEnabled("延时之力药水") and #Player:HealUnitsAround(GetSecondOptionValue("延时之力药水"), 40) or 0
    DivineStarEnemies = DivineStar:Exists() and #Player:UnitsInFrontRectangle(24, 5) or 0
    DivineStarUnits =     DivineStar:Exists() and #Player:UnitsInFrontRectangle(24, 5, true, GetSecondOptionValue("神圣之星")) or 0
    HaloEnemies = #Player:EnemiesWithinDistance(30, true)
    HaloUnits = Halo:Exists() and #Player:HealUnitsAround(GetSecondOptionValue("光晕"), 30) or 0
    PowerInfusionUnits = PowerInfusion:Exists() and #Player:HealUnitsAround(GetSecondOptionValue("能量灌注"), 40) or 0
    RaptureUnits =     Rapture:Exists() and IsOptionEnabled("全神贯注") and #Player:HealUnitsAround(GetSecondOptionValue("全神贯注"), 40) or 0
    ShadowCovenantUnit =     ShadowCovenant:Exists() and IsOptionEnabled("暗影盟约") and Player:CanCast(ShadowCovenant) and
    Player:BestClusterOfAlliesToHeal(GetOptionValue("暗影盟约"), GetSecondOptionValue("暗影盟约"), 30) or
    nil
    ShadowfiendUnits = not Mindbender:Exists() and #Player:HealUnitsAround(GetSecondOptionValue("暗影魔"), 40) or 0
    AtonementBuffUnits = Player:UnitsWithBuff(HealUnits, Atonement, 0.1)
    AtonementUnits = #AtonementBuffUnits
    SetOutput("|cFFFFDE73救赎:", AtonementUnits)
    EvangelismUnits =     Evangelism:Exists() and IsOptionEnabled("福音") and
    #Player:UnitsWithBuff(AtonementBuffUnits, Atonement, 0.1, GetSecondOptionValue("福音")) or
    0
    BarrierUnit =     Barrier:Exists() and IsOptionEnabled("真言术：障") and not Barrier:IsOnCooldown() and
    Player:BestClusterOfAlliesToHeal(GetOptionValue("真言术：障"), GetSecondOptionValue("真言术：障"), 13) or
    nil
    if IsOptionEnabled("优先DPS目标") then
        Enemies_40y = Player:EnemiesWithinDistance(40, true)
        BestPenanceUnit, BestPenanceUnitRemains, BestDPSUnit = nil, 1, nil
        for i = 1, #Enemies_40y do
            ThisUnit = Enemies_40y[i]
            if ThisUnit:DebuffRemains(PurgeTheWickedDebuff) > BestPenanceUnitRemains and ThisUnit:CanCast(PenanceDamage) then
                BestPenanceUnit, BestPenanceUnitRemains = ThisUnit, ThisUnit:DebuffRemains(PurgeTheWickedDebuff)
            end
            if ThisUnit:DebuffRemains(Schism) and ThisUnit:CanCast(Smite) then
                BestDPSUnit = ThisUnit
            end
        end
    end
end
function Rotation:Combat()
    if IsOptionEnabled("优先DPS目标") and BestDPSUnit ~= nil and BestDPSUnit:CanCast(Smite) then
        BestTarget = BestDPSUnit
    elseif Target:Exists() and Target:CanCast(Smite) then
        BestTarget = Target
    elseif MainTankTarget and MainTankTarget:CanCast(Smite) then
        BestTarget = MainTankTarget
    elseif OffTankTarget and OffTankTarget:CanCast(Smite) then
        BestTarget = OffTankTarget
    elseif Mouseover:Exists() and Mouseover:CanCast(Smite) then
        BestTarget = Mouseover
    else
        BestTarget = Target
    end
    if Player:IsInCombat() or GetOptionValue("脱离战斗后暂停治疗") == "启用" then
        if CurrentBadDebuffs ~= nil then
            Player:DispelHandler(Purify, "驱散", DispelUnit, CurrentBadDebuffs.Dispel, "高")
        end
        if Player:IsInCombat() and CooldownsAllowed() then
            if IsOptionEnabled("使用种族技能") then
                if RacialsUnits >= GetOptionValue("使用种族技能和饰品的单位数量") then
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury)
                        return
                    end
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        CastSpellByID(26297, "player")
                        return
                    end
                end
                if
                ArcaneTorrent:Exists() and Player:PowerPercentage() < GetOptionValue("使用种族技能") and
                Player:CanCast(ArcaneTorrent)
                then
                    Player:Cast(ArcaneTorrent)
                    return
                end
            end
            if IsOptionEnabled("使用饰品 1") and Trinket1:IsUsableInventory() then
                Option1, Option2 = GetOptionValue("使用饰品 1"), GetSecondOptionValue("使用饰品 1")
                if
                Option1 == "无条件使用" or (Option1 == "血量" and Trinket1Units >= GetOptionValue("使用种族技能和饰品的单位数量")) or
                (Option1 == "蓝量" and Player:PowerPercentage() < GetSecondOptionValue("使用饰品 1"))
                then
                    Trinket1:UseInventory()
                end
            end
            if IsOptionEnabled("使用饰品 2") and Trinket2:IsUsableInventory() then
                Option1, Option2 = GetOptionValue("使用饰品 2"), GetSecondOptionValue("使用饰品 2")
                if
                Option1 == "无条件使用" or (Option1 == "血量" and Trinket2Units >= GetOptionValue("使用种族技能和饰品的单位数量")) or
                (Option1 == "蓝量" and Player:PowerPercentage() < GetSecondOptionValue("使用饰品 2"))
                then
                    Trinket2:UseInventory()
                end
            end
            if
            Evangelism:Exists() and IsOptionEnabled("福音") and EvangelismUnits >= GetOptionValue("福音") and
            Player:CanCast(Evangelism)
            then
                Player:Cast(Evangelism)
                return
            end
            if
            PowerInfusion:Exists() and IsOptionEnabled("能量灌注") and PowerInfusionUnits >= GetOptionValue("能量灌注") and
            Player:CanCast(PowerInfusion)
            then
                Player:Cast(PowerInfusion)
            end
            if GiftOfTheNaaru:Exists() then
                if IsOptionEnabled("纳鲁的赐福") and GiftOfTheNaaru:Exists() then
                    if
                    MainTank and MainTank:SpecialHealthPercentage() <= GetOptionValue("纳鲁的赐福") and
                    MainTank:CanCast(GiftOfTheNaaru)
                    then
                        MainTank:Cast(GiftOfTheNaaru)
                        return
                    end
                    if
                    OffTank and OffTank:SpecialHealthPercentage() <= GetOptionValue("纳鲁的赐福") and
                    OffTank:CanCast(GiftOfTheNaaru)
                    then
                        OffTank:Cast(GiftOfTheNaaru)
                        return
                    end
                    if
                    Lowest and Lowest:SpecialHealthPercentage() <= GetSecondOptionValue("纳鲁的赐福") and
                    Lowest:CanCast(GiftOfTheNaaru)
                    then
                        Lowest:Cast(GiftOfTheNaaru)
                        return
                    end
                end
            end
            if PainSuppression:Exists() and IsOptionEnabled("痛苦压制") then
                if
                MainTank and MainTank:SpecialHealthPercentage() <= GetOptionValue("痛苦压制") and
                MainTank:CanCast(PainSuppression)
                then
                    MainTank:Cast(PainSuppression)
                    return
                end
                if
                OffTank and OffTank:SpecialHealthPercentage() <= GetOptionValue("痛苦压制") and
                OffTank:CanCast(PainSuppression)
                then
                    OffTank:Cast(PainSuppression)
                    return
                end
                if
                Lowest and Lowest:SpecialHealthPercentage() <= GetSecondOptionValue("痛苦压制") and
                Lowest:CanCast(PainSuppression)
                then
                    Lowest:Cast(PainSuppression)
                    return
                end
            end
            if
            not Mindbender:Exists() and IsOptionEnabled("暗影魔") and BestTarget:Exists() and
            BestTarget:CanCast(Shadowfiend) and
            BestTarget:TimeToDie() > 12 and
            ShadowfiendUnits >= GetOptionValue("暗影魔")
            then
                BestTarget:Cast(Shadowfiend)
                return
            end
            if
            Rapture:Exists() and
            ((GetOptionValue("全神贯注护盾周期") == "启用" and Player:BuffAny(Innervate)) or
            RaptureUnits >= GetOptionValue("全神贯注")) and
            Player:CanCast(Rapture)
            then
                Player:Cast(Rapture)
                return
            end
        end
    end
    if Player:IsInCombat() or GetOptionValue("脱离战斗后暂停治疗") == "启用" then
        if self.LightsWrathAfterRapture ~= 0 and self.LightsWrathAfterRapture < GetTime() and not Player:Buff(Rapture) then
            if Schism:Exists() and BestTarget:CanCast(Schism) then
                Bug("Schism after Rapture")
                BestTarget:Cast(Schism)
                return
            end
            if LightsWrath:Exists() and BestTarget:CanCast(LightsWrath) then
                Bug("Light's Wrath after Rapture")
                BestTarget:Cast(LightsWrath)
                return
            end
            self.LightsWrathAfterRapture = 0
        end
        if Rapture:Exists() and Player:Buff(Rapture) and IsOptionEnabled("全神贯注护盾周期") then
            self.LightsWrathAfterRapture = GetSecondOptionValue("全神贯注护盾周期") == "启用" and GetTime() + 2 or 0
            if MainTank and not MainTank:Buff(Atonement) and MainTank:CanCast(Shield) then
                MainTank:Cast(Shield)
                return
            end
            if OffTank and not OffTank:Buff(Atonement) and OffTank:CanCast(Shield) then
                OffTank:Cast(Shield)
                return
            end
            BestUnit, BestUnitHealth = nil, 100
            for i = 1, #HealUnits do
                ThisUnit, ThisUnitHealth = HealUnits[i], HealUnits[i]:SpecialHealthPercentage()
                if not ThisUnit:Buff(Atonement) and ThisUnit:CanCast(Shield) then
                    if not BestUnit or ThisUnitHealth < BestUnitHealth then
                        BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth
                    end
                end
            end
            if BestUnit then
                Bug("Power Word: Shield on " .. BestUnit:Name() .. " via Rapture Cycle.")
                BestUnit:Cast(Shield)
                return
            end
        end
        if CurrentBadDebuffs ~= nil then
            Player:DispelHandler(Purify, "驱散", DispelUnit, CurrentBadDebuffs.Dispel, "正常")
        end
        if
        Target:CanCast(ShadowMend) and IsOptionEnabled("治疗目标") and
        (GetOptionValue("治疗目标") == 2 or
        (Target:ShouldBeHealed() ~= 0 and Target:HealthPercentage() < Target:ShouldBeHealed()))
        then
            self:HealTarget(Target)
            return
        end
    end
    if Player:IsInCombat() or GetSecondOptionValue("脱离战斗后暂停治疗") == "启用" then
        if
        Mindbender:Exists() and IsOptionEnabled("摧心魔") and Player:PowerPercentage() <= GetOptionValue("摧心魔") and
        BestTarget:Exists() and
        BestTarget:CanCast(Mindbender) and
        BestTarget:TimeToDie() > 12
        then
            BestTarget:Cast(Mindbender)
            return
        end
        if UnitExists("playerpet") and UnitName("playerpettarget") == nil and BestTarget:Exists() then
            RunMacroText("/petattack " .. BestTarget.UnitID)
        end
    end
    if
    AngelicFeather:Exists() and IsOptionEnabled("天堂之羽") and Player:Moving() > GetOptionValue("天堂之羽") and
    not IsFalling() and
    Player:BuffRemains(AngelicFeatherBuff) < 0.5 and
    Player:CanCast(AngelicFeather)
    then
        self:AngelicFeatherHandler()
    end
    if
    BodyAndSoul:Exists() and IsOptionEnabled("身心合一") and Player:Moving() > GetOptionValue("身心合一") and
    not Player:Buff(BodyAndSoulBuff) and
    Player:CanCast(Shield) and
    not Player:Buff(Shield)
    then
        Player:Cast(Shield)
        return
    end
    if Player:IsInCombat() or GetSecondOptionValue("脱离战斗后暂停治疗") == "启用" then
        if Halo:Exists() and IsOptionEnabled("光晕") and Player:CanCast(Halo) and HaloUnits >= GetOptionValue("光晕") then
            Player:Cast(Halo)
            return
        end
        if
        DivineStar:Exists() and IsOptionEnabled("神圣之星") and Player:CanCast(DivineStar) and
        DivineStarUnits >= GetOptionValue("神圣之星")
        then
            Player:Cast(DivineStar)
            return
        end
        if self.AlternateDamage >= GetOptionValue("交替 治疗与伤害") then
            self:DPSHandler("(Alternate Damage)")
        end
    end
    if Player:IsInCombat() or GetOptionValue("脱离战斗后暂停治疗") == "启用" then
        if
        IsOptionEnabled("Expiration") and CurrentBadDebuffs and #CurrentBadDebuffs.Expiration > 0 and
        not Shield:IsOnCooldown()
        then
            BestUnit, BestUnitHealth = nil, 100
            for i = 1, #CurrentBadDebuffs.Expiration do
                ThisUnit, ThisUnitHealth =                 CurrentBadDebuffs.Expiration[i],
                CurrentBadDebuffs.Expiration[i]:SpecialHealthPercentage()
                if
                ThisUnit:CanCast(Shield) and not ThisUnit:BuffAny(Shield) and
                (BestUnit == nil or ThisUnitHealth < BestUnitHealth)
                then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth
                end
            end
            if BestUnit ~= nil then
                if
                IsOptionEnabled("Expiration") and BestUnit:CanCast(Shield) and
                BestUnitHealth <= GetOptionValue("Expiration")
                then
                    BestUnit:Cast(Shield)
                    Bug("Power Word: Shield on " .. BestUnit:Name() .. " to mitigate expiring debuff")
                    return
                end
            end
        end
        if IsOptionEnabled("坦克") and CurrentBadDebuffs and #CurrentBadDebuffs.Tanks > 0 then
            BestUnit, BestUnitHealth = nil, 100
            BestShieldUnit, BestShieldUnitHealth = nil, 100
            for i = 1, #CurrentBadDebuffs.Tanks do
                ThisUnit, ThisUnitHealth =                 CurrentBadDebuffs.Tanks[i],
                CurrentBadDebuffs.Tanks[i]:SpecialHealthPercentage()
                if
                not ThisUnit:Buff(Atonement) and ThisUnit:CanCast(Plea) and
                (BestUnit == nil or ThisUnitHealth < BestUnitHealth)
                then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth
                end
            end
            if BestUnit ~= nil and BestUnitHealth <= GetOptionValue("坦克") then
                if BestUnit:CanCast(Shield) then
                    self.AlternateDamage = self.AlternateDamage + 1
                    BestUnit:Cast(Shield)
                    Bug("Power Word: Shield on " .. BestUnit:Name() .. " to apply Atonement on it (Tank Debuff)")
                    return
                end
                if not BestUnit:Buff(Atonement) and BestUnit:CanCast(Plea) then
                    self.AlternateDamage = self.AlternateDamage + 1
                    BestUnit:Cast(Plea)
                    Bug("Plea on " .. BestUnit:Name() .. " to apply Atonement on it (Tank Debuff)")
                    return
                end
            end
        end
        if IsOptionEnabled("Debuff") and CurrentBadDebuffs and #CurrentBadDebuffs.Debuff > 0 then
            BestUnit, BestUnitHealth = nil, 100
            BestShieldUnit, BestShieldUnitHealth = nil, 100
            for i = 1, #CurrentBadDebuffs.Debuff do
                ThisUnit, ThisUnitHealth =                 CurrentBadDebuffs.Debuff[i],
                CurrentBadDebuffs.Debuff[i]:SpecialHealthPercentage()
                if
                not ThisUnit:Buff(Atonement) and ThisUnit:CanCast(Plea) and
                (BestUnit == nil or ThisUnitHealth < BestUnitHealth)
                then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth
                end
            end
            if BestUnit ~= nil and BestUnitHealth <= GetOptionValue("Debuff") then
                if BestUnit:CanCast(Shield) then
                    self.AlternateDamage = self.AlternateDamage + 1
                    BestUnit:Cast(Shield)
                    Bug("Power Word: Shield on " .. BestUnit:Name() .. " to apply Atonement on it (Debuff)")
                    return
                end
                if not BestUnit:Buff(Atonement) and BestUnit:CanCast(Plea) then
                    self.AlternateDamage = self.AlternateDamage + 1
                    BestUnit:Cast(Plea)
                    Bug("Plea on " .. BestUnit:Name() .. " to apply Atonement on it (Debuff)")
                    return
                end
            end
        end
        if IsOptionEnabled("智能上盾") and CurrentBadDebuffs and #CurrentBadDebuffs.Shield > 0 and not Shield:IsOnCooldown() then
            BestUnit, BestUnitHealth = nil, 100
            for i = 1, #CurrentBadDebuffs.Shield do
                ThisUnit, ThisUnitHealth =                 CurrentBadDebuffs.Shield[i],
                CurrentBadDebuffs.Shield[i]:SpecialHealthPercentage()
                if ThisUnit:CanCast(Shield) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth
                end
            end
            if BestUnit ~= nil then
                if
                IsOptionEnabled("智能上盾") and not BestUnit:BuffAny(Shield) and BestUnit:CanCast(Shield) and
                BestUnitHealth <= GetOptionValue("智能上盾")
                then
                    self.AlternateDamage = self.AlternateDamage + 1
                    BestUnit:Cast(Shield)
                    Bug("Power Word: Shield on " .. BestUnit:Name() .. " as it have a healing immunity debuff")
                    return
                end
            end
        end
        if
        IsOptionEnabled("主动治疗") and IsOptionEnabled("速度") and CurrentBadDebuffs and #CurrentBadDebuffs.Speed > 0 and
        (BodyAndSoul:Exists() or AngelicFeather:Exists())
        then
            BestUnit, BestUnitHealth = nil, 100
            for i = 1, #CurrentBadDebuffs.Speed do
                ThisUnit, ThisUnitHealth =                 CurrentBadDebuffs.Speed[i],
                CurrentBadDebuffs.Speed[i]:SpecialHealthPercentage()
                if ThisUnit:CanCast(Shield) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth
                end
            end
            if BestUnit ~= nil then
                if BodyAndSoul:Exists() and BestUnit:CanCast(Shield) and BestUnitHealth <= GetOptionValue("速度") then
                    BestUnit:Cast(Shield)
                    Bug("Power Word: Shield on " .. BestUnit:Name() .. " to help it run away")
                    return
                end
                if
                AngelicFeather:Exists() and AngelicFeather:Charges() >= 1 and BestUnit:CanCast(AngelicFeather) and
                BestUnitHealth <= GetOptionValue("速度")
                then
                    BestUnit:Cast(AngelicFeather)
                    Bug("Angelic Feather on " .. BestUnit:Name() .. " to help it run away")
                    return
                end
            end
        end
        if IsOptionEnabled("主动治疗") and IsOptionEnabled("Topping") and CurrentBadDebuffs and #CurrentBadDebuffs.Top > 0 then
            BestUnit, BestUnitHealth = nil, 100
            BestShieldUnit, BestShieldUnitHealth = nil, 100
            for i = 1, #CurrentBadDebuffs.Top do
                ThisUnit, ThisUnitHealth = CurrentBadDebuffs.Top[i], CurrentBadDebuffs.Top[i]:SpecialHealthPercentage()
                if ThisUnit:CanCast(Plea) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth
                end
            end
            if BestUnit ~= nil and BestUnitHealth <= GetOptionValue("Topping") then
                if not BestUnit:Buff(Atonement) and BestUnit:CanCast(Shield) then
                    self.AlternateDamage = self.AlternateDamage + 1
                    BestUnit:Cast(Shield)
                    Bug("Power Word: Shield on on " .. BestUnit:Name() .. " to top it")
                    return
                end
                if not BestUnit:Buff(Atonement) and BestUnit:CanCast(Plea) then
                    self.AlternateDamage = self.AlternateDamage + 1
                    BestUnit:Cast(Plea)
                    Bug("Plea on " .. BestUnit:Name() .. " to top it")
                    return
                end
            end
        end
        if BarrierUnit and Player:CanCast(Barrier) then
            BarrierUnit:Cast(Barrier)
        end
        BestAtonementUnit, BestAtonementUnitHealth, RadianceUnits, LightsWrathUnits, AtonedUnits = nil, 100, 0, 0, 0
        for i = 1, #HealUnits do
            ThisUnit, ThisUnitHealth = HealUnits[i], HealUnits[i]:SpecialHealthPercentage()
            if ThisUnit:BuffRemains(Atonement) < 3 then
                if ThisUnit:CanCast(Plea) then
                    RadianceUnits =                     ThisUnit:SpecialHealthPercentage() < GetSecondOptionValue("真言术：耀") and RadianceUnits + 1 or
                    RadianceUnits
                    if (BestAtonementUnit == nil or ThisUnitHealth < BestAtonementUnitHealth) then
                        BestAtonementUnit, BestAtonementUnitHealth = ThisUnit, ThisUnitHealth
                    end
                end
            else
                AtonedUnits = AtonedUnits + 1
                if ThisUnit:SpecialHealthPercentage() <= GetSecondOptionValue("圣光之怒") then
                    LightsWrathUnits = LightsWrathUnits + 1
                end
            end
        end
    end
    if Player:IsInCombat() or GetSecondOptionValue("脱离战斗后暂停治疗") == "启用" then
        if LightsWrath:Exists() and BestTarget:TimeToDie() > 4 and BestTarget:CanCast(LightsWrath) then
            if IsOptionEnabled("圣光之怒") and LightsWrathUnits >= GetOptionValue("圣光之怒") then
                Bug("Light's Wrath for Raid")
                BestTarget:Cast(LightsWrath)
                return
            end
            if IsOptionEnabled("对坦克施放圣光之怒") then
                if
                MainTank and MainTank:SpecialHealthPercentage() < GetSecondOptionValue("对坦克施放圣光之怒") and
                AtonedUnits >= GetOptionValue("对坦克施放圣光之怒")
                then
                    Bug("Light's Wrath for Main Tank")
                    BestTarget:Cast(LightsWrath)
                    return
                end
                if
                OffTank and OffTank:SpecialHealthPercentage() < GetSecondOptionValue("对坦克施放圣光之怒") and
                AtonedUnits >= GetOptionValue("对坦克施放圣光之怒")
                then
                    Bug("Light's Wrath for Off Tank")
                    BestTarget:Cast(LightsWrath)
                    return
                end
            end
        end
    end
    if Player:IsInCombat() or GetOptionValue("脱离战斗后暂停治疗") == "启用" then
        if
        ShadowCovenant:Exists() and ShadowCovenantUnit and ShadowCovenantUnit:CanCast(ShadowCovenant) and
        ShadowCovenant:TimeSinceCast() >= 4
        then
            ShadowCovenantUnit:Cast(ShadowCovenant)
            ShadowCovenant.LastCastTime = GetTime()
            return
        end
        if ThePenitent:Exists() and PenanceHeal:Exists() and IsOptionEnabled("苦修 治疗") then
            if
            MainTank and MainTank:SpecialHealthPercentage() <= GetOptionValue("苦修 治疗") and
            MainTank:CanCast(PenanceHeal)
            then
                MainTank:Cast(PenanceHeal)
                return
            end
            if OffTank and OffTank:SpecialHealthPercentage() <= GetOptionValue("苦修 治疗") and OffTank:CanCast(PenanceHeal) then
                OffTank:Cast(PenanceHeal)
                return
            end
            if
            Lowest and Lowest:SpecialHealthPercentage() <= GetSecondOptionValue("苦修 治疗") and
            Lowest:CanCast(PenanceHeal)
            then
                Lowest:Cast(PenanceHeal)
                return
            end
        end
        if ShadowMend:Exists() and IsOptionEnabled("暗影愈合 紧急") then
            if
            MainTank and MainTank:SpecialHealthPercentage() <= GetOptionValue("暗影愈合 紧急") and
            MainTank:CanCast(ShadowMend)
            then
                MainTank:Cast(ShadowMend)
                return
            end
            if
            OffTank and OffTank:SpecialHealthPercentage() <= GetOptionValue("暗影愈合 紧急") and
            OffTank:CanCast(ShadowMend)
            then
                OffTank:Cast(ShadowMend)
                return
            end
            if
            Lowest and Lowest:SpecialHealthPercentage() <= GetSecondOptionValue("暗影愈合 紧急") and
            Lowest:CanCast(ShadowMend)
            then
                Lowest:Cast(ShadowMend)
                return
            end
        end
        if Shield:Exists() and Player:IsInCombat() and IsOptionEnabled("救赎") and not Shield:IsOnCooldown() then
            if ShieldDiscipline:Exists() then
                if MainTank and not MainTank:Buff(Shield) and self.MainTankTanking and MainTank:CanCast(Shield) then
                    self.AlternateDamage = self.AlternateDamage + 1
                    MainTank:Cast(Shield)
                    return
                end
                if OffTank and not OffTank:Buff(Shield) and self.OffTankTanking and OffTank:CanCast(Shield) then
                    self.AlternateDamage = self.AlternateDamage + 1
                    OffTank:Cast(Shield)
                    return
                end
            else
                BestTank =                 MainTank and (MainTank:SpecialHealthPercentage() < GetOptionValue("救赎") or self.MainTankTanking) and
                MainTank:BuffRemains(Shield) < 5 and
                MainTank:CanCast(Shield) and
                MainTank or
                OffTank and (OffTank:SpecialHealthPercentage() < GetOptionValue("救赎") or self.OffTankTanking) and
                OffTank:BuffRemains(Shield) < 5 and
                OffTank:CanCast(Shield) and
                OffTank
                if BestTank then
                    self.AlternateDamage = self.AlternateDamage + 1
                    BestTank:Cast(Shield)
                    return
                end
            end
            if
            MainTank == nil and OffTank == nil and Lowest and
            Lowest:SpecialHealthPercentage() < GetOptionValue("救赎") and
            not Lowest:Buff(Atonement) and
            Lowest:CanCast(Shield)
            then
                self.AlternateDamage = self.AlternateDamage + 1
                Lowest:Cast(Shield)
                return
            end
        end
        if
        Radiance:Exists() and IsOptionEnabled("真言术：耀") and RadianceUnits >= GetOptionValue("真言术：耀") and
        BestAtonementUnit and
        BestAtonementUnit:CanCast(Radiance)
        then
            self.AlternateDamage = self.AlternateDamage + 1
            Bug("Radiance - Atonement")
            BestAtonementUnit:Cast(Radiance)
            return
        end
        if BestAtonementUnit then
            if BestAtonementUnit:CanCast(Plea) then
                if
                (BestAtonementUnit:SpecialHealthPercentage() < GetOptionValue("救赎") or Player:Buff(Rapture)) and
                BestAtonementUnit:CanCast(Shield)
                then
                    self.AlternateDamage = self.AlternateDamage + 1
                    Bug("Power Word: Shield (Rapture) - Atonement")
                    BestAtonementUnit:Cast(Shield)
                    return
                elseif
                BestAtonementUnit:SpecialHealthPercentage() < GetOptionValue("救赎") and
                AtonementUnits < GetOptionValue("救赎 恳求")
                then
                    self.AlternateDamage = self.AlternateDamage + 1
                    Bug("Plea - Atonement")
                    BestAtonementUnit:Cast(Plea)
                    return
                end
            end
        end
        if ThePenitent:Exists() and PenanceHeal:Exists() and IsOptionEnabled("苦修 治疗") then
            if MainTank and MainTank:SpecialHealthPercentage() <= 80 and MainTank:CanCast(PenanceHeal) then
                MainTank:Cast(PenanceHeal)
                return
            end
            if OffTank and OffTank:SpecialHealthPercentage() <= 80 and OffTank:CanCast(PenanceHeal) then
                OffTank:Cast(PenanceHeal)
                return
            end
            if Lowest and Lowest:SpecialHealthPercentage() <= 80 and Lowest:CanCast(PenanceHeal) then
                Lowest:Cast(PenanceHeal)
                return
            end
        end
        if ShadowMend:Exists() and IsOptionEnabled("暗影愈合") then
            if
            MainTank and MainTank:SpecialHealthPercentage() <= GetOptionValue("暗影愈合") and
            MainTank:CanCast(ShadowMend)
            then
                self.AlternateDamage = self.AlternateDamage + 1
                MainTank:Cast(ShadowMend)
                return
            end
            if OffTank and OffTank:SpecialHealthPercentage() <= GetOptionValue("暗影愈合") and OffTank:CanCast(ShadowMend) then
                self.AlternateDamage = self.AlternateDamage + 1
                OffTank:Cast(ShadowMend)
                return
            end
            if
            Lowest and Lowest:SpecialHealthPercentage() <= GetSecondOptionValue("暗影愈合") and
            Lowest:CanCast(ShadowMend)
            then
                self.AlternateDamage = self.AlternateDamage + 1
                Lowest:Cast(ShadowMend)
                return
            end
        end
    end
    if Player:IsInCombat() or GetSecondOptionValue("脱离战斗后暂停治疗") == "启用" then
        self:DPSHandler("(Filler)")
    end
    if Player:IsInCombat() or GetOptionValue("脱离战斗后暂停治疗") == "启用" then
        self:Overshield()
        if
        MainTank and MainTank:BuffRemains(Atonement) < 3 and
        (MainTank:SpecialHealthPercentage() < GetSecondOptionValue("救赎 恳求") or
        (MainTank:SpecialHealthPercentage() <= GetOptionValue("救赎") and
        AtonementUnits < GetOptionValue("救赎 恳求"))) and
        MainTank:CanCast(Plea)
        then
            self.AlternateDamage = self.AlternateDamage + 1
            MainTank:Cast(Plea)
            return
        end
        if
        OffTank and OffTank:BuffRemains(Atonement) < 3 and
        (OffTank:SpecialHealthPercentage() < GetSecondOptionValue("救赎 恳求") or
        (OffTank:SpecialHealthPercentage() <= GetOptionValue("救赎") and
        AtonementUnits < GetOptionValue("救赎 恳求"))) and
        OffTank:CanCast(Plea)
        then
            self.AlternateDamage = self.AlternateDamage + 1
            OffTank:Cast(Plea)
            return
        end
        if
        Lowest and Lowest:BuffRemains(Atonement) < 3 and
        (Lowest:SpecialHealthPercentage() < GetSecondOptionValue("救赎 恳求") or
        (Lowest:SpecialHealthPercentage() <= GetOptionValue("救赎") and
        AtonementUnits < GetOptionValue("救赎 恳求"))) and
        Lowest:CanCast(Plea)
        then
            self.AlternateDamage = self.AlternateDamage + 1
            Lowest:Cast(Plea)
            return
        end
    end
end
function Rotation:OutOfCombat()
    self:Overshield()
    if
    Shield:Exists() and MainTank and IsOptionEnabled("真言术：盾") and not MainTank:Buff(Atonement) and
    MainTank:IsInCombat() and
    not MainTank:Buff(Shield) and
    MainTank:CanCast(Shield)
    then
        MainTank:Cast(Shield)
        return
    end
    if
    PenanceHeal:Exists() and ThePenitent:Exists() and Lowest and Lowest:SpecialHealthPercentage() < 90 and
    Lowest:CanCast(PenanceHeal)
    then
        Lowest:Cast(PenanceHeal)
        return
    end
    if
    AngelicFeather:Exists() and IsOptionEnabled("天堂之羽") and Player:Moving() > GetOptionValue("天堂之羽") and
    not IsFalling() and
    Player:BuffRemains(AngelicFeatherBuff) < 0.5 and
    Player:CanCast(AngelicFeather)
    then
        self:AngelicFeatherHandler()
    end
    if
    BodyAndSoul:Exists() and IsOptionEnabled("身心合一") and Player:Moving() > GetOptionValue("身心合一") and
    not Player:Buff(BodyAndSoulBuff) and
    Player:CanCast(Shield) and
    not Player:Buff(Shield)
    then
        Player:Cast(Shield)
        return
    end
    if IsOptionEnabled("自动进入战斗") and Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        local EngageSpell = Smite
        if EngageSpell:Exists() and Target:CanCast(EngageSpell) then
            Target:Cast(EngageSpell)
            return
        end
    end
    if IsOptionEnabled("脱离战斗后暂停治疗") then
        self:Combat()
    end
end
SetRotation(257, {})
local Rotation = Rotations[257]
function Rotation:Initialize()
    Trinket1 = Item(13, false, false, true)
    Trinket2 = Item(14, false, false, true)
    Berserking = Spell(26297, false, false, true)
    BloodFury = Spell(33697, false, false, true)
    ArcaneTorrent = Spell(232633, false, false, true)
    AngelicFeather = Spell(121536, false, false, true)
    AngelicFeatherBuff = Spell(121557)
    Apotheosis = Spell(200183, false, false, true)
    BindingHeal = Spell(32546, false, false, true)
    BodyAndMind = Spell(214121, false, false, true)
    CircleOfHealing = Spell(204883, false, false, false)
    DesperatePrayer = Spell(19236, false, false, true)
    DispelMagic = Spell(528, false, false, true)
    DivineHymn = Spell(64843, false, false, false)
    DivineStar = Spell(110744, false, false, true)
    Fade = Spell(586, false, false, true)
    FlashHeal = Spell(2061, false, false, false)
    GiftOfTheNaaru = Spell(59544, false, false, true)
    GuardianSpirit = Spell(47788, false, false, true)
    Halo = Spell(120517, false, false, true)
    Heal = Spell(2060, false, false, false)
    HolyFire = Spell(14914, false, true, true)
    HolyNova = Spell(132157, false, false, true)
    HolyWordChastise = Spell(88625, true, true, true)
    HolyWordSanctify = Spell(34861, false, false, true)
    HolyWordSerenity = Spell(2050, false, false, true)
    LightOfTuure = Spell(208065, false, false, true)
    Piety = Spell(197034)
    PrayerOfHealing = Spell(596, false, false, false)
    PrayerOfMending = Spell(33076, false, false, true)
    PrayerOfMendingBuff = Spell(41635, false, false, true)
    Purify = Spell(527, false, false, true)
    Renew = Spell(139, false, false, true)
    Resurrection = Spell(2006, false, false, false, true)
    SpiritOfRedemption = Spell(27827, false, false, true)
    SurgeOfLight = Spell(114255)
    Smite = Spell(585, true, true, false)
    AddPage("常规")
    AddPage("治愈")
    AddPage("大技能")
    AddPage("攻/防")
    AddCommonOptions()
    AddPresetOption("GeneralHealer")
    AddSection("常规", "移动", "Yellow")
    AddNewOption(
    "常规",
    "天堂之羽",
    220,
    true,
    { 1.5, 0, 10, 0.1 },
    nil,
    "Use Angelic Feather on player." ..
    C.TOOLTIP_VALUE .. "Select desired time to wait when you start moving to use it.(seconds)"
    )
    AddNewOption(
    "常规",
    "身心合一",
    220,
    true,
    { 1.5, 0, 10, 0.1 },
    nil,
    "Use Body and Mind on player." ..
    C.TOOLTIP_VALUE .. "Select desired time to wait when you start moving to use it.(seconds)"
    )
    AddSection("治愈", "通用治疗参数", "Yellow")
    AddNewOption(
    "治愈",
    "联结治疗",
    222,
    true,
    { 90, 0, 100, 1 },
    { 80, 0, 100, 1 },
    "Use Binding Heal when our health is under the set Binding Heal Player option." ..
    C.TOOLTIP_VALUE_1 ..
    "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid."
    )
    AddNewOption(
    "治愈",
    "Binding Heal Player",
    120,
    true,
    { 95, 0, 100, 1 },
    nil,
    "Only use Binding Heal when our health is below or at the given amount of %."
    )
    AddNewOption(
    "治愈",
    "治疗之环",
    222,
    true,
    { 3, 1, 5, 1 },
    { 80, 0, 100, 1 },
    "Use when selected number of units are under health threshold." ..
    C.TOOLTIP_VALUE_1 .. "Number of Units." .. C.TOOLTIP_VALUE_2 .. "Health threshold."
    )
    AddNewOption(
    "治愈",
    "快速治疗",
    222,
    true,
    { 70, 0, 100, 1 },
    { 35, 0, 100, 1 },
    "Use Flash Heal." ..
    C.TOOLTIP_VALUE_1 ..
    "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid."
    )
    AddNewOption(
    "治愈",
    "快速治疗 圣光涌动",
    222,
    true,
    { 80, 0, 100, 1 },
    { 55, 0, 100, 1 },
    "Use Flash Heal with Surge Of Light procs." ..
    C.TOOLTIP_VALUE_1 ..
    "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid."
    )
    AddNewOption(
    "治愈",
    "治疗术",
    222,
    true,
    { 90, 0, 100, 1 },
    { 80, 0, 100, 1 },
    "Use Heal." ..
    C.TOOLTIP_VALUE_1 ..
    "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid."
    )
    AddNewOption(
    "治愈",
    "恢复",
    222,
    true,
    { 95, 0, 100, 1 },
    { 92, 0, 100, 1 },
    "Use Renew." ..
    C.TOOLTIP_VALUE_1 ..
    "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid."
    )
    AddNewOption(
    "治愈",
    "治疗祷言",
    222,
    true,
    { 3, 1, 5, 1 },
    { 70, 0, 100, 1 },
    "Use when selected number of units are under health threshold." ..
    C.TOOLTIP_VALUE_1 .. "Number of Units." .. C.TOOLTIP_VALUE_2 .. "Health threshold."
    )
    AddNewOption(
    "治愈",
    "愈合祷言",
    222,
    true,
    { 1, 1, 5, 1 },
    { 95, 0, 100, 1 },
    "Use when selected number of units are under health threshold." ..
    C.TOOLTIP_VALUE_1 .. "Number of Units." .. C.TOOLTIP_VALUE_2 .. "Health threshold."
    )
    AddNewOption(
    "治愈",
    "愈合祷言 高优先",
    232,
    true,
    { 1, "以上 DPS", "以下 DPS" },
    { 3, 0, 30, 0.5 },
    "Use Prayer of Mending as high priority without checking for health. Tanks > Raid." ..
    C.TOOLTIP_VALUE_1 ..
    "Above DPS = Highest Priority even above High Priority DPS. Below DPS = Below High Priority DPS and some other important spells in priority." ..
    C.TOOLTIP_VALUE_2 ..
    "Prayer of Mending buff remaining to consider ally not have it. E.g. 3: all allies with no buff or a buff duration below 3 are considered a valid target for PoM."
    )
    AddNewOption(
    "治愈",
    "脱离战斗后暂停治疗",
    233,
    true,
    { 2, "禁用", "启用" },
    { 1, "禁用", "启用" },
    "Pulse rotation while Out of Combat." ..
    C.TOOLTIP_VALUE_1 ..
    "Allow healing rotation while out of combat." ..
    C.TOOLTIP_VALUE_2 .. "Allow dps rotation while out of combat."
    )
    AddNewOption(
    "治愈",
    "紧急治疗",
    222,
    true,
    { 30, 1, 75, 1 },
    { 45, 1, 75, 1 },
    "Heal the tanks or the player as very high priority when their health is critical." ..
    C.TOOLTIP_VALUE_1 .. "Tanks health threshold." .. C.TOOLTIP_VALUE_2 .. "Player health threshold."
    )
    AddSection("治愈", "主动治疗", "Yellow")
    AddNewOption(
    "治愈",
    "治疗目标",
    230,
    true,
    { 1, "已知单位", "任何单位" },
    nil,
    "Heal our current target if it is listed to be healed." ..
    C.TOOLTIP_VALUE ..
    "Choose preferred mode." ..
    C.TOOLTIP_SUBVALUE("已知单位") ..
    "Allow Heal Target to be used only when we are targetting a unit listed for it." ..
    C.TOOLTIP_SUBVALUE("任何单位") .. "Allow Heal Target to be used on any unit."
    )
    AddNewOption(
    "治愈",
    "团队成员Debuffs",
    220,
    true,
    { 40, 0, 100, 1 },
    nil,
    "Use Renew on Debuffed units." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddNewOption(
    "治愈",
    "坦克Debuffs",
    220,
    true,
    { 50, 0, 100, 1 },
    nil,
    "Use Renew on Debuffed tanks." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddNewOption(
    "治愈",
    "Topping",
    220,
    true,
    { 100, 0, 100, 1 },
    nil,
    "Use Renew/Flash Heal on units to be topped." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddSection("大技能", "大技能", "Yellow")
    AddNewOption(
    "大技能",
    "神圣化身",
    222,
    true,
    { 3, 1, 25, 1 },
    { 60, 0, 100, 1 },
    "Use when selected number of units are under health threshold." ..
    C.TOOLTIP_VALUE_1 .. "Number of Units." .. C.TOOLTIP_VALUE_2 .. "Health threshold."
    )
    AddNewOption(
    "大技能",
    "神圣化身 圣言术：静",
    222,
    true,
    { 65, 0, 100, 1 },
    { 90, 0, 100, 1 },
    "Use Flash Heal or Heal during Apotheosis when Holy Word: Serenity is on Cooldown." ..
    C.TOOLTIP_VALUE_1 ..
    "Threshold to use Flash Heal on any unit." .. C.TOOLTIP_VALUE_2 .. "Threshold to use Heal on any unit."
    )
    AddNewOption(
    "大技能",
    "神圣化身 圣言术：灵",
    222,
    true,
    { 3, 1, 5, 1 },
    { 80, 0, 100, 1 },
    "Use Prayer Of Healing and Prayer of Mending (if Piety is talented) during Apotheosis when Holy Word: Sanctify is on Cooldown." ..
    C.TOOLTIP_VALUE_1 ..
    "Number of units that needs to be under threshold." ..
    C.TOOLTIP_VALUE_2 ..
    "Threshold health under which the units must be." ..
    C.TOOLTIP_HINT(
    "Prayer of Mending will be used always, without health checks, on the tanks."
    )
    )
    AddNewOption(
    "大技能",
    "神圣赞美诗",
    222,
    true,
    { 3, 1, 25, 1 },
    { 70, 0, 100, 1 },
    "Use when selected number of units are under health threshold." ..
    C.TOOLTIP_VALUE_1 .. "Number of Units." .. C.TOOLTIP_VALUE_2 .. "Health threshold."
    )
    AddNewOption(
    "大技能",
    "神圣之星",
    222,
    true,
    { 2, 1, 25, 1 },
    { 90, 0, 100, 1 },
    "Use when selected number of units are under health threshold." ..
    C.TOOLTIP_VALUE_1 .. "Number of Units." .. C.TOOLTIP_VALUE_2 .. "Health threshold."
    )
    AddNewOption(
    "大技能",
    "守护之魂",
    222,
    true,
    { 30, 0, 100, 1 },
    { 0, 0, 100, 1 },
    "Use Guardian Spirit." ..
    C.TOOLTIP_VALUE_1 ..
    "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid."
    )
    AddNewOption(
    "大技能",
    "光晕",
    222,
    true,
    { 4, 1, 25, 1 },
    { 80, 0, 100, 1 },
    "Use when selected number of units are under health threshold." ..
    C.TOOLTIP_VALUE_1 .. "Number of Units." .. C.TOOLTIP_VALUE_2 .. "Health threshold."
    )
    AddNewOption(
    "大技能",
    "圣言术：灵",
    222,
    true,
    { 3, 1, 10, 1 },
    { 80, 0, 100, 1 },
    "Use when selected number of units are under health threshold." ..
    C.TOOLTIP_VALUE_1 .. "Number of Units." .. C.TOOLTIP_VALUE_2 .. "Health threshold."
    )
    AddNewOption(
    "大技能",
    "圣言术：静",
    222,
    true,
    { 50, 0, 100, 1 },
    { 30, 0, 100, 1 },
    "Use Holy Word Serenity." ..
    C.TOOLTIP_VALUE_1 ..
    "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid."
    )
    AddNewOption(
    "大技能",
    "图雷之光",
    222,
    true,
    { 60, 0, 100, 1 },
    { 40, 0, 100, 1 },
    "Use Light Of T'uure." ..
    C.TOOLTIP_VALUE_1 ..
    "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid."
    )
    AddSection("攻/防", "伤害输出", "Yellow")
    AddNewOption(
    "攻/防",
    "DPS",
    223,
    true,
    { 95, 0, 100, 1 },
    { 1, "高", "Low" },
    "Enables DPS options." ..
    C.TOOLTIP_VALUE_1 ..
    "Will only DPS if the Lowest unit is above DPS health treshold." ..
    C.TOOLTIP_VALUE_1 ..
    "High = As highest priority. Low = After all heal conditions are checked without extra checking for lowest member."
    )
    AddNewOption(
    "攻/防",
    "神圣之火",
    220,
    true,
    { 75, 0, 100, 1 },
    nil,
    "Use Holy Fire in the DPS rotation." ..
    C.TOOLTIP_VALUE_1 ..
    "Mana threshold." ..
    C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold")
    )
    AddNewOption(
    "攻/防",
    "神圣新星",
    222,
    true,
    { 3, 1, 10, 1 },
    { 85, 0, 100, 1 },
    "Use Holy Nova in the DPS rotation." ..
    C.TOOLTIP_VALUE_1 ..
    "Amount of units required to be in 12 yards of Player to use." ..
    C.TOOLTIP_VALUE_2 ..
    "Mana threshold." ..
    C.TOOLTIP_HINT(
    "Only used when the Lowest unit's health is higher than the DPS health threshold"
    )
    )
    AddNewOption(
    "攻/防",
    "圣言术：罚",
    220,
    true,
    { 85, 0, 100, 1 },
    nil,
    "Use Holy Word: Chastise in the DPS rotation." ..
    C.TOOLTIP_VALUE_1 ..
    "Mana threshold." ..
    C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold")
    )
    AddNewOption(
    "攻/防",
    "惩击",
    210,
    true,
    nil,
    nil,
    "Use Smite in the DPS rotation." ..
    C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold")
    )
    AddSection("攻/防", "防御", "Yellow")
    AddNewOption(
    "攻/防",
    "治疗物品",
    220,
    true,
    { 35, 1, 95, 1 },
    nil,
    "Use Healing Belt / Healing Pot / Healthstone." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddNewOption(
    "攻/防",
    "绝望祷言",
    220,
    true,
    { 30, 1, 100, 1 },
    nil,
    "Use Desperate Prayer." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddNewOption(
    "攻/防",
    "渐隐术",
    220,
    true,
    { 20, 1, 100, 1 },
    nil,
    "Use Fade when there is threath on us." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    if GiftOfTheNaaru:Exists() then
        AddNewOption(
        "攻/防",
        "纳鲁的赐福",
        222,
        true,
        { 65, 0, 100, 1 },
        { 55, 0, 100, 1 },
        "Use Gift Of The Naaru." ..
        C.TOOLTIP_VALUE_1 ..
        "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid."
        )
    end
    AddSection("攻/防", "救赎之魂相关功能", "Yellow")
    AddNewOption(
    "攻/防",
    "效果期间施放治疗之环",
    222,
    true,
    { 2, 1, 5, 1 },
    { 90, 0, 100, 1 },
    "Use Circle Of Healing during Spirit of Redemption." ..
    C.TOOLTIP_VALUE_1 ..
    "Number of units that needs to be under threshold." ..
    C.TOOLTIP_VALUE_2 .. "Threshold health under which the units must be."
    )
    AddNewOption(
    "攻/防",
    "效果期间施放治疗祷言",
    222,
    true,
    { 2, 1, 5, 1 },
    { 90, 0, 100, 1 },
    "Use Prayer Of Healing during Spirit of Redemption." ..
    C.TOOLTIP_VALUE_1 ..
    "Number of units that needs to be under threshold." ..
    C.TOOLTIP_VALUE_2 .. "Threshold health under which the units must be."
    )
    AddNewOption(
    "攻/防",
    "效果期间施放神圣赞美诗",
    222,
    true,
    { 3, 1, 25, 1 },
    { 80, 0, 100, 1 },
    "Use Divine Hymn during Spirit of Redemption." ..
    C.TOOLTIP_VALUE_1 ..
    "Number of units that needs to be under threshold." ..
    C.TOOLTIP_VALUE_2 .. "Threshold health under which the units must be."
    )
    AddNewOption(
    "攻/防",
    "效果期间施放守护之魂",
    222,
    true,
    { 30, 0, 100, 1 },
    { 0, 0, 100, 1 },
    "Use Guardian Spirit during Spirit of Redemption." ..
    C.TOOLTIP_VALUE_1 ..
    "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid."
    )
    AddNewOption(
    "攻/防",
    "效果消失前施放守护之魂",
    210,
    true,
    nil,
    nil,
    "Will use Guardian Spirit on the Lowest Tank before Spirit of Redemption buff fades"
    )
    AddNewOption(
    "攻/防",
    "效果期间施放快速治疗",
    222,
    true,
    { 75, 0, 100, 1 },
    { 65, 0, 100, 1 },
    "Use Flash Heal during Spirit of Redemption." ..
    C.TOOLTIP_VALUE_1 ..
    "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid."
    )
    AddNewOption(
    "攻/防",
    "效果期间施放恢复",
    220,
    true,
    { 95, 0, 100, 1 },
    nil,
    "Use Renew during Spirit of Redemption." .. C.TOOLTIP_VALUE .. "Health Threshold."
    )
    AddOutput("|cFF9A2EFE主T:")
    AddOutput("|cFF9A2EFE副T:")
    AddOutput("|cFF9A2EFE最低:")
    AddOutput("|cFF9A2EFE有害效果:")
    SetOutput("|cFF9A2EFE有害效果:", 0)
    ISCL = {[Heal:ID()] = "治疗术", [FlashHeal:ID()] = "快速治疗" }
end
function Rotation:Events()
end
function Rotation:Pulse()
    if
    Player:Channeling(DivineHymn) or not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or
    Player:IsEating()
    then
        return
    end
    if BMPullTime() < 5 then
        self:Opening()
        return
    end
    if GetTime() < Rotation.SpamPrevention then
        return
    end
    Rotation.SpamPrevention = GetTime() + 0.05
    Target = Unit.Target
    local InCombat = Player:IsInCombat()
    Rotations:RefreshUnitTables(Rotation.Identifier)
    if not InCombat then
        SetOutput("|cFF9A2EFE有害效果:", 0)
        self:OutOfCombat()
        return
    end
    if InCombat then
        self:Defensives()
    end
    Target = Player:ReTarget(Smite, false) or Unit.Target
    self:Interrupts()
    self:OffGCDAbilities()
    if Player:GlobalCooldown() == 0 then
        self:Combat()
    end
end
function Rotation:Opening()
    Player:UsePotions("智力药水", GetSecondOptionValue("抢先使用药水"))
    if
    Target:Exists() and IsOptionEnabled("抢先施放(需DBM插件)") and
    (GetOptionValue("抢先施放(需DBM插件)") == "无条件使用" or
    (GetOptionValue("抢先施放(需DBM插件)") == "打BOSS使用" and Target:IsBoss()))
    then
        if Smite:Exists() and BMPullTime() < GetSecondOptionValue("抢先施放(需DBM插件)") and Target:CanCast(Smite) then
            Target:Cast(Smite)
            return
        end
    end
end
function Rotation:Interrupts()
    Player:UseInterrupt(nil, ArcaneTorrent)
end
function Rotation:OffGCDAbilities()
    if IsOptionEnabled("延时之力药水") and ProlongedPowerUnitsCount >= GetOptionValue("延时之力药水") then
        Player:UsePotions("延时之力药水")
    end
    Player:UsePotions(GetOptionValue("使用法力药水"))
end
function Rotation:Defensives()
    Player:UseHealingItem()
    if IsOptionEnabled("渐隐术") and Player:ThreatSituation() == 3 and Player:CanCast(Fade) and Player:IsInGroup() then
        Player:Cast(Fade)
        return
    end
    if
    DesperatePrayer:Exists() and IsOptionEnabled("绝望祷言") and Player:HealthPercentage() <= GetOptionValue("绝望祷言") and
    Player:CanCast(DesperatePrayer)
    then
        Player:Cast(DesperatePrayer)
        return
    end
    if GiftOfTheNaaru:Exists() and IsOptionEnabled("纳鲁的赐福") then
        if
        MainTank and MainTank:SpecialHealthPercentage() <= GetOptionValue("纳鲁的赐福") and
        MainTank:CanCast(GiftOfTheNaaru)
        then
            MainTank:Cast(GiftOfTheNaaru)
            return
        elseif
        MainTank and OffTank and OffTank:SpecialHealthPercentage() <= GetOptionValue("纳鲁的赐福") and
        OffTank:CanCast(GiftOfTheNaaru)
        then
            OffTank:Cast(GiftOfTheNaaru)
            return
        elseif
        Lowest and Lowest:SpecialHealthPercentage() <= GetSecondOptionValue("纳鲁的赐福") and
        Lowest:CanCast(GiftOfTheNaaru)
        then
            Lowest:Cast(GiftOfTheNaaru)
            return
        end
    end
end
Rotation.TanksStatus, Rotation.MainTankTanking, Rotation.OffTankTanking = {
    Main = { IsTanking = GetTime() },
    Off = { IsTanking = GetTime() }
}
function Rotation:RefreshTanksStatus()
    self.TanksStatus = {
        Main = {
            IsTanking = MainTank and MainTank:ThreatSituation() == 3 and GetTime() or self.TanksStatus.Main.IsTanking
        },
        Off = { IsTanking = OffTank and OffTank:ThreatSituation() == 3 and GetTime() or self.TanksStatus.Off.IsTanking }
    }
    self.MainTankTanking = GetTime() - self.TanksStatus.Main.IsTanking < 3 or false
    self.OffTankTanking = GetTime() - self.TanksStatus.Off.IsTanking < 3 or false
end
function Rotation:HealTarget(ThisUnit)
    if ThisUnit:CanCast(Renew) and ThisUnit:BuffRemains(Renew) < 2 then
        ThisUnit:Cast(Renew)
        return
    end
    if not Player:IsMoving() then
        if ThisUnit:CanCast(FlashHeal) and ThisUnit:SpecialHealthPercentage() < 100 then
            ThisUnit:Cast(FlashHeal)
            return
        end
        if ThisUnit:CanCast(Heal) then
            ThisUnit:Cast(Heal)
            return
        end
    end
end
function Rotation:SpiritRotation()
    if IsOptionEnabled("效果期间施放守护之魂") then
        if MainTank and MainTank:HealthPercentage() <= GetOptionValue("效果期间施放守护之魂") and MainTank:CanCast(GuardianSpirit) then
            MainTank:Cast(GuardianSpirit)
            return
        elseif
        OffTank and OffTank:HealthPercentage() <= GetOptionValue("效果期间施放守护之魂") and OffTank:CanCast(GuardianSpirit)
        then
            OffTank:Cast(GuardianSpirit)
            return
        end
    end
    if IsOptionEnabled("效果消失前施放守护之魂") and Player:BuffRemains(SpiritOfRedemption) < 3 then
        local BestGuardianUnit = nil
        if MainTank and MainTank:CanCast(GuardianSpirit) then
            BestGuardianUnit = MainTank
        elseif
        OffTank and OffTank:CanCast(GuardianSpirit) and
        OffTank:SpecialHealthPercentage() <= MainTank:SpecialHealthPercentage()
        then
            BestGuardianUnit = OffTank
        end
        if BestGuardianUnit then
            BestGuardianUnit:Cast(GuardianSpirit)
            return
        end
    end
    if
    IsOptionEnabled("效果期间施放神圣赞美诗") and Player:CanCast(DivineHymn) and
    #Player:HealUnitsAround(GetSecondOptionValue("效果期间施放神圣赞美诗"), 40) >= GetOptionValue("效果期间施放神圣赞美诗")
    then
        Player:Cast(DivineHymn)
        return
    end
    if CurrentBadDebuffs ~= nil then
        Player:DispelHandler(Purify, "驱散", DispelUnit, CurrentBadDebuffs.Dispel, "正常")
    end
    if IsOptionEnabled("效果期间施放治疗之环") and Player:CanCast(CircleOfHealing) then
        if CoHUnit and CoHUnit:CanCast(CircleOfHealing) then
            CoHUnit:Cast(CircleOfHealing)
            return
        end
    end
    if PrayerOfHealing:Exists() and IsOptionEnabled("效果期间施放治疗祷言") and PoHUnit and PoHUnit:CanCast(PrayerOfHealing) then
        PoHUnit:Cast(PrayerOfHealing)
        return
    end
    if IsOptionEnabled("效果期间施放快速治疗") then
        if
        MainTank and MainTank:SpecialHealthPercentage() <= GetOptionValue("效果期间施放快速治疗") and
        MainTank:CanCast(FlashHeal)
        then
            MainTank:Cast(FlashHeal)
            return
        elseif
        MainTank and OffTank and OffTank:SpecialHealthPercentage() <= GetOptionValue("效果期间施放快速治疗") and
        OffTank:CanCast(FlashHeal)
        then
            OffTank:Cast(FlashHeal)
            return
        elseif
        Lowest and Lowest:SpecialHealthPercentage() <= GetSecondOptionValue("效果期间施放快速治疗") and
        Lowest:CanCast(FlashHeal)
        then
            Lowest:Cast(FlashHeal)
            return
        end
    end
    if IsOptionEnabled("效果期间施放恢复") and HealUnits then
        local BestUnit = nil
        local BestUnitHealth = 101
        for i = 1, #HealUnits do
            local ThisUnit = HealUnits[i]
            local ThisUnitHealth = ThisUnit:SpecialHealthPercentage()
            if
            ThisUnit:CanCast(Renew) and ThisUnitHealth <= GetOptionValue("效果期间施放恢复") and
            ThisUnit:BuffRemains(Renew) <= 3 and
            ThisUnitHealth < BestUnitHealth
            then
                BestUnitHealth = ThisUnitHealth
                BestUnit = ThisUnit
            end
        end
        if BestUnit then
            BestUnit:Cast(Renew)
            return
        end
    end
end
function Rotation:LowestWithoutPoM(Table, ThisDuration)
    ThisDuration = ThisDuration or 0
    local UnitsTable, ThisUnit = {}, nil
    for i = 1, #Table do
        ThisUnit = Table[i]
        if ThisUnit:Exists() and ThisUnit:BuffRemains(PrayerOfMendingBuff) <= ThisDuration then
            UnitsTable[#UnitsTable + 1] = ThisUnit
        end
    end
    local Lowest, LowestHealth = nil, 101
    for i = 1, #UnitsTable do
        ThisUnit = UnitsTable[i]
        if not Lowest or ThisUnit:SpecialHealthPercentage() < LowestHealth then
            Lowest, LowestHealth = ThisUnit, ThisUnit:SpecialHealthPercentage()
        end
    end
    return Lowest
end
function Rotation:UnitTables()
    HealUnits = Player:HealUnitsAround(100, 40)
    CurrentBadDebuffs = Player:GetRaidDebuffs(HealUnits)
    if CurrentBadDebuffs ~= nil then
        SetOutput("|cFF9A2EFE有害效果:", #CurrentBadDebuffs.Top + #CurrentBadDebuffs.Debuff)
    end
    DispelUnit = Unit.Dispel(HealUnits, Purify)
    MainTank, MainTankTarget, OffTank, OffTankTarget = Unit.GetMainTanks()
    self:RefreshTanksStatus()
    Lowest = Unit.Lowest(HealUnits)
    SetOutput("|cFF9A2EFE最低:", Lowest and Lowest:Name() or "")
    Trinket1Units =     IsOptionEnabled("使用饰品 1") and Trinket1:IsUsableInventory() and
    #Player:HealUnitsAround(GetSecondOptionValue("使用饰品 1"), 40) or
    0
    Trinket2Units =     IsOptionEnabled("使用饰品 2") and Trinket2:IsUsableInventory() and
    #Player:HealUnitsAround(GetSecondOptionValue("使用饰品 2"), 40) or
    0
    RacialsUnits =     IsOptionEnabled("使用种族技能") and
    ((Berserking:Exists() and Player:CanCast(Berserking)) or (BloodFury:Exists() and Player:CanCast(BloodFury))) and
    #Player:HealUnitsAround(GetOptionValue("使用种族技能"), 40) or
    0
    ProlongedPowerUnitsCount =     IsOptionEnabled("延时之力药水") and #Player:HealUnitsAround(GetSecondOptionValue("延时之力药水"), 40) or 0
    ApotheosisUnits =     Apotheosis:Exists() and IsOptionEnabled("神圣化身") and #Player:HealUnitsAround(GetSecondOptionValue("神圣化身"), 40) or
    0
    ApotheosisPoHUnit =     PrayerOfHealing:Exists() and Apotheosis:Exists() and IsOptionEnabled("神圣化身 圣言术：灵") and
    Player:BestClusterOfAlliesToHeal(GetOptionValue("神圣化身 圣言术：灵"), GetSecondOptionValue("神圣化身 圣言术：灵"), 20) or
    nil
    CoHUnit =     CircleOfHealing:Exists() and not CircleOfHealing:IsOnCooldown() and Player:Buff(SpiritOfRedemption) and
    IsOptionEnabled("效果期间施放治疗之环") and
    Player:BestClusterOfAlliesToHeal(GetOptionValue("效果期间施放治疗之环"), GetSecondOptionValue("效果期间施放治疗之环"), 30) or
    CircleOfHealing:Exists() and not CircleOfHealing:IsOnCooldown() and IsOptionEnabled("治疗之环") and
    Player:BestClusterOfAlliesToHeal(GetOptionValue("治疗之环"), GetSecondOptionValue("治疗之环"), 30) or
    nil
    DivineStarUnits =     DivineStar:Exists() and IsOptionEnabled("神圣之星") and DivineStar:Cooldown() <= 2 and
    #Player:UnitsInFrontRectangle(24, 5, true, GetSecondOptionValue("神圣之星")) or
    0
    DivineHymnUnits =     DivineHymn:Exists() and IsOptionEnabled("神圣赞美诗") and DivineHymn:Cooldown() <= 2 and
    #Player:HealUnitsAround(GetSecondOptionValue("神圣赞美诗"), 40) or
    0
    HaloUnits =     Halo:Exists() and IsOptionEnabled("光晕") and Halo:Cooldown() <= 2 and
    #Player:HealUnitsAround(GetSecondOptionValue("光晕"), 30) or
    0
    HolyNovaUnits = HolyNova:Exists() and IsOptionEnabled("神圣新星") and #Player:EnemiesWithinDistance(12) or 0
    MendingUnits =     PrayerOfMending:Exists() and PrayerOfMending:Cooldown() < 1 and IsOptionEnabled("愈合祷言") and
    #Player:HealUnitsAround(GetSecondOptionValue("愈合祷言"), 40) or
    0
    LowestForPoM =     PrayerOfMending:Exists() and PrayerOfMending:Cooldown() < 1 and IsOptionEnabled("愈合祷言 高优先") and
    self:LowestWithoutPoM(HealUnits, GetSecondOptionValue("愈合祷言 高优先"))
    PoHUnit =     PrayerOfHealing:Exists() and Player:Buff(SpiritOfRedemption) and IsOptionEnabled("效果期间施放治疗祷言") and
    Player:BestClusterOfAlliesToHeal(GetOptionValue("效果期间施放治疗祷言"), GetSecondOptionValue("效果期间施放治疗祷言"), 20) or
    PrayerOfHealing:Exists() and IsOptionEnabled("治疗祷言") and
    Player:BestClusterOfAlliesToHeal(GetOptionValue("治疗祷言"), GetSecondOptionValue("治疗祷言"), 20) or
    nil
    HolyWordSanctifyUnit =     HolyWordSanctify:Exists() and IsOptionEnabled("圣言术：灵") and HolyWordSanctify:Cooldown() <= 2 and
    Player:BestClusterOfAlliesToHeal(GetOptionValue("圣言术：灵"), GetSecondOptionValue("圣言术：灵"), 10) or
    nil
end
function Rotation:Combat()
    if Target:Exists() and Target:CanCast(Smite) then
        BestTarget = Target
    elseif MainTankTarget and MainTankTarget:CanCast(Smite) then
        BestTarget = MainTankTarget
    elseif OffTankTarget and OffTankTarget:CanCast(Smite) then
        BestTarget = OffTankTarget
    elseif Mouseover:Exists() and Mouseover:CanCast(Smite) then
        BestTarget = Mouseover
    else
        BestTarget = Target
    end
    if CurrentBadDebuffs ~= nil then
        Player:DispelHandler(Purify, "驱散", DispelUnit, CurrentBadDebuffs.Dispel, "高")
    end
    if
    Target:CanCast(Heal) and IsOptionEnabled("治疗目标") and
    (GetOptionValue("治疗目标") == 2 or
    (Target:ShouldBeHealed() ~= 0 and Target:HealthPercentage() < Target:ShouldBeHealed()))
    then
        self:HealTarget(Target)
        return
    end
    if Player:Buff(SpiritOfRedemption) then
        self:SpiritRotation()
        return
    end
    if IsOptionEnabled("使用饰品 1") and Trinket1:IsUsableInventory() then
        local Option1, Option2 = GetOptionValue("使用饰品 1"), GetSecondOptionValue("使用饰品 1")
        if
        Option1 == "无条件使用" or (Option1 == "血量" and Lowest and Lowest:SpecialHealthPercentage() <= Option2) or
        (Option1 == "蓝量" and Player:PowerPercentage() < Option2)
        then
            Trinket1:UseInventory()
        end
    end
    if IsOptionEnabled("使用饰品 2") and Trinket2:IsUsableInventory() then
        local Option1, Option2 = GetOptionValue("使用饰品 2"), GetSecondOptionValue("使用饰品 2")
        if
        Option1 == "无条件使用" or (Option1 == "血量" and Lowest and Lowest:SpecialHealthPercentage() <= Option2) or
        (Option1 == "蓝量" and Player:PowerPercentage() < Option2)
        then
            Trinket2:UseInventory()
        end
    end
    if Player:IsInCombat() or GetSecondOptionValue("脱离战斗后暂停治疗") == "启用" then
        if
        Player:IsInCombat() and PrayerOfMending:Exists() and IsOptionEnabled("愈合祷言 高优先") and
        GetOptionValue("愈合祷言 高优先") == "以上 DPS"
        then
            if MainTank and MainTank:CanCast(PrayerOfMending) and MainTank:BuffCount(PrayerOfMendingBuff) <= 2 then
                MainTank:Cast(PrayerOfMending)
                return
            elseif OffTank and OffTank:CanCast(PrayerOfMending) and OffTank:BuffCount(PrayerOfMendingBuff) <= 2 then
                OffTank:Cast(PrayerOfMending)
                return
            elseif LowestForPoM and Lowest:CanCast(PrayerOfMending) then
                LowestForPoM:Cast(PrayerOfMending)
                return
            end
        end
        if
        BestTarget and IsOptionEnabled("DPS") and GetSecondOptionValue("DPS") == "高" and
        (not Lowest or Lowest:HealthPercentage() >= GetOptionValue("DPS")) and
        (not MainTank or MainTank:HealthPercentage() >= GetOptionValue("DPS")) and
        (not OffTank or OffTank:HealthPercentage() >= GetOptionValue("DPS")) and
        BestTarget:IsInCombat()
        then
            if
            HolyWordChastise:Exists() and IsOptionEnabled("圣言术：罚") and
            Player:ManaPercentage() >= GetOptionValue("圣言术：罚") and
            BestTarget:CanCast(HolyWordChastise)
            then
                BestTarget:Cast(HolyWordChastise)
                return
            end
            if
            HolyFire:Exists() and IsOptionEnabled("神圣之火") and Player:ManaPercentage() >= GetOptionValue("神圣之火") and
            BestTarget:CanCast(HolyFire)
            then
                BestTarget:Cast(HolyFire)
                return
            end
            if
            HolyNova:Exists() and HolyNovaUnits >= GetOptionValue("神圣新星") and
            Player:ManaPercentage() >= GetSecondOptionValue("神圣新星") and
            Player:CanCast(HolyNova)
            then
                Player:Cast(HolyNova)
                return
            end
            if Smite:Exists() and IsOptionEnabled("惩击") and BestTarget:CanCast(Smite) then
                BestTarget:Cast(Smite)
                return
            end
        end
    end
    if Player:IsInCombat() then
        if IsOptionEnabled("使用种族技能") then
            if RacialsUnits >= GetOptionValue("使用种族技能和饰品的单位数量") then
                if BloodFury:Exists() and Player:CanCast(BloodFury) then
                    Player:Cast(BloodFury)
                    return
                end
                if Berserking:Exists() and Player:CanCast(Berserking) then
                    CastSpellByID(26297, "player")
                    return
                end
            end
            if
            ArcaneTorrent:Exists() and Player:PowerPercentage() < GetOptionValue("使用种族技能") and
            Player:CanCast(ArcaneTorrent)
            then
                Player:Cast(ArcaneTorrent)
                return
            end
        end
        if IsOptionEnabled("使用饰品 1") and Trinket1:IsUsableInventory() then
            local Option1, Option2 = GetOptionValue("使用饰品 1"), GetSecondOptionValue("使用饰品 1")
            if
            Option1 == "无条件使用" or (Option1 == "血量" and Trinket1Units >= GetOptionValue("使用种族技能和饰品的单位数量")) or
            (Option1 == "蓝量" and Player:PowerPercentage() < GetSecondOptionValue("使用饰品 1"))
            then
                Trinket1:UseInventory()
            end
        end
        if IsOptionEnabled("使用饰品 2") and Trinket2:IsUsableInventory() then
            local Option1, Option2 = GetOptionValue("使用饰品 2"), GetSecondOptionValue("使用饰品 2")
            if
            Option1 == "无条件使用" or (Option1 == "血量" and Trinket2Units >= GetOptionValue("使用种族技能和饰品的单位数量")) or
            (Option1 == "蓝量" and Player:PowerPercentage() < GetSecondOptionValue("使用饰品 2"))
            then
                Trinket2:UseInventory()
            end
        end
        if GuardianSpirit:Exists() and IsOptionEnabled("守护之魂") then
            if MainTank and MainTank:HealthPercentage() <= GetOptionValue("守护之魂") and MainTank:CanCast(GuardianSpirit) then
                MainTank:Cast(GuardianSpirit)
                return
            elseif OffTank and OffTank:HealthPercentage() <= GetOptionValue("守护之魂") and OffTank:CanCast(GuardianSpirit) then
                OffTank:Cast(GuardianSpirit)
                return
            end
        end
        if
        DivineHymn:Exists() and IsOptionEnabled("神圣赞美诗") and Player:Standing() > 1 and Player:CanCast(DivineHymn) and
        DivineHymnUnits >= GetOptionValue("神圣赞美诗")
        then
            Player:Cast(DivineHymn)
            return
        end
        if Apotheosis:Exists() and ApotheosisUnits >= GetOptionValue("神圣化身") and Player:CanCast(Apotheosis) then
            Player:Cast(Apotheosis)
            return
        end
    end
    if Player:IsInCombat() or GetOptionValue("脱离战斗后暂停治疗") == "启用" then
        if CurrentBadDebuffs ~= nil then
            Player:DispelHandler(Purify, "驱散", DispelUnit, CurrentBadDebuffs.Dispel, "正常")
        end
        if
        AngelicFeather:Exists() and IsOptionEnabled("天堂之羽") and Player:Moving() > GetOptionValue("天堂之羽") and
        not IsFalling() and
        Player:BuffRemains(AngelicFeatherBuff) < 0.5 and
        Player:CanCast(AngelicFeather)
        then
            Player:Cast(AngelicFeather)
            return
        end
        if
        BodyAndMind:Exists() and IsOptionEnabled("身心合一") and Player:Moving() > GetOptionValue("身心合一") and
        not Player:Buff(BodyAndMind) and
        Player:CanCast(BodyAndMind)
        then
            Player:Cast(BodyAndMind)
            return
        end
        if IsOptionEnabled("紧急治疗") then
            MainTankHealth = MainTank and MainTank:CanCast(FlashHeal) and MainTank:SpecialHealthPercentage() or 100
            OffTankHealth = OffTank and OffTank:CanCast(FlashHeal) and OffTank:SpecialHealthPercentage() or 100
            BestTankTarget = MainTankHealth < OffTankHealth and MainTank or OffTank
            if BestTankTarget and BestTankTarget:SpecialHealthPercentage() < GetOptionValue("紧急治疗") then
                if LightOfTuure:Exists() and BestTankTarget:CanCast(LightOfTuure) then
                    Bug("Light of T'uure - Tanks Emergency")
                    BestTankTarget:Cast(LightOfTuure)
                    return
                elseif BestTankTarget:CanCast(HolyWordSerenity) then
                    Bug("Holy Word Serenity - Tanks Emergency")
                    BestTankTarget:Cast(HolyWordSerenity)
                    return
                elseif not Player:IsMoving() and BestTankTarget:CanCast(FlashHeal) then
                    Bug("Flash Heal - Tanks Emergency")
                    BestTankTarget:Cast(FlashHeal)
                    return
                end
            end
            if Player:SpecialHealthPercentage() < GetSecondOptionValue("紧急治疗") then
                if Player:CanCast(HolyWordSerenity) then
                    Bug("Holy Word Serenity - Player Emergency")
                    Player:Cast(HolyWordSerenity)
                    return
                elseif not Player:IsMoving() and Player:CanCast(FlashHeal) then
                    Bug("Flash Heal - Player Emergency")
                    Player:Cast(FlashHeal)
                    return
                end
            end
        end
        if LightOfTuure:Exists() and IsOptionEnabled("图雷之光") then
            if
            MainTank and MainTank:SpecialHealthPercentage() < GetOptionValue("图雷之光") and
            not MainTank:Buff(LightOfTuure) and
            MainTank:CanCast(LightOfTuure)
            then
                Bug("Light Of T'uure - MainTank")
                MainTank:Cast(LightOfTuure)
                return
            end
            if
            OffTank and OffTank:SpecialHealthPercentage() < GetOptionValue("图雷之光") and
            not OffTank:Buff(LightOfTuure) and
            OffTank:CanCast(LightOfTuure)
            then
                Bug("Light Of T'uure - OffTank")
                OffTank:Cast(LightOfTuure)
                return
            end
        end
        if HolyWordSerenity:Exists() and IsOptionEnabled("圣言术：静") then
            if
            MainTank and MainTank:SpecialHealthPercentage() < GetOptionValue("圣言术：静") and
            MainTank:CanCast(HolyWordSerenity)
            then
                Bug("Holy Word Serenity - MainTank")
                MainTank:Cast(HolyWordSerenity)
                return
            end
            if
            OffTank and OffTank:SpecialHealthPercentage() < GetOptionValue("圣言术：静") and
            OffTank:CanCast(HolyWordSerenity)
            then
                Bug("Holy Word Serenity - OffTank")
                OffTank:Cast(HolyWordSerenity)
                return
            end
            if
            Lowest and Lowest:SpecialHealthPercentage() < GetSecondOptionValue("圣言术：静") and
            Lowest:CanCast(HolyWordSerenity)
            then
                Bug("Holy Word Serenity - Lowest")
                Lowest:Cast(HolyWordSerenity)
                return
            end
        end
        if CircleOfHealing:Exists() and CoHUnit and CoHUnit:CanCast(CircleOfHealing) then
            CoHUnit:Cast(CircleOfHealing)
            return
        end
        if HolyWordSanctifyUnit and Player:CanCast(HolyWordSanctify) then
            HolyWordSanctifyUnit:Cast(HolyWordSanctify)
            return
        end
        if Player:IsInCombat() and PrayerOfMending:Exists() and IsOptionEnabled("愈合祷言 高优先") then
            if MainTank and MainTank:CanCast(PrayerOfMending) and MainTank:BuffCount(PrayerOfMendingBuff) <= 2 then
                MainTank:Cast(PrayerOfMending)
                return
            elseif OffTank and OffTank:CanCast(PrayerOfMending) and OffTank:BuffCount(PrayerOfMendingBuff) <= 2 then
                OffTank:Cast(PrayerOfMending)
                return
            elseif LowestForPoM and Lowest:CanCast(PrayerOfMending) then
                LowestForPoM:Cast(PrayerOfMending)
                return
            end
        end
        if Renew:Exists() and IsOptionEnabled("恢复") then
            if
            MainTank and MainTank:SpecialHealthPercentage() < GetOptionValue("恢复") and not MainTank:Buff(Renew) and
            MainTank:CanCast(Renew)
            then
                Bug("Renew - MainTank")
                MainTank:Cast(Renew)
                return
            end
            if
            OffTank and OffTank:SpecialHealthPercentage() < GetOptionValue("恢复") and not OffTank:Buff(Renew) and
            OffTank:CanCast(Renew)
            then
                Bug("Renew - OffTank")
                OffTank:Cast(Renew)
                return
            end
        end
        if Apotheosis:Exists() and Player:Buff(Apotheosis) then
            if IsOptionEnabled("神圣化身 圣言术：灵") and HolyWordSanctify:IsOnCooldown() and not Player:IsMoving() then
                if PrayerOfMending:Exists() and Piety:Exists() then
                    if MainTank and not MainTank:Buff(PrayerOfMendingBuff) and MainTank:CanCast(PrayerOfMending) then
                        Bug("Apotheosis - Prayer Of Mending MainTank")
                        MainTank:Cast(PrayerOfMending)
                        return
                    elseif OffTank and not OffTank:Buff(PrayerOfMendingBuff) and OffTank:CanCast(PrayerOfMending) then
                        Bug("Apotheosis - Prayer Of Mending OffTank")
                        OffTank:Cast(PrayerOfMending)
                        return
                    end
                end
                if PrayerOfHealing:Exists() and ApotheosisPoHUnit and ApotheosisPoHUnit:CanCast(PrayerOfHealing) then
                    ApotheosisPoHUnit:Cast(PrayerOfHealing)
                    return
                end
            end
            if IsOptionEnabled("神圣化身 圣言术：静") and HolyWordSerenity:IsOnCooldown() and not Player:IsMoving() then
                if FlashHeal:Exists() then
                    if
                    MainTank and MainTank:SpecialHealthPercentage() <= GetOptionValue("神圣化身 圣言术：静") and
                    MainTank:CanCast(FlashHeal)
                    then
                        Bug("Apotheosis - Flash Heal MainTank")
                        MainTank:Cast(FlashHeal)
                        return
                    end
                    if
                    OffTank and OffTank:SpecialHealthPercentage() <= GetOptionValue("神圣化身 圣言术：静") and
                    OffTank:CanCast(FlashHeal)
                    then
                        Bug("Apotheosis - Flash Heal OffTank")
                        OffTank:Cast(FlashHeal)
                        return
                    end
                    if
                    Lowest and Lowest:SpecialHealthPercentage() <= GetOptionValue("神圣化身 圣言术：静") and
                    Lowest:CanCast(FlashHeal)
                    then
                        Bug("Apotheosis - Flash Heal Lowest")
                        Lowest:Cast(FlashHeal)
                        return
                    end
                end
                if Heal:Exists() then
                    if
                    MainTank and MainTank:SpecialHealthPercentage() <= GetSecondOptionValue("神圣化身 圣言术：静") and
                    MainTank:CanCast(Heal)
                    then
                        Bug("Apotheosis - Heal MainTank")
                        MainTank:Cast(Heal)
                        return
                    end
                    if
                    OffTank and OffTank:SpecialHealthPercentage() <= GetSecondOptionValue("神圣化身 圣言术：静") and
                    OffTank:CanCast(Heal)
                    then
                        Bug("Apotheosis - Heal OffTank")
                        OffTank:Cast(Heal)
                        return
                    end
                    if
                    Lowest and Lowest:SpecialHealthPercentage() <= GetSecondOptionValue("神圣化身 圣言术：静") and
                    Lowest:CanCast(Heal)
                    then
                        Bug("Apotheosis - Heal Lowest")
                        Lowest:Cast(Heal)
                        return
                    end
                end
            end
        end
        if PrayerOfHealing:Exists() and IsOptionEnabled("治疗祷言") and PoHUnit and PoHUnit:CanCast(PrayerOfHealing) then
            PoHUnit:Cast(PrayerOfHealing)
            return
        end
        if FlashHeal:Exists() and IsOptionEnabled("快速治疗") and not Player:IsMoving() then
            if MainTank and MainTank:SpecialHealthPercentage() < GetOptionValue("快速治疗") and MainTank:CanCast(FlashHeal) then
                Bug("Flash Heal - MainTank")
                MainTank:Cast(FlashHeal)
                return
            end
            if OffTank and OffTank:SpecialHealthPercentage() < GetOptionValue("快速治疗") and OffTank:CanCast(FlashHeal) then
                Bug("Flash Heal - OffTank")
                OffTank:Cast(FlashHeal)
                return
            end
            if Lowest and Lowest:SpecialHealthPercentage() < GetSecondOptionValue("快速治疗") and Lowest:CanCast(FlashHeal) then
                Bug("Flash Heal - Lowest")
                Lowest:Cast(FlashHeal)
                return
            end
        end
        if FlashHeal:Exists() and Player:Buff(SurgeOfLight) and IsOptionEnabled("快速治疗 圣光涌动") and not Player:IsMoving() then
            if
            MainTank and MainTank:SpecialHealthPercentage() < GetOptionValue("快速治疗 圣光涌动") and
            MainTank:CanCast(FlashHeal)
            then
                Bug("Flash Heal Surge Of Light - MainTank")
                MainTank:Cast(FlashHeal)
                return
            end
            if
            OffTank and OffTank:SpecialHealthPercentage() < GetOptionValue("快速治疗 圣光涌动") and
            OffTank:CanCast(FlashHeal)
            then
                Bug("Flash Heal Surge Of Light - OffTank")
                OffTank:Cast(FlashHeal)
                return
            end
            if
            Lowest and Lowest:SpecialHealthPercentage() < GetSecondOptionValue("快速治疗 圣光涌动") and
            Lowest:CanCast(FlashHeal)
            then
                Bug("Flash Heal Surge Of Light - Lowest")
                Lowest:Cast(FlashHeal)
                return
            end
        end
        if PrayerOfMending:Exists() and MendingUnits >= GetOptionValue("愈合祷言") then
            if MainTank and MainTank:CanCast(PrayerOfMending) and not MainTank:Buff(PrayerOfMendingBuff) then
                MainTank:Cast(PrayerOfMending)
                return
            elseif OffTank and OffTank:CanCast(PrayerOfMending) and not OffTank:Buff(PrayerOfMendingBuff) then
                OffTank:Cast(PrayerOfMending)
                return
            end
        end
        if DivineStar:Exists() and DivineStarUnits >= GetOptionValue("神圣之星") and Player:CanCast(DivineStar) then
            Player:Cast(DivineStar)
            return
        end
        if Halo:Exists() and HaloUnits >= GetOptionValue("光晕") and Player:CanCast(Halo) then
            Player:Cast(Halo)
            return
        end
        if Renew:Exists() and IsOptionEnabled("坦克Debuffs") and CurrentBadDebuffs and #CurrentBadDebuffs.Tanks > 0 then
            local BestUnit, BestUnitHealth = nil, 100
            for i = 1, #CurrentBadDebuffs.Tanks do
                local ThisUnit, ThisUnitHealth =                 CurrentBadDebuffs.Tanks[i],
                CurrentBadDebuffs.Tanks[i]:SpecialHealthPercentage()
                if
                ThisUnit:CanCast(Renew) and not ThisUnit:Buff(Renew) and
                (BestUnit == nil or ThisUnitHealth < BestUnitHealth)
                then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth
                end
            end
            if BestUnit ~= nil and BestUnitHealth < GetOptionValue("坦克Debuffs") then
                Bug("Renew on " .. BestUnit:Name() .. " to heal tank debuff")
                BestUnit:Cast(Renew)
                return
            end
        end
        if Renew:Exists() and IsOptionEnabled("团队成员Debuffs") and CurrentBadDebuffs and #CurrentBadDebuffs.Debuff > 0 then
            local BestUnit, BestUnitHealth = nil, 100
            for i = 1, #CurrentBadDebuffs.Debuff do
                local ThisUnit, ThisUnitHealth =                 CurrentBadDebuffs.Debuff[i],
                CurrentBadDebuffs.Debuff[i]:SpecialHealthPercentage()
                if
                ThisUnit:CanCast(Renew) and not ThisUnit:Buff(Renew) and
                (BestUnit == nil or ThisUnitHealth < BestUnitHealth)
                then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth
                end
            end
            if BestUnit ~= nil and BestUnitHealth < GetOptionValue("团队成员Debuffs") then
                Bug("Renew on " .. BestUnit:Name() .. " to mitigate debuff")
                BestUnit:Cast(Renew)
                return
            end
        end
        if IsOptionEnabled("Topping") and CurrentBadDebuffs and #CurrentBadDebuffs.Top > 0 then
            local BestUnit, BestUnitHealth = nil, 100
            for i = 1, #CurrentBadDebuffs.Top do
                local ThisUnit, ThisUnitHealth =                 CurrentBadDebuffs.Top[i],
                CurrentBadDebuffs.Top[i]:SpecialHealthPercentage()
                if ThisUnit:CanCast(FlashHeal) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth
                end
            end
            if BestUnit ~= nil then
                if
                Renew:Exists() and BestUnitHealth <= GetOptionValue("Topping") and BestUnit:CanCast(Renew) and
                not BestUnit:Buff(Renew)
                then
                    Bug("Renew on " .. BestUnit:Name() .. " to top it")
                    BestUnit:Cast(Renew)
                    return
                end
                if FlashHeal:Exists() and BestUnitHealth <= GetOptionValue("Topping") and BestUnit:CanCast(FlashHeal) then
                    Bug("Flash Heal on " .. BestUnit:Name() .. " to top it")
                    BestUnit:Cast(FlashHeal)
                    return
                end
            end
        end
        if PrayerOfMending:Exists() and MendingUnits >= GetOptionValue("愈合祷言") then
            if Lowest and Lowest:CanCast(PrayerOfMending) and not Lowest:Buff(PrayerOfMendingBuff) then
                Lowest:Cast(PrayerOfMending)
                return
            end
        end
        if
        BindingHeal:Exists() and IsOptionEnabled("联结治疗") and
        Player:SpecialHealthPercentage() <= GetOptionValue("Binding Heal Player")
        then
            if MainTank and MainTank:HealthPercentage() <= GetOptionValue("联结治疗") and MainTank:CanCast(BindingHeal) then
                MainTank:Cast(BindingHeal)
                return
            elseif OffTank and OffTank:HealthPercentage() <= GetOptionValue("联结治疗") and OffTank:CanCast(BindingHeal) then
                OffTank:Cast(BindingHeal)
                return
            elseif
            Lowest and Lowest:SpecialHealthPercentage() <= GetOptionValue("联结治疗") and Lowest:CanCast(BindingHeal) and
            not Lowest:Equals(Player)
            then
                Lowest:Cast(BindingHeal)
                return
            end
        end
        if Renew:Exists() and IsOptionEnabled("恢复") then
            local BestUnit, BestUnitHealth = nil, 100
            for i = 1, #HealUnits do
                local ThisUnit, ThisUnitHealth = HealUnits[i], HealUnits[i]:SpecialHealthPercentage()
                if ThisUnitHealth <= BestUnitHealth and ThisUnit:CanCast(Renew) and ThisUnit:BuffRemains(Renew) < 3 then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth
                end
            end
            if BestUnit and BestUnitHealth <= GetSecondOptionValue("恢复") then
                Bug("Renew - Cycle")
                BestUnit:Cast(Renew)
                return
            end
        end
        if Heal:Exists() and IsOptionEnabled("治疗术") then
            if MainTank and MainTank:CanCast(Heal) and MainTank:SpecialHealthPercentage() <= GetSecondOptionValue("治疗术") then
                MainTank:Cast(Heal)
                return
            end
            if OffTank and OffTank:CanCast(Heal) and OffTank:SpecialHealthPercentage() <= GetSecondOptionValue("治疗术") then
                OffTank:Cast(Heal)
                return
            end
            if Lowest and Lowest:CanCast(Heal) and Lowest:SpecialHealthPercentage() <= GetOptionValue("治疗术") then
                Lowest:Cast(Heal)
                return
            end
        end
    end
    if Player:IsInCombat() or GetSecondOptionValue("脱离战斗后暂停治疗") == "启用" then
        if BestTarget and IsOptionEnabled("DPS") and GetSecondOptionValue("DPS") == "Low" and BestTarget:IsInCombat() then
            if
            HolyWordChastise:Exists() and IsOptionEnabled("圣言术：罚") and
            Player:ManaPercentage() >= GetOptionValue("圣言术：罚") and
            BestTarget:CanCast(HolyWordChastise)
            then
                BestTarget:Cast(HolyWordChastise)
                return
            end
            if
            HolyFire:Exists() and IsOptionEnabled("神圣之火") and Player:ManaPercentage() >= GetOptionValue("神圣之火") and
            BestTarget:CanCast(HolyFire)
            then
                BestTarget:Cast(HolyFire)
                return
            end
            if
            HolyNova:Exists() and HolyNovaUnits >= GetOptionValue("神圣新星") and
            Player:ManaPercentage() >= GetSecondOptionValue("神圣新星") and
            Player:CanCast(HolyNova)
            then
                Player:Cast(HolyNova)
                return
            end
            if Smite:Exists() and IsOptionEnabled("惩击") and BestTarget:CanCast(Smite) then
                BestTarget:Cast(Smite)
                return
            end
        end
    end
end
function Rotation:OutOfCombat()
    if
    IsOptionEnabled("天堂之羽") and AngelicFeather:Exists() and Player:Moving() > GetOptionValue("天堂之羽") and
    not IsFalling() and
    Player:BuffRemains(AngelicFeatherBuff) < 0.5 and
    Player:CanCast(AngelicFeather)
    then
        Player:Cast(AngelicFeather)
        return
    end
    if
    IsOptionEnabled("身心合一") and BodyAndMind:Exists() and Player:Moving() > GetOptionValue("身心合一") and
    not Player:Buff(BodyAndMind) and
    Player:CanCast(BodyAndMind)
    then
        Player:Cast(BodyAndMind)
        return
    end
    if IsOptionEnabled("自动进入战斗") and Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        local EngageSpell = Smite
        if EngageSpell:Exists() and Target:CanCast(EngageSpell) then
            Target:Cast(EngageSpell)
            return
        end
    end
    if IsOptionEnabled("脱离战斗后暂停治疗") then
        self:Combat()
    end
end
SetRotation(258, {})
local Rotation = Rotations[258]
function Rotation:Initialize()
    ArcaneTorrent = Spell(232633, false, false, true)
    Berserking = Spell(26297, false, false, true)
    BloodFury = Spell(33702, false, false, true)
    GiftOfTheNaaru = Spell(59544, false, false, true)
    AuspiciouSpirits = Spell(155271)
    BodyAndSoul = Spell(64129)
    BodyAndSoulBuff = Spell(65081)
    Death = Spell(32379, true, true, true)
    DeathReaper = Spell(199911, true, true, true)
    Dispersion = Spell(47585, false, false, true)
    Fade = Spell(586, false, false, true)
    FortressOfTheMind = Spell(193195)
    LegacyOfTheVoid = Spell(193225)
    LingeringInsanity = Spell(199849)
    Mindbender = Spell(200174, true, true, true)
    MindBlast = Spell(8092, true, true, false)
    MindFlay = Spell(15407, true, true, false)
    MindSear = Spell(48045, true, true, false)
    MindSpike = Spell(73510, true, true, false)
    Misery = Spell(238558)
    Pain = Spell(589, false, true, true)
    PowerInfusion = Spell(10060, false, false, true)
    PurifyDisease = Spell(213634, false, false, true)
    ReaperOfSouls = Spell(199853)
    Resurrection = Spell(2006, false, false, false, true)
    Sanlayn = Spell(199855)
    ShadowCrash = Spell(205385, false, true, true)
    ShadowMend = Spell(186263, false, false, false)
    Shadowfiend = Spell(34433, true, true, true)
    Shadowform = Spell(232698, false, false, true)
    ShadowWordPain = Spell(589, false, true, true)
    ShadowyInsight = Spell(162452)
    Shield = Spell(17, false, false, true)
    Silence = Spell(15487, true, true, true)
    SphereOfInsanity = Spell(194179)
    SurrenderToMadness = Spell(193223, false, false, true)
    TwistOfFateTalent = Spell(109142)
    TwistOfFate = Spell(123254)
    UnleashTheShadows = Spell(194093)
    VampiricEmbrace = Spell(15286, false, false, true)
    VampiricTouch = Spell(34914, false, true, false)
    Void = Spell(205351, true, true, false)
    VoidBolt = Spell(205448, true, true, true)
    VoidEruptionDamage = Spell(228260, true, true, true)
    VoidEruption = Spell(228260, false, false, true)
    Voidform = Spell(194249, false, false, true)
    VoidRay = Spell(205371)
    VoidRayBuff = Spell(205372)
    VoidTorrent = Spell(205065, true, true, false)
    MangazasMadness = Item(132864)
    BlessedDawnlightMedallion = Item(130234)
    BlessedDawnlightMedallionSpell = Spell(222275)
    ZeksExterminatus = Spell(236546)
    SephuzsSecret = Item(132452)
    KiljaedensBurningWish = Item(144259)
    RingOfCollapsingFutures = Item(142173)
    RingOfCollapsingFuturesCooldown = Spell(234143)
    LashOfInsanity = Spell(238137)
    SphereOfInsanity = Spell(194179)
    ToThePain = Spell(193644)
    TouchOfDarkness = Spell(194007)
    UnleashTheShadows = Spell(194093)
    VoidCorruption = Spell(194016)
    VoidBoltT19 = Spell(211657)
    AddPage("常规")
    AddPage("进攻")
    AddPage("防御")
    AddCommonOptions()
    AddPresetOption("常规", "Caster", nil, false)
    AddSection("常规", "移动", "Yellow")
    AddNewOption(
    "常规",
    "身心合一",
    220,
    true,
    { 1.5, 0, 10, 0.1 },
    nil,
    "Use Power Word: Shield on player for Body and Soul." ..
    C.TOOLTIP_VALUE .. "Time to wait when you start moving to use it.(In seconds)"
    )
    AddSection("常规", "Class", "Yellow")
    AddNewOption(
    "常规",
    "自动暗影形态",
    210,
    true,
    nil,
    nil,
    "Auto activate Shadowform." .. C.TOOLTIP_VALUE .. "Get into Shadowform if you are not in it already."
    )
    AddPresetOption("进攻")
    AddSection("进攻", "大技能", "Yellow")
    if Berserking:Exists() then
        AddNewOption(
        "进攻",
        "Berserking",
        232,
        true,
        { 2, "无条件使用", "自动", "Voidform only" },
        { 30, 1, 100, 1 },
        "Use Berserking." ..
        C.TOOLTIP_VALUE_1 ..
        "Choose the phase you want to use Berserking." ..
        C.TOOLTIP_SUBVALUE("无条件使用") ..
        "Use Berserking in- and outside of Voidform." ..
        C.TOOLTIP_SUBVALUE("自动") ..
        "Use Berserking automatically calculated by the CR." ..
        C.TOOLTIP_SUBVALUE("Voidform only") ..
        "Use Berserking in Voidform only at the chosen amount of voidform stacks." ..
        C.TOOLTIP_VALUE_2 .. "Use Berserking on X Stacks of Voidform."
        )
    end
    AddNewOption(
    "进攻",
    "摧心魔",
    223,
    true,
    { 15, 0, 100, 1 },
    { 2, "无条件使用", "大技能用法", "自动" },
    "Use Mindbender with >= 10 Void Form stacks. On cooldown if we have T18 2 pieces." ..
    C.TOOLTIP_VALUE_1 ..
    C.TOOLTIP_SUBVALUE("无条件使用", true) ..
    "Will use the ability even if CDs are disabled." ..
    C.TOOLTIP_SUBVALUE("大技能用法") ..
    "Will only use the ability if CDs are enabled." ..
    C.TOOLTIP_SUBVALUE("自动") .. "Automatic usage of Mindbender to stay longer in Voidform."
    )
    AddNewOption(
    "进攻",
    "暗影魔",
    223,
    true,
    { 15, 0, 100, 1 },
    { 1, "大技能用法", "S2M" },
    "Use Shadowfiend with chosen amount of Void Form stacks." ..
    C.TOOLTIP_VALUE_1 ..
    C.TOOLTIP_SUBVALUE("Cooldown only", true) ..
    "Will use the ability in Voidform at chosen amount of Voidform stacks." ..
    C.TOOLTIP_SUBVALUE("S2M") .. "Will use Shadowfiend only on S2M at chosen amount of stacks."
    )
    AddNewOption(
    "进攻",
    "能量灌注",
    223,
    true,
    { 18, 0, 100, 1 },
    { 2, "无条件使用", "大技能用法", "自动", "S2M" },
    "Use Power Infusion." ..
    C.TOOLTIP_VALUE_1 ..
    "Use Power Infusion with chosen amount of Voidform stacks with S2M or LotV." ..
    C.TOOLTIP_VALUE_2 ..
    C.TOOLTIP_SUBVALUE("无条件使用", true) ..
    "Will use the ability even if CDs are disabled." ..
    C.TOOLTIP_SUBVALUE("大技能用法") ..
    "Will only use the ability if CDs are enabled." ..
    C.TOOLTIP_SUBVALUE("自动") ..
    "Will only use the ability if CDs are enabled.\n Power Infusion will be used automatically by a mathematical formula to enlarge Voidform duration." ..
    C.TOOLTIP_SUBVALUE("S2M") ..
    "Only for Beta Rotation.\nUse Power Infusion on the minimum amount of Voidform Stacks set in the numeric field."
    )
    AddNewOption(
    "进攻",
    "虚空洪流",
    232,
    true,
    { 2, "无条件使用", "大技能用法" },
    { 35, 1, 100, 1 },
    "Use Void Torrent." ..
    C.TOOLTIP_VALUE_1 ..
    C.TOOLTIP_SUBVALUE("无条件使用", true) ..
    "Will use the ability even if CDs are disabled." ..
    C.TOOLTIP_SUBVALUE("大技能用法") ..
    "Will only use the ability if CDs are enabled." ..
    C.TOOLTIP_VALUE_2 .. "Used when Insanity fall under this threshold."
    )
    AddSection("进攻", "能力", "Yellow")
    AddNewOption(
    "进攻",
    "消散",
    232,
    true,
    { 1, "自动" },
    { 30, 1, 99, 1 },
    "Use Dispersion during Void Form." ..
    C.TOOLTIP_VALUE_1 ..
    "Dispersion usage mode." ..
    C.TOOLTIP_SUBVALUE("自动") ..
    "Automatic usage of Dispersion to stay longer in Voidform." ..
    C.TOOLTIP_VALUE_2 .. "Minimum Voidform stacks to use Dispersion."
    )
    AddNewOption(
    "进攻",
    "精神灼烧",
    222,
    true,
    { 5, 1, 99, 1 },
    { 5, 1, 99, 1 },
    "Use Mind Sear." ..
    C.TOOLTIP_VALUE ..
    "Amount of enemies that must be in 10 yards around your current target to skip Insanity generator spells and go on to Mind Sear.\nThe skip only happens when current target has Shadow Word: Pain on itself." ..
    C.TOOLTIP_VALUE_1 ..
    "Amount of Units around current target." ..
    C.TOOLTIP_VALUE_2 .. "Amount of Units around current target to use high prio Mind Sear."
    )
    AddNewOption(
    "进攻",
    "死亡倒计时与DoT",
    222,
    true,
    { 10, 0, 25, 0.5 },
    { 10, 0, 25, 0.5 },
    "Adjust the Time To Death Value. \nA value of 10 leads to only dotting units that live longer than 10 seconds." ..
    C.TOOLTIP_VALUE_1 ..
    "TTD for Target." ..
    C.TOOLTIP_VALUE_2 ..
    "TTD for Multi-Dot." ..
    C.TOOLTIP_HINT(
    "If this option is activated the CR won't dot Units dying in next chosen seconds. If you activate this option set the HP threshold for VT and SWP to 0, else the threshold will be another condition."
    )
    )
    AddNewOption(
    "进攻",
    "多目标 暗言术：痛",
    222,
    true,
    { 6, 1, 10, 1 },
    { 3, 0, 300, 0.1 },
    "Multi-Dot Shadow Word: Pain Cycle." ..
    C.TOOLTIP_VALUE_1 ..
    "Amount of dots to apply." .. C.TOOLTIP_VALUE_2 .. "Minimum health (in million) to apply."
    )
    AddNewOption(
    "进攻",
    "多目标 吸血鬼之触",
    222,
    true,
    { 4, 1, 10, 1 },
    { 3, 0, 300, 0.1 },
    "Multi-Dot Vampiric Touch Cycle." ..
    C.TOOLTIP_VALUE_1 ..
    "Amount of dots to apply." .. C.TOOLTIP_VALUE_2 .. "Minimum health (in million) to apply."
    )
    AddNewOption(
    "进攻",
    "虚空爆发",
    220,
    true,
    { 65, 65, 100, 1 },
    nil,
    "Void Eruption and Void Bolt options." ..
    C.TOOLTIP_VALUE .. "How much Insanity should we pool before using Void Eruption."
    )
    AddNewOption(
    "进攻",
    "虚空箭 模式",
    230,
    true,
    { 1, "目标", "焦点", "Lowest" },
    nil,
    "Which enemy shall be targeted by Void Bolt." ..
    C.TOOLTIP_VALUE_1 ..
    C.TOOLTIP_SUBVALUE("目标") ..
    "Will cast Void Bolt on the current target." ..
    C.TOOLTIP_SUBVALUE("焦点") ..
    "Will cast Void Bolt on the current focus. If there is no focus it will cast on target." ..
    C.TOOLTIP_SUBVALUE("Lowest") ..
    "Will cast Void Bolt on the unit with the lowest remaing time on Shadow Word: Pain and Vampiric Touch."
    )
    AddNewOption(
    "进攻",
    "暗影冲撞",
    232,
    true,
    { 2, "目标", "Target Standing", "Centered", "Centered Standing" },
    { 2, 1, 25, 1 },
    "Use Shadow Crash." ..
    C.TOOLTIP_VALUE_1 ..
    "Choose preferred mode." ..
    C.TOOLTIP_SUBVALUE("目标") ..
    "Always use on the current target." ..
    C.TOOLTIP_SUBVALUE("Target Standing") ..
    "Always use on the current target. Target must be standing still." ..
    C.TOOLTIP_SUBVALUE("Centered") ..
    "Use centered on a cluster of enemies." ..
    C.TOOLTIP_SUBVALUE("Centered Standing") ..
    "Use centered on a cluster of enemies. Enemies must be standing still." ..
    C.TOOLTIP_VALUE_2 ..
    "Amount of enemies that must be in the spell effect to use."
    )
    AddNewOption(
    "进攻",
    "暗言术：灭",
    132,
    true,
    { 1, "任何", "只有目标" },
    { 0, 0, 3, 0.1 },
    "Use Shadow Word: Death." ..
    C.TOOLTIP_VALUE_1 ..
    "On which targets should we use Shadow Word: Death." ..
    C.TOOLTIP_SUBVALUE("任何") ..
    "Use on Any target that is under health threshold. Priorise current target." ..
    C.TOOLTIP_SUBVALUE("目标") ..
    "Only use on current Target." ..
    C.TOOLTIP_VALUE_2 ..
    "How long before recharged to max charges should we use Shadow Word: Death without Insanity checks.\nOnly for S2M!" ..
    C.TOOLTIP_HINT(
    "Simcraft recommands using only with two charges. To do this, define recharge to 0."
    )
    )
    AddPresetOption("防御")
    AddSection("防御", "能力", "Yellow")
    AddNewOption(
    "防御",
    "防御 消散",
    220,
    true,
    { 30, 1, 100, 1 },
    nil,
    "Use Dispersion." ..
    C.TOOLTIP_VALUE .. "Health threshold." .. C.TOOLTIP_HINT("Never used during Surrender To Madness.")
    )
    AddNewOption(
    "防御",
    "渐隐术",
    220,
    true,
    { 70, 1, 100, 1 },
    nil,
    "Use Fade." ..
    C.TOOLTIP_VALUE ..
    "Health threshold." ..
    C.TOOLTIP_HINT(
    "Will only be used if we have high threat situation. Never used during Surrender To Madness."
    )
    )
    AddNewOption(
    "防御",
    "真言术：盾",
    220,
    true,
    { 50, 1, 100, 1 },
    nil,
    "Use Power Word: Shield on ourself." ..
    C.TOOLTIP_VALUE .. "Health threshold." .. C.TOOLTIP_HINT("Never used during Surrender To Madness.")
    )
    AddNewOption(
    "防御",
    "暗影愈合",
    222,
    true,
    { 25, 1, 100, 1 },
    { 85, 1, 100, 1 },
    "Use Shadow Mend on ouself." ..
    C.TOOLTIP_VALUE_1 ..
    "In Combat health threshold." ..
    C.TOOLTIP_VALUE_2 ..
    "Out of Combat health threshold." .. C.TOOLTIP_HINT("Never used during Surrender To Madness.")
    )
    if GiftOfTheNaaru:Exists() then
        AddNewOption(
        "防御",
        "纳鲁的赐福",
        220,
        true,
        { 40, 1, 100, 1 },
        nil,
        "Use Gift Of The Naaru on self." .. C.TOOLTIP_VALUE .. "Health threshold."
        )
    end
    AddSection("防御", "传奇物品", "Orange")
    AddNewOption(
    "防御",
    "塞弗斯的秘密",
    220,
    true,
    { 70, 1, 100, 1 },
    nil,
    "Use the Legendary Ring." ..
    C.TOOLTIP_VALUE ..
    "Apply Silence on the current Target at chosen amount of Voidform stacks to benefit from Ring proc."
    )
    AddNewOption(
    "防御",
    "祝福晨光垂饰",
    232,
    true,
    { 1, "Insanity", "血量" },
    { 30, 1, 100, 1 },
    "Use Blessed Dawnlight Medallion." ..
    C.TOOLTIP_VALUE_1 ..
    "Choose the ressource you want to gain." ..
    C.TOOLTIP_SUBVALUE("Insanity") ..
    "Use the Medallion on X Stacks of Voidform. Medallion will be used when you would run out of insanity if you are above the chosen Voidform stacks." ..
    C.TOOLTIP_SUBVALUE("血量") ..
    "Use the Medallion on X % Health to save you." ..
    C.TOOLTIP_VALUE_2 .. "Set the Stacks/Health%."
    )
    if VoidTorrent:Exists() then
        AddNewOption(
        "防御",
        "Arcane Torrent",
        232,
        true,
        { 1, "无条件使用", "Voidform only" },
        { 30, 1, 100, 1 },
        "Use Void Torrent." ..
        C.TOOLTIP_VALUE_1 ..
        "Choose the phase you want to use Arcane Torrent." ..
        C.TOOLTIP_SUBVALUE("Alwlays") ..
        "Use Arcane Torrent in- and outside of Voidform." ..
        C.TOOLTIP_SUBVALUE("Voidform only") ..
        "Use Arcane Torrent in Voidform only." ..
        C.TOOLTIP_VALUE_2 ..
        "Use Arcane Torrent on X Stacks of Voidform. Arcane Torrent will be used when you would run out of insanity if you are above the chosen Voidform stacks."
        )
    end
    AddOutput("狂乱值:")
    SetOutput("狂乱值:", string.format("%.1f", CurrentInsanityDrain or 0))
    ISCL = {
        [MindBlast:ID()] = "Mind Blast",
        [ShadowMend:ID()] = "暗影愈合",
        [VampiricTouch:ID()] = "Vampiric Touch",
        [Void:ID()] = "Shadow Word: Void",
        [VoidEruption:ID()] = "虚空爆发"
    }
    RegisterCommand(
    "mindbender",
    function()
        if Mindbender:Exists() then
            if ShouldMindbender == true then
                ShouldMindbender = false
                Bug("Mindbender Queue Canceled")
            elseif Mindbender:Cooldown() < 5 then
                ShouldMindbender = true
                Bug("Mindbender Queued")
            end
        else
            Bug("You do not have Mindbender talented.")
        end
    end
    )
end
function Rotation:Events()
    EventFrame:RegisterForCombatEvent(
    function(...)
        if GetSpecialization() == 3 then
            local Insanity_Bar_Voidform_Summary = false
            local Insanity_Bar_S2M_Summary = false
            local CurrentTime = GetTime()
            Voidform_Total_Stacks = Voidform_Total_Stacks or 0
            Voidform_Previous_Stack_Time = Voidform_Previous_Stack_Time or 0
            Voidform_Drain_Stacks = Voidform_Drain_Stacks or 0
            Voidform_VoidTorrent_Stacks = Voidform_VoidTorrent_Stacks or 0
            Voidform_Dispersion_Stacks = Voidform_Dispersion_Stacks or 0
            Insanity_Bar_LI_Last_Tick = Insanity_Bar_LI_Last_Tick or 0
            Insanity_Bar_LI_Last_Count = Insanity_Bar_LI_Last_Count or 0
            Voidform_Current_Drain_Rate = Voidform_Current_Drain_Rate or 0
            if Voidform_Total_Stacks >= 100 then
                if (CurrentTime - Voidform_Previous_Stack_Time) >= 1 then
                    Voidform_Previous_Stack_Time = CurrentTime
                    Voidform_Total_Stacks = Voidform_Total_Stacks + 1
                    if Voidform_VoidTorrent_Start == nil and Voidform_Dispersion_Start == nil then
                        Voidform_Drain_Stacks = Voidform_Drain_Stacks + 1
                    elseif Voidform_VoidTorrent_Start ~= nil then
                        Voidform_VoidTorrent_Stacks = Voidform_VoidTorrent_Stacks + 1
                    else
                        Voidform_Dispersion_Stacks = Voidform_Dispersion_Stacks + 1
                    end
                end
            end
            local SpellID = select(12, ...)
            local DestGUID = select(8, ...)
            local SrcGUID = select(4, ...)
            local Type = select(2, ...)
            if SrcGUID == Player:GUID() then
                if SpellID == 194249 then
                    if Type == "SPELL_AURA_APPLIED" then
                        Voidform_Previous_Stack_Time = CurrentTime
                        Voidform_VoidTorrent_Start = nil
                        Voidform_Dispersion_Start = nil
                        Voidform_Drain_Stacks = 1
                        Voidform_Start_Time = CurrentTime
                        Voidform_Total_Stacks = 1
                        Voidform_VoidTorrent_Stacks = 0
                        Voidform_Dispersion_Stacks = 0
                    elseif Type == "SPELL_AURA_APPLIED_DOSE" then
                        Voidform_Previous_Stack_Time = CurrentTime
                        Voidform_Total_Stacks = Voidform_Total_Stacks + 1
                        if Voidform_VoidTorrent_Start == nil and Voidform_Dispersion_Start == nil then
                            Voidform_Drain_Stacks = Voidform_Drain_Stacks + 1
                        elseif Voidform_VoidTorrent_Start ~= nil then
                            Voidform_VoidTorrent_Stacks = Voidform_VoidTorrent_Stacks + 1
                        else
                            Voidform_Dispersion_Stacks = Voidform_Dispersion_Stacks + 1
                        end
                    elseif Type == "SPELL_AURA_REMOVED" then
                        if Insanity_Bar_Voidform_Summary == true then
                            print("Voidform Info:")
                            print("--------------------------")
                            print(
                            string.format(
                            "Voidform Duration: %.2f seconds",
                            (CurrentTime - Voidform_Start_Time)
                            )
                            )
                            if Voidform_Total_Stacks > 100 then
                                print(string.format("Voidform Stacks: 100 (+%.0f)", (Voidform_Total_Stacks - 100)))
                            else
                                print(string.format("Voidform Stacks: %.0f", Voidform_Total_Stacks))
                            end
                            print(string.format("Dispersion Stacks: %.0f", Voidform_Dispersion_Stacks))
                            print(string.format("Void Torrent Stacks: %.0f", Voidform_VoidTorrent_Stacks))
                            print(
                            string.format(
                            "Final Drain: %.0f stacks; %.1f / sec",
                            Voidform_Drain_Stacks,
                            (6 + ((Voidform_Drain_Stacks - 1) * (2 / 3)))
                            )
                            )
                        end
                        Voidform_VoidTorrent_Start = nil
                        Voidform_Dispersion_Start = nil
                        Voidform_Drain_Stacks = 0
                        Voidform_Start_Time = nil
                        Voidform_Total_Stacks = 0
                        Voidform_VoidTorrent_Stacks = 0
                        Voidform_Dispersion_Stacks = 0
                    end
                elseif SpellID == 205065 then
                    if Type == "SPELL_AURA_APPLIED" then
                        Voidform_VoidTorrent_Start = CurrentTime
                    elseif Type == "SPELL_AURA_REMOVED" and Voidform_VoidTorrent_Start ~= nil then
                        Voidform_VoidTorrent_Start = nil
                    end
                elseif SpellID == 47585 then
                    if Type == "SPELL_AURA_APPLIED" then
                        Voidform_Dispersion_Start = CurrentTime
                    elseif Type == "SPELL_AURA_REMOVED" and Voidform_Dispersion_Start ~= nil then
                        Voidform_Dispersion_Start = nil
                    end
                elseif SpellID == 212570 then
                    if Type == "SPELL_AURA_APPLIED" then
                        Voidform_S2M_Activated = true
                        Voidform_S2M_Start = CurrentTime
                    end
                end
            elseif
            DestGUID == Player:GUID() and
            (Type == "UNIT_DIED" or Type == "UNIT_DESTROYED" or Type == "SPELL_INSTAKILL") and
            Voidform_S2M_Activated == true
            then
                Voidform_S2M_Activated = false
                if Insanity_Bar_S2M_Summary == true then
                    print("Surrender to Madness Info:")
                    print("--------------------------")
                    print(string.format("S2M Duration: %.2f seconds", (CurrentTime - Voidform_S2M_Start)))
                    print(string.format("Voidform Duration: %.2f seconds", (CurrentTime - Voidform_Start_Time)))
                    if WA_Voidform_Total_Stacks > 100 then
                        print(string.format("Voidform Stacks: 100 (+%.0f)", (Voidform_Total_Stacks - 100)))
                    else
                        print(string.format("Voidform Stacks: %.0f", Voidform_Total_Stacks))
                    end
                    print(string.format("Dispersion Stacks: %.0f", Voidform_Dispersion_Stacks))
                    print(string.format("Void Torrent Stacks: %.0f", Voidform_VoidTorrent_Stacks))
                    print(
                    string.format(
                    "Final Drain: %.0f stacks",
                    Voidform_Drain_Stacks,
                    (6 + ((Voidform_Drain_Stacks - 1) * (2 / 3)))
                    )
                    )
                end
                Voidform_S2M_Start = nil
                Voidform_VoidTorrent_Start = nil
                Voidform_Dispersion_Start = nil
                Voidform_Drain_Stacks = 0
                Voidform_Start_Time = nil
                Voidform_Total_Stacks = 0
                Voidform_VoidTorrent_Stacks = 0
                Voidform_Dispersion_Stacks = 0
            end
            local Insanity_Drain =             Player:Buff(Voidform) and math.round(6 + ((Voidform_Drain_Stacks - 1) * (2 / 3)), 1) or 0
            CurrentInsanityDrain =             Insanity_Drain *
            (SurrenderToMadness:Exists() and (Player:Buff(SurrenderToMadness) and 0.95 or 0.9) or 1)
            SetOutput("狂乱值:", string.format("%.1f", CurrentInsanityDrain or 0))
        end
    end,
    "SPELL_AURA_APPLIED",
    "SPELL_AURA_APPLIED_DOSE",
    "SPELL_AURA_REMOVED",
    "UNIT_DIED",
    "UNIT_DESTROYED",
    "SPELL_INSTAKILL"
    )
    EventFrame:RegisterForSelfCombatEvent(
    function(...)
        if select(12, ...) == 194249 then
            if select(2, ...) == "SPELL_AURA_APPLIED" then
                VoidFormStarted = GetTime()
                Bug("Void Form Started " .. VoidFormStarted)
            else
                VoidFormStarted = nil
                Bug("Void Form Ended")
            end
        end
    end,
    "SPELL_AURA_APPLIED",
    "SPELL_AURA_REMOVED"
    )
    EventFrame:RegisterForCombatEvent(
    function(...)
        if select(8, ...) == C.PLAYERGUID then
            VoidFormStarted = nil
            Bug("Void Form Ended")
        end
    end,
    "UNIT_DIED"
    )
end
function Rotation:Pulse()
    CurrentInsanityDrain = Player:Buff(Voidform) and CurrentInsanityDrain or 0
    Insanity = Player:Insanity() or 0
    if Player:IsMounted() or Player:InVehicle() or Player:IsEating() or Player:Channeling(VoidTorrent) then
        return
    end
    if Target:Exists() and BMPullTime() < 5 then
        self:Opening()
        return
    end
    if GetTime() < Rotation.SpamPrevention then
        return
    end
    Rotation.SpamPrevention = GetTime() + 0.05
    Target = Unit.Target
    local InCombat = Player:IsInCombat()
    if not InCombat then
        self:OutOfCombat()
        return
    end
    if InCombat then
        self:Defensives()
    end
    Target = Player:ReTarget(MindBlast, false) or Unit.Target
    if Target:Exists() then
        Rotations:RefreshUnitTables(Rotation.Identifier)
        self:Interrupts()
        if
        IsOptionEnabled("开怪技能") and
        (GetOptionValue("开怪技能") == "无条件使用" or (GetOptionValue("开怪技能") == "打BOSS使用" and Target:IsBoss()) or
        (GetOptionValue("开怪技能") == "CDs Only" and CooldownsAllowed())) and
        not OpenerEnded
        then
            self:Opener()
            return
        elseif CombatTime() > 10 then
            OpenerEnded = true
        end
        self:OffGCDAbilities()
        if Player:GlobalCooldown() == 0 then
            self:Combat()
        end
    end
end
function Rotation:Opening()
    Player:UsePotions("智力药水", GetSecondOptionValue("抢先使用药水"))
    if
    IsOptionEnabled("抢先施放(需DBM插件)") and
    (GetOptionValue("抢先施放(需DBM插件)") == "无条件使用" or
    (GetOptionValue("抢先施放(需DBM插件)") == "打BOSS使用" and Target:IsBoss()))
    then
        if MindBlast:Exists() and BMPullTime() < GetSecondOptionValue("抢先施放(需DBM插件)") and Target:CanCast(MindBlast) then
            Target:Cast(MindBlast)
            return
        end
    end
end
function Rotation:Opener()
    self.ChoosenOpener = nil
    if self.ChoosenOpener ~= nil then
        OpenerParser(self.ChoosenOpener)
    else
        Bug("Invalid Talents combination, Opener will not be used.")
        OpenerEnded = true
    end
end
function Rotation:Defensives()
    Player:UseHealingItem()
    if not Player:Buff(SurrenderToMadness) then
        if
        Dispersion:Exists() and IsOptionEnabled("防御 消散") and Player:HealthPercentage() <= GetOptionValue("防御 消散") and
        Player:CanCast(Dispersion)
        then
            SpellStopCasting()
            Player:Cast(Dispersion)
            return
        end
        if
        Fade:Exists() and IsOptionEnabled("渐隐术") and Target:Exists() and Player:ThreatSituation() == 3 and
        Player:HealthPercentage() <= GetOptionValue("渐隐术") and
        Player:CanCast(Fade)
        then
            Player:Cast(Fade)
            return
        end
        if
        ShadowMend:Exists() and IsOptionEnabled("暗影愈合") and Player:HealthPercentage() <= GetOptionValue("暗影愈合") and
        Player:CanCast(ShadowMend)
        then
            Player:Cast(ShadowMend)
            return
        end
        if
        Shield:Exists() and IsOptionEnabled("真言术：盾") and not Player:BuffAny(Shield) and
        Player:HealthPercentage() <= GetOptionValue("真言术：盾") and
        Player:CanCast(Shield)
        then
            Player:Cast(Shield)
            return
        end
    end
    if
    GiftOfTheNaaru:Exists() and IsOptionEnabled("纳鲁的赐福") and Player:HealthPercentage() <= GetOptionValue("纳鲁的赐福") and
    Player:CanCast(GiftOfTheNaaru)
    then
        Player:Cast(GiftOfTheNaaru)
        return
    end
end
function Rotation:Interrupts()
    Player:UseInterrupt(Silence, ArcaneTorrent)
end
function Rotation:OffGCDAbilities()
    if
    Berserking:Exists() and CooldownsAllowed() and IsOptionEnabled("Berserking") and
    (GetOptionValue("Berserking") == "无条件使用" or
    (GetOptionValue("Berserking") == "Voidform only" and Player:Buff(Voidform) and
    Player:BuffCount(Voidform) >= GetSecondOptionValue("Berserking"))) and
    Player:CanCast(Berserking)
    then
        Player:Cast(Berserking)
    end
    if
    BlessedDawnlightMedallion:IsEquipped(2) and IsOptionEnabled("祝福晨光垂饰") and
    Player:CanCast(BlessedDawnlightMedallionSpell)
    then
        if
        GetOptionValue("祝福晨光垂饰") == "Insanity" and Player:BuffCount(Voidform) >= GetSecondOptionValue("祝福晨光垂饰") and
        (Insanity - CurrentInsanityDrain * GCDMax) <= 10
        then
            Player:Cast(BlessedDawnlightMedallionSpell)
        end
        if GetOptionValue("祝福晨光垂饰") == "血量" and Player:Health() <= GetSecondOptionValue("祝福晨光垂饰") then
            Player:Cast(BlessedDawnlightMedallionSpell)
        end
    end
    if
    PowerInfusion:Exists() and CooldownsAllowed() and Player:Buff(Voidform) and IsOptionEnabled("能量灌注") and
    GetSecondOptionValue("能量灌注") == "大技能用法" and
    Player:BuffCount(Voidform) > GetOptionValue("能量灌注") and
    Player:CanCast(PowerInfusion)
    then
        Player:Cast(PowerInfusion)
    end
    if
    ArcaneTorrent:Exists() and CooldownsAllowed() and IsOptionEnabled("Arcane Torrent") and
    (GetOptionValue("Arcane Torrent") == "无条件使用" or
    GetOptionValue("Arcane Torrent") == "Voidform only" and Player:Buff(Voidform)) and
    Insanity <= GetSecondOptionValue("Arcane Torrent") and
    Player:CanCast(ArcaneTorrent)
    then
        Player:Cast(ArcaneTorrent)
    end
    if
    Silence:Exists() and SephuzsSecret:IsEquipped(11, 12) and SephuzsSecret:Cooldown() <= 0 and
    IsOptionEnabled("塞弗斯的秘密") and
    GetOptionValue("塞弗斯的秘密") > Player:BuffCount(Voidform) and
    Target:CanCast(Silence)
    then
        Target:Cast(Silence)
    end
    if Player:BuffCount(Voidform) >= 0 then
        if
        RingOfCollapsingFutures:IsEquipped(11) and RingOfCollapsingFutures:Cooldown() <= 0 and
        not Player:Debuff(RingOfCollapsingFuturesCooldown) and
        Item(11):UseInventory()
        then
            Item(11):UseInventory()
        end
        if
        RingOfCollapsingFutures:IsEquipped(12) and RingOfCollapsingFutures:Cooldown() <= 0 and
        not Player:Debuff(RingOfCollapsingFuturesCooldown) and
        Item(12):UseInventory()
        then
            Item(12):UseInventory()
        end
    end
end
function Rotation:MindFillers()
    if
    MindSear:Exists() and not Player:IsMoving() and UseAOE() and IsOptionEnabled("精神灼烧") and
    NumEnemies10y >= GetOptionValue("精神灼烧") and
    not Player:Channeling(MindSear) and
    Target:CanCast(MindSear)
    then
        Target:Cast(MindSear)
        return
    elseif
    not (MindSear:Exists() and IsOptionEnabled("精神灼烧") and NumEnemies10y >= GetOptionValue("精神灼烧") and
    not Player:IsMoving() and
    Player:Channeling(MindSear))
    then
        if not MindSpike:Exists() then
            if not Player:Channeling(MindFlay) and Target:CanCast(MindFlay) then
                Target:Cast(MindFlay)
                return
            end
        else
            if Target:CanCast(MindSpike) then
                Target:Cast(MindSpike)
                return
            end
        end
    end
end
function Rotation:GetMindSearValue(factor, priority)
    if factor == nil or priority == nil or Target:DebuffRemains(Pain) <= 0 or not IsOptionEnabled("精神灼烧") then
        return 9999
    end
    if priority == 1 then
        return (factor * GetOptionValue("精神灼烧"))
    elseif priority == 2 then
        return (factor * GetSecondOptionValue("精神灼烧"))
    else
        return 9999
    end
end
function Rotation:ShadowWordDeath()
    if Player:Buff(ZeksExterminatus) and Target:CanCast(Death) then
        Bug("Shadow Word: Death at " .. Insanity .. " Insanity")
        Target:Cast(Death)
        return
    end
    if Target:HealthPercentage() < DeathThreshold and Target:CanCast(Death) then
        Bug("Shadow Word: Death at " .. Insanity .. " Insanity")
        Target:Cast(Death)
        return
    end
    if GetOptionValue("暗言术：灭") == "任何" then
        if DeathUnit and DeathUnit:CanCast(Death, true, true) then
            Bug("Shadow Word: Death at " .. Insanity .. " Insanity")
            DeathUnit:Cast(Death)
            return
        end
    end
end
function Rotation:VoidBoltCycle2()
    if GetOptionValue("虚空箭 模式") == "目标" then
        if Target:CanCast(VoidBolt) then
            Target:Cast(VoidBolt)
            return
        end
    end
    if GetOptionValue("虚空箭 模式") == "焦点" then
        if Focus:Exists() and Focus:CanCast(VoidBolt) then
            Focus:Cast(VoidBolt)
            return
        end
    end
    if GetOptionValue("虚空箭 模式") == "Lowest" then
        local ThisUnit, BestUnit = nil, nil
        local BestUnitSWP, BestUnitVT = 0, 0
        for i = 1, #Enemies do
            ThisUnit = Enemies[i]
            if
            Player:IsFacing(ThisUnit) and ThisUnit:Debuff(Pain) and
            ThisUnit:DebuffRemains(Pain) > VoidBolt:TravelTime() and
            ThisUnit:CanCast(VoidBolt)
            then
                if
                BestUnit == nil or
                (ThisUnit:DebuffRemains(VampiricTouch) < BestUnitVT and
                ThisUnit:DebuffRemains(VampiricTouch) > VoidBolt:TravelTime()) or
                ThisUnit:DebuffRemains(Pain) < BestUnitSWP
                then
                    BestUnit, BestUnitSWP, BestUnitVT =                     ThisUnit,
                    ThisUnit:DebuffRemains(Pain),
                    ThisUnit:DebuffRemains(VampiricTouch)
                end
            end
        end
        if BestUnit and BestUnit:CanCast(VoidBolt) then
            if Target:DistanceTo(BestUnit) <= 8 and Target:CanCast(VoidBolt) then
                Target:Cast(VoidBolt)
                return true
            else
                BestUnit:Cast(VoidBolt)
                return true
            end
        end
    end
    if Target:CanCast(VoidBolt) then
        Target:Cast(VoidBolt)
        return true
    end
end
function Rotation:TTDOption(TargetMulti, GCDAmount)
    if IsOptionEnabled("死亡倒计时与DoT") then
        if GetOptionValue("Time To Death Mode") == "Manual" then
            if TargetMulti == "目标" then
                return GetOptionValue("死亡倒计时与DoT")
            else
                return GetSecondOptionValue("死亡倒计时与DoT")
            end
        elseif GetOptionValue("Time To Death Mode") == "自动" then
            return GCDAmount * GCDMax
        end
    else
        return 0
    end
end
function Rotation:DotRefreshUnit(
TheseUnits,
Spell,
Debuff,
RemainingDuration,
OptionName,
AlsoApply,
TTDCheck,
IgnoreMaxTargets)
    local MinHealth = GetSecondOptionValue(OptionName) * 1000000 or 0
    local BestUnit, BestUnitHealth, BestUnitDuration
    local DebuffsCount = 0
    for i = 1, #TheseUnits do
        local ThisUnit = TheseUnits[i]
        local ThisUnitHealth, ThisUnitDuration = ThisUnit:Health(), ThisUnit:DebuffRemains(Debuff)
        DebuffsCount =         ThisUnitDuration ~= 0 and ThisUnitDuration > RemainingDuration and DebuffsCount + 1 or DebuffsCount
        if
        (ThisUnit:Debuff(Debuff) or AlsoApply) and ThisUnit:IsInCombat() and ThisUnit:Exists() and
        not ThisUnit:IsHardBlacklisted() and
        not ThisUnit:IsCrowdControlled() and
        Player:CanAttack(ThisUnit) and
        Player:IsWithinCastRange(ThisUnit, Spell) and
        ThisUnitHealth >= MinHealth and
        ThisUnitDuration <= RemainingDuration and
        ((ThisUnit:TimeToDie() > RemainingDuration and ThisUnit:TimeToDie() > GetOptionValue("死亡倒计时与DoT")) or
        not TTDCheck) and
        ThisUnit:CanCast(Spell, false, false, false, true)
        then
            BestUnit, BestUnitHealth, BestUnitDuration = ThisUnit, ThisUnitHealth, ThisUnitDuration
        end
    end
    if IgnoreMaxTargets then
        return BestUnit
    end
    return DebuffsCount < GetOptionValue(OptionName) and BestUnit or nil
end
function Rotation:UnitTables()
    Enemies = UseAOE() and Player:EnemiesWithinDistance(40) or {}
    Enemies_10y = UseAOE() and Target:EnemiesWithinDistance(10) or {}
    NumEnemies10y = #Enemies_10y
    PainUnit18 = self:DotRefreshUnit(Enemies, Pain, Pain, 18, "多目标 暗言术：痛", true, true)
    PainUnitMoving = self:DotRefreshUnit(Enemies, Pain, Pain, 3 + (4 / 3), "多目标 暗言术：痛", true, false, true)
    PainUnitGCD = self:DotRefreshUnit(Enemies, Pain, Pain, Player:GCD(), "多目标 暗言术：痛", true, true)
    PainUnitMain = self:DotRefreshUnit(Enemies, Pain, Pain, 3 + (4 / 3), "多目标 暗言术：痛", true, true)
    VampUnit24 = self:DotRefreshUnit(Enemies, VampiricTouch, VampiricTouch, 24, "多目标 吸血鬼之触", true, true)
    VampUnit3GCD = self:DotRefreshUnit(Enemies, VampiricTouch, VampiricTouch, 3 * Player:GCD(), "多目标 吸血鬼之触", true, true)
    VampUnitMain = self:DotRefreshUnit(Enemies, VampiricTouch, VampiricTouch, 4 + (4 / 3), "多目标 吸血鬼之触", true, true)
    DeathThreshold = ReaperOfSouls:Exists() and 35 or 20
    DeathUnit = Unit.LightEnemyAvailableForSpellHP(Enemies, Death, DeathThreshold)
end
function Rotation:Combat()
    local TTDTarget = IsOptionEnabled("死亡倒计时与DoT") and GetOptionValue("死亡倒计时与DoT") or 0
    local TTDMultiDot = IsOptionEnabled("死亡倒计时与DoT") and GetSecondOptionValue("死亡倒计时与DoT") or 0
    T20_4pc = select(2, Player:HasTier("T20"))
    GCDMax = Player:GCD()
    local cd_time =     (10 + ((2 - (Mindbender:Exists() and T20_4pc and 2 or 0)) * (HasT19_2Pc and 1 or 0)) +
    (MangazasMadness:IsEquipped(6) and (3 - (Mindbender:Exists() and T20_4pc and 3 or 0)) or 0) +
    (T20_4pc and (6 + (Mindbender:Exists() and 5 or 0)) or 0) +
    2 * LashOfInsanity:ArtifactRank())
    local dot_swp_dpgcd = 38 * 1.2 * (1 + 0.06 * ToThePain:ArtifactRank()) * (1 + 0.2 + Player:MasteryEffect()) * 0.75
    local dot_vt_dpgcd =     71 * 1.2 * (1 + (Sanlayn:Exists() and 0.2 or 0)) * (1 + 0.05 * TouchOfDarkness:ArtifactRank()) *
    (1 + 0.2 + Player:MasteryEffect()) *
    0.5
    local sear_dpgcd = 80 * (1 + 0.05 * VoidCorruption:ArtifactRank())
    CurrentInsanityDrain = CurrentInsanityDrain or 0
    SetOutput("狂乱值:", string.format("%.1f", CurrentInsanityDrain or 0))
    if
    not Player:Buff(Shadowform) and IsOptionEnabled("自动暗影形态") and not Player:Buff(Voidform) and
    Player:CanCast(Shadowform)
    then
        Bug("自动暗影形态")
        Player:Cast(Shadowform)
        return
    end
    if Target:Exists() and Player:CanAttack(Target) then
        if Mindbender:Exists() and ShouldMindbender == true then
            if Mindbender:Cooldown() > 6 then
                ShouldMindbender = false
            else
                if Target:CanCast(Mindbender) then
                    Target:Cast(Mindbender)
                    return
                end
            end
        end
        if Player:IsWithinCastRange(Target, MindBlast) then
            Player:UseTrinkets()
        end
        if
        not Player:Buff(SurrenderToMadness) and BodyAndSoul:Exists() and IsOptionEnabled("身心合一") and
        Player:Moving() > GetOptionValue("身心合一") and
        not Player:Buff(BodyAndSoulBuff) and
        Player:CanCast(Shield)
        then
            Player:Cast(Shield)
            return
        end
        if Player:Buff(Voidform) and Player:Buff(SurrenderToMadness) then
            if Player:Buff(VoidBoltT19) and CurrentInsanityDrain < 10 and T20_4pc then
                self:VoidBoltCycle2()
            end
            if Player:Buff(ZeksExterminatus) and CurrentInsanityDrain * GCDMax <= Insanity and Target:CanCast(Death) then
                self:ShadowWordDeath()
                return
            end
            if ShadowCrash:Exists() and IsOptionEnabled("暗影冲撞") and Target:CanCast(ShadowCrash) then
                if Target:CastGroundSpell(ShadowCrash, "暗影冲撞", 8) then
                    return
                end
            end
            if
            Mindbender:Exists() and IsOptionEnabled("摧心魔") and
            (CooldownsAllowed() or GetSecondOptionValue("摧心魔") == "无条件使用") and
            Death:Cooldown() == 0 and
            Player:BuffCount(Voidform) > (45 + (T20_4pc and 25 or 0)) and
            Target:CanCast(Mindbender)
            then
                Target:Cast(Mindbender)
                return
            end
            if
            IsOptionEnabled("进攻性种族技能") and (CooldownsAllowed() or GetOptionValue("进攻性种族技能") == "无条件使用") and
            Player:BuffCount(Voidform) >= 65
            then
                if ArcaneTorrent:Exists() and CurrentInsanityDrain * GCDMax > Insanity and Player:CanCast(ArcaneTorrent) then
                    Player:Cast(ArcaneTorrent)
                    return
                end
                if BloodFury:Exists() and Player:CanCast(BloodFury) then
                    Player:Cast(BloodFury)
                end
                if Berserking:Exists() and Player:CanCast(Berserking) then
                    Player:Cast(Berserking)
                end
            end
            if
            Death:Exists() and CurrentInsanityDrain * GCDMax > Insanity and
            ((Insanity - (CurrentInsanityDrain * GCDMax) + (30 + (ReaperOfSouls:Exists() and 30 or 0))) < 100)
            then
                self:ShadowWordDeath()
                return
            end
            if
            PowerInfusion:Exists() and IsOptionEnabled("能量灌注") and
            ((GetSecondOptionValue("能量灌注") == "S2M" and Player:BuffCount(Voidform) >= GetOptionValue("能量灌注")) or
            GetSecondOptionValue("能量灌注") == "无条件使用" or
            CooldownsAllowed()) and
            Death:Charges() == 0 and
            Player:BuffCount(Voidform) > (45 + (T20_4pc and 25 or 0)) or
            Target:TimeToDie() <= 30 and Player:CanCast(PowerInfusion)
            then
                Player:Cast(PowerInfusion)
            end
            if Target:CanCast(VoidBolt) then
                self:VoidBoltCycle2()
            end
            if
            Death:Exists() and
            (#Enemies_10y <= self:GetMindSearValue(1, 1) or
            (ReaperOfSouls:Exists() and #Enemies_10y <= self:GetMindSearValue(0.5, 1))) and
            CurrentInsanityDrain * GCDMax > Insanity and
            (Insanity - (CurrentInsanityDrain * GCDMax) + (30 + (ReaperOfSouls:Exists() and 30 or 0))) < 100
            then
                self:ShadowWordDeath()
            end
            if VoidBolt:Cooldown() < GCDMax * 0.28 then
                Bug("Void Bolt in " .. VoidBolt:Cooldown())
                return
            end
            if Player:Buff(ZeksExterminatus) and Target:CanCast(Death) then
                self:ShadowWordDeath()
                return
            end
            if
            Dispersion:Exists() and IsOptionEnabled("消散") and CurrentInsanityDrain * GCDMax > Insanity and
            not Player:Buff(PowerInfusion) or
            (Player:BuffCount(Voidform) > 76 and Death:Charges() == 0 and
            CurrentInsanityDrain * GCDMax > Insanity) and
            Player:CanCast(Dispersion)
            then
                Player:Cast(Dispersion)
                return
            end
            if MindBlast:Exists() and #Enemies_10y <= self:GetMindSearValue(1, 1) and Target:CanCast(MindBlast) then
                Target:Cast(MindBlast)
                return
            end
            if MindBlast:Cooldown() < GCDMax * 0.28 and #Enemies_10y <= self:GetMindSearValue(1, 1) then
                Bug("Mind Blast in " .. MindBlast:Cooldown())
                return
            end
            if
            Death:Exists() and
            (#Enemies_10y <= self:GetMindSearValue(1, 1) or
            (ReaperOfSouls:Exists() and #Enemies_10y <= self:GetMindSearValue(0.5, 1))) and
            Death:Charges() == 2
            then
                self:ShadowWordDeath()
            end
            if
            Shadowfiend:Exists() and not Mindbender:Exists() and IsOptionEnabled("暗影魔") and
            (GetSecondOptionValue("暗影魔") == "大技能用法" and Player:BuffCount(Voidform) > 15 or
            CooldownsAllowed() and GetSecondOptionValue("暗影魔") == "S2M" and
            Player:BuffCount(Voidform) >= GetOptionValue("暗影魔")) and
            Target:CanCast(Shadowfiend)
            then
                Target:Cast(Shadowfiend)
                return
            end
            if Void:Exists() and (Insanity - (CurrentInsanityDrain * GCDMax) + 50) < 100 and Target:CanCast(Void) then
                Target:Cast(Void)
                return
            end
            if Misery:Exists() then
                if Pain:Exists() and Target:DebuffRemains(Pain) < GCDMax and Target:CanCast(Pain) then
                    Target:Cast(Pain)
                    return
                end
                if
                Pain:Exists() and UseAOE() and IsOptionEnabled("多目标 暗言术：痛") and PainUnitGCD and
                PainUnitGCD:CanCast(Pain)
                then
                    PainUnitGCD:Cast(Pain)
                    return
                end
                if
                VampiricTouch:Exists() and
                (Target:DebuffRemains(VampiricTouch) < 3 * GCDMax or Target:DebuffRemains(Pain) < 3 * GCDMax) and
                Target:CanCast(VampiricTouch)
                then
                    Target:Cast(VampiricTouch)
                    return
                end
                if
                VampiricTouch:Exists() and UseAOE() and IsOptionEnabled("多目标 吸血鬼之触") and VampUnit3GCD and
                (VampUnit3GCD:DebuffRemains(VampiricTouch) < 3 * GCDMax or
                VampUnit3GCD:DebuffRemains(Pain) < 3 * GCDMax) and
                VampUnit3GCD:CanCast(VampiricTouch)
                then
                    VampUnit3GCD:Cast(VampiricTouch)
                    return
                end
            end
            if not Misery:Exists() then
                if
                Pain:Exists() and not Target:Debuff(Pain) and
                (#Enemies_10y < self:GetMindSearValue(1, 1) or AuspiciouSpirits:Exists() or
                ShadowyInsight:Exists() or
                SphereOfInsanity:ArtifactRank() >= 1) and
                Target:CanCast(Pain)
                then
                    Target:Cast(Pain)
                    return
                end
                if
                VampiricTouch:Exists() and not Target:Debuff(VampiricTouch) and
                (#Enemies_10y < self:GetMindSearValue(1, 1) or Sanlayn:Exists() or
                (AuspiciouSpirits:Exists() and UnleashTheShadows:ArtifactRank() >= 1)) and
                Target:CanCast(VampiricTouch)
                then
                    Target:Cast(VampiricTouch)
                    return
                end
                if
                Pain:Exists() and UseAOE() and IsOptionEnabled("多目标 暗言术：痛") and PainUnit18 and
                not PainUnit18:Debuff(Pain) and
                PainUnit18:TimeToDie() > TTDMultiDot and
                (#Enemies_10y < self:GetMindSearValue(1, 1) and
                (AuspiciouSpirits:Exists() or ShadowyInsight:Exists())) and
                PainUnit18:CanCast(Pain)
                then
                    PainUnit18:Cast(Pain)
                    return
                end
                if
                VampiricTouch:Exists() and UseAOE() and IsOptionEnabled("多目标 吸血鬼之触") and VampUnit24 and
                not VampUnit24:Debuff(VampiricTouch) and
                VampUnit24:TimeToDie() > TTDMultiDot and
                (#Enemies_10y < self:GetMindSearValue(1, 1) or Sanlayn:Exists() or
                (AuspiciouSpirits:Exists() and UnleashTheShadows:ArtifactRank() >= 1)) and
                VampUnit24:CanCast(VampiricTouch)
                then
                    VampUnit24:Cast(VampiricTouch)
                    return
                end
                if
                Pain:Exists() and UseAOE() and IsOptionEnabled("多目标 暗言术：痛") and PainUnit18 and
                not PainUnit18:Debuff(Pain) and
                PainUnit18:TimeToDie() > TTDMultiDot and
                (#Enemies_10y < self:GetMindSearValue(1, 1) and SphereOfInsanity:ArtifactRank() >= 1) and
                PainUnit18:CanCast(Pain)
                then
                    PainUnit18:Cast(Pain)
                    return
                end
            end
            if Player:Channeling(MindFlay) then
                return
            end
            if MindFlay:Exists() and Target:CanCast(MindFlay) then
                Target:Cast(MindFlay)
                return
            end
        elseif Player:Buff(Voidform) then
            if
            MindFlay:Exists() and UseAOE() and IsOptionEnabled("精神灼烧") and not Player:Channeling(MindFlay) and
            Target:DebuffRemains(Pain) > 3 / (1 + Player:Haste() / 100) and
            NumEnemies10y >= GetSecondOptionValue("精神灼烧") and
            Target:CanCast(MindFlay)
            then
                Target:Cast(MindFlay)
                return
            end
            if
            MindFlay:Exists() and Pain:Exists() and UseAOE() and IsOptionEnabled("精神灼烧") and
            Target:DebuffRemains(Pain) < 3 / (1 + Player:Haste() / 100) and
            NumEnemies10y >= GetSecondOptionValue("精神灼烧") and
            Target:CanCast(Pain)
            then
                Target:Cast(Pain)
                return
            end
            if
            MindFlay:Exists() and UseAOE() and IsOptionEnabled("精神灼烧") and
            NumEnemies10y >= GetSecondOptionValue("精神灼烧")
            then
                return
            end
            if Player:Buff(ZeksExterminatus) and CurrentInsanityDrain * GCDMax <= Insanity and Target:CanCast(Death) then
                self:ShadowWordDeath()
                return
            end
            if
            Death:Exists() and GetOptionValue("暗言术：灭") == "任何" and
            (TwistOfFateTalent:Exists() and not Player:Buff(TwistOfFate) or not TwistOfFateTalent:Exists())
            then
                self:ShadowWordDeath()
            end
            if self:VoidBoltCycle2() then
                return
            end
            if ShadowCrash:Exists() and IsOptionEnabled("暗影冲撞") and Target:CanCast(ShadowCrash) then
                if Target:CastGroundSpell(ShadowCrash, "暗影冲撞", 8) then
                    return
                end
            end
            if
            VoidTorrent:Exists() and IsOptionEnabled("虚空洪流") and Target:DebuffRemains(Pain) > 5.5 and
            Target:DebuffRemains(VampiricTouch) > 5.5 and
            (CooldownsAllowed() or GetOptionValue("虚空洪流") == "无条件使用") and
            Insanity <= GetSecondOptionValue("虚空洪流") and
            Target:CanCast(VoidTorrent)
            then
                Target:Cast(VoidTorrent)
                return
            end
            if
            Mindbender:Exists() and IsOptionEnabled("摧心魔") and
            ((GetSecondOptionValue("摧心魔") == "无条件使用") or
            (CooldownsAllowed() and GetSecondOptionValue("摧心魔") == "大技能用法" and
            Player:BuffCount(Voidform) >= GetOptionValue("摧心魔")) or
            (GetSecondOptionValue("摧心魔") == "自动" and
            CurrentInsanityDrain >=
            (cd_time - 0 + (Player:HasHero() and (5 - (T20_4pc and 3 or 0)) or 0) +
            (T20_4pc and FortressOfTheMind:Exists() and 2 or 0)))) and
            Target:CanCast(Mindbender)
            then
                Target:Cast(Mindbender)
                return
            end
            if
            PowerInfusion:Exists() and CooldownsAllowed() and Player:Buff(Voidform) and IsOptionEnabled("能量灌注") and
            GetSecondOptionValue("能量灌注") == "自动" and
            CurrentInsanityDrain >= (cd_time + (Player:HasHero() and (1 + (T20_4pc and 1 or 0)) and 5 or 0)) and
            Player:CanCast(PowerInfusion)
            then
                Player:Cast(PowerInfusion)
            end
            if
            Berserking:Exists() and CooldownsAllowed() and IsOptionEnabled("Berserking") and
            (GetOptionValue("Berserking") == "无条件使用" or
            (GetOptionValue("Berserking") == "Voidform only" and Player:Buff(Voidform) and
            Player:BuffCount(Voidform) >= GetSecondOptionValue("Berserking")) or
            (GetOptionValue("Berserking") == "Voidform only" and
            (Player:BuffCount(Voidform) >= 10 and CurrentInsanityDrain <= 20))) and
            Player:CanCast(Berserking)
            then
                Player:Cast(Berserking)
            end
            if Player:Buff(ZeksExterminatus) and Target:CanCast(Death) then
                self:ShadowWordDeath()
                return
            end
            if
            Death:Exists() and
            (#Enemies_10y <= self:GetMindSearValue(1, 1) or
            (ReaperOfSouls:Exists() and #Enemies_10y <= self:GetMindSearValue(0.5, 1))) and
            CurrentInsanityDrain * GCDMax > Insanity and
            (Insanity - (CurrentInsanityDrain * GCDMax) + (ReaperOfSouls:Exists() and 30 or 15)) < 100
            then
                self:ShadowWordDeath()
            end
            if VoidBolt:Cooldown() < GCDMax * 0.28 then
                Bug("Void Bolt in " .. VoidBolt:Cooldown())
                return
            end
            if MindBlast:Exists() and #Enemies_10y <= self:GetMindSearValue(1, 1) and Target:CanCast(MindBlast) then
                Target:Cast(MindBlast)
                return
            end
            if MindBlast:Cooldown() < GCDMax * 0.28 and #Enemies_10y <= self:GetMindSearValue(1, 1) then
                Bug("Void Bolt in " .. MindBlast:Cooldown())
                return
            end
            if
            Death:Exists() and
            (#Enemies_10y <= self:GetMindSearValue(1, 1) or
            (ReaperOfSouls:Exists() and #Enemies_10y <= self:GetMindSearValue(0.5, 1))) and
            Death:Charges() == 2
            then
                self:ShadowWordDeath()
            end
            if
            Shadowfiend:Exists() and not Mindbender:Exists() and CooldownsAllowed() and IsOptionEnabled("暗影魔") and
            GetSecondOptionValue("暗影魔") == "大技能用法" and
            Player:BuffCount(Voidform) >= GetOptionValue("暗影魔") and
            Target:CanCast(Shadowfiend)
            then
                Target:Cast(Shadowfiend)
                return
            end
            if Void:Exists() and (Insanity - (CurrentInsanityDrain * GCDMax) + 25) < 100 and Target:CanCast(Void) then
                Target:Cast(Void)
                return
            end
            if Misery:Exists() then
                if
                Pain:Exists() and Target:DebuffRemains(Pain) < GCDMax and Target:TimeToDie() > TTDTarget and
                Target:CanCast(Pain)
                then
                    Target:Cast(Pain)
                    return
                end
                if
                Pain:Exists() and UseAOE() and IsOptionEnabled("多目标 暗言术：痛") and PainUnitGCD and
                PainUnitGCD:CanCast(Pain)
                then
                    PainUnitGCD:Cast(Pain)
                    return
                end
                if
                VampiricTouch:Exists() and Target:TimeToDie() > 5 * GCDMax and
                (Target:DebuffRemains(VampiricTouch) < 3 * GCDMax or Target:DebuffRemains(Pain) < 3 * GCDMax) and
                Target:CanCast(VampiricTouch)
                then
                    Target:Cast(VampiricTouch)
                    return
                end
                if
                VampiricTouch:Exists() and UseAOE() and IsOptionEnabled("多目标 吸血鬼之触") and VampUnit3GCD and
                (VampUnit3GCD:DebuffRemains(VampiricTouch) < 3 * GCDMax or
                VampUnit3GCD:DebuffRemains(Pain) < 3 * GCDMax) and
                VampUnit3GCD:CanCast(VampiricTouch)
                then
                    VampUnit3GCD:Cast(VampiricTouch)
                    return
                end
            end
            if not Misery:Exists() then
                if
                Pain:Exists() and not Target:Debuff(Pain) and Target:TimeToDie() > TTDTarget and
                (#Enemies_10y < self:GetMindSearValue(1, 1) or AuspiciouSpirits:Exists() or
                ShadowyInsight:Exists() or
                SphereOfInsanity:ArtifactRank() >= 1) and
                Target:CanCast(Pain)
                then
                    Target:Cast(Pain)
                    return
                end
                if
                VampiricTouch:Exists() and Target:TimeToDie() > TTDTarget and not Target:Debuff(VampiricTouch) and
                (#Enemies_10y < self:GetMindSearValue(1, 1) or Sanlayn:Exists() or
                (AuspiciouSpirits:Exists() and UnleashTheShadows:ArtifactRank() >= 1)) and
                Target:CanCast(VampiricTouch)
                then
                    Target:Cast(VampiricTouch)
                    return
                end
                if
                VampiricTouch:Exists() and UseAOE() and IsOptionEnabled("多目标 吸血鬼之触") and VampUnit24 and
                not VampUnit24:Debuff(VampiricTouch) and
                ((1 + 0.02 * Player:BuffCount(Voidform)) * dot_vt_dpgcd * VampUnit24:TimeToDie() /
                (GCDMax * (156 + sear_dpgcd * (NumEnemies10y - 1)))) >
                1 and
                VampUnit24:CanCast(VampiricTouch)
                then
                    VampUnit24:Cast(VampiricTouch)
                    return
                end
                if
                Pain:Exists() and UseAOE() and IsOptionEnabled("多目标 暗言术：痛") and PainUnit18 and
                not PainUnit18:Debuff(Pain) and
                ((1 + 0.02 * Player:BuffCount(Voidform)) * dot_swp_dpgcd * PainUnit18:TimeToDie() /
                (GCDMax * (118 + sear_dpgcd * (NumEnemies10y - 1)))) >
                1 and
                PainUnit18:CanCast(Pain)
                then
                    PainUnit18:Cast(Pain)
                    return
                end
            end
            if Player:Channeling(MindFlay) then
                return
            end
            if MindFlay:Exists() and Player:Moving() <= 0 and Target:CanCast(MindFlay) then
                Target:Cast(MindFlay)
                return
            end
            if Pain:Exists() and PainUnitMoving and PainUnitMoving:CanCast(Pain) then
                PainUnitMoving:Cast(Pain)
                return
            end
        else
            if
            VoidEruption:Exists() and IsOptionEnabled("虚空爆发") and Insanity >= GetOptionValue("虚空爆发") and UseAOE() and
            IsOptionEnabled("精神灼烧") and
            NumEnemies10y >= GetSecondOptionValue("精神灼烧") and
            Player:CanCast(VoidEruption)
            then
                Player:Cast(VoidEruption)
                return
            end
            if
            MindFlay:Exists() and UseAOE() and IsOptionEnabled("精神灼烧") and not Player:Channeling(MindFlay) and
            Target:DebuffRemains(Pain) > 3 / (1 + Player:Haste() / 100) and
            NumEnemies10y >= GetSecondOptionValue("精神灼烧") and
            Target:CanCast(MindFlay)
            then
                Target:Cast(MindFlay)
                return
            end
            if
            MindFlay:Exists() and Pain:Exists() and UseAOE() and IsOptionEnabled("精神灼烧") and
            Target:DebuffRemains(Pain) < 3 / (1 + Player:Haste() / 100) and
            NumEnemies10y >= GetSecondOptionValue("精神灼烧") and
            Target:CanCast(Pain)
            then
                Target:Cast(Pain)
                return
            end
            if
            MindFlay:Exists() and UseAOE() and IsOptionEnabled("精神灼烧") and
            NumEnemies10y >= GetSecondOptionValue("精神灼烧")
            then
                return
            end
            if Player:Buff(ZeksExterminatus) and Target:CanCast(Death) then
                self:ShadowWordDeath()
                return
            end
            if Player:Moving() then
                if
                Pain:Exists() and Misery:Exists() and Target:TimeToDie() > TTDTarget and Target:Debuff(Pain) and
                Target:DebuffRemains(Pain) <= GCDMax and
                Target:CanCast(Pain)
                then
                    Target:Cast(Pain)
                    return
                end
                if
                Pain:Exists() and UseAOE() and IsOptionEnabled("多目标 暗言术：痛") and Misery:Exists() and PainUnitGCD and
                PainUnitGCD:Debuff(Pain) and
                PainUnitGCD:CanCast(Pain)
                then
                    PainUnitGCD:Cast(Pain)
                    return
                end
            end
            if
            VampiricTouch:Exists() and Misery:Exists() and Target:TimeToDie() > TTDTarget and
            (Target:DebuffRemains(VampiricTouch) < 3 * GCDMax or Target:DebuffRemains(Pain) < 3 * GCDMax) and
            Target:CanCast(VampiricTouch)
            then
                Target:Cast(VampiricTouch)
                return
            end
            if
            VampiricTouch:Exists() and UseAOE() and IsOptionEnabled("多目标 吸血鬼之触") and Misery:Exists() and
            VampUnit3GCD and
            (VampUnit3GCD:DebuffRemains(VampiricTouch) < 3 * GCDMax or
            VampUnit3GCD:DebuffRemains(Pain) < 3 * GCDMax) and
            VampUnit3GCD:CanCast(VampiricTouch)
            then
                VampUnit3GCD:Cast(VampiricTouch)
                return
            end
            if
            Pain:Exists() and not Misery:Exists() and Target:TimeToDie() > TTDTarget and
            Target:DebuffRemains(Pain) < (3 + (4 / 3)) and
            Target:CanCast(Pain)
            then
                Target:Cast(Pain)
                return
            end
            if
            VampiricTouch:Exists() and not Misery:Exists() and Target:TimeToDie() > TTDTarget and
            Target:DebuffRemains(VampiricTouch) < (4 + (4 / 3)) and
            Target:CanCast(VampiricTouch)
            then
                Target:Cast(VampiricTouch)
                return
            end
            if
            VampiricTouch:Exists() and UseAOE() and IsOptionEnabled("多目标 吸血鬼之触") and not Misery:Exists() and
            VampUnitMain and
            VampUnitMain:CanCast(VampiricTouch)
            then
                VampUnitMain:Cast(VampiricTouch)
                return
            end
            if
            Pain:Exists() and UseAOE() and IsOptionEnabled("多目标 暗言术：痛") and not Misery:Exists() and PainUnitMain and
            PainUnitMain:CanCast(Pain)
            then
                PainUnitMain:Cast(Pain)
                return
            end
            if
            VoidEruption:Exists() and IsOptionEnabled("虚空爆发") and Insanity >= GetOptionValue("虚空爆发") and
            Player:CanCast(VoidEruption)
            then
                Player:Cast(VoidEruption)
                return
            end
            if ShadowCrash:Exists() and IsOptionEnabled("暗影冲撞") and Target:CanCast(ShadowCrash) then
                if Target:CastGroundSpell(ShadowCrash, "暗影冲撞", 8) then
                    return
                end
            end
            if
            Death:Exists() and
            (#Enemies_10y <= self:GetMindSearValue(1, 1) or
            (ReaperOfSouls:Exists() and #Enemies_10y <= self:GetMindSearValue(0.5, 1))) and
            Death:Charges() == 2 and
            Insanity <= (ReaperOfSouls:Exists() and 70 or 85)
            then
                self:ShadowWordDeath()
            end
            if
            MindBlast:Exists() and #Enemies_10y <= self:GetMindSearValue(1, 1) and LegacyOfTheVoid:Exists() and
            (Insanity <= 81 or (Insanity <= 75 and FortressOfTheMind:Exists())) and
            Target:CanCast(MindBlast)
            then
                Target:Cast(MindBlast)
                return
            end
            if
            MindBlast:Exists() and #Enemies_10y <= self:GetMindSearValue(1, 1) and
            (not LegacyOfTheVoid:Exists() or (Insanity <= 96 or (Insanity <= 95 and FortressOfTheMind:Exists()))) and
            Target:CanCast(MindBlast)
            then
                Target:Cast(MindBlast)
                return
            end
            if
            Pain:Exists() and not Misery:Exists() and not Target:Debuff(Pain) and Target:TimeToDie() > TTDTarget and
            (#Enemies_10y < self:GetMindSearValue(1, 1) and
            (AuspiciouSpirits:Exists() or ShadowyInsight:Exists())) and
            Target:CanCast(Pain)
            then
                Target:Cast(Pain)
                return
            end
            if
            Pain:Exists() and UseAOE() and IsOptionEnabled("多目标 暗言术：痛") and not Misery:Exists() and PainUnit18 and
            not PainUnit18:Debuff(Pain) and
            PainUnit18:TimeToDie() > TTDMultiDot and
            (#Enemies_10y < self:GetMindSearValue(1, 1) and
            (AuspiciouSpirits:Exists() or ShadowyInsight:Exists())) and
            PainUnit18:CanCast(Pain)
            then
                PainUnit18:Cast(Pain)
                return
            end
            if
            VampiricTouch:Exists() and IsOptionEnabled("多目标 吸血鬼之触") and NumEnemies10y > 1 and not Misery:Exists() and
            VampUnitMain and
            not VampUnitMain:Debuff(VampiricTouch) and
            (dot_vt_dpgcd * VampUnitMain:TimeToDie() / (GCDMax * (156 + sear_dpgcd * (NumEnemies10y - 1)))) > 1 and
            VampUnitMain:CanCast(VampiricTouch)
            then
                VampUnitMain:Cast(VampiricTouch)
                return
            end
            if
            Pain:Exists() and IsOptionEnabled("多目标 暗言术：痛") and NumEnemies10y > 1 and not Misery:Exists() and
            PainUnitMain and
            not PainUnitMain:Debuff(Pain) and
            (dot_swp_dpgcd * PainUnitMain:TimeToDie() / (GCDMax * (118 + sear_dpgcd * (NumEnemies10y - 1)))) > 1 and
            PainUnitMain:CanCast(Pain)
            then
                PainUnitMain:Cast(Pain)
                return
            end
            if Void:Exists() and (Insanity <= 75 - (LegacyOfTheVoid:Exists() and 10 or 0)) and Target:CanCast(Void) then
                Target:Cast(Void)
                return
            end
            if Player:Channeling(MindFlay) then
                return
            end
            if MindFlay:Exists() and Player:Moving() <= 0 and Target:CanCast(MindFlay) then
                Target:Cast(MindFlay)
                return
            end
            if Pain:Exists() and PainUnitMoving and PainUnitMoving:CanCast(Pain) then
                PainUnitMoving:Cast(Pain)
                return
            end
        end
    end
end
function Rotation:OutOfCombat()
    if ShouldMindbender == true then
        ShouldMindbender = false
        Bug("Mindbender Queue Canceled")
    end
    GCDMax, Insanity = Player:GCD(), Player:Insanity()
    CurrentInsanityDrain = CurrentInsanityDrain or 0
    SetOutput("狂乱值:", string.format("%.1f", CurrentInsanityDrain or 0))
    if
    not Player:Buff(Shadowform) and IsOptionEnabled("自动暗影形态") and not Player:Buff(Voidform) and
    Player:CanCast(Shadowform)
    then
        Bug("自动暗影形态")
        Player:Cast(Shadowform)
        return
    end
    if
    BodyAndSoul:Exists() and IsOptionEnabled("身心合一") and Player:Moving() > GetOptionValue("身心合一") and
    not Player:Buff(BodyAndSoulBuff) and
    Player:CanCast(Shield)
    then
        Player:Cast(Shield)
        return
    end
    if
    ShadowMend:Exists() and IsOptionEnabled("暗影愈合") and Player:HealthPercentage() <= GetSecondOptionValue("暗影愈合") and
    Player:CanCast(ShadowMend)
    then
        Player:Cast(ShadowMend)
        return
    end
    if IsOptionEnabled("自动进入战斗") and Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        if MindBlast:Exists() and Target:CanCast(MindBlast) then
            Target:Cast(MindBlast)
            return
        end
        if Pain:Exists() and Target:CanCast(Pain) then
            Target:Cast(Pain)
            return
        end
    end
end
SetRotation(259, {})
local Rotation = Rotations[259]
function Rotation:Initialize()
    ArcaneTorrent = Spell(25046, false, false, true)
    Berserking = Spell(26297, false, false, true)
    BloodFury = Spell(20572, false, false, true)
    GiftOfTheNaaru = Spell(59547, false, false, true)
    Envenom = Spell(32645, true, true, true)
    FanofKnives = Spell(51723, false, false, true)
    Garrote = Spell(703, true, true, true)
    Mutilate = Spell(1329, true, true, true)
    PoisonedKnife = Spell(185565, true, true, true)
    Rupture = Spell(1943, true, true, true)
    Stealth = Spell(1784, false, false, true)
    Vanish = Spell(1856, false, false, true)
    Vendetta = Spell(79140, true, true, true)
    Alacrity = Spell(193539)
    AlacrityBuff = Spell(193538)
    Anticipation = Spell(114015)
    DeathFromAbove = Spell(152150, true, true, true)
    DeeperStratagem = Spell(193531)
    ElaboratePlanning = Spell(193640)
    ElaboratePlanningBuff = Spell(193641)
    Exsanguinate = Spell(200806, true, true, true)
    Hemorrhage = Spell(16511, true, true, true)
    InternalBleeding = Spell(154953)
    MarkedForDeath = Spell(137619, false, true, true)
    MasterPoisoner = Spell(196864)
    Nightstalker = Spell(14062)
    ShadowFocus = Spell(108209)
    Subterfuge = Spell(108208)
    ToxicBlade = Spell(245388, true, true, true)
    ToxicBladeDebuff = Spell(245389)
    VenomRush = Spell(152152)
    Vigor = Spell(14983)
    AssassinsBlades = Spell(214368)
    Kingsbane = Spell(192759, true, true, true)
    MasterAssassin = Spell(192349)
    SilenceoftheUncrowned = Spell(241152)
    SinisterCirculation = Spell(238138)
    SlayersPrecision = Spell(214928)
    SurgeofToxins = Spell(192425)
    ToxicBlades = Spell(192310)
    UrgetoKill = Spell(192384)
    CloakofShadows = Spell(31224, false, false, true)
    CrimsonVial = Spell(185311, false, false, true)
    Feint = Spell(1966, false, false, true)
    Evasion = Spell(5277, false, false, true)
    CheapShot = Spell(1833, true, true, true)
    Kick = Spell(1766, true, true, true)
    KidneyShot = Spell(408, true, true, true)
    PickPocket = Spell(921, true, true, true)
    TricksoftheTrade = Spell(57934, false, false, true)
    CripplingPoison = Spell(3408)
    DeadlyPoison = Spell(2823)
    DeadlyPoisonDebuff = Spell(2818)
    LeechingPoison = Spell(108211)
    WoundPoison = Spell(8679)
    WoundPoisonDebuff = Spell(8680)
    DreadlordsDeceit = Spell(228224)
    MasterAssassinsInitiative = Spell(235027)
    MutilatedFlesh = Spell(211672)
    DuskwalkersFootpads = Item(137030, { 8 })
    InsigniaofRavenholdt = Item(137049, { 11, 12 })
    MantleoftheMasterAssassin = Item(144236, { 3 })
    Trinket1, Trinket2 = Item(13), Item(14)
    ConvergenceofFates = Item(140806, { 13, 14 })
    DraughtofSouls = Item(140808, { 13, 14 })
    Envenom:RegisterDamage(
    function()
        return Player:AttackPower() * self:CPSpend() * 0.6 * 1.17 * 1.11 *
        (ToxicBlades:ArtifactEnabled() and 1 + ToxicBlades:ArtifactRank() * 0.03 or 1) *
        (HasT19_4Pc and self:Assa_T19_4PC_EnvMultiplier() or 1) *
        (DeeperStratagem:Exists() and 1.05 or 1) *
        (1 + Player:MasteryPct() / 100) *
        (1 + Player:VersatilityDmgPct() / 100) *
        (SlayersPrecision:ArtifactEnabled() and 1.05 or 1) *
        (SilenceoftheUncrowned:ArtifactEnabled() and 1.1 or 1)
    end
    )
    Mutilate:RegisterDamage(
    function()
        local minDamage, maxDamage, _, _, _, _, percent = UnitDamage("player")
        local speed, _ = UnitAttackSpeed("player")
        local wSpeed = speed * (1 + Player:HastePct() / 100)
        local avgWpnDmg = (minDamage + maxDamage) / 2 / wSpeed / percent - (Player:AttackPower() / 3.5)
        return (avgWpnDmg * wSpeed + (Player:AttackPower() * 1.7 / 3.5)) * 1.5 * 3.6 * 1.17 * 1.11 *
        (AssassinsBlades:ArtifactEnabled() and 1.15 or 1) *
        (1 + Player:VersatilityDmgPct() / 100) *
        (SlayersPrecision:ArtifactEnabled() and 1.05 or 1) *
        (SilenceoftheUncrowned:ArtifactEnabled() and 1.1 or 1) *
        (InsigniaofRavenholdt:IsEquipped() and 1.3 or 1)
    end
    )
    AddPage("常规")
    AddPage("进攻")
    AddPage("防御")
    AddCommonOptions()
    AddPresetOption("GeneralRogue", "Melee", nil, false)
    AddSection("常规", "辅助", "Yellow")
    AddNewOption(
    "常规",
    "对焦点施放嫁祸诀窍",
    230,
    false,
    { 2, "无条件使用", "高仇恨" },
    nil,
    "Will use Tricks of the Trade on your focus if he's allied." ..
    C.TOOLTIP_VALUE ..
    C.TOOLTIP_SUBVALUE("无条件使用", true) ..
    "Everytime it is available." ..
    C.TOOLTIP_SUBVALUE("高仇恨") .. "Only if you have the aggro of something."
    )
    AddSection("常规", "毒药", "Yellow")
    AddNewOption(
    "常规",
    "致命 | 非致命",
    233,
    true,
    { 1, "致命药膏", "致伤药膏" },
    { 1, "吸血药膏", "减速药膏" },
    "Choose your Poisons" ..
    C.TOOLTIP_VALUE_1 ..
    "Choose your Lethal Poison." ..
    C.TOOLTIP_VALUE_2 ..
    "Choose your Non-Lethal Poison. " ..
    C.TOOLTIP_HINT(
    "If you choose Leeching but you don't have the talent it will put Crippling."
    )
    )
    AddNewOption(
    "常规",
    "自动上毒药(分钟)",
    120,
    true,
    { 15, 0, 60, 1 },
    nil,
    "Set the minimun duration to have on Poisons in minutes before starting the combat."
    )
    AddSection("常规", "单打", "Yellow")
    AddNewOption(
    "常规",
    "肾击",
    210,
    false,
    nil,
    nil,
    "Enable for the automatic usage of Kidney Shot." ..
    C.TOOLTIP_HINT("Useful if you're having hard time while soloing.")
    )
    AddNewOption(
    "常规",
    "偷袭",
    210,
    false,
    nil,
    nil,
    "Enable for the automatic usage of Cheap Shot." ..
    C.TOOLTIP_HINT("Useful if you're having hard time while soloing.")
    )
    AddNewOption(
    "常规",
    "搜索",
    210,
    false,
    nil,
    nil,
    "Will PickPocket your target before engaging it." ..
    C.TOOLTIP_HINT("Enabling Pick Pocket will turn on Auto-Loot.")
    )
    AddPresetOption("进攻")
    AddNewOption(
    "进攻",
    "潜行",
    230,
    true,
    { 1, "无条件使用", "Near Target" },
    nil,
    "Enable for the automatic usage of Stealth." ..
    C.TOOLTIP_VALUE ..
    C.TOOLTIP_SUBVALUE("无条件使用", true) ..
    "Everytime it is available." .. C.TOOLTIP_SUBVALUE("Near Target") .. "When approaching your target."
    )
    AddSection("进攻", "大技能", "Yellow")
    AddNewOption(
    "进攻",
    "抽血",
    230,
    true,
    { 1, "无条件使用", "大技能用法" },
    nil,
    "Enable for the automatic usage of Exsanguinate." ..
    C.TOOLTIP_VALUE ..
    C.TOOLTIP_SUBVALUE("无条件使用", true) ..
    "Will use the ability even if CDs are disabled." ..
    C.TOOLTIP_SUBVALUE("大技能用法") .. "Will only use the ability if CDs are enabled."
    )
    AddNewOption(
    "进攻",
    "死亡标记",
    233,
    true,
    { 2, "目标", "Adds" },
    { 1, "无条件使用", "大技能用法" },
    "Enable for the automatic usage of Marked for Death." ..
    C.TOOLTIP_VALUE_1 ..
    C.TOOLTIP_SUBVALUE("目标", true) ..
    "Only on your target with 1 or less CP." ..
    C.TOOLTIP_SUBVALUE("Adds") ..
    "On every units available." ..
    C.TOOLTIP_VALUE_2 ..
    C.TOOLTIP_SUBVALUE("无条件使用", true) ..
    "Will use the ability even if CDs are disabled." ..
    C.TOOLTIP_SUBVALUE("大技能用法") ..
    "Will only use the ability if CDs are enabled."
    )
    AddNewOption(
    "进攻",
    "消失",
    233,
    true,
    { 1, "无条件使用", "Not Tanking" },
    { 2, "无条件使用", "大技能用法" },
    "Enable for the automatic usage of Vanish." ..
    C.TOOLTIP_VALUE_1 ..
    C.TOOLTIP_SUBVALUE("无条件使用", true) ..
    "Will 'Always' use Vanish no matter if you're tanking or not." ..
    C.TOOLTIP_SUBVALUE("Not Tanking") ..
    "Will only use Vanish if you're 'Not Tanking' the target (Mostly for Solo)." ..
    C.TOOLTIP_VALUE_2 ..
    C.TOOLTIP_SUBVALUE("无条件使用", true) ..
    "Will use the ability even if CDs are disabled." ..
    C.TOOLTIP_SUBVALUE("大技能用法") ..
    "Will only use the ability if CDs are enabled."
    )
    AddNewOption(
    "进攻",
    "君王之灾",
    230,
    true,
    { 1, "无条件使用", "大技能用法" },
    nil,
    "Enable for the automatic usage of Kingsbane." ..
    C.TOOLTIP_VALUE ..
    C.TOOLTIP_SUBVALUE("无条件使用", true) ..
    "Will use the ability even if CDs are disabled." ..
    C.TOOLTIP_SUBVALUE("大技能用法") .. "Will only use the ability if CDs are enabled."
    )
    AddNewOption("进攻", "宿敌", 210, true, nil, nil, "Enable for the automatic usage of Vendetta.")
    AddSection("进攻", "能力", "Yellow")
    AddNewOption("进攻", "多目标割裂", 210, true, nil, nil, "Enable for the automatic cycling of Rupture.")
    AddNewOption("进攻", "多目标锁喉", 210, true, nil, nil, "Enable for the automatic cycling of Garrote.")
    AddNewOption("进攻", "多目标出血", 210, true, nil, nil, "Enable for the automatic cycling of Hemorrhage.")
    AddNewOption(
    "进攻",
    "剧毒之刃",
    220,
    true,
    { 75, 40, 150, 1 },
    nil,
    "Enable to auto use Poisoned Knfie while not being in melee range and not being stealthed." ..
    C.TOOLTIP_VALUE .. "Set the minimum energy to start using it."
    )
    AddNewOption(
    "进攻",
    "刀扇",
    220,
    true,
    { 2, 1, 20, 1 },
    nil,
    "Enable the use of Fan Of Knives when more than X enemies in range." ..
    C.TOOLTIP_VALUE ..
    "Set the minimum amount of enemies to start using Fan Of Knives." ..
    C.TOOLTIP_HINT("It automatically add one unit if you have Insignia of Ravenholdt.")
    )
    AddNewOption(
    "进攻",
    "施放毁伤刷新毒药",
    220,
    true,
    { 5, 1, 15, 0.1 },
    nil,
    "Use Mutilate to refresh poison on near enemies." ..
    C.TOOLTIP_VALUE .. "Minimum time left of debuff from Deadly Poison."
    )
    AddPresetOption("防御")
    AddSection("防御", "能力", "Yellow")
    AddNewOption("防御", "猩红之瓶", 220, true, { 65, 1, 100, 1 }, nil, "Health Percentage to use Crimson Vial.")
    AddNewOption(
    "防御",
    "佯攻",
    220,
    false,
    { 55, 1, 100, 1 },
    nil,
    "Health Percentage to use Feint." .. C.TOOLTIP_HINT("Put 100 to maintain 100% uptime.")
    )
    AddSection("防御", "大技能", "Yellow")
    AddNewOption("防御", "闪避", 220, true, { 25, 1, 100, 1 }, nil, "Health Percentage to use Evasion.")
    AddNewOption("防御", "暗影斗篷", 220, true, { 45, 1, 100, 1 }, nil, "Health Percentage to use Cloak of Shadows.")
    AddNewOption("防御", "消失 防御", 220, false, { 10, 1, 100, 1 }, nil, "Health Percentage to use Vanish defensively.")
    RegisterCommand(
    "feint",
    function()
        if ShouldFeint == true then
            ShouldFeint = false
            Bug("Feint Queue Canceled")
        elseif Feint:Exists() then
            ShouldFeint = true
            Bug("Feint Queued")
        end
    end
    )
    StealthAllowed, CombatStealthAllowed = false, true
    PoisonLethal, PoisonNonLethal, PoisonMinDuration, PoisonCastTime = nil, nil, nil, nil
    self.BleedTickTime, self.ExsanguinatedBleedTickTime = 2, 1
end
function Rotation:Events()
    BleedTable = {
        Assassination = { Garrote = {}, Rupture = {} },
        Subtlety = { Nightblade = {}, FinalityNightblade = false, FinalityNightbladeTime = 0 }
    }
    local BleedDuration, BleedExpires
    EventFrame:RegisterForSelfCombatEvent(
    function(...)
        local DestGUID, _, _, _, SpellID = select(8, ...)
        if SpellID == 200806 then
            for Key, _ in pairs(BleedTable.Assassination) do
                for Key2, _ in pairs(BleedTable.Assassination[Key]) do
                    if Key2 == DestGUID then
                        BleedTable.Assassination[Key][Key2][3] = true
                    end
                end
            end
        end
    end,
    "SPELL_CAST_SUCCESS"
    )
    local function GetBleedInfos(GUID, Spell)
        return select(6, UnitAura(GUID, ({ GetSpellInfo(Spell) })[1], nil, "HARMFUL|PLAYER"))
    end
    EventFrame:RegisterForSelfCombatEvent(
    function(...)
        local DestGUID, _, _, _, SpellID = select(8, ...)
        if SpellID == 703 then
            BleedDuration, BleedExpires = GetBleedInfos(DestGUID, SpellID)
            BleedTable.Assassination.Garrote[DestGUID] = { BleedDuration, BleedExpires, false }
        elseif SpellID == 1943 then
            BleedDuration, BleedExpires = GetBleedInfos(DestGUID, SpellID)
            BleedTable.Assassination.Rupture[DestGUID] = { BleedDuration, BleedExpires, false }
        end
    end,
    "SPELL_AURA_APPLIED",
    "SPELL_AURA_REFRESH"
    )
    EventFrame:RegisterForSelfCombatEvent(
    function(...)
        local DestGUID, _, _, _, SpellID = select(8, ...)
        if SpellID == 703 then
            if BleedTable.Assassination.Garrote[DestGUID] then
                BleedTable.Assassination.Garrote[DestGUID] = nil
            end
        elseif SpellID == 1943 then
            if BleedTable.Assassination.Rupture[DestGUID] then
                BleedTable.Assassination.Rupture[DestGUID] = nil
            end
        end
    end,
    "SPELL_AURA_REMOVED"
    )
    EventFrame:RegisterForCombatEvent(
    function(...)
        local DestGUID = select(8, ...)
        if BleedTable.Assassination.Garrote[DestGUID] then
            BleedTable.Assassination.Garrote[DestGUID] = nil
        end
        if BleedTable.Assassination.Rupture[DestGUID] then
            BleedTable.Assassination.Rupture[DestGUID] = nil
        end
    end,
    "UNIT_DIED",
    "UNIT_DESTROYED"
    )
    local RegisteredGCD = {
        [408] = "肾击",
        [703] = "Garrote",
        [1329] = "Mutilate",
        [1725] = "Distract",
        [1833] = "偷袭",
        [1943] = "Rupture",
        [1966] = "佯攻",
        [2823] = "Deadly Poison",
        [3408] = "Crippling Poison",
        [6770] = "Sap",
        [8679] = "Wound Poison",
        [32645] = "Envenom",
        [36554] = "Shadowstep",
        [51723] = "Fan of Knives",
        [108211] = "Leeching Poison",
        [114018] = "Shroud of Concealment",
        [185565] = "剧毒之刃",
        [200806] = "抽血"
    }
    EventFrame:RegisterForSelfCombatEvent(
    function(...)
        local DestGUID, _, _, _, SpellID = select(8, ...)
        if RegisteredGCD[SpellID] ~= nil then
            LastCast = SpellID
        end
    end,
    "SPELL_CAST_SUCCESS"
    )
end
function Rotation:Exsanguinated(Unit, SpellName)
    local BleedGUID = Unit:GUID()
    if BleedGUID then
        if SpellName == "Garrote" then
            if BleedTable.Assassination.Garrote[BleedGUID] then
                return BleedTable.Assassination.Garrote[BleedGUID][3]
            end
        elseif SpellName == "Rupture" then
            if BleedTable.Assassination.Rupture[BleedGUID] then
                return BleedTable.Assassination.Rupture[BleedGUID][3]
            end
        end
    end
    return false
end
function Rotation:CPMaxSpend()
    return DeeperStratagem:Exists() and 6 or 5
end
function Rotation:CPSpend()
    return math.min(Player:ComboPoints(), self:CPMaxSpend())
end
function Rotation:Poisoned(Unit)
    return (Unit:Debuff(DeadlyPoisonDebuff) or Unit:Debuff(WoundPoisonDebuff)) and true or false
end
function Rotation:PoisonRemains(Unit)
    return (Unit:Debuff(DeadlyPoisonDebuff) and Unit:DebuffRemains(DeadlyPoisonDebuff)) or
    (Unit:Debuff(WoundPoisonDebuff) and Unit:DebuffRemains(WoundPoisonDebuff)) or
    0
end
function Rotation:Bleeds()
    return (Target:Debuff(Garrote) and 1 or 0) + (Target:Debuff(Rupture) and 1 or 0) +
    (Target:Debuff(InternalBleeding) and 1 or 0)
end
function Rotation:PoisonedBleeds()
    local PoisonedBleedsCount = 0
    local ThisUnit
    for i = 1, NumEnemies_50y do
        ThisUnit = Enemies_50y[i]
        if self:Poisoned(ThisUnit) then
            if ThisUnit:Debuff(Garrote) then
                PoisonedBleedsCount = PoisonedBleedsCount + 1
            end
            if ThisUnit:Debuff(InternalBleeding) then
                PoisonedBleedsCount = PoisonedBleedsCount + 1
            end
            if ThisUnit:Debuff(Rupture) then
                PoisonedBleedsCount = PoisonedBleedsCount + 1
            end
        end
    end
    return PoisonedBleedsCount
end
function Rotation:Assa_T19_4PC_EnvMultiplier()
    return 1 + 0.1 * (self:Bleeds() + (Target:Debuff(MutilatedFlesh) and 1 or 0))
end
function Rotation:MantleDuration()
    if Player:BuffRemains(MasterAssassinsInitiative) < 0 then
        return Player:GlobalCooldown() + 6
    else
        return Player:BuffRemains(MasterAssassinsInitiative)
    end
end
function Rotation:EveryoneUnitIsCycleValid(Unit, BestUnitTTD, TimeToDieOffset)
    return Unit:FilteredTimeToDie(">", BestUnitTTD, TimeToDieOffset)
end
function Rotation:EveryoneCanDoTUnit(Unit, HealthThreshold)
    return Unit:Health() >= HealthThreshold or Unit:IsDummy()
end
function Rotation:RogueCanDoTUnit(Unit, HealthThreshold)
    return self:EveryoneCanDoTUnit(Unit, HealthThreshold * (self:MantleDuration() > 0 and 2 or 1))
end
function Rotation:Pulse()
    if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
        return
    end
    if GetTime() < Rotation.SpamPrevention then
        return
    end
    Rotation.SpamPrevention = GetTime() + 0.05
    Target = Unit.Target
    CombatStealthAllowed = Vanish:TimeSinceCast() > 0.5
    Stealth = Subterfuge:Exists() and Spell(115191, false, false, true) or Spell(1784, false, false, true)
    if Feint:Exists() and ShouldFeint and not Player:Buff(Feint) then
        if Player:CanCast(Feint) then
            Player:Cast(Feint)
            ShouldFeint = false
        end
        return
    end
    if not Player:IsInCombat() then
        self:OutOfCombat()
        return
    else
        self:Defensives()
    end
    Target = Player:ReTarget(Mutilate, false) or Unit.Target
    if Target:Exists() then
        Rotations:RefreshUnitTables(Rotation.Identifier)
        self:Interrupts()
        self:OffGCDAbilities()
        if Player:GlobalCooldown() == 0 then
            self:Combat()
        end
    end
end
function Rotation:Defensives()
    Player:UseHealingItem()
    if
    IsOptionEnabled("消失 防御") and Vanish:Exists() and not Player:IsStealthed(true) and
    Player:HealthPercentage() <= GetOptionValue("消失 防御") and
    Player:CanCast(Vanish)
    then
        Player:Cast(Vanish)
        Vanish.LastCastTime = GetTime()
        return
    end
    if
    IsOptionEnabled("闪避") and not Player:Buff(Evasion) and Player:HealthPercentage() <= GetOptionValue("闪避") and
    Player:CanCast(Evasion)
    then
        Player:Cast(Evasion)
    end
    if
    IsOptionEnabled("暗影斗篷") and CloakofShadows:Exists() and Player:HealthPercentage() <= GetOptionValue("暗影斗篷") and
    Player:CanCast(CloakofShadows)
    then
        Player:Cast(CloakofShadows)
    end
    if
    IsOptionEnabled("佯攻") and Feint:Exists() and Player:HealthPercentage() <= GetOptionValue("佯攻") and
    not Player:Buff(Feint) and
    Player:CanCast(Feint)
    then
        Player:Cast(Feint)
        return
    end
    if
    IsOptionEnabled("猩红之瓶") and CrimsonVial:Exists() and Player:HealthPercentage() <= GetOptionValue("猩红之瓶") and
    Player:CanCast(CrimsonVial)
    then
        Player:Cast(CrimsonVial)
        return
    end
    if
    GiftOfTheNaaru:Exists() and IsOptionEnabled("纳鲁的赐福") and Player:HealthPercentage() <= GetOptionValue("纳鲁的赐福") and
    Player:CanCast(GiftOfTheNaaru)
    then
        Player:Cast(GiftOfTheNaaru)
        return
    end
end
function Rotation:Interrupts()
    Player:UseInterrupt(Kick, ArcaneTorrent)
end
function Rotation:OffGCDAbilities()
    if
    IsOptionEnabled("对焦点施放嫁祸诀窍") and TricksoftheTrade:Exists() and
    (GetOptionValue("对焦点施放嫁祸诀窍") == "无条件使用" or (Player:ThreatSituation() and Player:ThreatSituation() >= 1)) and
    Focus:Exists() and
    Focus:IsInParty() and
    not Focus:Equals(Player) and
    Focus:CanCast(TricksoftheTrade)
    then
        Focus:Cast(TricksoftheTrade)
    end
    if Player:UseMarkedForDeath(MarkedForDeath, Player:ComboPointsDeficit()) then
        return
    end
end
function Rotation:UnitTables()
    Enemies_50y = UseAOE() and Player:EnemiesWithinDistance(50, false) or {}
    Enemies_30y = UseAOE() and Player:FilterEnemiesByDistance(Enemies_50y, 30, false) or {}
    Enemies_10y = UseAOE() and Player:FilterEnemiesByDistance(Enemies_30y, 10, true) or {}
    Enemies_8y = UseAOE() and Player:FilterEnemiesByDistance(Enemies_10y, 8, true) or {}
    Enemies_5y = UseAOE() and Player:FilterEnemiesByDistance(Enemies_8y, 5, false) or {}
    NumEnemies_50y = #Enemies_50y
    NumEnemies_30y = #Enemies_30y
    NumEnemies_10y = #Enemies_10y
    NumEnemies_8y = #Enemies_8y
    NumEnemies_5y = #Enemies_5y
end
function Rotation:Combat()
    if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        if not Player:IsStealthed(true) then
            Player:StartAttack()
        end
        local Vanish_CastAllowed =         Vanish:Exists() and IsOptionEnabled("消失") and (CooldownsAllowed() or GetSecondOptionValue("消失") == "无条件使用") and
        (not Player:IsTanking(Target) or GetOptionValue("消失") == "无条件使用") and
        CombatStealthAllowed
        local RuptureThreshold = (4 + Player:ComboPoints() * 4) * 0.3
        local RuptureDMGThreshold = Envenom:Damage() * 3
        local GarroteDMGThreshold = Mutilate:Damage() * 3
        local Energy_Regen_Combined =         Player:EnergyRegen() + self:PoisonedBleeds() * (7 + (VenomRush:Exists() and 3 or 0)) / 2
        local Energy_Time_To_Max_Combined = Player:EnergyDeficit() / Energy_Regen_Combined
        if Player:IsWithinCastRange(Target, Mutilate) then
            if Player:HasHero() or (Target:Debuff(Vendetta) and Vanish_CastAllowed and Vanish:Cooldown() < 5) then
                Player:UsePotions("Agility")
            end
            if not DraughtofSouls:IsEquipped() and (Player:HasHero() or Target:Debuff(Vendetta)) then
                Player:UseTrinkets()
            end
            if DraughtofSouls:IsEquipped() then
                if
                Player:EnergyDeficit() >= 35 + Energy_Regen_Combined * 2 and
                (not MantleoftheMasterAssassin:IsEquipped() or Vanish:Cooldown() > 8 or not Vanish_CastAllowed)
                then
                    if
                    GetOptionValue("饰品: 1 | 2") ~= "禁用" and
                    (CooldownsAllowed() or GetOptionValue("饰品: 1 | 2") == "无条件使用") and
                    Trinket1:IsUsableInventory()
                    then
                        Trinket2:UseInventory()
                    end
                    if
                    GetSecondOptionValue("饰品: 1 | 2") ~= "禁用" and
                    (CooldownsAllowed() or GetSecondOptionValue("饰品: 1 | 2") == "无条件使用") and
                    Trinket2:IsUsableInventory()
                    then
                        Trinket2:UseInventory()
                    end
                end
                if self:MantleDuration() > 0 and self:MantleDuration() < 3.5 and Target:Debuff(Kingsbane) then
                    if
                    GetOptionValue("饰品: 1 | 2") ~= "禁用" and
                    (CooldownsAllowed() or GetOptionValue("饰品: 1 | 2") == "无条件使用") and
                    Trinket1:IsUsableInventory()
                    then
                        Trinket2:UseInventory()
                    end
                    if
                    GetSecondOptionValue("饰品: 1 | 2") ~= "禁用" and
                    (CooldownsAllowed() or GetSecondOptionValue("饰品: 1 | 2") == "无条件使用") and
                    Trinket2:IsUsableInventory()
                    then
                        Trinket2:UseInventory()
                    end
                end
            end
            if CDOptionEnabled("进攻性种族技能") then
                if BloodFury:Exists() and Player:CanCast(BloodFury) then
                    Player:Cast(BloodFury)
                    return
                end
                if Berserking:Exists() and Player:CanCast(Berserking) then
                    Player:Cast(Berserking)
                    return
                end
                if
                ArcaneTorrent:Exists() and Target:Debuff(Kingsbane) and not Player:Buff(Envenom) and
                Player:EnergyDeficit() > 15 + Energy_Regen_Combined * Player:GlobalCooldown() * 1.1 and
                Player:CanCast(ArcaneTorrent)
                then
                    Player:Cast(ArcaneTorrent)
                    return
                end
            end
            if
            MarkedForDeath:Exists() and IsOptionEnabled("死亡标记") and GetOptionValue("死亡标记") == "目标" and
            (CooldownsAllowed() or GetSecondOptionValue("死亡标记") == "无条件使用") and
            Player:ComboPointsDeficit() >= self:CPMaxSpend() and
            Target:CanCast(MarkedForDeath)
            then
                Target:Cast(MarkedForDeath)
                return
            end
            if
            Vendetta:Exists() and IsOptionEnabled("宿敌") and CooldownsAllowed() and
            (not UrgetoKill:ArtifactEnabled() or Player:EnergyDeficit() >= 60 + Energy_Regen_Combined) and
            Target:CanCast(Vendetta)
            then
                Target:Cast(Vendetta)
            end
            if Vanish_CastAllowed and not Player:IsStealthed(true, true) and Player:CanCast(Vanish) then
                if Nightstalker:Exists() and Player:ComboPoints() >= self:CPMaxSpend() then
                    if not Exsanguinate:Exists() then
                        if
                        self:MantleDuration() == 0 and
                        ((MantleoftheMasterAssassin:IsEquipped() and HasT19_4Pc) or
                        ((not MantleoftheMasterAssassin:IsEquipped() or not HasT19_4Pc) and
                        ((Target:DebuffRefreshable(Rupture, RuptureThreshold) and
                        self:RogueCanDoTUnit(Target, RuptureDMGThreshold)) or
                        Target:Debuff(Vendetta))))
                        then
                            Player:Cast(Vanish)
                            Vanish.LastCastTime = GetTime()
                            return
                        end
                    else
                        if
                        Exsanguinate:Exists() and Exsanguinate:Cooldown() < 1 and
                        (Target:Debuff(Rupture) or CombatTime() > 10)
                        then
                            Player:Cast(Vanish)
                            Vanish.LastCastTime = GetTime()
                            return
                        end
                    end
                end
                if Subterfuge:Exists() then
                    if MantleoftheMasterAssassin:IsEquipped() then
                        if (Target:Debuff(Vendetta) or Target:FilteredTimeToDie("<", 10)) and self:MantleDuration() == 0 then
                            Player:Cast(Vanish)
                            Vanish.LastCastTime = GetTime()
                            return
                        end
                    else
                        if
                        not Player:IsStealthed(true, false) and Target:DebuffRefreshable(Garrote, 5.4) and
                        ((NumEnemies_10y <= 3 and Player:ComboPointsDeficit() >= 1 + NumEnemies_10y) or
                        (NumEnemies_10y >= 4 and Player:ComboPointsDeficit() >= 4))
                        then
                            Player:Cast(Vanish)
                            Vanish.LastCastTime = GetTime()
                            return
                        end
                    end
                end
                if ShadowFocus:Exists() and Energy_Time_To_Max_Combined >= 2 and Player:ComboPoints() >= 4 then
                    Player:Cast(Vanish)
                    Vanish.LastCastTime = GetTime()
                    return
                end
            end
            if
            Exsanguinate:Exists() and IsOptionEnabled("抽血") and
            (CooldownsAllowed() or GetOptionValue("抽血") == "无条件使用") and
            Rupture:TimeSinceCast() < 2 and
            Target:DebuffRemains(Rupture) > 4 + 4 * self:CPMaxSpend() and
            Target:CanCast(Exsanguinate)
            then
                Target:Cast(Exsanguinate)
                return
            end
        end
        if Player:IsStealthed(true, false) then
            if
            Rupture:Exists() and Nightstalker:Exists() and
            (not MantleoftheMasterAssassin:IsEquipped() or not HasT19_4Pc) and
            (Exsanguinate:Exists() or
            (Target:FilteredTimeToDie(">", 4, -Target:DebuffRemains(Rupture)) and
            self:RogueCanDoTUnit(Target, RuptureDMGThreshold))) and
            Target:CanCast(Rupture)
            then
                Target:Cast(Rupture)
                Rupture.LastCastTime = GetTime()
                return
            end
            if Garrote:Exists() and Subterfuge:Exists() and Player:ComboPointsDeficit() >= 1 then
                if
                Target:DebuffRefreshable(Garrote, 5.4) and
                (not self:Exsanguinated(Target, "Garrote") or
                Target:DebuffRemains(Garrote) <= self.ExsanguinatedBleedTickTime * 2) and
                (Target:FilteredTimeToDie(">", 2, -Target:DebuffRemains(Garrote)) or
                (Target:TimeToDieIsNotValid() and self:RogueCanDoTUnit(Target, GarroteDMGThreshold))) and
                Target:CanCast(Garrote)
                then
                    Target:Cast(Garrote)
                    return
                end
                if UseAOE() then
                    local BestUnit, BestUnitTTD = nil, 2
                    local ThisUnit
                    for i = 1, NumEnemies_5y do
                        ThisUnit = Enemies_5y[i]
                        if
                        self:EveryoneUnitIsCycleValid(ThisUnit, BestUnitTTD, -ThisUnit:DebuffRemains(Garrote)) and
                        ThisUnit:DebuffRefreshable(Garrote, 5.4) and
                        (not self:Exsanguinated(ThisUnit, "Garrote") or
                        ThisUnit:DebuffRemains(Garrote) <= self.ExsanguinatedBleedTickTime * 2) and
                        ThisUnit:CanCast(Garrote)
                        then
                            BestUnit, BestUnitTTD = ThisUnit, ThisUnit:TimeToDie()
                        end
                    end
                    if BestUnit then
                        BestUnit:Cast(Garrote)
                        return
                    end
                end
            end
            if Garrote:Exists() and Subterfuge:Exists() and Player:ComboPointsDeficit() >= 1 then
                if
                Target:DebuffRemains(Garrote) <= 10 and not self:Exsanguinated(Target, "Garrote") and
                (Target:FilteredTimeToDie(">", 2, -Target:DebuffRemains(Garrote)) or
                (Target:TimeToDieIsNotValid() and self:RogueCanDoTUnit(Target, GarroteDMGThreshold))) and
                Target:CanCast(Garrote)
                then
                    Target:Cast(Garrote)
                    return
                end
                if UseAOE() and IsOptionEnabled("多目标锁喉") then
                    local BestUnit, BestUnitTTD = nil, 2
                    local ThisUnit
                    for i = 1, NumEnemies_5y do
                        ThisUnit = Enemies_5y[i]
                        if
                        self:EveryoneUnitIsCycleValid(ThisUnit, BestUnitTTD, -ThisUnit:DebuffRemains(Garrote)) and
                        ThisUnit:DebuffRemains(Garrote) <= 10 and
                        not self:Exsanguinated(ThisUnit, "Garrote") and
                        ThisUnit:CanCast(Garrote)
                        then
                            BestUnit, BestUnitTTD = ThisUnit, ThisUnit:TimeToDie()
                        end
                    end
                    if BestUnit then
                        BestUnit:Cast(Garrote)
                        return
                    end
                end
            end
        end
        if
        Rupture:Exists() and not Exsanguinate:Exists() and Player:ComboPoints() >= 3 and not Target:Debuff(Rupture) and
        self:MantleDuration() <= Player:GlobalCooldown() + 0.2 and
        Target:FilteredTimeToDie(">", 6) and
        self:RogueCanDoTUnit(Target, RuptureDMGThreshold) and
        Target:CanCast(Rupture)
        then
            Target:Cast(Rupture)
            Rupture.LastCastTime = GetTime()
            return
        end
        if
        CooldownsAllowed() and Rupture:Exists() and Exsanguinate:Exists() and
        ((Player:ComboPoints() >= self:CPMaxSpend() and Exsanguinate:Cooldown() < 1) or
        (not Target:Debuff(Rupture) and
        (CombatTime() > 10 or (Player:ComboPoints() >= 2 + (UrgetoKill:ArtifactEnabled() and 1 or 0))))) and
        Target:CanCast(Rupture)
        then
            Target:Cast(Rupture)
            Rupture.LastCastTime = GetTime()
            return
        end
        if Player:ComboPoints() >= 4 then
            if
            Target:DebuffRefreshable(Rupture, RuptureThreshold) and
            (not self:Exsanguinated(Target, "Rupture") or Target:DebuffRemains(Rupture) <= 1.5) and
            Target:FilteredTimeToDie(">", 6, -Target:DebuffRemains(Rupture)) and
            self:RogueCanDoTUnit(Target, RuptureDMGThreshold) and
            Target:CanCast(Rupture)
            then
                Target:Cast(Rupture)
                Rupture.LastCastTime = GetTime()
                return
            end
            if UseAOE() and IsOptionEnabled("多目标割裂") then
                local BestUnit, BestUnitTTD = nil, 6
                local ThisUnit
                for i = 1, NumEnemies_5y do
                    ThisUnit = Enemies_5y[i]
                    if
                    self:EveryoneUnitIsCycleValid(ThisUnit, BestUnitTTD, -ThisUnit:DebuffRemains(Rupture)) and
                    self:RogueCanDoTUnit(ThisUnit, RuptureDMGThreshold) and
                    ThisUnit:DebuffRefreshable(Rupture, RuptureThreshold) and
                    (not self:Exsanguinated(ThisUnit, "Rupture") or ThisUnit:DebuffRemains(Rupture) <= 1.5) and
                    ThisUnit:CanCast(Rupture)
                    then
                        BestUnit, BestUnitTTD = ThisUnit, ThisUnit:TimeToDie()
                    end
                end
                if BestUnit then
                    BestUnit:Cast(Rupture)
                    Rupture.LastCastTime = GetTime()
                    return
                end
            end
        end
        if
        Kingsbane:Exists() and IsOptionEnabled("君王之灾") and (CooldownsAllowed() or GetOptionValue("君王之灾") == "无条件使用") and
        Player:ComboPointsDeficit() >= 1 + (self:MantleDuration() > Player:GlobalCooldown() + 0.2 and 1 or 0) and
        Target:CanCast(Kingsbane)
        then
            if
            SinisterCirculation:Exists() and
            not (DuskwalkersFootpads:IsEquipped() and ConvergenceofFates:IsEquipped() and
            MasterAssassin:ArtifactRank() >= 6) and
            (CombatTime() > 25 or not MantleoftheMasterAssassin:IsEquipped() or
            (Target:Debuff(Vendetta) and Target:Debuff(SurgeofToxins))) and
            (Subterfuge:Exists() or not Player:IsStealthed(true, false) or
            (Nightstalker:Exists() and (not MantleoftheMasterAssassin:IsEquipped() or not HasT19_4Pc)))
            then
                Target:Cast(Kingsbane)
                return
            end
            if
            not Exsanguinate:Exists() and Player:Buff(Envenom) and
            ((Target:Debuff(Vendetta) and Target:Debuff(SurgeofToxins)) or Vendetta:Cooldown() <= 5.8 or
            Vendetta:Cooldown() >= 10)
            then
                Target:Cast(Kingsbane)
                return
            end
            if Exsanguinate:Exists() and self:Exsanguinated(Target, "Rupture") then
                Target:Cast(Kingsbane)
                return
            end
        end
        if
        Garrote:Exists() and
        (not Subterfuge:Exists() or not CooldownsAllowed() or
        not (not Vanish:IsOnCooldown() and Vendetta:Cooldown() <= 4)) and
        Player:ComboPointsDeficit() >= 1
        then
            if
            Target:DebuffRefreshable(Garrote, 5.4) and
            (not self:Exsanguinated(Target, "Garrote") or Target:DebuffRemains(Garrote) <= 1.5) and
            (Target:FilteredTimeToDie(">", 4, -Target:DebuffRemains(Garrote)) or
            (Target:TimeToDieIsNotValid() and self:RogueCanDoTUnit(Target, GarroteDMGThreshold))) and
            Target:CanCast(Garrote, nil, true)
            then
                if Player:Energy() < 45 then
                    Bug("Pooling for Garrote")
                    return
                end
                Target:Cast(Garrote)
                return
            end
            if UseAOE() and IsOptionEnabled("多目标锁喉") then
                local BestUnit, BestUnitTTD = nil, 4
                local ThisUnit
                for i = 1, NumEnemies_5y do
                    ThisUnit = Enemies_5y[i]
                    if
                    self:EveryoneUnitIsCycleValid(ThisUnit, BestUnitTTD, -ThisUnit:DebuffRemains(Garrote)) and
                    ThisUnit:DebuffRefreshable(Garrote, 5.4) and
                    (not self:Exsanguinated(ThisUnit, "Garrote") or ThisUnit:DebuffRemains(Garrote) <= 1.5) and
                    ThisUnit:CanCast(Garrote, nil, true)
                    then
                        BestUnit, BestUnitTTD = ThisUnit, ThisUnit:TimeToDie()
                    end
                end
                if BestUnit then
                    if Player:Energy() < 45 then
                        Bug("Pooling for Garrote")
                        return
                    end
                    BestUnit:Cast(Garrote)
                    return
                end
            end
        end
        if
        ToxicBlade:Exists() and
        Player:ComboPointsDeficit() >= 1 + (self:MantleDuration() > Player:GlobalCooldown() + 0.2 and 1 or 0) and
        Target:DebuffRemains(Rupture) > 8 and
        Target:CanCast(ToxicBlade)
        then
            Target:Cast(ToxicBlade)
            return
        end
        if
        (not CooldownsAllowed() or not Exsanguinate:Exists() or Exsanguinate:Cooldown() > 2) and
        (not Target:DebuffRefreshable(Rupture, RuptureThreshold) or
        (self:Exsanguinated(Target, "Rupture") and Target:DebuffRemains(Rupture) >= 3.5) or
        Target:FilteredTimeToDie("<=", 6, -Target:DebuffRemains(Rupture)) or
        Target:TimeToDieIsNotValid() or
        not self:RogueCanDoTUnit(Target, RuptureDMGThreshold))
        then
            if
            DeathFromAbove:Exists() and IsOptionEnabled("Death From Above") and Target:CanCast(DeathFromAbove) and
            Player:ComboPoints() >= 5
            then
                Target:Cast(DeathFromAbove)
                return
            end
            if Envenom:Exists() and Target:CanCast(Envenom) then
                if
                Player:ComboPoints() >= 4 and
                (Target:Debuff(Vendetta) or self:MantleDuration() >= Player:GlobalCooldown() + 0.2 or
                Target:DebuffRemains(SurgeofToxins) < Player:GlobalCooldown() + 0.2 or
                Player:EnergyDeficit() <= 25 + Energy_Regen_Combined or
                not self:RogueCanDoTUnit(Target, RuptureDMGThreshold))
                then
                    Target:Cast(Envenom)
                    return
                end
                if
                ElaboratePlanning:Exists() and Player:ComboPoints() >= 3 + (Exsanguinate:Exists() and 0 or 1) and
                Player:BuffRemains(ElaboratePlanningBuff) < Player:GlobalCooldown() + 0.2
                then
                    Target:Cast(Envenom)
                    return
                end
            end
        end
        if Player:ComboPointsDeficit() > 1 or Player:EnergyDeficit() <= 25 + Energy_Regen_Combined then
            if Hemorrhage:Exists() then
                if Target:DebuffRefreshable(Hemorrhage, 6) and Target:CanCast(Hemorrhage) then
                    Target:Cast(Hemorrhage)
                    return
                end
                if
                UseAOE() and IsOptionEnabled("多目标出血") and
                NumEnemies_10y < GetOptionValue("刀扇") + (InsigniaofRavenholdt:IsEquipped() and 1 or 0)
                then
                    local BestUnit, BestUnitTTD = nil, 0
                    local ThisUnit
                    for i = 1, NumEnemies_5y do
                        ThisUnit = Enemies_5y[i]
                        if
                        self:EveryoneUnitIsCycleValid(ThisUnit, BestUnitTTD) and
                        ThisUnit:DebuffRefreshable(Hemorrhage, 6) and
                        ThisUnit:Debuff(Rupture) and
                        ThisUnit:CanCast(Hemorrhage)
                        then
                            BestUnit, BestUnitTTD = ThisUnit, ThisUnit:TimeToDie()
                        end
                    end
                    if BestUnit then
                        BestUnit:Cast(Hemorrhage)
                        return
                    end
                end
            end
            if
            FanofKnives:Exists() and IsOptionEnabled("刀扇") and UseAOE() and
            (NumEnemies_10y >= GetOptionValue("刀扇") + (InsigniaofRavenholdt:IsEquipped() and 1 or 0) or
            (UseAOE() and Player:BuffCount(DreadlordsDeceit) >= 29)) and
            Player:CanCast(FanofKnives)
            then
                Player:Cast(FanofKnives)
                return
            end
            if Mutilate:Exists() then
                if Target:DebuffRefreshable(DeadlyPoisonDebuff, 4) and Target:CanCast(Mutilate) then
                    Target:Cast(Mutilate)
                    return
                end
                if UseAOE() and IsOptionEnabled("施放毁伤刷新毒药") then
                    local BestUnit, BestUnitTTD = nil, 0
                    local ThisUnit
                    for i = 1, NumEnemies_5y do
                        ThisUnit = Enemies_5y[i]
                        if
                        self:EveryoneUnitIsCycleValid(ThisUnit, BestUnitTTD) and
                        ThisUnit:DebuffRefreshable(DeadlyPoisonDebuff, GetOptionValue("施放毁伤刷新毒药")) and
                        ThisUnit:CanCast(Mutilate)
                        then
                            BestUnit, BestUnitTTD = ThisUnit, ThisUnit:TimeToDie()
                        end
                    end
                    if BestUnit then
                        BestUnit:Cast(Mutilate)
                        return
                    end
                end
                if Target:CanCast(Mutilate) then
                    Target:Cast(Mutilate)
                    return
                end
            end
        end
        if
        IsOptionEnabled("剧毒之刃") and PoisonedKnife:Exists() and not Player:IsWithinCastRange(Target, Mutilate) and
        not Player:IsStealthed(true, true) and
        Player:Energy() > GetOptionValue("剧毒之刃") and
        (Player:ComboPoints() < Player:ComboPointsMax() or Player:PowerTimeToMax() <= 1.5) and
        Target:CanCast(PoisonedKnife)
        then
            Target:Cast(PoisonedKnife)
            return
        end
    end
end
function Rotation:OutOfCombat()
    StealthAllowed = GetNumLootItems() == 0 and not UnitExists("npc") and OutOfCombatTime() > 1 and true or false
    if IsOptionEnabled("搜索") and not Player.PickPocketInitialized then
        Player:PickPocketInit()
    end
    if not Player:IsMoving() and IsOptionEnabled("致命 | 非致命") then
        PoisonLethal = GetOptionValue("致命 | 非致命")
        PoisonNonLethal = GetSecondOptionValue("致命 | 非致命")
        PoisonMinDuration = GetOptionValue("自动上毒药(分钟)") * 60
        PoisonCastTime = 1.8
        if
        PoisonLethal == "致命药膏" and Player:BuffRemains(DeadlyPoison) <= PoisonMinDuration and
        DeadlyPoison:TimeSinceCast() > PoisonCastTime and
        Player:CanCast(DeadlyPoison)
        then
            Player:Cast(DeadlyPoison)
            DeadlyPoison.LastCastTime = GetTime()
            return
        elseif
        PoisonLethal == "致伤药膏" and Player:BuffRemains(WoundPoison) <= PoisonMinDuration and
        WoundPoison:TimeSinceCast() > PoisonCastTime and
        Player:CanCast(WoundPoison)
        then
            Player:Cast(WoundPoison)
            WoundPoison.LastCastTime = GetTime()
            return
        end
        if
        (not LeechingPoison:Exists() or PoisonNonLethal == "减速药膏") and
        Player:BuffRemains(CripplingPoison) <= PoisonMinDuration and
        CripplingPoison:TimeSinceCast() > PoisonCastTime and
        Player:CanCast(CripplingPoison)
        then
            Player:Cast(CripplingPoison)
            CripplingPoison.LastCastTime = GetTime()
            return
        elseif
        PoisonNonLethal == "吸血药膏" and LeechingPoison:Exists() and
        Player:BuffRemains(LeechingPoison) <= PoisonMinDuration and
        LeechingPoison:TimeSinceCast() > PoisonCastTime and
        Player:CanCast(LeechingPoison)
        then
            Player:Cast(LeechingPoison)
            LeechingPoison.LastCastTime = GetTime()
            return
        end
    end
    if
    IsOptionEnabled("潜行") and GetOptionValue("潜行") == "无条件使用" and StealthAllowed and not Player:IsStealthed(true) and
    Stealth:TimeSinceCast() > 0.4 and
    Player:CanCast(Stealth)
    then
        Player:Cast(Stealth)
        Stealth.LastCastTime = GetTime()
        return
    end
    if
    IsOptionEnabled("猩红之瓶") and CrimsonVial:Exists() and Player:HealthPercentage() <= GetOptionValue("猩红之瓶") and
    Player:CanCast(CrimsonVial)
    then
        Player:Cast(CrimsonVial)
        return
    end
    if
    IsOptionEnabled("对焦点施放嫁祸诀窍") and TricksoftheTrade:Exists() and BMPullTime() <= 1.5 and Focus:Exists() and
    Focus:IsInParty() and
    not Focus:Equals(Player) and
    Focus:CanCast(TricksoftheTrade)
    then
        Focus:Cast(TricksoftheTrade)
    end
    Player:UsePotions("Agility")
    if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        if
        IsOptionEnabled("潜行") and Player:DistanceTo(Target) < 25 and StealthAllowed and not Player:IsStealthed(true) and
        Stealth:TimeSinceCast() > 0.4 and
        Player:CanCast(Stealth)
        then
            Player:Cast(Stealth)
            Stealth.LastCastTime = GetTime()
            return
        end
        if Player:IsStealthed(true) and Player:HealthPercentage() > GetOptionValue("消失 防御") then
            if
            IsOptionEnabled("对焦点施放嫁祸诀窍") and TricksoftheTrade:Exists() and Player:DistanceTo(Target) < 10 and
            BMPullTime() == 60 and
            Focus:Exists() and
            Focus:IsInParty() and
            not Focus:Equals(Player) and
            Focus:CanCast(TricksoftheTrade)
            then
                Focus:Cast(TricksoftheTrade)
            end
            if BMPullTime() == 60 or BMPullTime() <= 0.5 then
                if IsOptionEnabled("搜索") and PickPocket:Exists() and not Player.PickPocketed[Target:GUID()] then
                    if Target:CanCast(PickPocket) then
                        Target:Cast(PickPocket)
                        PickPocketTarget = Target:GUID()
                        PickPocketAttempt = GetTime()
                    end
                    return
                end
                if IsOptionEnabled("自动进入战斗") and (BMPullTime() == 60 or BMPullTime() <= 0.5) then
                    if
                    IsOptionEnabled("偷袭") and CheapShot:Exists() and not Target:IsBoss() and
                    Target:CanCast(CheapShot)
                    then
                        Target:Cast(CheapShot)
                        return
                    end
                    if Garrote:Exists() and Target:CanCast(Garrote) then
                        Target:Cast(Garrote)
                        return
                    end
                    if Target:CanCast(Mutilate) then
                        Target:Cast(Mutilate)
                        return
                    end
                end
            end
        end
    end
end
SetRotation(260, {})
local Rotation = Rotations[260]
function Rotation:Initialize()
    ArcaneTorrent = Spell(25046, false, false, true)
    Berserking = Spell(26297, false, false, true)
    BloodFury = Spell(20572, false, false, true)
    GiftOfTheNaaru = Spell(59547, false, false, true)
    Shadowmeld = Spell(58984, false, false, true)
    AdrenalineRush = Spell(13750, false, false, true)
    Ambush = Spell(8676, true, true, true)
    BetweentheEyes = Spell(199804, true, true, true)
    BladeFlurry = Spell(13877, false, false, true)
    Gouge = Spell(1776, true, true, true)
    Opportunity = Spell(195627)
    PistolShot = Spell(185763, true, true, true)
    RolltheBones = Spell(193316, false, false, true)
    RunThrough = Spell(2098, true, true, true)
    SaberSlash = Spell(193315, true, true, true)
    Stealth = Spell(1784, false, false, true)
    Vanish = Spell(1856, false, false, true)
    Alacrity = Spell(193539)
    AlacrityBuff = Spell(193538)
    Anticipation = Spell(114015)
    CannonballBarrage = Spell(185767, false, true, true)
    DeathFromAbove = Spell(152150, true, true, true)
    DeeperStratagem = Spell(193531)
    DirtyTricks = Spell(108216)
    GhostlyStrike = Spell(196937, true, true, true)
    KillingSpree = Spell(51690, false, true, true)
    MarkedForDeath = Spell(137619, false, true, true)
    QuickDraw = Spell(196938)
    SliceandDice = Spell(5171, false, false, true)
    Vigor = Spell(14983)
    Blunderbuss = Spell(202895, true, true, true)
    CurseoftheDreadblades = Spell(202665, false, false, true)
    HiddenBlade = Spell(202754)
    LoadedDice = Spell(240837)
    CloakofShadows = Spell(31224, false, false, true)
    CrimsonVial = Spell(185311, false, false, true)
    Feint = Spell(1966, false, false, true)
    Riposte = Spell(199754, false, false, true)
    CheapShot = Spell(1833, true, true, true)
    Kick = Spell(1766, true, true, true)
    Gouge = Spell(1776, true, true, true)
    PickPocket = Spell(921, true, true, true)
    Sprint = Spell(2983, false, false, true)
    TricksoftheTrade = Spell(57934, false, false, true)
    Broadsides = Spell(193356)
    BuriedTreasure = Spell(199600)
    GrandMelee = Spell(193358)
    JollyRoger = Spell(199603)
    SharkInfestedWaters = Spell(193357)
    TrueBearing = Spell(193359)
    GreenskinsBuff = Spell(209423)
    MasterAssassinsInitiative = Spell(235027)
    GreenskinsItem = Item(137099, { 9 })
    MantleoftheMasterAssassin = Item(144236, { 3 })
    ThraxisTricksyTreads = Item(137031, { 8 })
    AddPage("常规")
    AddPage("进攻")
    AddPage("防御")
    AddCommonOptions()
    AddPresetOption("GeneralRogue", "Melee", nil, false)
    AddSection("常规", "单打", "Yellow")
    AddNewOption(
    "常规",
    "偷袭",
    210,
    false,
    nil,
    nil,
    "Enable for the automatic usage of Cheap Shot." ..
    C.TOOLTIP_HINT("Useful if you're having hard time while soloing.")
    )
    AddNewOption(
    "常规",
    "搜索",
    210,
    false,
    nil,
    nil,
    "Will PickPocket your target before engaging it." ..
    C.TOOLTIP_HINT("Enabling Pick Pocket will turn on Auto-Loot.")
    )
    AddPresetOption("进攻")
    if Shadowmeld:Exists() then
        AddPresetOption("Cooldown", "进攻性种族技能")
    end
    AddSection("进攻", "常规", "Yellow")
    AddNewOption(
    "进攻",
    "潜行",
    230,
    true,
    { 1, "无条件使用", "Near Target" },
    nil,
    "Enable for the automatic usage of Stealth." ..
    C.TOOLTIP_VALUE ..
    C.TOOLTIP_SUBVALUE("无条件使用", true) ..
    "Everytime it is available." .. C.TOOLTIP_SUBVALUE("Near Target") .. "When approaching your target."
    )
    AddSection("进攻", "大技能", "Yellow")
    AddNewOption(
    "进攻",
    "死亡标记",
    233,
    true,
    { 2, "目标", "Adds" },
    { 1, "无条件使用", "大技能用法" },
    "Enable for the automatic usage of Marked for Death." ..
    C.TOOLTIP_VALUE_1 ..
    C.TOOLTIP_SUBVALUE("目标", true) ..
    "Only on your target with 1 or less CP." ..
    C.TOOLTIP_SUBVALUE("Adds") ..
    "On every units available." ..
    C.TOOLTIP_VALUE_2 ..
    C.TOOLTIP_SUBVALUE("无条件使用", true) ..
    "Will use the ability even if CDs are disabled." ..
    C.TOOLTIP_SUBVALUE("大技能用法") ..
    "Will only use the ability if CDs are enabled."
    )
    AddNewOption(
    "进攻",
    "消失",
    233,
    true,
    { 1, "无条件使用", "Not Tanking" },
    { 2, "无条件使用", "大技能用法" },
    "Enable for the automatic usage of Vanish." ..
    C.TOOLTIP_VALUE_1 ..
    C.TOOLTIP_SUBVALUE("无条件使用", true) ..
    "Will 'Always' use Vanish no matter if you're tanking or not." ..
    C.TOOLTIP_SUBVALUE("Not Tanking") ..
    "Will only use Vanish if you're 'Not Tanking' the target (Mostly for Solo)." ..
    C.TOOLTIP_VALUE_2 ..
    C.TOOLTIP_SUBVALUE("无条件使用", true) ..
    "Will use the ability even if CDs are disabled." ..
    C.TOOLTIP_SUBVALUE("大技能用法") ..
    "Will only use the ability if CDs are enabled."
    )
    AddNewOption(
    "进攻",
    "恐惧之刃诅咒",
    230,
    true,
    { 2, "无条件使用", "大技能用法" },
    nil,
    "Enable for the automatic usage of Curse of the Dreadblades." ..
    C.TOOLTIP_VALUE ..
    C.TOOLTIP_SUBVALUE("无条件使用", true) ..
    "Will use the ability even if CDs are disabled." ..
    C.TOOLTIP_SUBVALUE("大技能用法") .. "Will only use the ability if CDs are enabled."
    )
    AddNewOption(
    "进攻",
    "炮弹弹幕 | 影舞步",
    223,
    true,
    { 1, 1, 3, 1 },
    { 2, "无条件使用", "大技能用法" },
    "Enable for the automatic usage of Cannonball Barrage | Killing Spree." ..
    C.TOOLTIP_VALUE_1 ..
    "Set the number of unit around you required in order to use Cannonball Barrage." ..
    C.TOOLTIP_VALUE_2 ..
    C.TOOLTIP_SUBVALUE("无条件使用", true) ..
    "Will use the ability even if CDs are disabled." ..
    C.TOOLTIP_SUBVALUE("大技能用法") .. "Will only use the ability if CDs are enabled."
    )
    AddNewOption("进攻", "冲动", 210, true, nil, nil, "Enable for the automatic usage of Adrenaline Rush.")
    AddSection("进攻", "能力", "Yellow")
    AddNewOption(
    "进攻",
    "命运骨骰逻辑",
    130,
    true,
    {
        1,
        "默认",
        "1+ Buff",
        "Broadsides",
        "Buried Treasure",
        "Grand Melee",
        "Jolly Roger",
        "Shark Infested Waters",
        "True Bearing"
    },
    nil,
    "Choose the Roll the Bones logic." ..
    C.TOOLTIP_VALUE ..
    C.TOOLTIP_SUBVALUE("默认", true) ..
    "Will reroll according to the SimC Default APL." ..
    C.TOOLTIP_SUBVALUE("1+ Buff") ..
    "Will just refresh Roll the Bones." ..
    C.TOOLTIP_SUBVALUE("Broadsides") ..
    "Will reroll until having at least Broadsides." ..
    C.TOOLTIP_SUBVALUE("Buried Treasure") ..
    "Will reroll until having at least Buried Treasure." ..
    C.TOOLTIP_SUBVALUE("Grand Melee") ..
    "Will reroll until having at least Grand Melee." ..
    C.TOOLTIP_SUBVALUE("Jolly Roger") ..
    "Will reroll until having at least Jolly Roger." ..
    C.TOOLTIP_SUBVALUE("Shark Infested Waters") ..
    "Will reroll until having at least Shark Infested Waters." ..
    C.TOOLTIP_SUBVALUE("True Bearing") ..
    "Will reroll until having at least True Bearing."
    )
    AddNewOption("进攻", "抢先施放死亡标记|命运骨骰", 210, false, nil, nil, "Enable to auto cast MfD and RtB during Prepull.")
    AddNewOption(
    "进攻",
    "剑刃乱舞",
    220,
    true,
    { 1, 0, 9, 1 },
    nil,
    "Enable for the automatic usage of Blade Flurry." ..
    C.TOOLTIP_VALUE ..
    "Set the timer to keep the Blade Flurry active after having only 1 enemy." ..
    C.TOOLTIP_HINT("Useful on fight where units jump in and out.")
    )
    AddNewOption(
    "进攻",
    "萨茜的迷惑之靴 疾跑",
    210,
    true,
    nil,
    nil,
    "Enable for the automatic usage of Sprint with Thraxis legendary."
    )
    AddNewOption("进攻", "邪恶计谋 凿击", 210, true, nil, nil, "Enable for the automatic usage of Gouge with Dirty Tricks.")
    AddNewOption(
    "进攻",
    "智能手枪射击",
    220,
    true,
    { 75, 40, 150, 1 },
    nil,
    "Enable to auto use Pistol Shot while not being in melee range and not being stealthed." ..
    C.TOOLTIP_VALUE .. "Set the minimum energy to start using it."
    )
    AddPresetOption("防御")
    AddSection("防御", "能力", "Yellow")
    AddNewOption("防御", "猩红之瓶", 220, true, { 65, 1, 100, 1 }, nil, "Health Percentage to use Crimson Vial.")
    AddNewOption(
    "防御",
    "佯攻",
    220,
    false,
    { 55, 1, 100, 1 },
    nil,
    "Health Percentage to use Feint." .. C.TOOLTIP_HINT("Put 100 to maintain 100% uptime.")
    )
    AddSection("防御", "大技能", "Yellow")
    AddNewOption("防御", "还击", 220, true, { 25, 1, 100, 1 }, nil, "Health Percentage to use Riposte.")
    AddNewOption("防御", "暗影斗篷", 220, true, { 45, 1, 100, 1 }, nil, "Health Percentage to use Cloak of Shadows.")
    AddNewOption(
    "防御",
    "施放影舞步前使用暗影斗篷",
    210,
    false,
    nil,
    nil,
    "Enable for the automatic usage of Cloak of Shadows if not in CD before using Kiling Spree."
    )
    AddNewOption("防御", "消失 防御", 220, false, { 10, 1, 100, 1 }, nil, "Health Percentage to use Vanish defensively.")
    RegisterCommand(
    "feint",
    function()
        if ShouldFeint == true then
            ShouldFeint = false
            Bug("Feint Queue Canceled")
        elseif Feint:Exists() then
            ShouldFeint = true
            Bug("Feint Queued")
        end
    end
    )
    self.StealthAllowed, self.CombatStealthAllowed = false, true
    self.BFTimer, self.BFReset = 0, nil
    self.Cache = { RtB_Buffs = nil, RtB_BuffRemains = nil, RtB_List = nil }
    self.Sequence = nil
    self.Count = nil
    self.RtB_BuffsList = { Broadsides, BuriedTreasure, GrandMelee, JollyRoger, SharkInfestedWaters, TrueBearing }
end
function Rotation:CPMaxSpend()
    return DeeperStratagem:Exists() and 6 or 5
end
function Rotation:MantleDuration()
    if Player:BuffRemains(MasterAssassinsInitiative) < 0 then
        return Player:GlobalCooldown() + 6
    else
        return Player:BuffRemains(MasterAssassinsInitiative)
    end
end
function Rotation:Otl_RtB_List(Type, List)
    if not self.Cache.RtB_List then
        self.Cache.RtB_List = {}
    end
    if not self.Cache.RtB_List[Type] then
        self.Cache.RtB_List[Type] = {}
    end
    self.Sequence = table.concat(List)
    if Type == "All" then
        if not self.Cache.RtB_List[Type][self.Sequence] then
            self.Count = 0
            for i = 1, #List do
                if Player:Buff(self.RtB_BuffsList[List[i]]) then
                    self.Count = self.Count + 1
                end
            end
            self.Cache.RtB_List[Type][self.Sequence] = self.Count == #List and true or false
        end
    else
        if not self.Cache.RtB_List[Type][self.Sequence] then
            self.Cache.RtB_List[Type][self.Sequence] = false
            for i = 1, #List do
                if Player:Buff(self.RtB_BuffsList[List[i]]) then
                    self.Cache.RtB_List[Type][self.Sequence] = true
                    break
                end
            end
        end
    end
    return self.Cache.RtB_List[Type][self.Sequence]
end
function Rotation:Otl_RtB_BuffRemains()
    if not self.Cache.RtB_BuffRemains then
        self.Cache.RtB_BuffRemains = 0
        for i = 1, #self.RtB_BuffsList do
            if Player:Buff(self.RtB_BuffsList[i]) then
                self.Cache.RtB_BuffRemains = Player:BuffRemains(self.RtB_BuffsList[i])
                break
            end
        end
    end
    return self.Cache.RtB_BuffRemains
end
function Rotation:Otl_RtB_Buffs()
    if not self.Cache.RtB_Buffs then
        self.Cache.RtB_Buffs = 0
        for i = 1, #self.RtB_BuffsList do
            if Player:Buff(self.RtB_BuffsList[i]) then
                self.Cache.RtB_Buffs = self.Cache.RtB_Buffs + 1
            end
        end
    end
    return self.Cache.RtB_Buffs
end
function Rotation:Events()
end
function Rotation:Pulse()
    if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
        return
    end
    if GetTime() < Rotation.SpamPrevention then
        return
    end
    Rotation.SpamPrevention = GetTime() + 0.05
    self.Cache.RtB_Buffs = nil
    self.Cache.RtB_BuffRemains = nil
    self.Cache.RtB_List = nil
    Target = Unit.Target
    local InCombat = Player:IsInCombat()
    MaxComboPoint = Anticipation:Exists() and 10 or DeeperStratagem:Exists() and 6 or 5
    CPDiff = MaxComboPoint - Player:ComboPoints()
    self.CombatStealthAllowed = Vanish:TimeSinceCast() > 0.5 and Shadowmeld:TimeSinceCast() > 0.5
    if Feint:Exists() and ShouldFeint and not Player:Buff(Feint) then
        if Player:CanCast(Feint) then
            Player:Cast(Feint)
            ShouldFeint = false
        end
        return
    end
    if not InCombat then
        self:OutOfCombat()
        return
    end
    if InCombat then
        self:Defensives()
    end
    Target = Player:ReTarget(SaberSlash, false) or Unit.Target
    if Target:Exists() then
        Rotations:RefreshUnitTables(Rotation.Identifier)
        self:Interrupts()
        self:OffGCDAbilities()
        if Player:GlobalCooldown() == 0 then
            self:Combat()
        end
    end
end
function Rotation:Defensives()
    Player:UseHealingItem()
    if
    IsOptionEnabled("消失 防御") and not Player:IsStealthed(true, true) and self.CombatStealthAllowed and
    Player:HealthPercentage() <= GetOptionValue("消失 防御") and
    Player:CanCast(Vanish)
    then
        Player:Cast(Vanish)
        Vanish.LastCastTime = GetTime()
        return
    end
    if
    IsOptionEnabled("还击") and Riposte:Exists() and not Player:Buff(Riposte) and
    Player:HealthPercentage() <= GetOptionValue("还击") and
    Player:CanCast(Riposte)
    then
        Player:Cast(Riposte)
    end
    if
    IsOptionEnabled("暗影斗篷") and CloakofShadows:Exists() and Player:HealthPercentage() <= GetOptionValue("暗影斗篷") and
    Player:CanCast(CloakofShadows)
    then
        Player:Cast(CloakofShadows)
    end
    if
    IsOptionEnabled("佯攻") and Feint:Exists() and Player:HealthPercentage() <= GetOptionValue("佯攻") and
    not Player:Buff(Feint) and
    Player:CanCast(Feint)
    then
        Player:Cast(Feint)
        return
    end
    if
    IsOptionEnabled("猩红之瓶") and CrimsonVial:Exists() and Player:HealthPercentage() <= GetOptionValue("猩红之瓶") and
    Player:CanCast(CrimsonVial)
    then
        Player:Cast(CrimsonVial)
        return
    end
end
function Rotation:Interrupts()
    Player:UseInterrupt(Kick, ArcaneTorrent)
end
function Rotation:OffGCDAbilities()
    if
    IsOptionEnabled("对焦点施放嫁祸诀窍") and
    (GetOptionValue("对焦点施放嫁祸诀窍") == "无条件使用" or (Player:ThreatSituation() and Player:ThreatSituation() >= 1)) and
    Focus:Exists() and
    Focus:IsInParty() and
    not Focus:Equals(Player) and
    Focus:CanCast(TricksoftheTrade)
    then
        Focus:Cast(TricksoftheTrade)
    end
    if Player:UseMarkedForDeath(MarkedForDeath, CPDiff) then
        return
    end
end
function Rotation:Otl_RtB_Reroll()
    if GetOptionValue("命运骨骰逻辑") == "1+ Buff" then
        return (not SliceandDice:Exists() and self:Otl_RtB_Buffs() <= 0) and true or false
    elseif GetOptionValue("命运骨骰逻辑") == "Broadsides" then
        return (not SliceandDice:Exists() and not Player:Buff(Broadsides)) and true or false
    elseif GetOptionValue("命运骨骰逻辑") == "Buried Treasure" then
        return (not SliceandDice:Exists() and not Player:Buff(BuriedTreasure)) and true or false
    elseif GetOptionValue("命运骨骰逻辑") == "Grand Melee" then
        return (not SliceandDice:Exists() and not Player:Buff(GrandMelee)) and true or false
    elseif GetOptionValue("命运骨骰逻辑") == "Jolly Roger" then
        return (not SliceandDice:Exists() and not Player:Buff(JollyRoger)) and true or false
    elseif GetOptionValue("命运骨骰逻辑") == "Shark Infested Waters" then
        return (not SliceandDice:Exists() and not Player:Buff(SharkInfestedWaters)) and true or false
    elseif GetOptionValue("命运骨骰逻辑") == "True Bearing" then
        return (not SliceandDice:Exists() and not Player:Buff(TrueBearing)) and true or false
    else
        return (not SliceandDice:Exists() and self:Otl_RtB_Buffs() < 2 and Player:Buff(LoadedDice)) and true or false
    end
end
function Rotation:Otl_SS_Useable_NoReroll()
    return (Player:ComboPoints() <
    5 + (DeeperStratagem:Exists() and 1 or 0) - ((Player:Buff(Broadsides) or Player:Buff(JollyRoger)) and 1 or 0) -
    ((Alacrity:Exists() and Player:BuffCount(AlacrityBuff) <= 4) and 1 or 0)) and
    true or
    false
end
function Rotation:Otl_SS_Useable()
    return ((Anticipation:Exists() and Player:ComboPoints() < 5) or
    (not Anticipation:Exists() and
    ((self:Otl_RtB_Reroll() and Player:ComboPoints() < 4 + (DeeperStratagem:Exists() and 1 or 0)) or
    (not self:Otl_RtB_Reroll() and self:Otl_SS_Useable_NoReroll())))) and
    true or
    false
end
function Rotation:Olt_Ambush_Condition()
    return (Player:ComboPointsDeficit() >=
    2 + 2 * ((GhostlyStrike:Exists() and not Target:Debuff(GhostlyStrike)) and 1 or 0) +
    (Player:Buff(Broadsides) and 1 or 0) and
    Player:Energy() > 60 and
    not Player:Buff(JollyRoger) and
    not Player:Buff(HiddenBlade)) and
    true or
    false
end
function Rotation:Otl_Bf()
    if
    IsOptionEnabled("剑刃乱舞") and
    ((NumEnemies_8y >= 2 and not Player:Buff(BladeFlurry) and Player:CanCast(BladeFlurry)) or
    (NumEnemies_8y < 2 and Player:Buff(BladeFlurry) and GetTime() > self.BFTimer))
    then
        Player:Cast(BladeFlurry)
    end
    return false
end
function Rotation:Otl_Build()
    if
    GhostlyStrike:Exists() and GhostlyStrike:TimeSinceCast() > 1.5 and
    Player:ComboPointsDeficit() >= 1 + (Player:Buff(Broadsides) and 1 or 0) and
    not Player:Debuff(CurseoftheDreadblades) and
    (Target:DebuffRefreshable(GhostlyStrike, 4.5) or
    (IsOptionEnabled("恐惧之刃诅咒") and CurseoftheDreadblades:Exists() and
    (CooldownsAllowed() or GetOptionValue("恐惧之刃诅咒") == "无条件使用") and
    CurseoftheDreadblades:Cooldown() < 3 and
    Target:DebuffRemains(GhostlyStrike) < 14)) and
    (Player:ComboPoints() >= 3 or (self:Otl_RtB_Reroll() and CombatTime() >= 10)) and
    Target:CanCast(GhostlyStrike)
    then
        Target:Cast(GhostlyStrike)
        GhostlyStrike.LastCastTime = GetTime()
        return "Cast Ghostly Strike"
    end
    if
    PistolShot:Exists() and Player:ComboPointsDeficit() >= 1 + (Player:Buff(Broadsides) and 1 or 0) and
    Player:Buff(Opportunity) and
    (Player:EnergyTimeToMax() > 2 - (QuickDraw:Exists() and 1 or 0) or
    (IsUsableSpell(Blunderbuss:Name()) and Player:Buff(GreenskinsBuff)) or
    (Player:Buff(GreenskinsBuff) and Player:BuffRemains(GreenskinsBuff) < 3)) and
    Target:CanCast(PistolShot)
    then
        Bug("Blunderbuss: " .. tostring(IsUsableSpell(Blunderbuss:Name())))
        Target:Cast(PistolShot)
        return "Cast Pistol Shot"
    end
    if SaberSlash:Exists() and self:Otl_SS_Useable() and Target:CanCast(SaberSlash) then
        Target:Cast(SaberSlash)
        return "Cast Saber Slash"
    end
    return false
end
function Rotation:Otl_Cds()
    if Player:IsWithinCastRange(Target, SaberSlash) then
        Player:UsePotions("Agility")
        if CooldownsAllowed() then
            Player:UseTrinkets()
            if (BloodFury:Exists() or Berserking:Exists() or ArcaneTorrent:Exists()) and CDOptionEnabled("进攻性种族技能") then
                if BloodFury:Exists() and Player:CanCast(BloodFury) then
                    Player:Cast(BloodFury)
                end
                if Berserking:Exists() and Player:CanCast(Berserking) then
                    CastSpellByID(26297, "player")
                end
                if ArcaneTorrent:Exists() and Player:CanCast(ArcaneTorrent) and Player:EnergyDeficit() > 40 then
                    Player:Cast(ArcaneTorrent)
                end
            end
            if
            IsOptionEnabled("炮弹弹幕 | 影舞步") and (CooldownsAllowed() or GetSecondOptionValue("炮弹弹幕 | 影舞步") == "无条件使用") and
            CannonballBarrage:Exists() and
            NumEnemies_8y >= GetOptionValue("炮弹弹幕 | 影舞步") and
            Target:CanCast(CannonballBarrage) and
            Player:CastGround(CannonballBarrage, 2, 6, 30, true)
            then
                return "Cast CB"
            end
            if
            IsOptionEnabled("冲动") and AdrenalineRush:Exists() and not Player:Buff(AdrenalineRush) and
            Player:EnergyDeficit() > 0 and
            Player:CanCast(AdrenalineRush)
            then
                Player:Cast(AdrenalineRush)
            end
        end
        if
        IsOptionEnabled("死亡标记") and GetOptionValue("死亡标记") == "目标" and
        (CooldownsAllowed() or GetSecondOptionValue("死亡标记") == "无条件使用") and
        MarkedForDeath:Exists() and
        not Player:IsStealthed(true, true) and
        Player:ComboPointsDeficit() >= self:CPMaxSpend() - 1 and
        Target:CanCast(MarkedForDeath)
        then
            Target:Cast(MarkedForDeath)
            return "Cast MfD"
        end
        if
        IsOptionEnabled("萨茜的迷惑之靴 疾跑") and ThraxisTricksyTreads:IsEquipped() and not self:Otl_SS_Useable() and
        Player:CanCast(Sprint)
        then
            Player:Cast(Sprint)
        end
        if
        IsOptionEnabled("恐惧之刃诅咒") and CurseoftheDreadblades:Exists() and
        (CooldownsAllowed() or GetOptionValue("恐惧之刃诅咒") == "无条件使用") and
        Player:ComboPointsDeficit() >= 4 and
        (not GhostlyStrike:Exists() or Target:Debuff(GhostlyStrike)) and
        Player:CanCast(CurseoftheDreadblades)
        then
            Player:Cast(CurseoftheDreadblades)
            return "Cast CotD"
        end
    end
    return false
end
function Rotation:Otl_Finish()
    if
    BetweentheEyes:Exists() and
    ((self:MantleDuration() >= Player:GlobalCooldown() + 0.2 and not ThraxisTricksyTreads:IsEquipped()) or
    (GreenskinsItem:IsEquipped() and not Player:Buff(GreenskinsBuff))) and
    Target:CanCast(BetweentheEyes)
    then
        Target:Cast(BetweentheEyes)
        return "Cast Between the Eyes"
    end
    if
    RunThrough:Exists() and
    (not DeathFromAbove:Exists() or Player:EnergyTimeToMax() < DeathFromAbove:Cooldown() + 3.5) and
    Target:CanCast(RunThrough)
    then
        Target:Cast(RunThrough)
        return "Cast Run Through"
    end
    return false
end
function Rotation:Otl_Stealth()
    if
    Ambush:Exists() and (Player:IsStealthed(true, true) or not self.CombatStealthAllowed) and
    self:Olt_Ambush_Condition() and
    Target:CanCast(Ambush)
    then
        Target:Cast(Ambush)
        return "Cast Ambush"
    end
    if
    Player:IsWithinCastRange(Target, SaberSlash) and
    (not Player:IsTanking(Target) or GetOptionValue("消失") == "无条件使用") and
    not Player:IsStealthed(true, true) and
    self.CombatStealthAllowed
    then
        if
        IsOptionEnabled("消失") and Vanish:Exists() and (CooldownsAllowed() or GetSecondOptionValue("消失") == "无条件使用") and
        (self:Olt_Ambush_Condition() or
        (MantleoftheMasterAssassin:IsEquipped() and self:MantleDuration() == 0 and not self:Otl_RtB_Reroll() and
        not self:Otl_SS_Useable())) and
        Player:CanCast(Vanish)
        then
            Player:Cast(Vanish)
            Vanish.LastCastTime = GetTime()
            return "Cast Vanish"
        end
        if
        Shadowmeld:Exists() and CDOptionEnabled("进攻性种族技能") and Player:Standing() >= 0.7 and
        self:Olt_Ambush_Condition() and
        Player:CanCast(Shadowmeld)
        then
            Player:Cast(Shadowmeld)
            Shadowmeld.LastCastTime = GetTime()
            return "Cast Shadowmeld"
        end
    end
    return false
end
function Rotation:UnitTables()
    Enemies_8y = UseAOE() and Player:EnemiesWithinDistance(6.5, true) or {}
    NumEnemies_8y = #Enemies_8y
end
function Rotation:Combat()
    if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        if not Player:IsStealthed(true) then
            Player:StartAttack()
        end
        if NumEnemies_8y == 1 and self.BFReset then
            self.BFTimer, self.BFReset = GetTime() + GetOptionValue("剑刃乱舞"), false
        elseif NumEnemies_8y > 1 then
            self.BFReset = true
        end
        self:Otl_Bf()
        if self:Otl_Cds() then
            return
        end
        if self:Otl_Stealth() then
            return
        end
        if
        DeathFromAbove:Exists() and Player:EnergyTimeToMax() > 2 and not self:Otl_SS_Useable_NoReroll() and
        Target:CanCast(DeathFromAbove)
        then
            Target:Cast(DeathFromAbove)
            return "Cast Death From Above"
        end
        if SliceandDice:Exists() then
            if
            not self:Otl_SS_Useable() and Player:BuffRemains(SliceandDice) < Target:TimeToDie() and
            Player:BuffRemains(SliceandDice) < (1 + Player:ComboPoints()) * 1.8 and
            Player:CanCast(SliceandDice)
            then
                Player:Cast(SliceandDice)
                return "Cast Slice and Dice"
            end
        else
            if
            RolltheBones:Exists() and not self:Otl_SS_Useable() and
            (Target:TimeToDie() > 20 or self:Otl_RtB_BuffRemains() < Target:TimeToDie() or
            self:Otl_RtB_BuffRemains() == 0) and
            (self:Otl_RtB_BuffRemains() <= 3 or self:Otl_RtB_Reroll()) and
            Player:CanCast(RolltheBones)
            then
                Player:Cast(RolltheBones)
                return "Cast Roll the Bones"
            end
        end
        if
        IsOptionEnabled("炮弹弹幕 | 影舞步") and (CooldownsAllowed() or GetSecondOptionValue("炮弹弹幕 | 影舞步") == "无条件使用") and
        KillingSpree:Exists() and
        (Player:PowerTimeToMax() > 5 or Player:Energy() < 15) and
        Target:CanCast(KillingSpree)
        then
            if IsOptionEnabled("施放影舞步前使用暗影斗篷") and Player:CanCast(CloakofShadows) then
                Player:Cast(CloakofShadows)
            end
            Target:Cast(KillingSpree)
            return
        end
        if self:Otl_Build() then
            return
        end
        if not self:Otl_SS_Useable() then
            if self:Otl_Finish() then
                return
            end
        end
        if
        IsOptionEnabled("邪恶计谋 凿击") and DirtyTricks:Exists() and Player:ComboPointsDeficit() >= 1 and
        Target:IsFacing(Player) and
        Target:CanCast(Gouge)
        then
            Target:Cast(Gouge)
            return "Cast Gouge"
        end
        if
        IsOptionEnabled("智能手枪射击") and PistolShot:Exists() and not Player:IsWithinCastRange(Target, SaberSlash) and
        not Player:IsStealthed(true, true) and
        Player:Energy() > GetOptionValue("智能手枪射击") and
        (Player:ComboPoints() < MaxComboPoint or Player:PowerTimeToMax() <= 1.5) and
        Target:CanCast(PistolShot)
        then
            Target:Cast(PistolShot)
            return "Cast Pistol Shot"
        end
        return
    end
end
function Rotation:OutOfCombat()
    self.StealthAllowed = GetNumLootItems() == 0 and not UnitExists("npc") and OutOfCombatTime() > 1 and true or false
    if IsOptionEnabled("搜索") and not Player.PickPocketInitialized then
        Player:PickPocketInit()
    end
    if
    IsOptionEnabled("潜行") and GetOptionValue("潜行") == "无条件使用" and self.StealthAllowed and not Player:IsStealthed() and
    Stealth:TimeSinceCast() > 0.4 and
    Player:CanCast(Stealth)
    then
        Player:Cast(Stealth)
        Stealth.LastCastTime = GetTime()
        return
    end
    if IsOptionEnabled("猩红之瓶") and Player:HealthPercentage() <= GetOptionValue("猩红之瓶") and Player:CanCast(CrimsonVial) then
        Player:Cast(CrimsonVial)
        return
    end
    if
    IsOptionEnabled("对焦点施放嫁祸诀窍") and BMPullTime() <= 1.5 and Focus:Exists() and Focus:IsInParty() and
    not Focus:Equals(Player) and
    Focus:CanCast(TricksoftheTrade)
    then
        Focus:Cast(TricksoftheTrade)
    end
    Player:UsePotions("Agility")
    if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        if
        IsOptionEnabled("潜行") and Player:DistanceTo(Target) < 25 and self.StealthAllowed and
        not Player:IsStealthed() and
        Stealth:TimeSinceCast() > 0.4 and
        Player:CanCast(Stealth)
        then
            Player:Cast(Stealth)
            Stealth.LastCastTime = GetTime()
            return
        end
        if Player:IsStealthed(true, true) and Player:HealthPercentage() > GetOptionValue("消失 防御") then
            if
            IsOptionEnabled("对焦点施放嫁祸诀窍") and Player:DistanceTo(Target) < 10 and BMPullTime() == 60 and
            Focus:Exists() and
            Focus:IsInParty() and
            not Focus:Equals(Player) and
            Focus:CanCast(TricksoftheTrade)
            then
                Focus:Cast(TricksoftheTrade)
            end
            if IsOptionEnabled("搜索") and not Player.PickPocketed[Target:GUID()] then
                if Target:CanCast(PickPocket) then
                    Target:Cast(PickPocket)
                    PickPocketTarget = Target:GUID()
                    PickPocketAttempt = GetTime()
                end
                return
            end
            if IsOptionEnabled("抢先施放死亡标记|命运骨骰") and BMPullTime() <= 2.5 then
                if Player:ComboPoints() < 2 and MarkedForDeath:Exists() and Target:CanCast(MarkedForDeath) then
                    Target:Cast(MarkedForDeath)
                end
                if Player:ComboPoints() > 2 and RolltheBones:Exists() and Player:CanCast(RolltheBones) then
                    Player:Cast(RolltheBones)
                    return
                end
            end
            if IsOptionEnabled("自动进入战斗") and (BMPullTime() == 60 or BMPullTime() <= 0.5) then
                if IsOptionEnabled("偷袭") and CheapShot:Exists() and not Target:IsBoss() and Target:CanCast(CheapShot) then
                    Target:Cast(CheapShot)
                    return
                end
                if Target:CanCast(Ambush) then
                    if
                    IsOptionEnabled("恐惧之刃诅咒") and CurseoftheDreadblades:Exists() and
                    (CooldownsAllowed() or GetOptionValue("恐惧之刃诅咒") == "无条件使用") and
                    Player:ComboPointsDeficit() >= 4 and
                    Player:CanCast(CurseoftheDreadblades)
                    then
                        Player:Cast(CurseoftheDreadblades)
                        return "Cast CotD"
                    end
                    Target:Cast(Ambush)
                    return
                end
            end
        end
    end
end
SetRotation(261, {})
local Rotation = Rotations[261]
function Rotation:Initialize()
    self.HasBetaRotation = true
    ArcaneTorrent = Spell(25046, false, false, true)
    Berserking = Spell(26297, false, false, true)
    BloodFury = Spell(20572, false, false, true)
    GiftOfTheNaaru = Spell(59547, false, false, true)
    Shadowmeld = Spell(58984, false, false, true)
    Backstab = Spell(53, true, true, true)
    Eviscerate = Spell(196819, true, true, true)
    Nightblade = Spell(195452, true, true, true)
    ShadowBlades = Spell(121471, false, false, true)
    ShadowDance = Spell(185313, false, false, true)
    ShadowDanceBuff = Spell(185422)
    Shadowstrike = Spell(185438, false, true, true)
    ShurikenStorm = Spell(197835, false, false, true)
    ShurikenToss = Spell(114014, true, true, true)
    Stealth = Spell(1784, false, false, true)
    StealthWithSubterfuge = Spell(115191, false, false, true)
    StealthWithoutSubterfuge = Spell(1784, false, false, true)
    SymbolsofDeath = Spell(212283, false, false, true)
    Vanish = Spell(1856, false, false, true)
    VanishBuff = Spell(115193)
    Alacrity = Spell(193539)
    AlacrityBuff = Spell(193538)
    Anticipation = Spell(114015)
    DarkShadow = Spell(245687)
    DeathfromAbove = Spell(152150, true, true, true)
    DeeperStratagem = Spell(193531)
    EnvelopingShadows = Spell(238104, false, false, true)
    Gloomblade = Spell(200758, true, true, true)
    MarkedForDeath = Spell(137619, false, true, true)
    MasterofShadows = Spell(196976)
    MasterofShadowsBuff = Spell(196980)
    MasterOfSubtlety = Spell(31223)
    MasterOfSubtletyBuff = Spell(31665)
    ShadowFocus = Spell(108209)
    Subterfuge = Spell(108208)
    Vigor = Spell(14983)
    FeedingFrenzy = Spell(242705)
    FinalityEviscerate = Spell(197496)
    FinalityNightblade = Spell(197498)
    FlickeringShadows = Spell(197256)
    GoremawsBite = Spell(209782, true, true, true)
    LegionBlade = Spell(214930)
    ShadowFangs = Spell(221856)
    CrimsonVial = Spell(185311, false, false, true)
    CloakofShadows = Spell(31224, false, false, true)
    Evasion = Spell(5277, false, false, true)
    Feint = Spell(1966, false, false, true)
    Blind = Spell(2094)
    CheapShot = Spell(1833, true, true, true)
    Kick = Spell(1766, true, true, true)
    KidneyShot = Spell(408, true, true, true)
    PickPocket = Spell(921, true, true, true)
    Sprint = Spell(2983, false, false, true)
    TricksoftheTrade = Spell(57934, false, false, true)
    DreadlordsDeceit = Spell(228224)
    MasterAssassinsInitiative = Spell(235027)
    TheFirstoftheDeadBuff = Spell(248210)
    DenialoftheHalfGiants = Item(137100, { 9 })
    DraughtofSouls = Item(140808, { 13, 14 })
    MantleoftheMasterAssassin = Item(144236, { 3 })
    ShadowSatyrsWalk = Item(137032, { 8 })
    TheFirstoftheDead = Item(151818, { 10 })
    InsigniaofRavenholdt = Item(137049, { 11, 12 })
    AddPage("常规")
    AddPage("进攻")
    AddPage("防御")
    if self.HasBetaRotation then
        AddNewOption(
        "常规",
        "测试版循环",
        210,
        true,
        nil,
        nil,
        "Use the lastest updated combat routine. May not be as optimized and can contain error regarding execution!"
        )
    end
    AddCommonOptions()
    AddPresetOption("GeneralRogue", "Melee", nil, false)
    AddSection("常规", "辅助", "Yellow")
    AddNewOption(
    "常规",
    "对焦点施放嫁祸诀窍",
    230,
    false,
    { 2, "无条件使用", "高仇恨" },
    nil,
    "Will use Tricks of the Trade on your focus if he's allied." ..
    C.TOOLTIP_VALUE ..
    C.TOOLTIP_SUBVALUE("无条件使用", true) ..
    "Everytime it is available." ..
    C.TOOLTIP_SUBVALUE("高仇恨") .. "Only if you have the aggro of something."
    )
    AddSection("常规", "单打", "Yellow")
    AddNewOption(
    "常规",
    "肾击",
    210,
    false,
    nil,
    nil,
    "Enable for the automatic usage of Kidney Shot." ..
    C.TOOLTIP_HINT("Useful if you're having hard time while soloing.")
    )
    AddNewOption(
    "常规",
    "偷袭",
    210,
    false,
    nil,
    nil,
    "Enable for the automatic usage of Cheap Shot." ..
    C.TOOLTIP_HINT("Useful if you're having hard time while soloing.")
    )
    AddNewOption(
    "常规",
    "搜索",
    210,
    false,
    nil,
    nil,
    "Will PickPocket your target before engaging it." ..
    C.TOOLTIP_HINT("Enabling Pick Pocket will turn on Auto-Loot.")
    )
    AddPresetOption("进攻")
    if Shadowmeld:Exists() then
        AddPresetOption("Cooldown", "进攻性种族技能")
    end
    AddNewOption(
    "进攻",
    "潜行",
    230,
    true,
    { 1, "无条件使用", "Near Target" },
    nil,
    "Enable for the automatic usage of Stealth." ..
    C.TOOLTIP_VALUE ..
    C.TOOLTIP_SUBVALUE("无条件使用", true) ..
    "Everytime it is available." .. C.TOOLTIP_SUBVALUE("Near Target") .. "When approaching your target."
    )
    AddSection("进攻", "大技能", "Yellow")
    AddNewOption(
    "进攻",
    "死亡标记",
    233,
    true,
    { 2, "目标", "Adds" },
    { 1, "无条件使用", "大技能用法" },
    "Enable for the automatic usage of Marked for Death." ..
    C.TOOLTIP_VALUE_1 ..
    C.TOOLTIP_SUBVALUE("目标", true) ..
    "Only on your target with 1 or less CP." ..
    C.TOOLTIP_SUBVALUE("Adds") ..
    "On every units available." ..
    C.TOOLTIP_VALUE_2 ..
    C.TOOLTIP_SUBVALUE("无条件使用", true) ..
    "Will use the ability even if CDs are disabled." ..
    C.TOOLTIP_SUBVALUE("大技能用法") ..
    "Will only use the ability if CDs are enabled."
    )
    AddNewOption(
    "进攻",
    "消失",
    233,
    true,
    { 1, "无条件使用", "Not Tanking" },
    { 2, "无条件使用", "大技能用法" },
    "Enable for the automatic usage of Vanish." ..
    C.TOOLTIP_VALUE_1 ..
    C.TOOLTIP_SUBVALUE("无条件使用", true) ..
    "Will 'Always' use Vanish no matter if you're tanking or not." ..
    C.TOOLTIP_SUBVALUE("Not Tanking") ..
    "Will only use Vanish if you're 'Not Tanking' the target (Mostly for Solo)." ..
    C.TOOLTIP_VALUE_2 ..
    C.TOOLTIP_SUBVALUE("无条件使用", true) ..
    "Will use the ability even if CDs are disabled." ..
    C.TOOLTIP_SUBVALUE("大技能用法") ..
    "Will only use the ability if CDs are enabled."
    )
    AddNewOption(
    "进攻",
    "赤喉之咬",
    230,
    true,
    { 2, "无条件使用", "大技能用法" },
    nil,
    "Enable for the automatic usage of Goremaw's Bite." ..
    C.TOOLTIP_VALUE ..
    C.TOOLTIP_SUBVALUE("无条件使用", true) ..
    "Will use the ability even if CDs are disabled." ..
    C.TOOLTIP_SUBVALUE("大技能用法") .. "Will only use the ability if CDs are enabled."
    )
    AddNewOption(
    "进攻",
    "暗影之舞",
    230,
    true,
    { 2, "无条件使用", "大技能用法" },
    nil,
    "Enable for the automatic usage of Shadow Dance." ..
    C.TOOLTIP_VALUE ..
    C.TOOLTIP_SUBVALUE("无条件使用", true) ..
    "Will use the ability even if CDs are disabled." ..
    C.TOOLTIP_SUBVALUE("大技能用法") ..
    "Will only use the ability if CDs are enabled and enables the Shadow Dance Eco Mode when CDs are disabled."
    )
    AddNewOption(
    "进攻",
    "暗影之舞节能模式",
    122,
    false,
    { 1, 1, 3, 1 },
    { 10, 1, 60, 1 },
    "Set how many Shadow Dance charges you want to save if Shadow Dance is in 'Cooldown Only' mode and CDs are disabled." ..
    C.TOOLTIP_VALUE_1 ..
    "Set the minimum number of charges to keep." ..
    C.TOOLTIP_VALUE_2 .. "Set the minimum remaining time until the next charge before using it."
    )
    AddNewOption(
    "进攻",
    "暗影之刃",
    230,
    true,
    { 2, "无条件使用", "大技能用法" },
    nil,
    "Enable for the automatic usage of Shadow Blades." ..
    C.TOOLTIP_VALUE ..
    C.TOOLTIP_SUBVALUE("无条件使用", true) ..
    "Will use the ability even if CDs are disabled." ..
    C.TOOLTIP_SUBVALUE("大技能用法") .. "Will only use the ability if CDs are enabled."
    )
    AddNewOption(
    "进攻",
    "Symbols Of Death",
    230,
    true,
    { 2, "无条件使用", "大技能用法" },
    nil,
    "Enable for the automatic usage of Symbols Of Death." ..
    C.TOOLTIP_VALUE ..
    C.TOOLTIP_SUBVALUE("无条件使用", true) ..
    "Will use the ability even if CDs are disabled." ..
    C.TOOLTIP_SUBVALUE("大技能用法") .. "Will only use the ability if CDs are enabled."
    )
    AddSection("进攻", "能力", "Yellow")
    AddNewOption(
    "进攻",
    "夜刃 多目标",
    220,
    false,
    { 12, 10, 24, 1 },
    nil,
    "Cycle Nightblade on available units and set the minimum TTD." ..
    C.TOOLTIP_HINT("It will always cast on the unit available with the Highest TTD.")
    )
    AddNewOption(
    "进攻",
    "Nightblade TTD",
    122,
    true,
    { 5, 0, 100, 0.5 },
    { 5, 3, 30, 1 },
    "BETA ONLY: Nightblade TimeToDie option. We use the HP threshold first, if the enemy is below the amount of HP it will use the regular TTD function with the given amount of samples." ..
    C.TOOLTIP_VALUE_1 ..
    "Enemy HP in million." ..
    C.TOOLTIP_VALUE_2 ..
    "TTD sample size. Higher means more accurate TTD-time but also takes longer to gather data."
    )
    AddNewOption(
    "进攻",
    "天降杀机",
    222,
    true,
    { 5, 5, 15, 1 },
    { 5, 0, 20, 1 },
    "Enable for the automatic usage of Death from Above." ..
    C.TOOLTIP_VALUE_1 ..
    "Set range while being In Combat." ..
    C.TOOLTIP_VALUE_2 ..
    "BETA ONLY: Time to die in seconds. (Also checks the Death from Above TTD option)"
    )
    AddNewOption(
    "进攻",
    "Death from Above TTD",
    122,
    true,
    { 6, 0, 100, 0.5 },
    { 5, 3, 30, 1 },
    "BETA ONLY: Death from Above TimeToDie option. We use the HP threshold first, if the enemy is below the amount of HP it will use the regular TTD function with the given amount of samples." ..
    C.TOOLTIP_VALUE_1 ..
    "Enemy HP in million." ..
    C.TOOLTIP_VALUE_2 ..
    "TTD sample size. Higher means more accurate TTD-time but also takes longer to gather data."
    )
    AddNewOption("进攻", "Force DfA With Vanish", 210, false, nil, nil, "Use Death from Above when Vanish buff is up.")
    AddNewOption(
    "进攻",
    "暗影打击 范围",
    122,
    true,
    { 5, 5, 25, 1 },
    { 5, 5, 25, 1 },
    "Set the range from the target to use Shadowstrike." ..
    C.TOOLTIP_VALUE_1 .. "While being In Combat." .. C.TOOLTIP_VALUE_2 .. "While being Out of Combat."
    )
    AddNewOption(
    "进攻",
    "飞镖投掷",
    220,
    true,
    { 75, 40, 150, 1 },
    nil,
    "Enable to auto use Throw while not being in melee range and not being stealthed." ..
    C.TOOLTIP_VALUE .. "Set the minimum energy to start using it."
    )
    AddNewOption(
    "进攻",
    "Dreadlords Deceit",
    220,
    true,
    { 29, 1, 30, 1 },
    nil,
    "Use Shuriken Storm on single target with Dreadlords Deceit legendary." ..
    C.TOOLTIP_VALUE .. "Number of buff stacks."
    )
    AddPresetOption("防御")
    AddSection("防御", "能力", "Yellow")
    AddNewOption("防御", "猩红之瓶", 220, true, { 65, 1, 100, 1 }, nil, "Health Percentage to use Crimson Vial.")
    AddNewOption(
    "防御",
    "佯攻",
    220,
    false,
    { 55, 1, 100, 1 },
    nil,
    "Health Percentage to use Feint." .. C.TOOLTIP_HINT("Put 100 to maintain 100% uptime.")
    )
    AddSection("防御", "大技能", "Yellow")
    AddNewOption("防御", "闪避", 220, true, { 25, 1, 100, 1 }, nil, "Health Percentage to use Evasion.")
    AddNewOption("防御", "暗影斗篷", 220, true, { 45, 1, 100, 1 }, nil, "Health Percentage to use Cloak of Shadows.")
    AddNewOption("防御", "消失 防御", 220, false, { 10, 1, 100, 1 }, nil, "Health Percentage to use Vanish defensively.")
    RegisterCommand(
    "feint",
    function()
        if ShouldFeint == true then
            ShouldFeint = false
            Bug("Feint Queue Canceled")
        elseif Feint:Exists() then
            ShouldFeint = true
            Bug("Feint Queued")
        end
    end
    )
    self.StealthAllowed, self.CombatStealthAllowed = false, true
    self.NominalDuration = 6
    self.NightbladeThreshold = 4.8
    self.dsh_dfa = false
end
function Rotation:UseBetaRotation()
    return self.HasBetaRotation and IsOptionEnabled("测试版循环")
end
function Rotation:Events()
    self.BleedTable = {
        Assassination = { Garrote = {}, Rupture = {} },
        Subtlety = { Nightblade = {}, FinalityNightblade = false, FinalityNightbladeTime = 0 }
    }
    EventFrame:RegisterForSelfCombatEvent(
    function(...)
        if Nightblade then
            SpellID = select(12, ...)
            if SpellID == 195452 then
                Rotation.BleedTable.Subtlety.FinalityNightblade = Player:Buff(FinalityNightblade) and true or false
                Rotation.BleedTable.Subtlety.FinalityNightbladeTime = GetTime() + 0.3
            end
        end
    end,
    "SPELL_CAST_SUCCESS"
    )
    EventFrame:RegisterForSelfCombatEvent(
    function(...)
        if Nightblade then
            DestGUID, _, _, _, SpellID = select(8, ...)
            if SpellID == 195452 then
                Rotation.BleedTable.Subtlety.Nightblade[DestGUID] =                 GetTime() < Rotation.BleedTable.Subtlety.FinalityNightbladeTime and
                Rotation.BleedTable.Subtlety.FinalityNightblade
            end
        end
    end,
    "SPELL_AURA_APPLIED",
    "SPELL_AURA_REFRESH"
    )
    EventFrame:RegisterForSelfCombatEvent(
    function(...)
        if Nightblade then
            DestGUID, _, _, _, SpellID = select(8, ...)
            if SpellID == 195452 then
                if Rotation.BleedTable.Subtlety.Nightblade[DestGUID] then
                    Rotation.BleedTable.Subtlety.Nightblade[DestGUID] = nil
                end
            end
        end
    end,
    "SPELL_AURA_REMOVED"
    )
    EventFrame:RegisterForCombatEvent(
    function(...)
        if Nightblade then
            DestGUID = select(8, ...)
            if Rotation.BleedTable.Subtlety.Nightblade[DestGUID] then
                Rotation.BleedTable.Subtlety.Nightblade[DestGUID] = nil
            end
        end
    end,
    "UNIT_DIED",
    "UNIT_DESTROYED"
    )
end
function Rotation:Finality(Unit)
    BleedGUID = Unit:GUID()
    if BleedGUID then
        if self.BleedTable.Subtlety.Nightblade[BleedGUID] then
            return self.BleedTable.Subtlety.Nightblade[BleedGUID]
        end
    end
    return false
end
function Rotation:CPMaxSpend()
    return DeeperStratagem:Exists() and 6 or 5
end
function Rotation:CPSpend()
    return math.min(Player:ComboPoints(), self:CPMaxSpend())
end
function Rotation:MantleDuration()
    if Player:BuffRemains(MasterAssassinsInitiative) < 0 then
        if Player:Buff(VanishBuff) then
            return Player:BuffRemains(VanishBuff) + self.NominalDuration
        else
            return 1 + self.NominalDuration
        end
    else
        return Player:BuffRemains(MasterAssassinsInitiative)
    end
end
function Rotation:StealthMacro(StealthSpell)
    if StealthSpell:ID() == ShadowDance:ID() then
        if
        Player:ComboPoints() >= 5 and
        (NumEnemies_10y >= 3 + (ShadowSatyrsWalk:IsEquipped() and 1 or 0) or
        (self:MantleDuration() <= 1.3 and self:MantleDuration() - Player:GlobalCooldown() >= 0.3))
        then
            self:Sub_Finish()
        elseif
        not Player:Buff(Shadowmeld) and
        ((Player:ComboPointsDeficit() >= 3 and NumEnemies_10y >= 3 + (ShadowSatyrsWalk:IsEquipped() and 1 or 0)) or
        (UseAOE() and IsOptionEnabled("Dreadlords Deceit") and Player:IsWithinCastRange(Target, Backstab) and
        Player:ComboPointsDeficit() >= 1 and
        Player:BuffCount(DreadlordsDeceit) >= GetOptionValue("Dreadlords Deceit"))) and
        Player:CanCast(ShurikenStorm)
        then
            Player:Cast(ShurikenStorm)
        elseif
        Player:ComboPoints() >= 5 and
        Player:ComboPointsDeficit() <
        3 + (Player:Buff(ShadowBlades) and 1 or 0) - (MantleoftheMasterAssassin:IsEquipped(3) and 1 or 0)
        then
            self:Sub_Finish()
        else
            Target:Cast(Shadowstrike)
        end
    elseif StealthSpell:ID() == Vanish:ID() then
        if
        not Player:Buff(Shadowmeld) and
        ((Player:ComboPointsDeficit() >= 3 and NumEnemies_10y >= 3 + (ShadowSatyrsWalk:IsEquipped() and 1 or 0)) or
        (UseAOE() and IsOptionEnabled("Dreadlords Deceit") and Player:IsWithinCastRange(Target, Backstab) and
        Player:ComboPointsDeficit() >= 1 and
        Player:BuffCount(DreadlordsDeceit) >= GetOptionValue("Dreadlords Deceit"))) and
        Player:CanCast(ShurikenStorm)
        then
            Player:Cast(ShurikenStorm)
        elseif
        self:UseBetaRotation() and DeathfromAbove:Exists() and DeathfromAbove:Cooldown() < 2 and
        IsOptionEnabled("Force DfA With Vanish") and
        IsOptionEnabled("天降杀机") and
        Player:ComboPoints() >= 5
        then
            if SymbolsofDeathEnabled and Player:CanCast(SymbolsofDeath) then
                Player:Cast(SymbolsofDeath)
            end
            if Target:CanCast(DeathfromAbove) then
                Target:Cast(DeathfromAbove)
                return "Cast"
            end
        else
            Target:Cast(Shadowstrike)
        end
    else
        Target:Cast(Shadowstrike)
    end
end
function Rotation:Pulse()
    if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
        return
    end
    if GetTime() < Rotation.SpamPrevention then
        return
    end
    Rotation.SpamPrevention = GetTime() + 0.05
    Target = Unit.Target
    local InCombat = Player:IsInCombat()
    self.CombatStealthAllowed =     ShadowDance:TimeSinceCast() > 0.5 and Vanish:TimeSinceCast() > 0.5 and Shadowmeld:TimeSinceCast() > 0.5
    Stealth = Subterfuge:Exists() and StealthWithSubterfuge or StealthWithoutSubterfuge
    if Feint:Exists() and ShouldFeint and not Player:Buff(Feint) then
        if Player:CanCast(Feint) then
            Player:Cast(Feint)
            ShouldFeint = false
        end
        return
    end
    if not InCombat then
        self:OutOfCombat()
        return
    end
    if InCombat then
        self:Defensives()
    end
    Target = Player:ReTarget(Backstab, false) or Unit.Target
    if Target:Exists() then
        Rotations:RefreshUnitTables(Rotation.Identifier)
        self:Interrupts()
        self:OffGCDAbilities()
        if Player:GlobalCooldown() == 0 then
            if self:UseBetaRotation() then
                self:CombatBeta()
            else
                self:Combat()
            end
        end
    end
end
function Rotation:Defensives()
    Player:UseHealingItem()
    if
    IsOptionEnabled("消失 防御") and Vanish:Exists() and not Player:IsStealthed(true, true) and
    Player:HealthPercentage() <= GetOptionValue("消失 防御") and
    Shadowmeld:TimeSinceCast() > 0.5 and
    Player:CanCast(Vanish)
    then
        Player:Cast(Vanish)
        Vanish.LastCastTime = GetTime()
        return
    end
    if
    IsOptionEnabled("闪避") and not Player:Buff(Evasion) and Player:HealthPercentage() <= GetOptionValue("闪避") and
    Player:CanCast(Evasion)
    then
        Player:Cast(Evasion)
    end
    if
    IsOptionEnabled("暗影斗篷") and CloakofShadows:Exists() and Player:HealthPercentage() <= GetOptionValue("暗影斗篷") and
    Player:CanCast(CloakofShadows)
    then
        Player:Cast(CloakofShadows)
    end
    if
    IsOptionEnabled("佯攻") and Feint:Exists() and Player:HealthPercentage() <= GetOptionValue("佯攻") and
    not Player:Buff(Feint) and
    Player:CanCast(Feint)
    then
        Player:Cast(Feint)
        return
    end
    if
    IsOptionEnabled("猩红之瓶") and CrimsonVial:Exists() and Player:HealthPercentage() <= GetOptionValue("猩红之瓶") and
    Player:CanCast(CrimsonVial)
    then
        Player:Cast(CrimsonVial)
        return
    end
    if
    GiftOfTheNaaru:Exists() and IsOptionEnabled("纳鲁的赐福") and Player:HealthPercentage() <= GetOptionValue("纳鲁的赐福") and
    Player:CanCast(GiftOfTheNaaru)
    then
        Player:Cast(GiftOfTheNaaru)
        return
    end
end
function Rotation:Interrupts()
    Player:UseInterrupt(Kick, ArcaneTorrent)
end
function Rotation:OffGCDAbilities()
    ShadowDanceEnabled =     IsOptionEnabled("暗影之舞") and ShadowDance:Exists() and
    (GetOptionValue("暗影之舞") == "无条件使用" or CooldownsAllowed() or
    (ShadowDance:Charges() >= GetOptionValue("暗影之舞节能模式") and
    ShadowDance:Recharge() <= GetSecondOptionValue("暗影之舞节能模式")))
    if
    self:UseBetaRotation() and ShadowDanceEnabled and not Player:IsStealthed(true, true) and
    DeathfromAbove:TimeSinceCast() < 1.5 and
    ShadowDance:Charges() >= 1 and
    ShadowDance:TimeSinceCast() > 1 and
    Player:CanCast(ShadowDance)
    then
        Bug("Shadow Dance while using Death from Above.")
        Player:Cast(ShadowDance)
    end
    if
    IsOptionEnabled("对焦点施放嫁祸诀窍") and TricksoftheTrade:Exists() and
    (GetOptionValue("对焦点施放嫁祸诀窍") == "无条件使用" or (Player:ThreatSituation() and Player:ThreatSituation() >= 1)) and
    Focus:Exists() and
    Focus:IsInParty() and
    not Focus:Equals(Player) and
    Focus:CanCast(TricksoftheTrade)
    then
        Focus:Cast(TricksoftheTrade)
    end
    if Player:UseMarkedForDeath(MarkedForDeath, Player:ComboPointsDeficit()) then
        return
    end
end
function Rotation:Sub_SSW_Refund()
    return ShadowSatyrsWalk:IsEquipped(8) and 6 or 0
end
function Rotation:Sub_Stealth_Threshold()
    return 65 + (Vigor:Exists() and 35 or 0) + (MasterofShadows:Exists() and 10 or 0) + self:Sub_SSW_Refund()
end
function Rotation:Sub_ShD_Fractional()
    return 1.725 + (EnvelopingShadows:Exists() and 0.725 or 0)
end
function Rotation:Sub_Build()
    if ShurikenStorm:Exists() and NumEnemies_10y >= 2 and Player:CanCast(ShurikenStorm) then
        Player:Cast(ShurikenStorm)
        return "Cast"
    end
    if Gloomblade:Exists() then
        if Target:CanCast(Gloomblade) then
            Target:Cast(Gloomblade)
            return "Cast"
        end
    else
        if Target:CanCast(Backstab) then
            Target:Cast(Backstab)
            return "Cast"
        end
    end
    return false
end
function Rotation:Sub_CDs()
    if Player:IsWithinCastRange(Target, Backstab) then
        Player:UsePotions("Agility")
        if CooldownsAllowed() and (Player:IsStealthed(true, false) or Target:TimeToDie(10) < 20) then
            Player:UseTrinkets()
        end
        if (BloodFury:Exists() or Berserking:Exists() or ArcaneTorrent:Exists()) and CDOptionEnabled("进攻性种族技能") then
            if Player:IsStealthed(true, false) then
                if BloodFury:Exists() and Player:CanCast(BloodFury) then
                    Player:Cast(BloodFury)
                end
                if Berserking:Exists() and Player:CanCast(Berserking) then
                    CastSpellByID(26297, "player")
                end
                if ArcaneTorrent:Exists() and Player:EnergyDeficit() > 70 and Player:CanCast(ArcaneTorrent) then
                    Player:Cast(ArcaneTorrent)
                end
            end
        end
        if
        SymbolsofDeathEnabled and Player:EnergyDeficit() >= 40 - (Player:IsStealthed(true, true) and 30 or 0) and
        Player:CanCast(SymbolsofDeath)
        then
            Player:Cast(SymbolsofDeath)
        end
        if
        IsOptionEnabled("死亡标记") and GetOptionValue("死亡标记") == "目标" and
        (CooldownsAllowed() or GetSecondOptionValue("死亡标记") == "无条件使用") and
        MarkedForDeath:Exists() and
        Player:ComboPointsDeficit() >= self:CPMaxSpend() and
        Target:CanCast(MarkedForDeath)
        then
            Target:Cast(MarkedForDeath)
            return "Cast"
        end
        if
        ShadowBlades:Exists() and IsOptionEnabled("暗影之刃") and
        (CooldownsAllowed() or GetOptionValue("暗影之刃") == "无条件使用") and
        not Player:Buff(ShadowBlades) and
        Player:ComboPointsDeficit() >=
        2 + (Player:IsStealthed(true, true) and 1 or 0) -
        (MantleoftheMasterAssassin:IsEquipped() and 1 or 0) and
        Player:CanCast(ShadowBlades)
        then
            Player:Cast(ShadowBlades)
        end
        if
        GoremawsBiteEnabled and not Player:IsStealthed(true, true) and
        ShadowDance:FractionalCharges() <= self:Sub_ShD_Fractional() and
        ((Player:ComboPointsDeficit() >= 4 - (CombatTime() < 10 and 2 or 0) and
        Player:EnergyDeficit() > 50 + (Vigor:Exists() and 25 or 0) - (CombatTime() >= 10 and 15 or 0)) or
        (Player:ComboPointsDeficit() >= 1 and Target:TimeToDie(10) < 8)) and
        Target:CanCast(GoremawsBite)
        then
            Target:Cast(GoremawsBite)
            return "Cast"
        end
    end
    return false
end
function Rotation:Sub_Finish()
    if
    KidneyShot:Exists() and IsOptionEnabled("肾击") and not Target:IsBoss() and Target:DebuffRemains(CheapShot) < 1 and
    Target:CanCast(KidneyShot)
    then
        Target:Cast(KidneyShot)
        return "Cast"
    end
    if
    IsOptionEnabled("天降杀机") and DeathfromAbove:Exists() and NumEnemies_8y >= 5 and
    Player:DistanceTo(Target) <= GetOptionValue("天降杀机") and
    Target:CanCast(DeathfromAbove)
    then
        Target:Cast(DeathfromAbove)
        return "Cast"
    end
    if Nightblade:Exists() then
        self.NightbladeThreshold =         (6 +
        math.min(Player:ComboPoints(), 5 + (DeeperStratagem:Exists() and 1 or 0)) * (2 + (HasT19_2Pc and 2 or 0))) *
        0.3
        if
        Target:TimeToDie() - Target:DebuffRemains(Nightblade) > 8 and
        (self:MantleDuration() == 0 or Target:DebuffRemains(Nightblade) <= self:MantleDuration()) and
        ((Target:DebuffRefreshable(Nightblade, self.NightbladeThreshold) and
        (not self:Finality(Target) or Player:Buff(FinalityNightblade))) or
        Target:DebuffRemains(Nightblade) < 4) and
        Target:CanCast(Nightblade)
        then
            Target:Cast(Nightblade)
            return "Cast"
        end
        if IsOptionEnabled("夜刃 多目标") and UseAOE() and self:MantleDuration() == 0 then
            local BestUnit, BestUnitTTD = nil, 0
            local ThisUnit, ThisUnitTTD
            for i = 1, #Enemies_5y do
                ThisUnit = Enemies_5y[i]
                ThisUnitTTD = ThisUnit:TimeToDie(5)
                if
                ThisUnitTTD > GetOptionValue("夜刃 多目标") and ThisUnitTTD < 5000 and ThisUnitTTD > BestUnitTTD and
                ((ThisUnit:DebuffRefreshable(Nightblade, self.NightbladeThreshold) and
                (not self:Finality(ThisUnit) or Player:Buff(FinalityNightblade))) or
                ThisUnit:DebuffRemains(Nightblade) < 4) and
                ThisUnit:CanCast(Nightblade)
                then
                    BestUnit, BestUnitTTD = ThisUnit, ThisUnitTTD
                end
            end
            if BestUnit then
                BestUnit:Cast(Nightblade)
                return "Cast"
            end
        end
    end
    if
    IsOptionEnabled("天降杀机") and DeathfromAbove:Exists() and Player:DistanceTo(Target) <= GetOptionValue("天降杀机") and
    Target:CanCast(DeathfromAbove)
    then
        Target:Cast(DeathfromAbove)
        return "Cast"
    end
    if
    Eviscerate:Exists() and
    (not DeathfromAbove:Exists() or not IsOptionEnabled("天降杀机") or
    DeathfromAbove:Cooldown() >=
    (Player:EnergyTimeToX(Player:EnergyMax() - self:CPSpend() * 6) -
    (2 + (MantleoftheMasterAssassin:IsEquipped() and DenialoftheHalfGiants:IsEquipped() and 1 or 0)))) and
    Target:CanCast(Eviscerate)
    then
        Target:Cast(Eviscerate)
        return "Cast"
    end
    return false
end
function Rotation:Sub_Sprinted()
end
function Rotation:Sub_Stealth_CDs()
    if Player:IsWithinCastRange(Target, Backstab) then
        if
        VanishEnabled and self:MantleDuration() == 0 and
        ShadowDance:FractionalCharges() <
        self:Sub_ShD_Fractional() +
        (MantleoftheMasterAssassin:IsEquipped(3) and CombatTime() < 30 and 0.3 or 0) and
        Player:CanCast(Vanish)
        then
            Player:Cast(Vanish)
            self:StealthMacro(Vanish)
            Vanish.LastCastTime = GetTime()
            return "Cast"
        end
        if
        ShadowDanceEnabled and ShadowDance:FractionalCharges() >= self:Sub_ShD_Fractional() and
        Player:CanCast(ShadowDance)
        then
            Player:Cast(ShadowDance)
            self:StealthMacro(ShadowDance)
            ShadowDance.LastCastTime = GetTime()
            return "Cast"
        end
        if Shadowmeld:Exists() then
            if
            CDOptionEnabled("进攻性种族技能") and (not Player:IsTanking(Target) or GetOptionValue("消失") == "无条件使用") and
            Player:Standing() > 0.7 and
            Player:EnergyDeficit() > 10 + self:Sub_SSW_Refund() and
            Player:CanCast(Shadowmeld)
            then
                if Player:Energy() < 40 then
                    return "Pool"
                end
                Player:Cast(Shadowmeld)
                self:StealthMacro(Shadowmeld)
                Shadowmeld.LastCastTime = GetTime()
                return "Cast"
            end
        end
        if
        ShadowDanceEnabled and
        Player:ComboPointsDeficit() >=
        2 + ((Subterfuge:Exists() or Player:Buff(TheFirstoftheDeadBuff)) and 2 or 0) and
        (SymbolsofDeath:Cooldown() > 2 or not DarkShadow:Exists()) and
        Player:CanCast(ShadowDance)
        then
            Player:Cast(ShadowDance)
            self:StealthMacro(ShadowDance)
            ShadowDance.LastCastTime = GetTime()
            return "Cast"
        end
    end
    return false
end
function Rotation:Sub_Stealth_ALS()
    if
    (Player:EnergyDeficit() <= self:Sub_Stealth_Threshold() and
    (not ShadowSatyrsWalk:IsEquipped(8) or ShadowDance:FractionalCharges() >= self:Sub_ShD_Fractional() or
    Player:EnergyDeficit() >= 10)) or
    self:MantleDuration() > 2.3 or
    NumEnemies_10y >= 5 or
    (not Shadowmeld:IsOnCooldown() and Vanish:IsOnCooldown() and ShadowDance:Charges() <= 1) or
    (Target:TimeToDie() < 12 * ShadowDance:FractionalCharges() * (ShadowSatyrsWalk:IsEquipped(8) and 1.5 or 1))
    then
        return self:Sub_Stealth_CDs()
    end
    return false
end
function Rotation:Sub_Stealthed()
    if
    Player:ComboPoints() >= 5 and
    (NumEnemies_10y >= 3 + (ShadowSatyrsWalk:IsEquipped() and 1 or 0) or
    (self:MantleDuration() <= 1.3 and self:MantleDuration() - Player:GlobalCooldown() >= 0.3))
    then
        return self:Sub_Finish()
    end
    if
    not Player:Buff(Shadowmeld) and
    ((Player:ComboPointsDeficit() >= 3 and NumEnemies_10y >= 3 + (ShadowSatyrsWalk:IsEquipped() and 1 or 0)) or
    (UseAOE() and IsOptionEnabled("Dreadlords Deceit") and Player:IsWithinCastRange(Target, Backstab) and
    Player:ComboPointsDeficit() >= 1 and
    Player:BuffCount(DreadlordsDeceit) >= GetOptionValue("Dreadlords Deceit"))) and
    Player:CanCast(ShurikenStorm)
    then
        Player:Cast(ShurikenStorm)
        return "Cast"
    end
    if
    Player:ComboPoints() >= 5 and
    Player:ComboPointsDeficit() <
    3 + (Player:Buff(ShadowBlades) and 1 or 0) - (MantleoftheMasterAssassin:IsEquipped(3) and 1 or 0)
    then
        return self:Sub_Finish()
    end
    if Player:DistanceTo(Target) <= GetOptionValue("暗影打击 范围") and Target:CanCast(Shadowstrike) then
        Target:Cast(Shadowstrike)
        return "Cast"
    end
    return false
end
function Rotation:UnitTables()
    Enemies_10y = UseAOE() and Player:EnemiesWithinDistance(10, true) or {}
    Enemies_8y = UseAOE() and Player:FilterEnemiesByDistance(Enemies_10y, 8, true) or {}
    Enemies_5y = UseAOE() and Player:FilterEnemiesByDistance(Enemies_8y, 5, false) or {}
    NumEnemies_10y = #Enemies_10y
    NumEnemies_8y = #Enemies_8y
end
function Rotation:Combat()
    VanishEnabled =     Vanish:Exists() and IsOptionEnabled("消失") and (CooldownsAllowed() or GetSecondOptionValue("消失") == "无条件使用") and
    (not Player:IsTanking(Target) or GetOptionValue("消失") == "无条件使用")
    SymbolsofDeathEnabled =     SymbolsofDeath:Exists() and IsOptionEnabled("Symbols Of Death") and
    (CooldownsAllowed() or GetOptionValue("Symbols Of Death") == "无条件使用")
    GoremawsBiteEnabled =     GoremawsBite:Exists() and IsOptionEnabled("赤喉之咬") and (CooldownsAllowed() or GetOptionValue("赤喉之咬") == "无条件使用")
    if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        if not Player:IsStealthed(true) then
            Player:StartAttack()
        end
        if self:Sub_CDs() then
            return
        end
        if Player:Level() > 22 and (Player:IsStealthed(true, true) or not self.CombatStealthAllowed) then
            self:Sub_Stealthed()
            return
        end
        if
        Target:TimeToDie() > 8 and Target:DebuffRemains(Nightblade) < Player:GCD() and Player:ComboPoints() >= 4 and
        Target:CanCast(Nightblade)
        then
            Target:Cast(Nightblade)
            return "Cast"
        end
        if DarkShadow:Exists() then
            if
            Player:ComboPointsDeficit() >= 3 and
            (Target:DebuffRemains(Nightblade) > 4 + (Subterfuge:Exists() and 1 or 0) or
            (ShadowDance:FractionalCharges() >= 1.9 and
            (not DenialoftheHalfGiants:IsEquipped() or CombatTime() > 10)))
            then
                if self:Sub_Stealth_ALS() then
                    return
                end
            end
        else
            if
            Player:ComboPointsDeficit() >= 3 or
            ShadowDance:FractionalCharges() >= 1.9 + (EnvelopingShadows:Exists() and 1 or 0)
            then
                if self:Sub_Stealth_ALS() then
                    return
                end
            end
        end
        if Player:ComboPoints() >= 5 or (Player:ComboPoints() >= 4 and NumEnemies_10y >= 3 and NumEnemies_10y <= 4) then
            if self:Sub_Finish() then
                return
            end
        end
        if Player:EnergyDeficit() <= self:Sub_Stealth_Threshold() then
            if self:Sub_Build() then
                return
            end
        end
        if
        IsOptionEnabled("飞镖投掷") and not Player:IsWithinCastRange(Target, Backstab) and
        not Player:IsStealthed(true, true) and
        Player:Energy() > GetOptionValue("飞镖投掷") and
        Player:EnergyDeficit() < 20 and
        (Player:ComboPointsDeficit() >= 1 or Player:EnergyTimeToMax() <= 1.2) and
        Target:CanCast(ShurikenToss)
        then
            Target:Cast(ShurikenToss)
            return
        end
    end
    return
end
function Rotation:TimeToDieWithOption(Unit, OptionName)
    local UnitTTD = Unit:TimeToDie(GetSecondOptionValue(OptionName))
    if UnitTTD == 6666 then
        return 999
    end
    if Unit:Health() >= GetOptionValue(OptionName) * 1000000 then
        return 999
    end
    if UnitTTD < 5000 then
        return UnitTTD
    end
    return -1
end
function Rotation:Sub_CDsBeta()
    if Player:IsWithinCastRange(Target, Backstab) then
        Player:UsePotions("Agility")
        if CooldownsAllowed() and (Player:IsStealthed(true, false) or Target:TimeToDie(10) < 20) then
            Player:UseTrinkets()
        end
        if (BloodFury:Exists() or Berserking:Exists() or ArcaneTorrent:Exists()) and CDOptionEnabled("进攻性种族技能") then
            if Player:IsStealthed(true, false) then
                if BloodFury:Exists() and Player:CanCast(BloodFury) then
                    Player:Cast(BloodFury)
                end
                if Berserking:Exists() and Player:CanCast(Berserking) then
                    CastSpellByID(26297, "player")
                end
                if ArcaneTorrent:Exists() and Player:EnergyDeficit() > 70 and Player:CanCast(ArcaneTorrent) then
                    Player:Cast(ArcaneTorrent)
                end
            end
        end
        if SymbolsofDeathEnabled and not SymbolsofDeath:IsOnCooldown() then
            if
            not DeathfromAbove:Exists() and
            ((CombatTime() > 10 and Player:EnergyDeficit() >= 40 - (Player:IsStealthed(true, true) and 30 or 0)) or
            (CombatTime() < 10 and Target:DebuffRemains(Nightblade) > 0)) and
            Player:CanCast(SymbolsofDeath)
            then
                Player:Cast(SymbolsofDeath)
            end
            if
            (DeathfromAbove:Exists() and DeathfromAbove:Cooldown() <= 3 and
            (ShadowDance:Charges() > 0 or
            (ShadowDance:Charges() == 0 and
            ShadowDance:Cooldown() <= 1 + (EnvelopingShadows:Exists() and 15 or 9))) and
            (Target:DebuffRemains(Nightblade) >= DeathfromAbove:Cooldown() + 3 or
            Target:TimeToDie() - Target:DebuffRemains(Nightblade) <= 6) and
            (CombatTime() >= 3 or HasT20_4Pc or TheFirstoftheDead:IsEquipped())) or
            (Target:IsBoss() and Target:TimeToDie() <= 10) and Player:CanCast(SymbolsofDeath)
            then
                Player:Cast(SymbolsofDeath)
            end
        end
        if
        IsOptionEnabled("死亡标记") and GetOptionValue("死亡标记") == "目标" and
        (CooldownsAllowed() or GetSecondOptionValue("死亡标记") == "无条件使用") and
        MarkedForDeath:Exists() and
        Player:ComboPointsDeficit() >= self:CPMaxSpend() and
        Target:CanCast(MarkedForDeath)
        then
            Target:Cast(MarkedForDeath)
            return "Cast"
        end
        if
        ShadowBlades:Exists() and IsOptionEnabled("暗影之刃") and
        (CooldownsAllowed() or GetOptionValue("暗影之刃") == "无条件使用") and
        not Player:Buff(ShadowBlades) and
        ((CombatTime() > 10 and
        Player:ComboPointsDeficit() >=
        2 + (Player:IsStealthed(true, true) and 1 or 0) -
        (MantleoftheMasterAssassin:IsEquipped() and 1 or 0)) or
        (CombatTime() < 10 and
        (not DeathfromAbove:Exists() or Player:ComboPointsDeficit() >= 3 or
        Target:DebuffRemains(Nightblade) > 0))) and
        Player:CanCast(ShadowBlades)
        then
            Player:Cast(ShadowBlades)
        end
        if
        GoremawsBiteEnabled and not Player:IsStealthed(true, true) and
        ShadowDance:FractionalCharges() <= self:Sub_ShD_Fractional() and
        ((Player:ComboPointsDeficit() >= 4 - (CombatTime() < 10 and 2 or 0) and
        Player:EnergyDeficit() > 50 + (Vigor:Exists() and 25 or 0) - (CombatTime() >= 10 and 15 or 0)) or
        (Player:ComboPointsDeficit() >= 1 and Target:TimeToDie(10) < 8)) and
        Target:CanCast(GoremawsBite)
        then
            Target:Cast(GoremawsBite)
            return "Cast"
        end
        if
        VanishEnabled and self.dsh_dfa and
        (((not MantleoftheMasterAssassin:IsEquipped() or Player:Buff(SymbolsofDeath)) and
        ShadowDance:FractionalCharges() <= self:Sub_ShD_Fractional() and
        not Player:IsStealthed(true, false) and
        self:MantleDuration() == 0 and
        (Target:DebuffRemains(Nightblade) >= DeathfromAbove:Cooldown() + 6 or
        (Target:IsBoss() and Target:TimeToDie() - Target:DebuffRemains(Nightblade) <= 6)) and
        DeathfromAbove:Cooldown() <= 1) or
        (Target:IsBoss() and Target:TimeToDie() <= 7)) and
        Player:CanCast(Vanish)
        then
            if Player:Energy() < 55 - (ShadowFocus:Exists() and 10 or 0) then
                return "Pool"
            end
            Player:Cast(Vanish)
            self:StealthMacro(Vanish)
            Vanish.LastCastTime = GetTime()
            return "Cast"
        end
    end
    return false
end
function Rotation:Sub_FinishBeta()
    if
    KidneyShot:Exists() and IsOptionEnabled("肾击") and not Target:IsBoss() and Target:DebuffRemains(CheapShot) < 1 and
    Target:CanCast(KidneyShot)
    then
        Target:Cast(KidneyShot)
        return "Cast"
    end
    if Nightblade:Exists() then
        self.NightbladeThreshold =         (6 +
        math.min(Player:ComboPoints(), 5 + (DeeperStratagem:Exists() and 1 or 0)) * (2 + (HasT19_2Pc and 2 or 0))) *
        0.3
        if
        (not DarkShadow:Exists() or not Player:Buff(ShadowDance)) and
        self:TimeToDieWithOption(Target, "Nightblade TTD") - Target:DebuffRemains(Nightblade) > 6 and
        (self:MantleDuration() == 0 or Target:DebuffRemains(Nightblade) <= self:MantleDuration()) and
        ((Target:DebuffRefreshable(Nightblade, self.NightbladeThreshold) and
        (not self:Finality(Target) or Player:Buff(FinalityNightblade) or self.dsh_dfa)) or
        Target:DebuffRemains(Nightblade) < 4) and
        ((NumEnemies_10y < 4 and not self.dsh_dfa) or not Player:Buff(SymbolsofDeath)) and
        Target:CanCast(Nightblade)
        then
            Target:Cast(Nightblade)
            return "Cast"
        end
        if IsOptionEnabled("夜刃 多目标") and UseAOE() and self:MantleDuration() == 0 then
            local BestUnit, BestUnitTTD = nil, 0
            local ThisUnit, ThisUnitTTD
            for i = 1, #Enemies_5y do
                ThisUnit = Enemies_5y[i]
                ThisUnitTTD = self:TimeToDieWithOption(ThisUnit, "Nightblade TTD")
                if
                ThisUnitTTD - ThisUnit:DebuffRemains(Nightblade) >= GetOptionValue("夜刃 多目标") and
                ThisUnitTTD > BestUnitTTD and
                ((ThisUnit:DebuffRefreshable(Nightblade, self.NightbladeThreshold) and
                (not self:Finality(ThisUnit) or Player:Buff(FinalityNightblade or self.dsh_dfa))) or
                ThisUnit:DebuffRemains(Nightblade) < 4) and
                ((NumEnemies_10y < 4 and not self.dsh_dfa) or not Player:Buff(SymbolsofDeath)) and
                ThisUnit:CanCast(Nightblade)
                then
                    BestUnit, BestUnitTTD = ThisUnit, ThisUnitTTD
                end
            end
            if BestUnit then
                BestUnit:Cast(Nightblade)
                return "Cast"
            end
        end
        if
        SymbolsofDeathEnabled and
        self:TimeToDieWithOption(Target, "Nightblade TTD") - Target:DebuffRemains(Nightblade) > 6 and
        (Target:DebuffRemains(Nightblade) < SymbolsofDeath:Cooldown() + 10 and
        SymbolsofDeath:Cooldown() <= 5 + (Player:ComboPoints() == 6 and 2 or 0)) and
        Target:CanCast(Nightblade)
        then
            Target:Cast(Nightblade)
            return "Cast"
        end
    end
    if
    IsOptionEnabled("天降杀机") and DeathfromAbove:Exists() and
    ((not Player:Buff(ShadowDance) or NumEnemies_8y >= 4) and
    (Player:Buff(SymbolsofDeath) or SymbolsofDeath:Cooldown() >= 10 + (HasT20_4Pc and 5 or 0)) and
    Player:BuffRemains(TheFirstoftheDeadBuff) < 1 and
    (Player:Buff(FinalityEviscerate) or NumEnemies_10y < 4)) and
    Player:DistanceTo(Target) <= GetOptionValue("天降杀机") and
    self:TimeToDieWithOption(Target, "Death from Above TTD") > GetSecondOptionValue("天降杀机") and
    (ShadowDance:Charges() > 0 or
    (ShadowDance:Charges() == 0 and ShadowDance:Cooldown() >= 5 + (EnvelopingShadows:Exists() and 15 or 9)) or
    Player:BuffRemains(ShadowDanceBuff) > 2) and
    Target:CanCast(DeathfromAbove)
    then
        Target:Cast(DeathfromAbove)
        return "Cast"
    end
    if Eviscerate:Exists() and Target:CanCast(Eviscerate) then
        Target:Cast(Eviscerate)
        return "Cast"
    end
    return false
end
function Rotation:Sub_Stealth_CDsBeta()
    if Player:IsWithinCastRange(Target, Backstab) then
        if
        VanishEnabled and not self.dsh_dfa and self:MantleDuration() == 0 and
        ShadowDance:FractionalCharges() <
        self:Sub_ShD_Fractional() +
        (MantleoftheMasterAssassin:IsEquipped() and CombatTime() < 30 and 0.3 or 0) and
        (not MantleoftheMasterAssassin:IsEquipped() or not SymbolsofDeathEnabled or Player:Buff(SymbolsofDeath)) and
        Player:CanCast(Vanish)
        then
            Player:Cast(Vanish)
            self:StealthMacro(Vanish)
            Vanish.LastCastTime = GetTime()
            return "Cast"
        end
        if
        ShadowDanceEnabled and
        (ShadowDance:FractionalCharges() >= self:Sub_ShD_Fractional() or
        (Target:IsBoss() and SymbolsofDeathEnabled and Target:TimeToDie() < SymbolsofDeath:Cooldown())) and
        Player:CanCast(ShadowDance)
        then
            Player:Cast(ShadowDance)
            self:StealthMacro(ShadowDance)
            ShadowDance.LastCastTime = GetTime()
            return "Cast"
        end
        if Shadowmeld:Exists() then
            if
            CDOptionEnabled("进攻性种族技能") and (not Player:IsTanking(Target) or GetOptionValue("消失") == "无条件使用") and
            Player:Standing() > 0.7 and
            Player:EnergyDeficit() > 10 + self:Sub_SSW_Refund() and
            Player:CanCast(Shadowmeld)
            then
                if Player:Energy() < 40 then
                    return "Pool"
                end
                Player:Cast(Shadowmeld)
                self:StealthMacro(Shadowmeld)
                Shadowmeld.LastCastTime = GetTime()
                return "Cast"
            end
        end
        if
        ShadowDanceEnabled and not self.dsh_dfa and
        Player:ComboPointsDeficit() >=
        2 + ((Subterfuge:Exists() or Player:Buff(TheFirstoftheDeadBuff)) and 2 or 0) and
        (Player:BuffRemains(SymbolsofDeath) >= 1.2 or
        SymbolsofDeath:Cooldown() >=
        12 + (DarkShadow:Exists() and HasT20_4Pc and 3 or 0) -
        (not DarkShadow:Exists() and HasT20_4Pc and 4 or 0) or
        self:MantleDuration() > 0) and
        Player:CanCast(ShadowDance)
        then
            Player:Cast(ShadowDance)
            self:StealthMacro(ShadowDance)
            ShadowDance.LastCastTime = GetTime()
            return "Cast"
        end
    end
    return false
end
function Rotation:Sub_Stealth_ALSBeta()
    if
    (Player:EnergyDeficit() <=
    self:Sub_Stealth_Threshold() -
    (GoremawsBiteEnabled and GoremawsBite:IsOnCooldown() and not Player:Buff(FeedingFrenzy) and 25 or 0) and
    (not ShadowSatyrsWalk:IsEquipped(8) or ShadowDance:FractionalCharges() >= self:Sub_ShD_Fractional() or
    Player:EnergyDeficit() >= 10)) or
    self:MantleDuration() > 2.3 or
    NumEnemies_10y >= 5 or
    (not Shadowmeld:IsOnCooldown() and Vanish:IsOnCooldown() and ShadowDance:Charges() <= 1) or
    (Target:TimeToDie() < 12 * ShadowDance:FractionalCharges() * (ShadowSatyrsWalk:IsEquipped(8) and 1.5 or 1))
    then
        return self:Sub_Stealth_CDsBeta()
    end
    return false
end
function Rotation:Sub_StealthedBeta()
    if
    Shadowstrike:Exists() and Player:IsStealthed(false, false) and
    Player:DistanceTo(Target) <= GetOptionValue("暗影打击 范围") and
    Target:CanCast(Shadowstrike)
    then
        Target:Cast(Shadowstrike)
        return "Cast"
    end
    if
    Player:ComboPoints() >= 5 + (DeeperStratagem:Exists() and Player:Buff(VanishBuff) and 1 or 0) and
    (NumEnemies_10y >= 3 + (ShadowSatyrsWalk:IsEquipped() and 1 or 0) or
    (self:MantleDuration() <= 1.3 and self:MantleDuration() - Player:GlobalCooldown() >= 0.3))
    then
        return self:Sub_FinishBeta()
    end
    if
    ShurikenStorm:Exists() and not Player:Buff(Shadowmeld) and
    ((Player:ComboPointsDeficit() >= 2 + (InsigniaofRavenholdt:IsEquipped() and 1 or 0) and
    NumEnemies_10y >= 3 + (ShadowSatyrsWalk:IsEquipped() and 1 or 0)) or
    (UseAOE() and IsOptionEnabled("Dreadlords Deceit") and Player:IsWithinCastRange(Target, Backstab) and
    Player:ComboPointsDeficit() >= 1 and
    Player:BuffCount(DreadlordsDeceit) >= GetOptionValue("Dreadlords Deceit"))) and
    Player:CanCast(ShurikenStorm)
    then
        Player:Cast(ShurikenStorm)
        return "Cast"
    end
    if
    Player:ComboPoints() >= 5 + (DeeperStratagem:Exists() and Player:Buff(VanishBuff) and 1 or 0) and
    Player:ComboPointsDeficit() <
    3 + (Player:Buff(ShadowBlades) and 1 or 0) - (MantleoftheMasterAssassin:IsEquipped(3) and 1 or 0)
    then
        return self:Sub_FinishBeta()
    end
    if Shadowstrike:Exists() and Player:DistanceTo(Target) <= GetOptionValue("暗影打击 范围") and Target:CanCast(Shadowstrike) then
        Target:Cast(Shadowstrike)
        return "Cast"
    end
    return false
end
function Rotation:CombatBeta()
    VanishEnabled =     Vanish:Exists() and IsOptionEnabled("消失") and (CooldownsAllowed() or GetSecondOptionValue("消失") == "无条件使用") and
    (not Player:IsTanking(Target) or GetOptionValue("消失") == "无条件使用")
    SymbolsofDeathEnabled =     SymbolsofDeath:Exists() and IsOptionEnabled("Symbols Of Death") and
    (CooldownsAllowed() or GetOptionValue("Symbols Of Death") == "无条件使用")
    GoremawsBiteEnabled =     GoremawsBite:Exists() and IsOptionEnabled("赤喉之咬") and (CooldownsAllowed() or GetOptionValue("赤喉之咬") == "无条件使用")
    if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        if not Player:IsStealthed(true) then
            Player:StartAttack()
        end
        self.dsh_dfa = DeathfromAbove:Exists() and DarkShadow:Exists() and NumEnemies_8y < 4
        if
        ShadowDanceEnabled and not Player:IsStealthed(true, true) and Player:Buff(DeathfromAbove) and
        ShadowDance:Charges() >= 1 and
        ShadowDance:TimeSinceCast() > 1 and
        Player:CanCast(ShadowDance)
        then
            Bug("Shadow Dance while using Death from Above. 2")
            Player:Cast(ShadowDance)
            return
        end
        if self:Sub_CDsBeta() then
            return
        end
        if Player:Level() > 22 and (Player:IsStealthed(true, true) or not self.CombatStealthAllowed) then
            self:Sub_StealthedBeta()
            return
        end
        if
        self:TimeToDieWithOption(Target, "Nightblade TTD") > 8 and Target:DebuffRemains(Nightblade) < Player:GCD() and
        Player:ComboPoints() >= 4 - (CombatTime() < 10 and 2 or 0) and
        Target:CanCast(Nightblade)
        then
            Target:Cast(Nightblade)
            return "Cast"
        end
        if DarkShadow:Exists() then
            if
            Player:ComboPointsDeficit() >= 2 + (Player:Buff(ShadowBlades) and 1 or 0) and
            (Target:DebuffRemains(Nightblade) > 4 + (Subterfuge:Exists() and 1 or 0) or
            (ShadowDance:FractionalCharges() >= 1.9 and
            (not DenialoftheHalfGiants:IsEquipped() or CombatTime() > 10)))
            then
                if self:Sub_Stealth_ALSBeta() then
                    return
                end
            end
        else
            if
            Player:ComboPointsDeficit() >= 2 + (Player:Buff(ShadowBlades) and 1 or 0) or
            ShadowDance:FractionalCharges() >= 1.9 + (EnvelopingShadows:Exists() and 1 or 0)
            then
                if self:Sub_Stealth_ALSBeta() then
                    return
                end
            end
        end
        if
        (Player:ComboPoints() >=
        5 + (Player:Buff(TheFirstoftheDeadBuff) and Anticipation:Exists() and 3 or 0) +
        (DeeperStratagem:Exists() and not Player:Buff(ShadowBlades) and
        (self:MantleDuration() == 0 or HasT20_4Pc) and
        1 or
        0) or
        (Player:ComboPoints() >= 4 and Player:ComboPointsDeficit() <= 2 and NumEnemies_10y >= 3 and
        NumEnemies_10y <= 4))
        then
            if self:Sub_FinishBeta() then
                return
            end
        end
        if Player:EnergyDeficit() <= self:Sub_Stealth_Threshold() then
            if self:Sub_Build() then
                return
            end
        end
        if
        IsOptionEnabled("飞镖投掷") and not Player:IsWithinCastRange(Target, Backstab) and
        not Player:IsStealthed(true, true) and
        Player:Energy() > GetOptionValue("飞镖投掷") and
        Player:EnergyDeficit() < 20 and
        (Player:ComboPointsDeficit() >= 1 or Player:EnergyTimeToMax() <= 1.2) and
        Target:CanCast(ShurikenToss)
        then
            Target:Cast(ShurikenToss)
            return
        end
    end
    return
end
function Rotation:OutOfCombat()
    self.StealthAllowed = GetNumLootItems() == 0 and not UnitExists("npc") and OutOfCombatTime() > 1 and true or false
    if IsOptionEnabled("搜索") and not Player.PickPocketInitialized then
        Player:PickPocketInit()
    end
    if
    IsOptionEnabled("潜行") and GetOptionValue("潜行") == "无条件使用" and self.StealthAllowed and
    not Player:IsStealthed(true, false) and
    Stealth:TimeSinceCast() > 0.4 and
    Player:CanCast(Stealth)
    then
        Player:Cast(Stealth)
        Stealth.LastCastTime = GetTime()
        return
    end
    if
    IsOptionEnabled("猩红之瓶") and CrimsonVial:Exists() and Player:HealthPercentage() <= GetOptionValue("猩红之瓶") and
    Player:CanCast(CrimsonVial)
    then
        Player:Cast(CrimsonVial)
        return
    end
    if
    IsOptionEnabled("对焦点施放嫁祸诀窍") and TricksoftheTrade:Exists() and BMPullTime() <= 1.5 and Focus:Exists() and
    Focus:IsInParty() and
    not Focus:Equals(Player) and
    Focus:CanCast(TricksoftheTrade)
    then
        Focus:Cast(TricksoftheTrade)
    end
    Player:UsePotions("Agility")
    if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        if
        IsOptionEnabled("潜行") and Player:DistanceTo(Target) < 25 and self.StealthAllowed and
        not Player:IsStealthed(true, false) and
        Stealth:TimeSinceCast() > 0.4 and
        Player:CanCast(Stealth)
        then
            Player:Cast(Stealth)
            Stealth.LastCastTime = GetTime()
            return
        end
        if Player:IsStealthed(true, true) and Player:HealthPercentage() > GetOptionValue("消失 防御") then
            if
            IsOptionEnabled("对焦点施放嫁祸诀窍") and TricksoftheTrade:Exists() and
            Player:DistanceTo(Target) < GetSecondOptionValue("暗影打击 范围") + 5 and
            BMPullTime() == 60 and
            Focus:Exists() and
            Focus:IsInParty() and
            not Focus:Equals(Player) and
            Focus:CanCast(TricksoftheTrade)
            then
                Focus:Cast(TricksoftheTrade)
            end
            if BMPullTime() == 60 or BMPullTime() <= 0.5 then
                if IsOptionEnabled("搜索") and not Player.PickPocketed[Target:GUID()] then
                    if PickPocket:Exists() and Target:CanCast(PickPocket) then
                        Target:Cast(PickPocket)
                        PickPocketTarget = Target:GUID()
                        PickPocketAttempt = GetTime()
                    end
                    return
                end
                if
                IsOptionEnabled("自动进入战斗") and (BMPullTime() == 60 or BMPullTime() <= 0.5) and
                Player:DistanceTo(Target) <= GetSecondOptionValue("暗影打击 范围")
                then
                    if
                    IsOptionEnabled("偷袭") and CheapShot:Exists() and not Target:IsBoss() and
                    Target:CanCast(CheapShot)
                    then
                        Target:Cast(CheapShot)
                        return
                    end
                    if Shadowstrike:Exists() then
                        if Target:CanCast(Shadowstrike) then
                            Target:Cast(Shadowstrike)
                            return
                        end
                    else
                        if Gloomblade:Exists() then
                            if Target:CanCast(Gloomblade) then
                                Target:Cast(Gloomblade)
                                return "Cast"
                            end
                        else
                            if Target:CanCast(Backstab) then
                                Target:Cast(Backstab)
                                return "Cast"
                            end
                        end
                    end
                end
            end
        end
    end
end
SetRotation(262, {})
local Rotation = Rotations[262]
function Rotation:Initialize()
    Berserking = Spell(26297, false, false, true)
    BloodFury = Spell(33702, false, false, true)
    GiftOfTheNaaru = Spell(59548, false, false, true)
    Aftershock = Spell(210707)
    AncestralGuidance = Spell(108281, false, false, true)
    AncestralSwiftness = Spell(192087, false, false, true)
    Ascendance = Spell(114050, false, false, true)
    AstralShift = Spell(108271, false, false, true)
    ChainLightning = Spell(188443, true, true, true)
    EchoOfTheElements = Spell(108283)
    EarthElemental = Spell(198103, false, false, true)
    Earthquake = Spell(61882, false, true, true)
    EarthShock = Spell(8042, true, true, true)
    ElementalBlast = Spell(117014, true, true, false)
    ElementalFocus = Spell(16246)
    ElementalFusion = Spell(192235)
    ElementalMastery = Spell(16166, false, false, true)
    EmberTotem = Spell(210658)
    FlameShock = Spell(188389, true, true, true)
    FrostShock = Spell(196840, true, true, true)
    FireElemental = Spell(198067, false, false, true)
    GhostWolf = Spell(2645, false, false, true)
    GiftOfTheNaaru = Spell(59547, false, false, true)
    HealingSurge = Spell(8004, false, false, false)
    IceFury = Spell(210714, true, true, false)
    LavaBeam = Spell(114074, true, true, true)
    LavaBurst = Spell(51505, true, true, false)
    LavaBurstInstant = Spell(51505, true, true, true)
    LavaSurge = Spell(77762)
    LightningBolt = Spell(188196, true, true, true)
    LightningRod = Spell(210689)
    LiquidMagma = Spell(192222, false, true, true)
    PrimalElementalist = Spell(117013)
    StormElemental = Spell(192249, false, false, true)
    Stormkeeper = Spell(205495, false, false, true)
    Thunderstorm = Spell(51490, false, false, true)
    TotemMastery = Spell(210643, false, false, true)
    WindShear = Spell(57994, true, true, true)
    SwellingMaelstrom = Spell(238105)
    EchoesOfTheGreatSundering = Spell(208723)
    PowerOfTheMaelstrom = Spell(191861)
    SmolderingHeart = Item(151819)
    TheDeceiversBloodPact = Item(137035)
    AddPage("常规")
    AddPage("进攻")
    AddPage("防御")
    AddCommonOptions()
    AddPresetOption("常规", "Caster", nil, true)
    AddSection("常规", "移动", "Yellow")
    AddNewOption(
    "常规",
    "幽魂之狼",
    232,
    true,
    { 3, "无条件使用", "在战斗中", "脱离战斗后" },
    { 2.5, 0, 10, 0.1 },
    "Use Ghost Wolf on player." ..
    C.TOOLTIP_VALUE_1 ..
    "When should we use Ghost Wolf." ..
    C.TOOLTIP_VALUE_2 .. "Select desired time to wait when you start moving to use it.(seconds)"
    )
    AddPresetOption("进攻")
    AddSection("进攻", "大技能", "Yellow")
    AddPresetOption("Cooldown", "升腾", nil, { 3, 3, 20, 1 }, "Number of enemies to use Asendance in AoE situation.")
    AddPresetOption("Cooldown", "土元素")
    AddPresetOption("Cooldown", "元素掌握")
    AddPresetOption("Cooldown", "火元素")
    AddPresetOption("Cooldown", "风暴元素")
    AddPresetOption("Cooldown", "风暴守护者")
    AddSection("进攻", "常规", "Yellow")
    AddNewOption(
    "进攻",
    "AoE Rotation",
    120,
    true,
    { 3, 1, 20, 1 },
    nil,
    "Use AoE rotation when given amount of enemies can be hit by Chain Lightning."
    )
    AddSection("进攻", "能力", "Yellow")
    AddNewOption(
    "进攻",
    "震地图腾大分裂的回响",
    232,
    true,
    { 2, "目标", "Target Standing", "Centered", "Centered Standing" },
    { 1, 1, 25, 1 },
    "Use Earthquake Totem with the Echoes of the Great Sundering buff (Meant for Single target as usual Earthquake Totem will work right if doing AoE)." ..
    C.TOOLTIP_VALUE_1 ..
    "Choose preferred mode." ..
    C.TOOLTIP_SUBVALUE("目标") ..
    "Always use on the current target." ..
    C.TOOLTIP_SUBVALUE("Target Standing") ..
    "Always use on the current target. Target must be standing still." ..
    C.TOOLTIP_SUBVALUE("Centered") ..
    "Use centered on a cluster of enemies." ..
    C.TOOLTIP_SUBVALUE("Centered Standing") ..
    "Use centered on a cluster of enemies. Enemies must be standing still." ..
    C.TOOLTIP_VALUE_2 ..
    "Amount of enemies that must be in the spell effect to use."
    )
    AddNewOption(
    "进攻",
    "震地图腾",
    232,
    true,
    { 2, "目标", "Target Standing", "Centered", "Centered Standing" },
    { 3, 1, 25, 1 },
    "Use Earthquake Totem." ..
    C.TOOLTIP_VALUE_1 ..
    "Choose preferred mode." ..
    C.TOOLTIP_SUBVALUE("目标") ..
    "Always use on the current target." ..
    C.TOOLTIP_SUBVALUE("Target Standing") ..
    "Always use on the current target. Target must be standing still." ..
    C.TOOLTIP_SUBVALUE("Centered") ..
    "Use centered on a cluster of enemies." ..
    C.TOOLTIP_SUBVALUE("Centered Standing") ..
    "Use centered on a cluster of enemies. Enemies must be standing still." ..
    C.TOOLTIP_VALUE_2 ..
    "Amount of enemies that must be in the spell effect to use."
    )
    AddNewOption(
    "进攻",
    "烈焰震击叠加",
    222,
    true,
    { 3, 1, 10, 1 },
    { 3, 0, 25, 0.1 },
    "Multi-Dot Flame Shock Cycle." ..
    C.TOOLTIP_VALUE_1 ..
    "Amount of dots to apply." .. C.TOOLTIP_VALUE_2 .. "Minimum health (in million) to apply."
    )
    AddNewOption(
    "进攻",
    "熔岩弹射",
    220,
    true,
    { 2, 1, 5, 1 },
    nil,
    "Use Lava Beam." ..
    C.TOOLTIP_VALUE .. "Define minimum number of units that needs to be in 10 yards around the target."
    )
    AddNewOption(
    "进攻",
    "岩浆图腾",
    232,
    true,
    { 2, "目标", "Target Standing", "Centered", "Centered Standing" },
    { 2, 1, 25, 1 },
    "Use Liquid Magma Totem." ..
    C.TOOLTIP_VALUE_1 ..
    "Choose preferred mode." ..
    C.TOOLTIP_SUBVALUE("目标") ..
    "Always use on the current target." ..
    C.TOOLTIP_SUBVALUE("Target Standing") ..
    "Always use on the current target. Target must be standing still." ..
    C.TOOLTIP_SUBVALUE("Centered") ..
    "Use centered on a cluster of enemies." ..
    C.TOOLTIP_SUBVALUE("Centered Standing") ..
    "Use centered on a cluster of enemies. Enemies must be standing still." ..
    C.TOOLTIP_VALUE_2 ..
    "Amount of enemies that must be in the spell effect to use."
    )
    AddNewOption("进攻", "图腾掌握", 210, true, nil, nil, "Maintain Totem Mastery buffs.")
    AddPresetOption("防御")
    AddSection("防御", "能力", "Yellow")
    AddNewOption(
    "防御",
    "星界转移",
    220,
    true,
    { 50, 1, 100, 1 },
    nil,
    "Use Astral Shift." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddNewOption(
    "防御",
    "先祖指引",
    220,
    true,
    { 40, 1, 100, 1 },
    nil,
    "Use Ancestral Guidance." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddNewOption(
    "防御",
    "治疗之涌",
    222,
    true,
    { 20, 0, 95, 5 },
    { 90, 0, 95, 5 },
    "Use Healing Surge." ..
    C.TOOLTIP_VALUE_1 ..
    "Health threshold while in combat." .. C.TOOLTIP_VALUE_2 .. "Health threshold while out of combat."
    )
    ISCL = {
        [ChainLightning:ID()] = "闪电链",
        [ElementalBlast:ID()] = "Elemental Blast",
        [LavaBurst:ID()] = "熔岩爆裂",
        [LightningBolt:ID()] = "闪电箭"
    }
end
function Rotation:Events()
end
function Rotation:Pulse()
    if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
        return
    end
    if Target:Exists() and BMPullTime() < 5 then
        self:Opening()
        return
    end
    if GetTime() < Rotation.SpamPrevention then
        return
    end
    Rotation.SpamPrevention = GetTime() + 0.05
    Target = Unit.Target
    local InCombat = Player:IsInCombat()
    if not InCombat then
        self:OutOfCombat()
        return
    end
    if InCombat then
        self:Defensives()
    end
    Target = Player:ReTarget(LightningBolt, false) or Unit.Target
    if Target:Exists() then
        Rotations:RefreshUnitTables(Rotation.Identifier)
        self:Interrupts()
        if
        IsOptionEnabled("开怪技能") and
        (GetOptionValue("开怪技能") == "无条件使用" or (GetOptionValue("开怪技能") == "打BOSS使用" and Target:IsBoss()) or
        (GetOptionValue("开怪技能") == "CDs Only" and CooldownsAllowed())) and
        not OpenerEnded
        then
            self:Opener()
            return
        elseif CombatTime() > 10 then
            OpenerEnded = true
        end
        self:OffGCDAbilities()
        if Player:GlobalCooldown() == 0 then
            self:Combat()
        end
    end
end
function Rotation:Opening()
    Player:UsePotions("智力药水", GetSecondOptionValue("抢先使用药水"))
    if
    IsOptionEnabled("抢先施放(需DBM插件)") and
    (GetOptionValue("抢先施放(需DBM插件)") == "无条件使用" or
    (GetOptionValue("抢先施放(需DBM插件)") == "打BOSS使用" and Target:IsBoss()))
    then
        if
        TotemMastery:Exists() and (not Player:Buff(EmberTotem) or TotemMastery:TotemDuration() < 100) and
        Player:CanCast(TotemMastery)
        then
            Player:Cast(TotemMastery)
            return
        end
        OpenerSpell = ElementalBlast:Exists() and ElementalBlast or LightningBolt
        if OpenerSpell:Exists() and BMPullTime() < GetSecondOptionValue("抢先施放(需DBM插件)") and Target:CanCast(OpenerSpell) then
            Target:Cast(OpenerSpell)
            return
        end
    end
end
function Rotation:Opener()
    self.ChoosenOpener = nil
    BuilderSpell = NumEnemies < 2 and LightningBolt or ChainLightning
    if LightningRod:Exists() then
        self.ChoosenOpener = {
            [1] = { FireElemental, Player, CDOptionEnabled("火元素") },
            [2] = { "Racials", { BloodFury, Berserking } },
            [3] = { "Trinkets" },
            [4] = { ElementalBlast, Target, ElementalBlast:Exists() and not ElementalBlast:IsOnCooldown() },
            [5] = { FlameShock, Target, Target:Debuff(FlameShock) == nil },
            [6] = { LavaBurst, Target, Target:Debuff(FlameShock) ~= nil },
            [7] = { Stormkeeper, Player, CDOptionEnabled("风暴守护者") },
            [8] = { BuilderSpell, Target, Player:Buff(Stormkeeper) ~= nil },
            [9] = { BuilderSpell, Target, Player:Buff(Stormkeeper) ~= nil },
            [10] = { BuilderSpell, Target, Player:Buff(Stormkeeper) ~= nil },
            [11] = "Lightning Rod Opener"
        }
    elseif IceFury:Exists() then
        self.ChoosenOpener = {
            [1] = { FireElemental, Player, CDOptionEnabled("火元素") },
            [2] = { "Racials", { BloodFury, Berserking } },
            [3] = { "Trinkets" },
            [4] = { ElementalBlast, Target, ElementalBlast:Exists() and not ElementalBlast:IsOnCooldown() },
            [5] = { LavaBurst, Target, Target:Debuff(FlameShock) ~= nil },
            [6] = { FlameShock, Target, Target:Debuff(FlameShock) == nil },
            [7] = { IceFury, Target, true },
            [8] = { Stormkeeper, Player, CDOptionEnabled("风暴守护者") },
            [9] = { LavaBurst, Target, Target:Debuff(FlameShock) ~= nil },
            [10] = { BuilderSpell, Target, Player:Buff(Stormkeeper) ~= nil },
            [11] = { BuilderSpell, Target, Player:Buff(Stormkeeper) ~= nil },
            [12] = { BuilderSpell, Target, Player:Buff(Stormkeeper) ~= nil },
            [13] = { ElementalBlast, Target, ElementalBlast:Exists() and not ElementalBlast:IsOnCooldown() },
            [14] = { FrostShock, Target, Player:Buff(IceFury) ~= nil },
            [15] = { FrostShock, Target, Player:Buff(IceFury) ~= nil },
            [16] = { FrostShock, Target, Player:Buff(IceFury) ~= nil },
            [17] = { FrostShock, Target, Player:Buff(IceFury) ~= nil },
            [18] = "Ice Fury Opener"
        }
    elseif Ascendance:Exists() then
        self.ChoosenOpener = {
            [1] = { FireElemental, Player, CDOptionEnabled("火元素") },
            [2] = { ElementalBlast, Target, ElementalBlast:Exists() and not ElementalBlast:IsOnCooldown() },
            [3] = { FlameShock, Target, Target:Debuff(FlameShock) == nil },
            [4] = { LavaBurst, Target, Target:Debuff(FlameShock) ~= nil },
            [5] = { LavaBurst, Target, Target:Debuff(FlameShock) ~= nil },
            [6] = { "Racials", { BloodFury, Berserking } },
            [7] = { "Trinkets" },
            [8] = { Ascendance, Player, CDOptionEnabled("升腾") },
            [9] = "Ascendance Opener"
        }
    end
    if self.ChoosenOpener ~= nil then
        OpenerParser(self.ChoosenOpener)
    else
        Bug("Invalid Talents combination, Opener will not be used.")
        OpenerEnded = true
    end
end
function Rotation:Defensives()
    Player:UseHealingItem()
    if
    AncestralGuidance:Exists() and IsOptionEnabled("先祖指引") and Player:CanCast(AncestralGuidance) and
    Player:HealthPercentage() <= GetOptionValue("先祖指引")
    then
        Player:Cast(AncestralGuidance)
    end
    if
    AstralShift:Exists() and IsOptionEnabled("星界转移") and Player:CanCast(AstralShift) and
    Player:HealthPercentage() <= GetOptionValue("星界转移")
    then
        Player:Cast(AstralShift)
    end
    if
    GiftOfTheNaaru:Exists() and IsOptionEnabled("纳鲁的赐福") and
    Player:SpecialHealthPercentage() <= GetOptionValue("纳鲁的赐福") and
    Player:CanCast(GiftOfTheNaaru)
    then
        Player:Cast(GiftOfTheNaaru)
        return
    end
end
function Rotation:Interrupts()
    Player:UseInterrupt(WindShear)
end
function Rotation:OffGCDAbilities()
end
function Rotation:UseGhostWolf()
    if
    GhostWolf:Exists() and IsOptionEnabled("幽魂之狼") and
    (GetOptionValue("幽魂之狼") == "无条件使用" or (GetOptionValue("幽魂之狼") == "在战斗中" and Player:IsInCombat()) or
    (GetOptionValue("幽魂之狼") == "脱离战斗后" and not Player:IsInCombat())) and
    Player:Moving() > GetSecondOptionValue("幽魂之狼") and
    not IsFalling() and
    not Player:Buff(GhostWolf) and
    Player:CanCast(GhostWolf)
    then
        Player:Cast(GhostWolf)
        return true
    end
    return false
end
function Rotation:UnitTables()
    Enemies = UseAOE() and Player:EnemiesWithinDistance(40) or {}
    FlameShockUnit = UseAOE() and Unit.DotCycle(Enemies, FlameShock, FlameShock, 30, "烈焰震击叠加") or nil
    TargetEnemies_10y = UseAOE() and Target:EnemiesWithinDistance(10) or {}
    NumEnemies = #TargetEnemies_10y
end
function Rotation:Combat()
    if
    IsOptionEnabled("治疗之涌") and not Player:IsMoving() and Player:CanCast(HealingSurge) and
    Player:HealthPercentage() <= GetOptionValue("治疗之涌")
    then
        Player:Cast(HealingSurge)
        return
    end
    Maelstrom, SpellHaste = Player:Maelstrom(), 1 - GetHaste() / 100
    if Target:Exists() and Player:CanAttack(Target) then
        if Player:IsWithinCastRange(Target, LightningBolt) then
            Player:UsePotions("智力药水")
            if
            TotemMastery:Exists() and IsOptionEnabled("图腾掌握") and TotemMastery:TimeSinceCast() > 5 and
            (not Player:Buff(EmberTotem) or TotemMastery:TotemDuration() < 3) and
            Player:CanCast(TotemMastery)
            then
                TotemMastery.LastCastTime = GetTime()
                Player:Cast(TotemMastery)
                return
            end
            Player:UseTrinkets()
            if
            not StormElemental:Exists() and FireElemental:Exists() and CDOptionEnabled("火元素") and
            Player:CanCast(FireElemental)
            then
                Player:Cast(FireElemental)
                return
            end
            if StormElemental:Exists() and CDOptionEnabled("风暴元素") and Player:CanCast(StormElemental) then
                Player:Cast(StormElemental)
                return
            end
            if ElementalMastery:Exists() and CDOptionEnabled("元素掌握") and Player:CanCast(ElementalMastery) then
                Player:Cast(ElementalMastery)
                return
            end
            if CDOptionEnabled("进攻性种族技能") then
                if
                BloodFury:Exists() and
                (not Ascendance:Exists() or Player:Buff(Ascendance) or Ascendance:Cooldown() > 50) and
                Player:CanCast(BloodFury)
                then
                    Player:Cast(BloodFury)
                end
                if
                Berserking:Exists() and (not Ascendance:Exists() or Player:Buff(Ascendance)) and
                Player:CanCast(Berserking)
                then
                    Player:Cast(Berserking)
                end
            end
            if EarthElemental:Exists() and CDOptionEnabled("土元素") and Player:CanCast(EarthElemental) then
                Player:Cast(EarthElemental)
                return
            end
        end
        if UseAOE() and Earthquake:Exists() and IsOptionEnabled("震地图腾") and Target:CanCast(Earthquake) then
            if Target:CastGroundSpell(Earthquake, "震地图腾", 8) then
                Earthquake.LastCastTime = GetTime()
                return
            end
        end
        if NumEnemies >= GetOptionValue("AoE Rotation") then
            if
            Stormkeeper:Exists() and CDOptionEnabled("风暴守护者") and
            (not Player:Buff(Ascendance) or (IsOptionEnabled("熔岩弹射") and NumEnemies >= GetOptionValue("熔岩弹射"))) and
            Player:CanCast(Stormkeeper)
            then
                Player:Cast(Stormkeeper)
                return
            end
            if
            Ascendance:Exists() and CDOptionEnabled("升腾") and NumEnemies >= GetSecondOptionValue("升腾") and
            not Player:Buff(Ascendance) and
            Player:CanCast(Ascendance)
            then
                Player:Cast(Ascendance)
                return
            end
            if LiquidMagma:Exists() and IsOptionEnabled("岩浆图腾") and Target:CanCast(LiquidMagma) then
                if Target:CastGroundSpell(LiquidMagma, "岩浆图腾", 8) then
                    return
                end
            end
            if FlameShock:Exists() and NumEnemies < 4 and Maelstrom >= 20 then
                if Target:DebuffRemains(FlameShock) < 8 and Target:CanCast(FlameShock) then
                    Target:Cast(FlameShock)
                    return
                end
                if
                FlameShockUnit and FlameShockUnit:DebuffRemains(FlameShock) < 8 and
                FlameShockUnit:CanCast(FlameShock)
                then
                    FlameShockUnit:Cast(FlameShock)
                    return
                end
            end
            if Earthquake:Exists() and IsOptionEnabled("震地图腾") and Target:CanCast(Earthquake) then
                if Target:CastGroundSpell(Earthquake, "震地图腾", 8) then
                    Earthquake.LastCastTime = GetTime()
                    return
                end
            end
            if
            LavaBurstInstant:Exists() and Target:DebuffRemains(FlameShock) > 1 and Player:Buff(LavaSurge) and
            not LightningRod:Exists() and
            NumEnemies < 4 and
            Target:CanCast(LavaBurstInstant)
            then
                Target:Cast(LavaBurstInstant)
                return
            end
            if
            ElementalBlast:Exists() and ((not LightningRod:Exists() and NumEnemies < 5) or NumEnemies < 4) and
            Target:CanCast(ElementalBlast)
            then
                Target:Cast(ElementalBlast)
                return
            end
            if
            ChainLightning:Exists() and Player:Buff(Ascendance) and IsOptionEnabled("熔岩弹射") and
            NumEnemies >= GetOptionValue("熔岩弹射") and
            Target:CanCast(ChainLightning)
            then
                Target:Cast(ChainLightning)
                return
            end
            if ChainLightning:Exists() and not Player:Buff(Ascendance) and Target:CanCast(ChainLightning) then
                Target:Cast(ChainLightning)
                return
            end
            if
            LavaBurstInstant:Exists() and Player:Buff(LavaSurge) and
            Target:DebuffRemains(FlameShock) > LavaBurst:TravelTime() and
            Target:CanCast(LavaBurstInstant)
            then
                Target:Cast(LavaBurstInstant)
                return
            end
            if FlameShock:Exists() and Player:IsMoving() then
                if Target:DebuffRemains(FlameShock) < 8 and Target:CanCast(FlameShock) then
                    Target:Cast(FlameShock)
                    return
                end
                if IsOptionEnabled("烈焰震击叠加") and FlameShockUnit then
                    FlameShockUnit:Cast(FlameShock)
                    return
                end
            end
            return
        end
        if Ascendance:Exists() then
            if
            ElementalBlast:Exists() and CDOptionEnabled("升腾") and Ascendance:Cooldown() < 2 and
            Target:DebuffRemains(FlameShock) > 15 and
            Target:CanCast(ElementalBlast)
            then
                Bug("Elemental Blast before Ascendance")
                Target:Cast(ElementalBlast)
                return
            end
            if
            Ascendance:Exists() and
            (Target:DebuffRemains(FlameShock) > 15 and LavaBurst:IsOnCooldown() and not Player:Buff(Stormkeeper)) and
            (not ElementalBlast:Exists() or ElementalBlast:Cooldown() > 3) and
            CDOptionEnabled("升腾") and
            not Player:Buff(Ascendance) and
            Player:CanCast(Ascendance)
            then
                Player:Cast(Ascendance)
                return
            end
            if FlameShock:Exists() and Target:DebuffRemains(FlameShock) < Player:GCD() and Target:CanCast(FlameShock) then
                Target:Cast(FlameShock)
                return
            end
            if
            FlameShock:Exists() and FlameShockUnit and Maelstrom >= 20 and
            FlameShockUnit:DebuffRemains(FlameShock) < Player:GCD() and
            FlameShockUnit:CanCast(FlameShock)
            then
                FlameShockUnit:Cast(FlameShock)
                return
            end
            if
            FlameShock:Exists() and Maelstrom >= 20 and Target:DebuffRemains(FlameShock) < 15 and
            Ascendance:Cooldown() + 15 < 30 and
            Target:CanCast(FlameShock)
            then
                Target:Cast(FlameShock)
                return
            end
            if
            FlameShock:Exists() and FlameShockUnit and Maelstrom >= 20 and
            FlameShockUnit:DebuffRemains(FlameShock) < 15 and
            Ascendance:Cooldown() + 15 < 30 and
            FlameShockUnit:CanCast(FlameShock)
            then
                FlameShockUnit:Cast(FlameShock)
                return
            end
            if ElementalBlast:Exists() and Target:CanCast(ElementalBlast) then
                Target:Cast(ElementalBlast)
                return
            end
            if
            Earthquake:Exists() and IsOptionEnabled("震地图腾大分裂的回响") and Player:Buff(EchoesOfTheGreatSundering) and
            not Player:Buff(Ascendance) and
            Maelstrom >= 86 and
            Target:CanCast(Earthquake)
            then
                if Target:CastGroundSpell(Earthquake, "震地图腾大分裂的回响", 8) then
                    Earthquake.LastCastTime = GetTime()
                    return
                end
            end
            if
            EarthShock:Exists() and Maelstrom >= 117 or
            (not SwellingMaelstrom:ArtifactEnabled() and Maelstrom >= 92) and Target:CanCast(EarthShock)
            then
                Target:Cast(EarthShock)
                return
            end
            if
            Stormkeeper:Exists() and CDOptionEnabled("风暴守护者") and
            (not CDOptionEnabled("升腾") or Ascendance:Cooldown() >= 10) and
            not Player:Buff(Ascendance) and
            Player:CanCast(Stormkeeper)
            then
                Player:Cast(Stormkeeper)
                return
            end
            if UseAOE() and LiquidMagma:Exists() and IsOptionEnabled("岩浆图腾") and Target:CanCast(LiquidMagma) then
                if Target:CastGroundSpell(LiquidMagma, "岩浆图腾", 8) then
                    return
                end
            end
            if
            LightningBolt:Exists() and Player:Buff(PowerOfTheMaelstrom) and Player:Buff(Stormkeeper) and
            NumEnemies < 3 and
            Target:CanCast(LightningBolt)
            then
                Target:Cast(LightningBolt)
                return
            end
            if
            LavaBurst:Exists() and Target:DebuffRemains(FlameShock) > LavaBurst:CastTime() + LavaBurst:TravelTime() and
            Target:CanCast(LavaBurst)
            then
                Target:Cast(LavaBurst)
                return
            end
            if
            FlameShock:Exists() and Maelstrom >= 20 and Player:Buff(ElementalFocus) and
            Target:DebuffRemains(FlameShock) < 8 and
            Target:CanCast(FlameShock)
            then
                Target:Cast(FlameShock)
                return
            end
            if
            FlameShock:Exists() and FlameShockUnit and Maelstrom >= 20 and Player:Buff(ElementalFocus) and
            FlameShockUnit:DebuffRemains(FlameShock) < 8 and
            FlameShockUnit:CanCast(FlameShock)
            then
                FlameShockUnit:Cast(FlameShock)
                return
            end
            if
            EarthShock:Exists() and
            (Maelstrom >= 111 or (not SwellingMaelstrom:ArtifactEnabled() and Maelstrom >= 86) or
            (Maelstrom > 70 and Aftershock:Exists() and SmolderingHeart:IsEquipped(10) and
            TheDeceiversBloodPact:IsEquipped(8))) and
            Target:CanCast(EarthShock)
            then
                Target:Cast(EarthShock)
                return
            end
            if
            TotemMastery:Exists() and IsOptionEnabled("图腾掌握") and TotemMastery:TimeSinceCast() > 5 and
            (TotemMastery:TotemDuration() < 10 or
            (TotemMastery:TotemDuration() < (15 + Ascendance:Cooldown()) and Ascendance:Cooldown() < 15)) and
            Player:CanCast(TotemMastery)
            then
                TotemMastery.LastCastTime = GetTime()
                Player:Cast(TotemMastery)
                return
            end
            if
            Earthquake:Exists() and IsOptionEnabled("震地图腾大分裂的回响") and Player:Buff(EchoesOfTheGreatSundering) and
            Target:CanCast(Earthquake)
            then
                if Target:CastGroundSpell(Earthquake, "震地图腾大分裂的回响", 8) then
                    Earthquake.LastCastTime = GetTime()
                    return
                end
            end
            if
            ChainLightning:Exists() and Player:Buff(Ascendance) and IsOptionEnabled("熔岩弹射") and
            NumEnemies >= GetOptionValue("熔岩弹射") and
            Target:CanCast(ChainLightning)
            then
                Target:Cast(ChainLightning)
                return
            end
            if
            LightningBolt:Exists() and Player:Buff(PowerOfTheMaelstrom) and NumEnemies < 3 and
            Target:CanCast(LightningBolt)
            then
                Target:Cast(LightningBolt)
                return
            end
            if
            ChainLightning:Exists() and not Player:Buff(Ascendance) and NumEnemies >= 2 and
            Target:CanCast(ChainLightning)
            then
                Target:Cast(ChainLightning)
                return
            end
            if LightningBolt:Exists() and Target:CanCast(LightningBolt) then
                Target:Cast(LightningBolt)
                return
            end
            if
            FlameShock:Exists() and Player:IsMoving() and Target:DebuffRemains(FlameShock) < 8 and
            Target:CanCast(FlameShock)
            then
                Target:Cast(FlameShock)
                return
            end
            if
            EarthShock:Exists() and Player:IsMoving() and Target:DebuffRemains(FlameShock) > 19 and Maelstrom >= 10 and
            Target:CanCast(EarthShock)
            then
                Target:Cast(EarthShock)
                return
            end
            if FlameShock:Exists() and Player:IsMoving() and IsOptionEnabled("烈焰震击叠加") and FlameShockUnit then
                FlameShockUnit:Cast(FlameShock)
                return
            end
            self:UseGhostWolf()
            return
        elseif IceFury:Exists() then
            if FlameShock:Exists() and Target:DebuffRemains(FlameShock) < Player:GCD() and Target:CanCast(FlameShock) then
                Target:Cast(FlameShock)
                return
            end
            if
            FlameShock:Exists() and FlameShockUnit and Maelstrom >= 20 and
            FlameShockUnit:DebuffRemains(FlameShock) < Player:GCD() and
            FlameShockUnit:CanCast(FlameShock)
            then
                FlameShockUnit:Cast(FlameShock)
                return
            end
            if
            Earthquake:Exists() and IsOptionEnabled("震地图腾大分裂的回响") and Player:Buff(EchoesOfTheGreatSundering) and
            not Player:Buff(Ascendance) and
            Maelstrom >= 86 and
            Target:CanCast(Earthquake)
            then
                if Target:CastGroundSpell(Earthquake, "震地图腾大分裂的回响", 8) then
                    Earthquake.LastCastTime = GetTime()
                    return
                end
            end
            if
            FrostShock:Exists() and Player:Buff(IceFury) and
            (Maelstrom >= 111 or (not SwellingMaelstrom:ArtifactEnabled() and Maelstrom >= 86)) and
            not Player:Buff(Ascendance) and
            Target:CanCast(FrostShock)
            then
                Target:Cast(FrostShock)
                return
            end
            if ElementalBlast:Exists() and Target:CanCast(ElementalBlast) then
                Target:Cast(ElementalBlast)
                return
            end
            if
            EarthShock:Exists() and Maelstrom >= 117 or
            (not SwellingMaelstrom:ArtifactEnabled() and Maelstrom >= 92) and Target:CanCast(EarthShock)
            then
                Target:Cast(EarthShock)
                return
            end
            if Stormkeeper:Exists() and CDOptionEnabled("风暴守护者") and Player:CanCast(Stormkeeper) then
                Player:Cast(Stormkeeper)
                return
            end
            if
            IceFury:Exists() and
            ((SwellingMaelstrom:ArtifactEnabled() and Maelstrom <= 101) or
            (not SwellingMaelstrom:ArtifactEnabled() and Maelstrom <= 76)) and
            not Player:Buff(Ascendance) and
            Target:CanCast(IceFury)
            then
                Target:Cast(IceFury)
                return
            end
            if UseAOE() and LiquidMagma:Exists() and IsOptionEnabled("岩浆图腾") and Target:CanCast(LiquidMagma) then
                if Target:CastGroundSpell(LiquidMagma, "岩浆图腾", 8) then
                    return
                end
            end
            if
            LightningBolt:Exists() and Player:Buff(PowerOfTheMaelstrom) and Player:Buff(Stormkeeper) and
            NumEnemies < 3 and
            Target:CanCast(LightningBolt)
            then
                Target:Cast(LightningBolt)
                return
            end
            if
            LavaBurst:Exists() and Target:DebuffRemains(FlameShock) > LavaBurst:CastTime() + LavaBurst:TravelTime() and
            Target:CanCast(LavaBurst)
            then
                Target:Cast(LavaBurst)
                return
            end
            if
            FrostShock:Exists() and Player:Buff(IceFury) and
            (Maelstrom >= 20 or Player:BuffRemains(IceFury) < 1.5 * SpellHaste * Player:BuffCount(IceFury) + 1) and
            Target:CanCast(FrostShock)
            then
                Target:Cast(FrostShock)
                return
            end
            if
            FlameShock:Exists() and Maelstrom >= 20 and Player:Buff(ElementalFocus) and
            Target:DebuffRemains(FlameShock) < 8 and
            Target:CanCast(FlameShock)
            then
                Target:Cast(FlameShock)
                return
            end
            if
            FlameShock:Exists() and FlameShockUnit and Maelstrom >= 20 and Player:Buff(ElementalFocus) and
            FlameShockUnit:DebuffRemains(FlameShock) < 8 and
            FlameShockUnit:CanCast(FlameShock)
            then
                FlameShockUnit:Cast(FlameShock)
                return
            end
            if FrostShock:Exists() and Player:IsMoving() and Player:Buff(IceFury) and Target:CanCast(FrostShock) then
                Target:Cast(FrostShock)
                return
            end
            if
            EarthShock:Exists() and
            (Maelstrom >= 111 or (not SwellingMaelstrom:ArtifactEnabled() and Maelstrom >= 86) or
            (Maelstrom > 70 and Aftershock:Exists() and SmolderingHeart:IsEquipped(10) and
            TheDeceiversBloodPact:IsEquipped(8))) and
            Target:CanCast(EarthShock)
            then
                Target:Cast(EarthShock)
                return
            end
            if
            TotemMastery:Exists() and IsOptionEnabled("图腾掌握") and TotemMastery:TimeSinceCast() > 5 and
            TotemMastery:TotemDuration() < 10 and
            Player:CanCast(TotemMastery)
            then
                TotemMastery.LastCastTime = GetTime()
                Player:Cast(TotemMastery)
                return
            end
            if
            Earthquake:Exists() and IsOptionEnabled("震地图腾大分裂的回响") and Player:Buff(EchoesOfTheGreatSundering) and
            Target:CanCast(Earthquake)
            then
                if Target:CastGroundSpell(Earthquake, "震地图腾大分裂的回响", 8) then
                    Earthquake.LastCastTime = GetTime()
                    return
                end
            end
            if
            LightningBolt:Exists() and Player:Buff(PowerOfTheMaelstrom) and NumEnemies < 3 and
            Target:CanCast(LightningBolt)
            then
                Target:Cast(LightningBolt)
                return
            end
            if
            ChainLightning:Exists() and not Player:Buff(Ascendance) and NumEnemies >= 2 and
            Target:CanCast(ChainLightning)
            then
                Target:Cast(ChainLightning)
                return
            end
            if LightningBolt:Exists() and Target:CanCast(LightningBolt) then
                Target:Cast(LightningBolt)
                return
            end
            if
            FlameShock:Exists() and Player:IsMoving() and Target:DebuffRemains(FlameShock) < 8 and
            Target:CanCast(FlameShock)
            then
                Target:Cast(FlameShock)
                return
            end
            if
            EarthShock:Exists() and Player:IsMoving() and Target:DebuffRemains(FlameShock) > 19 and Maelstrom >= 10 and
            Target:CanCast(EarthShock)
            then
                Target:Cast(EarthShock)
                return
            end
            if FlameShock:Exists() and Player:IsMoving() and IsOptionEnabled("烈焰震击叠加") and FlameShockUnit then
                FlameShockUnit:Cast(FlameShock)
                return
            end
            self:UseGhostWolf()
            return
        else
            if FlameShock:Exists() and Target:DebuffRemains(FlameShock) < Player:GCD() and Target:CanCast(FlameShock) then
                Target:Cast(FlameShock)
                return
            end
            if
            FlameShock:Exists() and FlameShockUnit and Maelstrom >= 20 and
            FlameShockUnit:DebuffRemains(FlameShock) < Player:GCD() and
            FlameShockUnit:CanCast(FlameShock)
            then
                FlameShockUnit:Cast(FlameShock)
                return
            end
            if ElementalBlast:Exists() and Target:CanCast(ElementalBlast) then
                Target:Cast(ElementalBlast)
                return
            end
            if
            Earthquake:Exists() and IsOptionEnabled("震地图腾大分裂的回响") and Player:Buff(EchoesOfTheGreatSundering) and
            Target:CanCast(Earthquake)
            then
                if Target:CastGroundSpell(Earthquake, "震地图腾大分裂的回响", 8) then
                    Earthquake.LastCastTime = GetTime()
                    return
                end
            end
            if
            EarthShock:Exists() and Maelstrom >= 117 or
            (not SwellingMaelstrom:ArtifactEnabled() and Maelstrom >= 92) and Target:CanCast(EarthShock)
            then
                Target:Cast(EarthShock)
                return
            end
            if Stormkeeper:Exists() and CDOptionEnabled("风暴守护者") and Player:CanCast(Stormkeeper) then
                Player:Cast(Stormkeeper)
                return
            end
            if UseAOE() and LiquidMagma:Exists() and IsOptionEnabled("岩浆图腾") and Target:CanCast(LiquidMagma) then
                if Target:CastGroundSpell(LiquidMagma, "岩浆图腾", 8) then
                    return
                end
            end
            if
            LavaBurst:Exists() and Target:DebuffRemains(FlameShock) > LavaBurst:CastTime() + LavaBurst:TravelTime() and
            Target:CanCast(LavaBurst)
            then
                Target:Cast(LavaBurst)
                return
            end
            if
            FlameShock:Exists() and Maelstrom >= 20 and Player:Buff(ElementalFocus) and
            Target:DebuffRemains(FlameShock) < 8 and
            Target:CanCast(FlameShock)
            then
                Target:Cast(FlameShock)
                return
            end
            if
            FlameShock:Exists() and FlameShockUnit and Maelstrom >= 20 and Player:Buff(ElementalFocus) and
            FlameShockUnit:DebuffRemains(FlameShock) < 8 and
            FlameShockUnit:CanCast(FlameShock)
            then
                FlameShockUnit:Cast(FlameShock)
                return
            end
            if
            EarthShock:Exists() and
            (Maelstrom >= 111 or (not SwellingMaelstrom:ArtifactEnabled() and Maelstrom >= 86) or
            (Maelstrom > 70 and Aftershock:Exists() and SmolderingHeart:IsEquipped(10) and
            TheDeceiversBloodPact:IsEquipped(8))) and
            Target:CanCast(EarthShock)
            then
                Target:Cast(EarthShock)
                return
            end
            if
            TotemMastery:Exists() and IsOptionEnabled("图腾掌握") and TotemMastery:TimeSinceCast() > 5 and
            (TotemMastery:TotemDuration() < 10 or
            (TotemMastery:TotemDuration() < (15 + Ascendance:Cooldown()) and Ascendance:Cooldown() < 15)) and
            Player:CanCast(TotemMastery)
            then
                TotemMastery.LastCastTime = GetTime()
                Player:Cast(TotemMastery)
                return
            end
            if
            LightningBolt:Exists() and Player:Buff(PowerOfTheMaelstrom) and NumEnemies < 3 and
            Target:CanCast(LightningBolt)
            then
                Target:Cast(LightningBolt)
                return
            end
            if
            ChainLightning:Exists() and not Player:Buff(Ascendance) and NumEnemies >= 2 and
            Target:CanCast(ChainLightning)
            then
                Target:Cast(ChainLightning)
                return
            end
            if LightningBolt:Exists() and Target:CanCast(LightningBolt) then
                Target:Cast(LightningBolt)
                return
            end
            if
            FlameShock:Exists() and Player:IsMoving() and Target:DebuffRemains(FlameShock) < 8 and
            Target:CanCast(FlameShock)
            then
                Target:Cast(FlameShock)
                return
            end
            if
            EarthShock:Exists() and Player:IsMoving() and Target:DebuffRemains(FlameShock) > 19 and Maelstrom >= 10 and
            Target:CanCast(EarthShock)
            then
                Target:Cast(EarthShock)
                return
            end
            if FlameShock:Exists() and Player:IsMoving() and IsOptionEnabled("烈焰震击叠加") and FlameShockUnit then
                FlameShockUnit:Cast(FlameShock)
                return
            end
            self:UseGhostWolf()
            return
        end
    end
end
function Rotation:OutOfCombat()
    if
    IsOptionEnabled("治疗之涌") and not Player:IsMoving() and Player:CanCast(HealingSurge) and
    Player:HealthPercentage() <= GetSecondOptionValue("治疗之涌")
    then
        Player:Cast(HealingSurge)
        return
    end
    if self:UseGhostWolf() then
        return
    end
    if IsOptionEnabled("自动进入战斗") and Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        local EngageSpell =         ElementalBlast:Exists() and not ElementalBlast:IsOnCooldown() and ElementalBlast or LightningBolt
        if EngageSpell:Exists() and Target:CanCast(EngageSpell) then
            Target:Cast(EngageSpell)
            return
        end
    end
end
SetRotation(263, {})
local Rotation = Rotations[263]
function Rotation:Initialize()
    BloodFury = Spell(33697, false, false, true)
    Berserking = Spell(26297, false, false, true)
    GiftOfTheNaaru = Spell(59547, false, false, true)
    AlphaWolf = Spell(904)
    AncestralSpirit = Spell(2008, false, false, false, true)
    Ascendance = Spell(114051, false, false, true)
    AstralShift = Spell(108271, false, false, true)
    Boulderfist = Spell(246035, true, true, true)
    BoulderfistBuff = Spell(218825, false, false, true)
    CrashingStorm = Spell(192246)
    CrashLightning = Spell(187874, false, false, true)
    CrashLightningBuff = Spell(187878, false, false, true)
    DoomWinds = Spell(204945, true, true, true)
    EarthenSpike = Spell(188089, true, true, true)
    FeralLunge = Spell(196884, true, true, true)
    FeralSpirit = Spell(51533, false, false, true)
    FeralSpiritArtifact = Spell(198506, false, false, true)
    Flametongue = Spell(193796, true, true, true)
    FlametongueBuff = Spell(194084, false, false, true)
    Frostbrand = Spell(196834, true, true, true)
    FrostbrandBuff = Spell(196834, false, false, true)
    FuryOfAir = Spell(197211, false, false, true)
    GhostWolf = Spell(2645, false, false, true)
    Hailstorm = Spell(210853)
    HealingSurge = Spell(188070, false, false, true)
    HotHand = Spell(215785, false, false, true)
    Landslide = Spell(197992)
    LandslideBuff = Spell(202004)
    LavaLash = Spell(60103, true, true, true)
    LightningBolt = Spell(187837, true, true, false)
    LightningShield = Spell(192106, false, false, true)
    Overcharge = Spell(210727, false, false, true)
    Purge = Spell(370, true, true, true)
    Rainfall = Spell(215864, false, false, true)
    Rockbiter = Spell(193786, true, true, true)
    SpiritWalk = Spell(58875, false, false, true)
    Stormbringer = Spell(201846)
    Stormstrike = Spell(17364, true, true, true)
    Sundering = Spell(197214, false, false, true)
    WindShear = Spell(57994, true, true, true)
    Windsong = Spell(201898, false, true, true)
    Windstrike = Spell(115356, true, true, true)
    StormTempests = Spell(214265)
    AkainusAbsoluteJustice = Item(137084)
    StormTempestsBelt = Item(137103)
    PrimalAscendantsStormcallers = Item(151820)
    SmolderingHeart = Item(151819)
    AddPage("常规")
    AddPage("进攻")
    AddPage("防御")
    AddCommonOptions()
    AddPresetOption("常规", "Melee", nil, false)
    AddSection("常规", "辅助", "Yellow")
    AddNewOption("常规", "闪电之盾", 210, true, nil, nil, "Maintain Lightning Shield on us.")
    AddNewOption(
    "常规",
    "净化术",
    230,
    false,
    { 1, "任意目标", "目标" },
    nil,
    "Remove known magic buffs from the Target or Any Target."
    )
    AddSection("常规", "移动", "Yellow")
    AddNewOption(
    "常规",
    "狂野扑击",
    133,
    true,
    { 1, "禁用", "启用" },
    { 1, "禁用", "启用" },
    "Use Feral Lunge to close the gap between you and your target." ..
    C.TOOLTIP_VALUE_1 .. "In Combat." .. C.TOOLTIP_VALUE_2 .. "Out of Combat."
    )
    AddNewOption(
    "常规",
    "幽魂之狼",
    223,
    true,
    { 1.5, 0, 10, 0.1 },
    { 1, "Auto Unshapeshift", "Stay Shapeshifted" },
    "Use Ghost Wolf during combat." ..
    C.TOOLTIP_VALUE_1 ..
    "Time to wait when you start moving to use it.(In seconds)" ..
    C.TOOLTIP_VALUE_2 ..
    "Choose if you want to automatically unshapeshift when you are in melee range of your target."
    )
    AddNewOption(
    "常规",
    "脱离战斗后施放幽魂之狼",
    220,
    true,
    { 1.5, 0, 10, 0.1 },
    nil,
    "Use Ghost Wolf while out of combat." ..
    C.TOOLTIP_VALUE_1 .. "Time to wait when you start moving to use it.(In seconds)"
    )
    AddNewOption(
    "常规",
    "幽魂步",
    220,
    true,
    { 1.5, 0, 10, 0.1 },
    nil,
    "Use Spirit Walk." .. C.TOOLTIP_VALUE .. "Time to wait when you start moving to use it.(In seconds)"
    )
    AddPresetOption("进攻")
    AddSection("进攻", "大技能", "Yellow")
    AddPresetOption("Cooldown", "升腾")
    AddPresetOption("Cooldown", "毁灭之风")
    AddPresetOption("Cooldown", "大地之刺", nil, { 25, 0, 100, 0.1 }, "Minimum health of the target (in million) to use.")
    AddPresetOption("Cooldown", "野性狼魂")
    AddPresetOption("Cooldown", "裂地术")
    AddPresetOption("Cooldown", "风歌")
    AddSection("进攻", "能力", "Yellow")
    AddNewOption(
    "进攻",
    "Ascendance High Prio",
    210,
    false,
    nil,
    nil,
    "Use a High Priority APL when Ascendance buff is up. This will priorise Windstrike above most other spell, which may lead to dropped buffs, but maybe preferred in high burst single target."
    )
    AddNewOption("进攻", "毁灭闪电", 210, true, nil, nil, "Use Crash Lightning.")
    AddNewOption(
    "进攻",
    "Crash Lightning Range",
    122,
    true,
    { 8, 8, 12, 0.05 },
    { 120, 120, 180, 1 },
    "Crash Lightning range check." ..
    C.TOOLTIP_VALUE_1 ..
    "Spell Distance." ..
    C.TOOLTIP_VALUE_2 .. "Spell Effect Degrees." .. C.TOOLTIP_HINT("DO NOT MESS WITH IT")
    )
    AddNewOption("进攻", "空气之怒", 210, true, nil, nil, "Use Fury of Air.")
    AddNewOption("进攻", "闪电之盾", 210, true, nil, nil, "Maintain Lightning Shield on us.")
    AddNewOption("进攻", "超出攻击距离时施放闪电箭", 210, true, nil, nil, "Use Lightning Bolt when we are out of range as filler.")
    AddPresetOption("防御")
    AddSection("防御", "能力", "Yellow")
    AddNewOption(
    "防御",
    "治疗之涌",
    222,
    true,
    { 25, 0, 100, 1 },
    { 85, 0, 100, 1 },
    "Use Healing Surge." ..
    C.TOOLTIP_VALUE_1 .. "In Combat health threshold." .. C.TOOLTIP_VALUE_2 .. "Out of Combat health threshold."
    )
    AddNewOption(
    "防御",
    "降雨",
    222,
    true,
    { 3, 1, 10, 1 },
    { 70, 0, 100, 1 },
    "Use Rainfall." ..
    C.TOOLTIP_VALUE_1 ..
    "Number of units that needs to be under threshold." ..
    C.TOOLTIP_VALUE_2 .. "Threshold health under which the units must be."
    )
    AddSection("防御", "大技能", "Yellow")
    AddNewOption("防御", "星界转移", 220, true, { 30, 0, 100, 1 }, nil, "Use Astral Shift.")
    FuryOfAirName = GetSpellInfo(197211)
end
function Rotation:Events()
    FrostWolf = 0
    FireWolf = 0
    LightningWolf = 0
    FeralSpiritCasted = 0
    MyWolves = {}
    EventFrame:RegisterForCombatEvent(
    function(...)
        WolfGUID, _, _, _, DestGUID, _, _, _, SpellID = select(4, ...)
        FeralSpiritCasted = GetTime()
        if MyWolves[WolfGUID] and MyWolves[WolfGUID] ~= true then
            if SpellID == 224125 then
                FireWolf = FireWolf + 1
                MyWolves[WolfGUID] = true
                Bug("Fiery Jaws (" .. tostring(FireWolf) .. ")")
            end
            if SpellID == 198480 then
                FireWolf = FireWolf + 1
                MyWolves[WolfGUID] = true
                Bug("Fire Nova (" .. tostring(FireWolf) .. ")")
            end
            if SpellID == 224126 then
                FrostWolf = FrostWolf + 1
                MyWolves[WolfGUID] = true
                Bug("Frozen Bite (" .. tostring(FrostWolf) .. ")")
            end
            if SpellID == 198483 then
                FrostWolf = FrostWolf + 1
                MyWolves[WolfGUID] = true
                Bug("Snow Storm (" .. tostring(FrostWolf) .. ")")
            end
            if SpellID == 198485 then
                LightningWolf = LightningWolf + 1
                MyWolves[WolfGUID] = true
                Bug("Thunder Bite (" .. tostring(LightningWolf) .. ")")
            end
            if SpellID == 224127 then
                LightningWolf = LightningWolf + 1
                MyWolves[WolfGUID] = true
                Bug("Crackling Surge (" .. tostring(LightningWolf) .. ")")
            end
        end
    end,
    "SPELL_DAMAGE"
    )
    EventFrame:RegisterForSelfCombatEvent(
    function(...)
        DestGUID, _, _, _, SpellID = select(8, ...)
        FeralSpiritCasted = GetTime()
        if SpellID == 51533 then
            FrostWolf = 0
            FireWolf = 0
            LightningWolf = 0
        end
    end,
    "SPELL_CAST_SUCCESS"
    )
    EventFrame:RegisterForSelfCombatEvent(
    function(...)
        DestGUID, _, _, _, SpellID = select(8, ...)
        if SpellID == 198506 then
            if (#MyWolves > 2) then
                MyWolves = {}
            end
            MyWolves[DestGUID] = "Hello World"
        end
    end,
    "SPELL_SUMMON"
    )
end
function Rotation:Pulse()
    if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
        return
    end
    if Target:Exists() and BMPullTime() < 5 then
        self:Opening()
        return
    end
    if GetTime() < Rotation.SpamPrevention then
        return
    end
    Rotation.SpamPrevention = GetTime() + 0.05
    Target = Unit.Target
    local InCombat = Player:IsInCombat()
    Rotations:RefreshUnitTables(Rotation.Identifier)
    if FuryOfAir:Exists() and IsOptionEnabled("空气之怒") and #Enemies_15y < 1 and Player:Buff(FuryOfAir) then
        RunMacroText("/cancelaura " .. FuryOfAirName)
    end
    if not InCombat then
        self:OutOfCombat()
        if not IsOptionEnabled("自动进入战斗") then
            return
        end
    end
    if InCombat then
        self:Defensives()
    end
    Target = Player:ReTarget(Stormstrike, false) or Unit.Target
    if Target:Exists() then
        self:Interrupts()
        self:OffGCDAbilities()
        if Player:GlobalCooldown() == 0 then
            self:Combat()
        end
    end
end
function Rotation:Opening()
    Player:UsePotions("Agility")
    if
    IsOptionEnabled("抢先施放(需DBM插件)") and
    (GetOptionValue("抢先施放(需DBM插件)") == "无条件使用" or
    (GetOptionValue("抢先施放(需DBM插件)") == "打BOSS使用" and Target:IsBoss()))
    then
        local OpenerSpell = Boulderfist:Exists() and Boulderfist or Rockbiter
        if OpenerSpell:Exists() and BMPullTime() < GetSecondOptionValue("抢先施放(需DBM插件)") and Target:CanCast(OpenerSpell) then
            Player:StartAttack()
            Target:Cast(OpenerSpell)
            return
        end
    end
end
function Rotation:Defensives()
    Player:UseHealingItem()
    if
    AstralShift:Exists() and IsOptionEnabled("星界转移") and Player:HealthPercentage() <= GetOptionValue("星界转移") and
    Player:CanCast(AstralShift)
    then
        Player:Cast(AstralShift)
    end
    if
    GiftOfTheNaaru:Exists() and IsOptionEnabled("纳鲁的赐福") and Player:HealthPercentage() <= GetOptionValue("纳鲁的赐福") and
    Player:CanCast(GiftOfTheNaaru)
    then
        Player:Cast(GiftOfTheNaaru)
        return
    end
end
function Rotation:Interrupts()
    Player:UseInterrupt(WindShear)
end
function Rotation:OffGCDAbilities()
end
function Rotation:PurgeCycle()
    if module.GetOptionValue("净化术") == "任意目标" then
        for i = 1, #Enemies_30y do
            local ThisUnit = Enemies_30y[i]
            if ThisUnit:IsMagicBuffed() and ThisUnit:CanCast(Purge) then
                module.Bug("Purge - Any on " .. ThisUnit:Name())
                ThisUnit:Cast(Purge)
                return
            end
        end
    else
        if Target:IsMagicBuffed() and Target:CanCast(Purge) then
            module.Bug("Purge - Target")
            Target:Cast(Purge)
            return
        end
    end
end
function Rotation:UnitTables()
    RainfallUnit =     Rainfall:Exists() and IsOptionEnabled("降雨") and not Rainfall:IsOnCooldown() and
    Player:BestClusterOfAlliesToHeal(GetOptionValue("降雨"), GetSecondOptionValue("降雨"), 12) or
    nil
    Enemies_30y = UseAOE() and Player:EnemiesWithinDistance(30, true, false) or {}
    Enemies_15y = UseAOE() and Player:EnemiesWithinDistance(15, true) or {}
    Enemies_5y = UseAOE() and Player:EnemiesWithinDistance(5, true) or {}
    CrashEnemies =     Player:UnitsInFrontCone(GetOptionValue("Crash Lightning Range"), GetSecondOptionValue("Crash Lightning Range")) or
    {}
    SunderingEnemies = Sundering:Exists() and #Player:UnitsInFrontRectangle(10, 5) or 0
    SunderingEnemies = (not UseAOE() and SunderingEnemies > 0) and 1 or SunderingEnemies
    NumEnemies = #CrashEnemies
end
function Rotation:StormstrikeHandler()
    if UseAOE() and StormTempestsBelt:IsEquipped(6) then
        for i = 1, #Enemies_5y do
            ThisUnit = Enemies_5y[i]
            if not ThisUnit:Debuff(StormTempests) then
                if Player:Buff(Ascendance) then
                    if ThisUnit:CanCast(Windstrike) then
                        Bug("Windstrike Cycle 1")
                        ThisUnit:Cast(Windstrike)
                        return
                    end
                else
                    if ThisUnit:CanCast(Stormstrike) then
                        Bug("Stormstrike Cycle 1")
                        ThisUnit:Cast(Stormstrike)
                        return
                    end
                end
            end
        end
    end
    Target:Cast(Stormstrike)
    return
end
function Rotation:Rainfall()
    if RainfallUnit and not Player:Buff(Rainfall) and Player:CanCast(Rainfall) then
        RainfallUnit:Cast(Rainfall)
        return
    end
end
function Rotation:Combat()
    Maelstrom = Player:Maelstrom()
    if Player:DistanceTo(Target) > 14 then
        if
        SpiritWalk:Exists() and IsOptionEnabled("幽魂步") and Player:Moving() > GetOptionValue("幽魂步") and
        Player:CanCast(SpiritWalk)
        then
            Player:Cast(SpiritWalk)
            return
        end
        if GhostWolf:Exists() and IsOptionEnabled("幽魂之狼") and not Player:Buff(GhostWolf) and Player:CanCast(GhostWolf) then
            StartedMoving =             (not Player:IsWithinCastRange(Target, Stormstrike) and Player:IsMoving() and StartedMoving == 0) and
            GetTime() or
            StartedMoving
            if StartedMoving and StartedMoving ~= 0 and GetTime() - StartedMoving > GetOptionValue("幽魂之狼") then
                Player:Cast(GhostWolf)
                return
            end
        end
    end
    StartedMoving = (Player:IsWithinCastRange(Target, Stormstrike)) and 0 or StartedMoving
    if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) and Player:IsFacing(Target) then
        Player:StartAttack()
        if
        LightningShield:Exists() and IsOptionEnabled("闪电之盾") and Player:BuffRemains(LightningShield) < 900 and
        Player:CanCast(LightningShield)
        then
            Player:Cast(LightningShield)
            return
        end
        if
        HealingSurge:Exists() and IsOptionEnabled("治疗之涌") and Player:CanCast(HealingSurge, true) and
        Player:HealthPercentage() <= GetOptionValue("治疗之涌")
        then
            if Player:Maelstrom() >= 20 then
                Player:Cast(HealingSurge)
                return
            elseif not Player:IsMoving() then
                Player:Cast(HealingSurge)
                return
            end
        end
        if
        (not Player:Buff(GhostWolf) or
        (GetSecondOptionValue("幽魂之狼") == "Auto Unshapeshift" and Player:DistanceTo(Target) < 15)) and
        Player:IsWithinCastRange(Target, LightningBolt)
        then
            if
            FeralLunge:Exists() and GetOptionValue("狂野扑击") == "启用" and Player:DistanceTo(Target) >= 9 and
            Player:DistanceTo(Target) <= 24 and
            Target:CanCast(FeralLunge)
            then
                Target:Cast(FeralLunge)
                return
            end
            hailstormCheck = ((Hailstorm:Exists() and not Player:Buff(FrostbrandBuff)) or not Hailstorm:Exists())
            furyCheck80 = (not FuryOfAir:Exists() or (FuryOfAir:Exists() and Player:Maelstrom() > 80))
            furyCheck70 = (not FuryOfAir:Exists() or (FuryOfAir:Exists() and Player:Maelstrom() > 70))
            furyCheck45 = (not FuryOfAir:Exists() or (FuryOfAir:Exists() and Player:Maelstrom() > 45))
            furyCheck25 = (not FuryOfAir:Exists() or (FuryOfAir:Exists() and Player:Maelstrom() > 25))
            OCPool70 = (not Overcharge:Exists() or (Overcharge:Exists() and Player:Maelstrom() > 70))
            OCPool60 = (not Overcharge:Exists() or (Overcharge:Exists() and Player:Maelstrom() > 60))
            heartEquipped = SmolderingHeart:IsEquipped(10)
            akainuEquipped = AkainusAbsoluteJustice:IsEquipped(9)
            akainuAS = (akainuEquipped and Player:Buff(HotHand) and not Player:Buff(FrostbrandBuff))
            LightningCrashNotUp = (not Player:Buff(CrashLightningBuff) and HasT20_2Pc)
            alphaWolfCheck = (CrashLightning:TimeSinceCast() > 6) and GetTotemTimeLeft(1) > 4
            if
            Rockbiter:Exists() and Player:Maelstrom() < 15 and CombatTime() < Player:GCD() and
            Target:CanCast(Rockbiter)
            then
                return Target:Cast(Rockbiter)
            end
            if Player:Buff(Ascendance) and IsOptionEnabled("Ascendance High Prio") then
                if
                EarthenSpike:Exists() and CDOptionEnabled("大地之刺") and
                Target:Health() >= GetSecondOptionValue("大地之刺") * 1000000 and
                Target:CanCast(EarthenSpike)
                then
                    return Target:Cast(EarthenSpike)
                end
                if
                DoomWinds:Exists() and CDOptionEnabled("毁灭之风") and not Windstrike:IsOnCooldown() and
                Player:DistanceTo(Target) <= 5 and
                Target:CanCast(DoomWinds)
                then
                    return Target:Cast(DoomWinds)
                end
                if Stormstrike:Exists() and Target:CanCast(Windstrike) then
                    return self:StormstrikeHandler()
                end
            end
            if
            Rockbiter:Exists() and Landslide:Exists() and not Player:Buff(LandslideBuff) and
            Target:CanCast(Rockbiter)
            then
                return Target:Cast(Rockbiter)
            end
            if
            FuryOfAir:Exists() and IsOptionEnabled("空气之怒") and #Enemies_15y >= 1 and Maelstrom > 22 and
            not Player:Buff(FuryOfAir) and
            Player:CanCast(FuryOfAir)
            then
                return Player:Cast(FuryOfAir)
            end
            if
            CrashLightning:Exists() and AlphaWolf:ArtifactEnabledPowerID() and ShouldEmpowerFeralSpirit and
            #CrashEnemies >= 1 and
            Player:CanCast(CrashLightning)
            then
                ShouldEmpowerFeralSpirit = false
                CrashLightning.LastCastTime = GetTime()
                return Player:Cast(CrashLightning)
            end
            if Flametongue:Exists() and not Player:Buff(FlametongueBuff) and Target:CanCast(Flametongue) then
                return Target:Cast(Flametongue)
            end
            if
            Frostbrand:Exists() and Hailstorm:Exists() and not Player:Buff(FrostbrandBuff) and furyCheck45 and
            Target:CanCast(Frostbrand)
            then
                return Target:Cast(Frostbrand)
            end
            if
            Flametongue:Exists() and Player:BuffRemains(FlametongueBuff) < 6 + Player:GCD() and
            (CDOptionEnabled("毁灭之风") and DoomWinds:Cooldown() < Player:GCD() * 2) and
            Target:CanCast(Flametongue)
            then
                return Target:Cast(Flametongue)
            end
            if
            Frostbrand:Exists() and Hailstorm:Exists() and Player:BuffRemains(FrostbrandBuff) < 6 + Player:GCD() and
            (CDOptionEnabled("毁灭之风") and DoomWinds:Cooldown() < Player:GCD() * 2) and
            Target:CanCast(Frostbrand)
            then
                return Target:Cast(Frostbrand)
            end
            if Player:IsWithinCastRange(Target, Stormstrike) then
                Player:UsePotions("Agility")
                Player:UseTrinkets()
                if CDOptionEnabled("进攻性种族技能") then
                    if
                    Berserking:Exists() and
                    (Player:Buff(Ascendance) or (GetTime() - FeralSpirit.LastCastTime < 10) or
                    (DoomWinds:Cooldown() <= 6 and FeralSpirit:Cooldown() > 6)) and
                    Player:DistanceTo(Target) <= 5 and
                    Player:CanCast(Berserking)
                    then
                        Player:Cast(Berserking)
                    end
                    if
                    BloodFury:Exists() and
                    (Player:Buff(Ascendance) or (GetTime() - FeralSpirit.LastCastTime < 10) or
                    (DoomWinds:Cooldown() <= 6 and FeralSpirit:Cooldown() > 6)) and
                    Player:DistanceTo(Target) <= 5 and
                    Player:CanCast(BloodFury)
                    then
                        Player:Cast(BloodFury)
                    end
                end
            end
            if
            FeralSpirit:Exists() and CDOptionEnabled("野性狼魂") and Player:DistanceTo(Target) <= 10 and
            Player:CanCast(FeralSpirit)
            then
                ShouldEmpowerFeralSpirit = true
                return Player:Cast(FeralSpirit)
            end
            if
            DoomWinds:Exists() and CDOptionEnabled("毁灭之风") and
            ((Ascendance:Exists() and (not CDOptionEnabled("升腾") or Ascendance:Cooldown() > 6)) or
            (EarthenSpike:Exists() and (not CDOptionEnabled("大地之刺") or Target:Debuff(EarthenSpike))) or
            Boulderfist:Exists()) and
            Player:DistanceTo(Target) <= 5 and
            Target:CanCast(DoomWinds)
            then
                return Target:Cast(DoomWinds)
            end
            if
            Ascendance:Exists() and CDOptionEnabled("升腾") and
            (Windstrike:Cooldown() > 0 and Stormstrike:Cooldown() > 0) and
            not Player:Buff(Ascendance) and
            Player:DistanceTo(Target) <= 10 and
            Player:CanCast(Ascendance)
            then
                return Player:Cast(Ascendance)
            end
            if
            EarthenSpike:Exists() and CDOptionEnabled("大地之刺") and
            Target:Health() >= GetSecondOptionValue("大地之刺") * 1000000 and
            furyCheck25 and
            Target:CanCast(EarthenSpike)
            then
                return Target:Cast(EarthenSpike)
            end
            if
            CrashLightning:Exists() and UseAOE() and IsOptionEnabled("毁灭闪电") and not Player:Buff(CrashLightningBuff) and
            #CrashEnemies >= 2 and
            Player:CanCast(CrashLightning)
            then
                Bug("Crashing Storm 2+ Enemies for Crash Lightning buff")
                ShouldEmpowerFeralSpirit = false
                CrashLightning.LastCastTime = GetTime()
                return Player:Cast(CrashLightning)
            end
            if Windsong:Exists() and Target:CanCast(Windsong) then
                return Target:Cast(Windsong)
            end
            if
            CrashLightning:Exists() and UseAOE() and IsOptionEnabled("毁灭闪电") and
            (#CrashEnemies >= 8 or (#CrashEnemies >= 6 and CrashingStorm:Exists())) and
            Player:CanCast(CrashLightning)
            then
                Bug("Crash Lightning 8+ Targets (6+ with Crashing Storm)")
                ShouldEmpowerFeralSpirit = false
                CrashLightning.LastCastTime = GetTime()
                return Player:Cast(CrashLightning)
            end
            if Stormstrike:Exists() and Player:Buff(Ascendance) and Target:CanCast(Windstrike) then
                return self:StormstrikeHandler()
            end
            if Stormstrike:Exists() and Player:Buff(Stormbringer) and furyCheck25 and Target:CanCast(Stormstrike) then
                return self:StormstrikeHandler()
            end
            if
            CrashLightning:Exists() and UseAOE() and IsOptionEnabled("毁灭闪电") and
            (#CrashEnemies >= 4 or (#CrashEnemies >= 2 and CrashingStorm:Exists())) and
            Player:CanCast(CrashLightning)
            then
                Bug("Crash Lightning 4+ Targets (2+ with Crashing Storm)")
                ShouldEmpowerFeralSpirit = false
                CrashLightning.LastCastTime = GetTime()
                return Player:Cast(CrashLightning)
            end
            if
            LightningBolt:Exists() and Overcharge:Exists() and furyCheck45 and Player:Maelstrom() >= 40 and
            Target:CanCast(LightningBolt)
            then
                return Target:Cast(LightningBolt)
            end
            if
            Stormstrike:Exists() and
            ((not Overcharge:Exists() and furyCheck45) or (Overcharge:Exists() and furyCheck80)) and
            Target:CanCast(Stormstrike)
            then
                return self:StormstrikeHandler()
            end
            if Frostbrand:Exists() and akainuAS and Target:CanCast(Frostbrand) then
                return Target:Cast(Frostbrand)
            end
            if
            LavaLash:Exists() and
            (Player:Buff(HotHand) and ((akainuEquipped and Player:Buff(FrostbrandBuff)) or not akainuEquipped)) and
            Target:CanCast(LavaLash)
            then
                return Target:Cast(LavaLash)
            end
            if
            Sundering:Exists() and UseAOE() and CDOptionEnabled("裂地术") and SunderingEnemies >= 3 and
            Player:CanCast(Sundering)
            then
                return Player:Cast(Sundering)
            end
            if
            CrashLightning:Exists() and IsOptionEnabled("毁灭闪电") and #CrashEnemies >= 1 and
            (#CrashEnemies >= 3 or LightningCrashNotUp or alphaWolfCheck) and
            Player:CanCast(CrashLightning)
            then
                Bug("Crash Lightning 3+ Enemies (T20 Buff missing or Wolf Buffs)")
                ShouldEmpowerFeralSpirit = false
                CrashLightning.LastCastTime = GetTime()
                return Player:Cast(CrashLightning)
            end
            self:Rainfall()
            if Rockbiter:Exists() and Player:Maelstrom() < 120 and Target:CanCast(Rockbiter) then
                return Target:Cast(Rockbiter)
            end
            if Flametongue:Exists() and Player:BuffRemains(FlametongueBuff) < 4.8 and Target:CanCast(Flametongue) then
                return Target:Cast(Flametongue)
            end
            if
            CrashLightning:Exists() and IsOptionEnabled("毁灭闪电") and #CrashEnemies >= 1 and
            (CrashingStorm:Exists() or NumEnemies >= 2) and
            Target:Debuff(EarthenSpike) and
            Player:Maelstrom() >= 40 and
            OCPool60 and
            Player:CanCast(CrashLightning)
            then
                Bug("Crash Lightning 2+ Enemies (1+ Crashing Storm) with Earthen Spike debuff")
                ShouldEmpowerFeralSpirit = false
                CrashLightning.LastCastTime = GetTime()
                return Player:Cast(CrashLightning)
            end
            if
            Frostbrand:Exists() and Hailstorm:Exists() and Player:BuffRemains(FrostbrandBuff) < 4.8 and
            Player:Maelstrom() > 40 and
            Target:CanCast(Frostbrand)
            then
                return Target:Cast(Frostbrand)
            end
            if
            Frostbrand:Exists() and akainuEquipped and not Player:Buff(FrostbrandBuff) and Player:Maelstrom() >= 75 and
            Target:CanCast(Frostbrand)
            then
                return Target:Cast(Frostbrand)
            end
            if Sundering:Exists() and IsOptionEnabled("裂地术") and SunderingEnemies > 0 and Player:CanCast(Sundering) then
                return Player:Cast(Sundering)
            end
            if LavaLash:Exists() and Player:Maelstrom() >= 50 and OCPool70 and furyCheck80 and Target:CanCast(LavaLash) then
                return Target:Cast(LavaLash)
            end
            if Rockbiter:Exists() and Target:CanCast(Rockbiter) then
                return Target:Cast(Rockbiter)
            end
            if
            CrashLightning:Exists() and IsOptionEnabled("毁灭闪电") and #CrashEnemies >= 1 and
            (Player:Maelstrom() >= 65 or CrashingStorm:Exists() or #CrashEnemies >= 2) and
            OCPool60 and
            furyCheck45 and
            Player:CanCast(CrashLightning)
            then
                Bug("Filler - Crash Lightning 2+ Enemies (1+ Crashing Storm or 65+ Maelstrom)")
                ShouldEmpowerFeralSpirit = false
                CrashLightning.LastCastTime = GetTime()
                return Player:Cast(CrashLightning)
            end
            if Flametongue:Exists() and Target:CanCast(Flametongue) then
                return Target:Cast(Flametongue)
            end
            if
            LightningBolt:Exists() and IsOptionEnabled("超出攻击距离时施放闪电箭") and not Player:Buff(Ascendance) and
            Player:IsInCombat() and
            Player:DistanceTo(Target) > 10 and
            Target:CanCast(LightningBolt)
            then
                Bug("Lightning Bolt - Out of range filler")
                Target:Cast(LightningBolt)
                return
            end
        end
    end
end
function Rotation:OutOfCombat()
    if
    HealingSurge:Exists() and IsOptionEnabled("治疗之涌") and Player:CanCast(HealingSurge, true) and
    Player:HealthPercentage() <= GetSecondOptionValue("治疗之涌")
    then
        if Player:Maelstrom() > 20 then
            Player:Cast(HealingSurge)
            return
        elseif not Player:IsMoving() then
            Player:Cast(HealingSurge)
            return
        end
    end
    if
    LightningShield:Exists() and IsOptionEnabled("闪电之盾") and Player:BuffRemains(LightningShield) < 900 and
    Player:CanCast(LightningShield)
    then
        Player:Cast(LightningShield)
        return
    end
    if
    GhostWolf:Exists() and IsOptionEnabled("脱离战斗后施放幽魂之狼") and Player:Moving() > GetOptionValue("幽魂之狼") and
    not Player:Buff(GhostWolf) and
    Player:CanCast(GhostWolf) and
    (not Target:Exists() or Player:DistanceTo(Target) > 14)
    then
        Player:Cast(GhostWolf)
        return
    end
    if
    FeralLunge:Exists() and GetSecondOptionValue("狂野扑击") == "启用" and Player:DistanceTo(Target) >= 9 and
    Player:DistanceTo(Target) <= 24 and
    Target:CanCast(FeralLunge)
    then
        Target:Cast(FeralLunge)
        return
    end
    if IsOptionEnabled("自动进入战斗") and Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        if Target:CanCast(Rockbiter) then
            Target:Cast(Rockbiter)
            return
        end
    end
end
SetRotation(264, {})
local Rotation = Rotations[264]
function Rotation:Initialize()
    Trinket1 = Item(13, false, false, true)
    Trinket2 = Item(14, false, false, true)
    Berserking = Spell(26297, false, false, true)
    BloodFury = Spell(33697, false, false, true)
    GiftOfTheNaaru = Spell(59547, false, false, true)
    AncestralGuidance = Spell(108281, false, false, true)
    AncestralProtectionTotem = Spell(207399, false, false, true)
    AncestralSpirit = Spell(2008, false, false, false)
    AncestralVision = Spell(212048, false, false, false)
    Ascendance = Spell(114052, false, false, true)
    AstralShift = Spell(108271, false, false, true)
    ChainHeal = Spell(1064, false, false, false)
    ChainLightning = Spell(421, true, true, false)
    CloudBurstTotem = Spell(157153, false, false, true)
    CloudBurstTotemBuff = Spell(157504)
    CloudBurstTotemRelease = Spell(201764, false, false, true)
    EchoOfTheElements = Spell(108283)
    EarthenShieldTotem = Spell(198838, false, false, true)
    FlameShock = Spell(188838, true, true, true)
    GhostWolf = Spell(2645, false, false, true)
    GiftOfTheQueen = Spell(207778, false, false, false)
    HealingRain = Spell(73920, false, false, false)
    HealingStreamTotem = Spell(5394, false, false, true)
    HealingSurge = Spell(8004, false, false, false)
    HealingTideTotem = Spell(108280, false, false, true)
    HealingWave = Spell(77472, false, false, false)
    LavaBurst = Spell(51505, true, true, false)
    LightningBolt = Spell(403, true, true, false)
    Purge = Spell(370, true, true, true)
    PurifySpirit = Spell(77130, false, false, true)
    Riptide = Spell(61295, false, false, true)
    SpiritLinkTotem = Spell(98008, false, false, true)
    SpiritwalkersGrace = Spell(79206, false, false, true)
    TidalWave = Spell(53390)
    UnleashLife = Spell(73685, false, false, true)
    Wellspring = Spell(197995, false, false, false)
    WindShear = Spell(57994, true, true, true)
    AddPage("常规")
    AddPage("治愈")
    AddPage("大技能")
    AddPage("攻/防")
    AddCommonOptions()
    AddPresetOption("GeneralHealer")
    AddSection("常规", "移动", "Yellow")
    AddNewOption(
    "常规",
    "幽魂之狼",
    232,
    true,
    { 3, "无条件使用", "在战斗中", "脱离战斗后" },
    { 2.5, 0, 10, 0.1 },
    "Use Ghost Wolf on player." ..
    C.TOOLTIP_VALUE_1 ..
    "When should we use Ghost Wolf." ..
    C.TOOLTIP_VALUE_2 .. "Select desired time to wait when you start moving to use it.(seconds)"
    )
    AddNewOption(
    "常规",
    "灵魂行者的恩赐",
    220,
    true,
    { 0.7, 0, 10, 0.1 },
    nil,
    "Use Spiritwalkers Grace when moving for more than specified duration." ..
    C.TOOLTIP_VALUE .. "Select desired time to wait when you start moving to use it.(seconds)"
    )
    AddSection("治愈", "通用治疗参数", "Yellow")
    AddNewOption(
    "治愈",
    "治疗链",
    222,
    true,
    { 3, 1, 5, 1 },
    { 70, 0, 100, 1 },
    "Use when selected number of units are under health threshold." ..
    C.TOOLTIP_VALUE_1 .. "Number of Units." .. C.TOOLTIP_VALUE_2 .. "Health threshold."
    )
    AddNewOption(
    "治愈",
    "女王的恩赐",
    222,
    true,
    { 1, 1, 5, 1 },
    { 95, 0, 100, 1 },
    "Use when selected number of units are under health threshold." ..
    C.TOOLTIP_VALUE_1 .. "Number of Units." .. C.TOOLTIP_VALUE_2 .. "Health threshold."
    )
    AddNewOption(
    "治愈",
    "治疗之雨",
    222,
    true,
    { 3, 1, 5, 1 },
    { 70, 0, 100, 1 },
    "Use when selected number of units are under health threshold." ..
    C.TOOLTIP_VALUE_1 .. "Number of Units." .. C.TOOLTIP_VALUE_2 .. "Health threshold."
    )
    AddNewOption(
    "治愈",
    "治疗之涌",
    220,
    true,
    { 70, 0, 100, 1 },
    nil,
    "Use Healing Surge." .. C.TOOLTIP_VALUE .. "Threshold to use on any unit."
    )
    AddNewOption(
    "治愈",
    "治疗波",
    220,
    true,
    { 90, 0, 100, 1 },
    nil,
    "Use Healing Wave." .. C.TOOLTIP_VALUE .. "Threshold to use on any unit."
    )
    AddNewOption(
    "治愈",
    "激流",
    222,
    true,
    { 95, 0, 100, 1 },
    { 92, 0, 100, 1 },
    "Use Riptide." ..
    C.TOOLTIP_VALUE_1 ..
    "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid."
    )
    AddNewOption(
    "治愈",
    "生命释放",
    222,
    true,
    { 70, 0, 100, 1 },
    { 35, 0, 100, 1 },
    "Use Riptide." ..
    C.TOOLTIP_VALUE_1 ..
    "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid."
    )
    AddNewOption(
    "治愈",
    "奔涌之流",
    222,
    true,
    { 3, 1, 5, 1 },
    { 80, 0, 100, 1 },
    "Use when selected number of units are under health threshold." ..
    C.TOOLTIP_VALUE_1 .. "Number of Units." .. C.TOOLTIP_VALUE_2 .. "Health threshold."
    )
    AddNewOption(
    "治愈",
    "紧急治疗",
    222,
    true,
    { 45, 1, 75, 1 },
    { 45, 1, 75, 1 },
    "Heal the tanks or the player as very high priority when their health is critical." ..
    C.TOOLTIP_VALUE_1 .. "Tanks health threshold." .. C.TOOLTIP_VALUE_2 .. "Player health threshold."
    )
    AddSection("治愈", "主动治疗", "Yellow")
    AddNewOption(
    "治愈",
    "治疗目标",
    230,
    true,
    { 1, "已知单位", "任何单位" },
    nil,
    "Heal our current target if it is listed to be healed." ..
    C.TOOLTIP_VALUE ..
    "Choose preferred mode." ..
    C.TOOLTIP_SUBVALUE("已知单位") ..
    "Allow Heal Target to be used only when we are targetting a unit listed for it." ..
    C.TOOLTIP_SUBVALUE("任何单位") .. "Allow Heal Target to be used on any unit."
    )
    AddNewOption(
    "治愈",
    "团队成员Debuffs",
    220,
    true,
    { 40, 0, 100, 1 },
    nil,
    "Use Renew on Debuffed units." .. C.TOOLTIP_VALUE .. "Helath threshold."
    )
    AddNewOption(
    "治愈",
    "坦克Debuffs",
    220,
    true,
    { 50, 0, 100, 1 },
    nil,
    "Use Renew on Debuffed tanks." .. C.TOOLTIP_VALUE .. "Helath threshold."
    )
    AddNewOption(
    "治愈",
    "Topping",
    220,
    true,
    { 100, 0, 100, 1 },
    nil,
    "Use Renew/Flash Heal on units to be topped." .. C.TOOLTIP_VALUE .. "Helath threshold."
    )
    AddSection("大技能", "大技能", "Yellow")
    AddNewOption(
    "大技能",
    "先祖护佑图腾",
    220,
    true,
    { 15, 0, 100, 1 },
    nil,
    "Use on a dieing Tank." ..
    C.TOOLTIP_VALUE ..
    "Tank Health threshold." ..
    C.TOOLTIP_HINT(
    "The spell will normally always be used on as many units as possible around the Tank."
    )
    )
    AddNewOption(
    "大技能",
    "先祖指引",
    222,
    true,
    { 3, 1, 25, 1 },
    { 60, 0, 100, 1 },
    "Use when selected number of units are under health threshold." ..
    C.TOOLTIP_VALUE_1 .. "Number of Units." .. C.TOOLTIP_VALUE_2 .. "Health threshold."
    )
    AddNewOption(
    "大技能",
    "升腾",
    222,
    true,
    { 3, 1, 25, 1 },
    { 60, 0, 100, 1 },
    "Use when selected number of units are under health threshold." ..
    C.TOOLTIP_VALUE_1 .. "Number of Units." .. C.TOOLTIP_VALUE_2 .. "Health threshold."
    )
    AddNewOption(
    "大技能",
    "暴雨图腾 充能",
    120,
    true,
    { 10, 0, 1000, 1 },
    nil,
    "Minimum Health that needs to be stored before we release Cloud Burst Totem." ..
    C.TOOLTIP_VALUE .. "Healing Stored Value (In thousand)."
    )
    AddNewOption(
    "大技能",
    "召回暴雨图腾",
    222,
    true,
    { 3, 1, 25, 1 },
    { 70, 0, 100, 1 },
    "Use when selected number of units are under health threshold." ..
    C.TOOLTIP_VALUE_1 ..
    "Number of Units." ..
    C.TOOLTIP_VALUE_2 ..
    "Health threshold." ..
    C.TOOLTIP_HINT(
    "Requires having at least as much health stored as the Cloud Burst Charge value."
    )
    )
    AddNewOption(
    "大技能",
    "暴雨图腾",
    222,
    true,
    { 2, 1, 25, 1 },
    { 90, 0, 100, 1 },
    "Use when selected number of units are under health threshold." ..
    C.TOOLTIP_VALUE_1 .. "Number of Units." .. C.TOOLTIP_VALUE_2 .. "Health threshold."
    )
    AddNewOption(
    "大技能",
    "大地之盾图腾",
    220,
    true,
    { 15, 0, 100, 1 },
    nil,
    "Use on a dieing Tank." ..
    C.TOOLTIP_VALUE ..
    "Tank Health threshold." ..
    C.TOOLTIP_HINT(
    "The spell will normally always be used on as many units as possible around the Tank."
    )
    )
    AddNewOption(
    "大技能",
    "治疗之泉图腾",
    222,
    true,
    { 2, 1, 25, 1 },
    { 90, 0, 100, 1 },
    "Use when selected number of units are under health threshold." ..
    C.TOOLTIP_VALUE_1 .. "Number of Units." .. C.TOOLTIP_VALUE_2 .. "Health threshold."
    )
    AddNewOption(
    "大技能",
    "治疗之潮图腾",
    222,
    true,
    { 3, 1, 25, 1 },
    { 70, 0, 100, 1 },
    "Use when selected number of units are under health threshold." ..
    C.TOOLTIP_VALUE_1 .. "Number of Units." .. C.TOOLTIP_VALUE_2 .. "Health threshold."
    )
    AddNewOption(
    "大技能",
    "灵魂链接图腾 急救",
    222,
    true,
    { 3, 1, 25, 1 },
    { 25, 0, 100, 1 },
    "Use when selected number of units are around a dieing Tank." ..
    C.TOOLTIP_VALUE_1 .. "Number of Units." .. C.TOOLTIP_VALUE_2 .. "Tank Health threshold."
    )
    AddNewOption(
    "大技能",
    "灵魂链接图腾 队员",
    222,
    true,
    { 3, 1, 25, 1 },
    { 50, 0, 100, 1 },
    "Use when selected number of units are under health threshold." ..
    C.TOOLTIP_VALUE_1 .. "Number of Units." .. C.TOOLTIP_VALUE_2 .. "Health threshold."
    )
    AddSection("攻/防", "伤害输出", "Yellow")
    AddNewOption(
    "攻/防",
    "DPS",
    220,
    true,
    { 95, 0, 100, 1 },
    nil,
    "Enables DPS options." .. C.TOOLTIP_VALUE .. "Will only DPS if the Lowest unit is above DPS health treshold."
    )
    AddNewOption(
    "攻/防",
    "闪电链",
    220,
    true,
    { 3, 1, 10, 1 },
    nil,
    "Use Chain Lightning in the DPS rotation." ..
    C.TOOLTIP_VALUE ..
    "Amount of units required to be in 12 yards of Player to use." ..
    C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold")
    )
    AddNewOption(
    "攻/防",
    "烈焰震击",
    210,
    true,
    nil,
    nil,
    "Use Flame Shock in the DPS rotation." ..
    C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold")
    )
    AddNewOption(
    "攻/防",
    "熔岩爆裂",
    210,
    true,
    nil,
    nil,
    "Use Lava Burst in the DPS rotation." ..
    C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold")
    )
    AddNewOption(
    "攻/防",
    "闪电箭",
    210,
    true,
    nil,
    nil,
    "Use Lightning Bolt in the DPS rotation." ..
    C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold")
    )
    AddSection("攻/防", "防御", "Yellow")
    AddNewOption(
    "攻/防",
    "星界转移",
    220,
    true,
    { 30, 1, 100, 1 },
    nil,
    "Use Astral Shift." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    if GiftOfTheNaaru:Exists() then
        AddNewOption(
        "攻/防",
        "纳鲁的赐福",
        222,
        true,
        { 65, 0, 100, 1 },
        { 55, 0, 100, 1 },
        "Use Gift Of The Naaru." ..
        C.TOOLTIP_VALUE_1 ..
        "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid."
        )
    end
    AddNewOption(
    "攻/防",
    "治疗物品",
    220,
    true,
    { 35, 1, 95, 1 },
    nil,
    "Use Healing Belt / Healing Pot / Healthstone." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddOutput("|cFF9A2EFE主T:")
    AddOutput("|cFF9A2EFE副T:")
    AddOutput("|cFF9A2EFE最低:")
    AddOutput("|cFF9A2EFE有害效果:")
    SetOutput("|cFF9A2EFE有害效果:", 0)
    AddOutput("|cFF00BFFF暴雨图腾 充能:")
    SetOutput("|cFF00BFFF暴雨图腾 充能:", 0)
    ISCL = {
        [GiftOfTheQueen:ID()] = "女王的恩赐",
        [HealingSurge:ID()] = "治疗之涌",
        [HealingWave:ID()] = "治疗波",
        [ChainHeal:ID()] = "治疗链"
    }
end
function Rotation:Events()
end
function Rotation:Pulse()
    if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
        return
    end
    if BMPullTime() < 5 then
        self:Opening()
        return
    end
    if GetTime() < Rotation.SpamPrevention then
        return
    end
    Rotation.SpamPrevention = GetTime() + 0.05
    SetOutput("|cFF00BFFF暴雨图腾 充能:", self:CloudBurstTotemCharge())
    Target = Unit.Target
    local InCombat = Player:IsInCombat()
    Rotations:RefreshUnitTables(Rotation.Identifier)
    if not InCombat then
        SetOutput("|cFF9A2EFE有害效果:", 0)
        self:OutOfCombat()
        return
    end
    if InCombat then
        self:Defensives()
    end
    Target = Player:ReTarget(LightningBolt, false) or Unit.Target
    self:Interrupts()
    self:OffGCDAbilities()
    if Player:GlobalCooldown() == 0 then
        self:Combat()
    end
end
function Rotation:Opening()
    Player:UsePotions("智力药水", GetSecondOptionValue("抢先使用药水"))
    if
    Target:Exists() and IsOptionEnabled("抢先施放(需DBM插件)") and
    (GetOptionValue("抢先施放(需DBM插件)") == "无条件使用" or
    (GetOptionValue("抢先施放(需DBM插件)") == "打BOSS使用" and Target:IsBoss()))
    then
        if
        LightningBolt:Exists() and BMPullTime() < GetSecondOptionValue("抢先施放(需DBM插件)") and
        Target:CanCast(LightningBolt)
        then
            Target:Cast(LightningBolt)
            return
        end
    end
end
function Rotation:Interrupts()
    Player:UseInterrupt(WindShear)
end
Rotation.RefreshCloudBurstRelease, Rotation.CloudBurstReleaseCount = 0, 0
function Rotation:OffGCDAbilities()
    if IsOptionEnabled("延时之力药水") and ProlongedPowerUnitsCount >= GetOptionValue("延时之力药水") then
        Player:UsePotions("延时之力药水")
    end
    Player:UsePotions(GetOptionValue("使用法力药水"))
    if self.RefreshCloudBurstRelease < GetTime() and self:CloudBurstTotemCharge() >= GetOptionValue("暴雨图腾 充能") * 1000 then
        self.CloudBurstReleaseCount =         Player:Buff(CloudBurstTotemBuff) and IsOptionEnabled("召回暴雨图腾") and
        #Player:HealUnitsAround(GetSecondOptionValue("召回暴雨图腾"), 40) or
        0
        self.RefreshCloudBurstRelease = GetTime() + 0.25
    end
    if
    CloudBurstTotem:Exists() and Player:Buff(CloudBurstTotemBuff) and
    self:CloudBurstTotemCharge() > GetOptionValue("暴雨图腾 充能") * 1000 and
    self.CloudBurstReleaseCount >= GetOptionValue("召回暴雨图腾") and
    Player:CanCast(CloudBurstTotemRelease)
    then
        Bug("Cloud Burst Totem Released")
        Player:Cast(CloudBurstTotemRelease)
        return
    end
end
function Rotation:Defensives()
    Player:UseHealingItem()
    if
    AstralShift:Exists() and IsOptionEnabled("星界转移") and Player:HealthPercentage() <= GetOptionValue("星界转移") and
    Player:CanCast(AstralShift)
    then
        Player:Cast(AstralShift)
        return
    end
    if GiftOfTheNaaru:Exists() and IsOptionEnabled("纳鲁的赐福") then
        if
        MainTank and MainTank:SpecialHealthPercentage() <= GetOptionValue("纳鲁的赐福") and
        MainTank:CanCast(GiftOfTheNaaru)
        then
            MainTank:Cast(GiftOfTheNaaru)
            return
        elseif
        MainTank and OffTank and OffTank:SpecialHealthPercentage() <= GetOptionValue("纳鲁的赐福") and
        OffTank:CanCast(GiftOfTheNaaru)
        then
            OffTank:Cast(GiftOfTheNaaru)
            return
        elseif
        Lowest and Lowest:SpecialHealthPercentage() <= GetSecondOptionValue("纳鲁的赐福") and
        Lowest:CanCast(GiftOfTheNaaru)
        then
            Lowest:Cast(GiftOfTheNaaru)
            return
        end
    end
end
Rotation.TanksStatus, Rotation.MainTankTanking, Rotation.OffTankTanking = {
    Main = { IsTanking = GetTime() },
    Off = { IsTanking = GetTime() }
}
function Rotation:RefreshTanksStatus()
    self.TanksStatus = {
        Main = {
            IsTanking = MainTank and MainTank:ThreatSituation() == 3 and GetTime() or self.TanksStatus.Main.IsTanking
        },
        Off = { IsTanking = OffTank and OffTank:ThreatSituation() == 3 and GetTime() or self.TanksStatus.Off.IsTanking }
    }
    self.MainTankTanking = GetTime() - self.TanksStatus.Main.IsTanking < 3 or false
    self.OffTankTanking = GetTime() - self.TanksStatus.Off.IsTanking < 3 or false
end
function Rotation:HealTarget(ThisUnit)
    if ThisUnit:CanCast(Riptide) and ThisUnit:BuffRemains(Riptide) < 2 then
        ThisUnit:Cast(Riptide)
        return
    end
    if not Player:IsMoving() and ThisUnit:CanCast(HealingSurge) then
        if ThisUnit:CanCast(HealingSurge) and ThisUnit:SpecialHealthPercentage() < 100 then
            ThisUnit:Cast(HealingSurge)
            return
        end
        if ThisUnit:CanCast(HealingWave) then
            ThisUnit:Cast(HealingWave)
            return
        end
    end
end
function Rotation:CloudBurstTotemCharge()
    self.ChargeValue = select(17, UnitAura("player", GetSpellInfo(157504)))
    return self.ChargeValue and self.ChargeValue * 1 or 0
end
function Rotation:SpiritwalkersGraceHandler()
    if
    SpiritwalkersGrace:Exists() and IsOptionEnabled("灵魂行者的恩赐") and Player:Moving() > GetOptionValue("灵魂行者的恩赐") and
    not IsFalling() and
    not Player:Buff(SpiritwalkersGrace) and
    Player:CanCast(SpiritwalkersGrace)
    then
        Player:Cast(SpiritwalkersGrace)
        return
    end
    return true
end
function Rotation:UnitTables()
    HealUnits = Player:HealUnitsAround(101, 40)
    CurrentBadDebuffs = Player:GetRaidDebuffs(HealUnits)
    if CurrentBadDebuffs ~= nil then
        SetOutput("|cFF9A2EFE有害效果:", #CurrentBadDebuffs.Tanks + #CurrentBadDebuffs.Top + #CurrentBadDebuffs.Debuff)
    end
    DispelUnit = Unit.Dispel(HealUnits, PurifySpirit)
    MainTank, MainTankTarget, OffTank, OffTankTarget = Unit.GetMainTanks()
    Lowest = Unit.Lowest(HealUnits)
    SetOutput("|cFF9A2EFE最低:", Lowest and Lowest:Name() or "")
    RacialsUnits =     IsOptionEnabled("使用种族技能") and
    ((Berserking:Exists() and Player:CanCast(Berserking)) or (BloodFury:Exists() and Player:CanCast(BloodFury))) and
    #Player:HealUnitsAround(GetOptionValue("使用种族技能"), 40) or
    0
    Trinket1Units =     IsOptionEnabled("使用饰品 1") and Trinket1:IsUsableInventory() and
    #Player:HealUnitsAround(GetSecondOptionValue("使用饰品 1"), 40) or
    0
    Trinket2Units =     IsOptionEnabled("使用饰品 2") and Trinket2:IsUsableInventory() and
    #Player:HealUnitsAround(GetSecondOptionValue("使用饰品 2"), 40) or
    0
    ProlongedPowerUnitsCount =     IsOptionEnabled("延时之力药水") and #Player:HealUnitsAround(GetSecondOptionValue("延时之力药水"), 40) or 0
    TargetEnemies_10y = UseAOE() and BestTarget and BestTarget:Exists() and BestTarget:EnemiesWithinDistance(10) or {}
    AscendanceCount = Ascendance:Exists() and #Player:HealUnitsAround(GetSecondOptionValue("升腾"), 40) or 0
    AncestralGuidanceCount =     AncestralGuidance:Exists() and #Player:HealUnitsAround(GetSecondOptionValue("先祖指引"), 40) or 0
    ChainHealUnit =     ChainHeal:Exists() and IsOptionEnabled("治疗链") and
    Player:BestClusterOfAlliesToHeal(GetOptionValue("治疗链"), GetSecondOptionValue("治疗链"), 20) or
    nil
    CloudBurstTotemCount =     CloudBurstTotem:Exists() and IsOptionEnabled("暴雨图腾") and
    #Player:HealUnitsAround(GetSecondOptionValue("暴雨图腾"), 40) or
    0
    HealingStreamTotemCount =     HealingStreamTotem:Exists() and IsOptionEnabled("治疗之泉图腾") and
    #Player:HealUnitsAround(GetSecondOptionValue("治疗之泉图腾"), 40) or
    0
    HealingTideTotemCount =     HealingTideTotem:Exists() and IsOptionEnabled("治疗之潮图腾") and
    #Player:HealUnitsAround(GetSecondOptionValue("治疗之潮图腾"), 40) or
    0
    WellspringCount = Wellspring:Exists() and #Player:UnitsInFrontCone(30, 160, true, GetSecondOptionValue("奔涌之流")) or 0
    GiftOfTheQueenUnit =     GiftOfTheQueen:Exists() and IsOptionEnabled("女王的恩赐") and not GiftOfTheQueen:IsOnCooldown() and
    Player:BestClusterOfAlliesToHeal(GetOptionValue("女王的恩赐"), GetSecondOptionValue("女王的恩赐"), 12) or
    nil
    HealingRainUnit =     HealingRain:Exists() and IsOptionEnabled("治疗之雨") and not HealingRain:IsOnCooldown() and
    Player:BestClusterOfAlliesToHeal(GetOptionValue("治疗之雨"), GetSecondOptionValue("治疗之雨"), 10) or
    nil
    SpiritLinkTotemUnit =     SpiritLinkTotem:Exists() and IsOptionEnabled("灵魂链接图腾 队员") and not SpiritLinkTotem:IsOnCooldown() and
    Player:BestClusterOfAlliesToHeal(GetOptionValue("灵魂链接图腾 队员"), GetSecondOptionValue("灵魂链接图腾 队员"), 10) or
    nil
end
function Rotation:Combat()
    if Target:Exists() and Target:CanCast(LightningBolt) then
        BestTarget = Target
    elseif MainTankTarget and MainTankTarget:CanCast(LightningBolt) then
        BestTarget = MainTankTarget
    elseif OffTankTarget and OffTankTarget:CanCast(LightningBolt) then
        BestTarget = OffTankTarget
    elseif Mouseover:Exists() and Mouseover:CanCast(LightningBolt) then
        BestTarget = Mouseover
    else
        BestTarget = Target
    end
    if Player:IsInCombat() or GetOptionValue("脱离战斗后暂停治疗") == "启用" then
        if CurrentBadDebuffs ~= nil then
            Player:DispelHandler(PurifySpirit, "驱散", DispelUnit, CurrentBadDebuffs.Dispel, "高")
        end
        if
        Target:CanCast(HealingWave) and IsOptionEnabled("治疗目标") and
        (GetOptionValue("治疗目标") == 2 or
        (Target:ShouldBeHealed() ~= 0 and Target:HealthPercentage() < Target:ShouldBeHealed()))
        then
            self:HealTarget(Target)
            return
        end
    end
    if Player:IsInCombat() or GetSecondOptionValue("脱离战斗后暂停治疗") == "启用" then
        if
        IsOptionEnabled("DPS") and BestTarget and (not Lowest or Lowest:HealthPercentage() >= GetOptionValue("DPS")) and
        (not MainTank or MainTank:HealthPercentage() >= GetOptionValue("DPS")) and
        (not OffTank or OffTank:HealthPercentage() >= GetOptionValue("DPS")) and
        BestTarget:IsInCombat()
        then
            if
            FlameShock:Exists() and IsOptionEnabled("烈焰震击") and BestTarget:DebuffRemains(FlameShock) < 3 and
            BestTarget:CanCast(FlameShock)
            then
                BestTarget:Cast(FlameShock)
                return
            end
            if
            LavaBurst:Exists() and IsOptionEnabled("熔岩爆裂") and
            (BestTarget:Debuff(FlameShock) or not IsOptionEnabled("烈焰震击")) and
            BestTarget:CanCast(LavaBurst)
            then
                BestTarget:Cast(LavaBurst)
                return
            end
            if
            ChainLightning:Exists() and IsOptionEnabled("闪电链") and #TargetEnemies_10y >= GetOptionValue("闪电链") and
            BestTarget:CanCast(ChainLightning)
            then
                BestTarget:Cast(ChainLightning)
                return
            end
            if LightningBolt:Exists() and IsOptionEnabled("闪电箭") and BestTarget:CanCast(LightningBolt) then
                BestTarget:Cast(LightningBolt)
                return
            end
            if (not Target:Exists() or Target:IsDead()) and GetOptionValue("目标 | 攻击") ~= "禁用" then
                local NewTargetUnit = Unit.AutoTarget(LightningBolt, GetOptionValue("目标 | 攻击"))
                if NewTargetUnit then
                    NewTargetUnit:Attack()
                    return
                end
            end
        end
    end
    if Player:IsInCombat() then
        if SpiritLinkTotem:Exists() and Player:CanCast(SpiritLinkTotem) then
            if
            MainTank and IsOptionEnabled("灵魂链接图腾 急救") and not MainTank:IsMoving() and
            MainTank:SpecialHealthPercentage() < GetSecondOptionValue("灵魂链接图腾 急救") and
            MainTank:CanCast(HealingWave)
            then
                local TheseHealUnits = MainTank:HealUnitsAround(100, 10)
                if #TheseHealUnits >= GetOptionValue("灵魂链接图腾 急救") then
                    Bug("Spirit Link Emergency on Main Tank.")
                    Player:CastGroundHeal(SpiritLinkTotem, TheseHealUnits)
                    return
                end
            end
            if
            OffTank and IsOptionEnabled("灵魂链接图腾 急救") and not OffTank:IsMoving() and
            OffTank:SpecialHealthPercentage() < GetSecondOptionValue("灵魂链接图腾 急救") and
            OffTank:CanCast(HealingWave)
            then
                local TheseHealUnits = OffTank:HealUnitsAround(100, 10)
                if #TheseHealUnits >= GetOptionValue("灵魂链接图腾 急救") then
                    Bug("Spirit Link Emergency on Off Tank.")
                    Player:CastGroundHeal(SpiritLinkTotem, TheseHealUnits)
                    return
                end
            end
            if SpiritLinkTotemUnit then
                Bug("灵魂链接图腾 队员")
                SpiritLinkTotemUnit:Cast(SpiritLinkTotem)
                return
            end
        end
        if AncestralProtectionTotem:Exists() and Player:CanCast(AncestralProtectionTotem) then
            if
            MainTank and IsOptionEnabled("先祖护佑图腾") and not MainTank:IsMoving() and
            MainTank:SpecialHealthPercentage() < GetOptionValue("先祖护佑图腾") and
            MainTank:CanCast(AncestralProtectionTotem)
            then
                local TheseHealUnits = MainTank:HealUnitsAround(100, 10)
                Bug("Ancestral Protection on Main Tank.")
                Player:CastGroundHeal(AncestralProtectionTotem, TheseHealUnits)
                return
            end
            if
            OffTank and IsOptionEnabled("先祖护佑图腾") and not OffTank:IsMoving() and
            OffTank:SpecialHealthPercentage() < GetOptionValue("先祖护佑图腾") and
            OffTank:CanCast(AncestralProtectionTotem)
            then
                local TheseHealUnits = OffTank:HealUnitsAround(100, 10)
                Bug("Ancestral Protection on Off Tank.")
                Player:CastGroundHeal(AncestralProtectionTotem, TheseHealUnits)
                return
            end
        end
        if EarthenShieldTotem:Exists() and Player:CanCast(EarthenShieldTotem) then
            if
            MainTank and IsOptionEnabled("大地之盾图腾") and not MainTank:IsMoving() and
            MainTank:SpecialHealthPercentage() < GetOptionValue("大地之盾图腾") and
            MainTank:CanCast(EarthenShieldTotem)
            then
                local TheseHealUnits = MainTank:HealUnitsAround(100, 10)
                Bug("Earthen Shield Totem on Main Tank.")
                Player:CastGroundHeal(EarthenShieldTotem, TheseHealUnits)
                return
            end
            if
            OffTank and IsOptionEnabled("大地之盾图腾") and not OffTank:IsMoving() and
            OffTank:SpecialHealthPercentage() < GetOptionValue("大地之盾图腾") and
            OffTank:CanCast(EarthenShieldTotem)
            then
                local TheseHealUnits = OffTank:HealUnitsAround(100, 10)
                Bug("Earthen Shield Totem on Off Tank.")
                Player:CastGroundHeal(EarthenShieldTotem, TheseHealUnits)
                return
            end
        end
        if
        HealingTideTotem:Exists() and IsOptionEnabled("治疗之潮图腾") and
        HealingTideTotemCount >= GetOptionValue("治疗之潮图腾") and
        Player:CanCast(HealingTideTotem)
        then
            Player:Cast(HealingTideTotem)
            return
        end
        if
        HealingStreamTotem:Exists() and IsOptionEnabled("治疗之泉图腾") and HealingStreamTotem:TimeSinceCast() >= 12 and
        HealingStreamTotemCount >= GetOptionValue("治疗之泉图腾") and
        Player:CanCast(HealingStreamTotem)
        then
            Player:Cast(HealingStreamTotem)
            HealingStreamTotem.LastCastTime = GetTime()
            return
        end
        if
        CloudBurstTotem:Exists() and IsOptionEnabled("暴雨图腾") and CloudBurstTotemCount >= GetOptionValue("暴雨图腾") and
        Player:CanCast(CloudBurstTotem)
        then
            Player:Cast(CloudBurstTotem)
            return
        end
        if IsOptionEnabled("使用种族技能") then
            if RacialsUnits >= GetOptionValue("使用种族技能和饰品的单位数量") then
                if BloodFury:Exists() and Player:CanCast(BloodFury) then
                    Player:Cast(BloodFury)
                    return
                end
                if Berserking:Exists() and Player:CanCast(Berserking) then
                    CastSpellByID(26297, "player")
                    return
                end
            end
        end
        if IsOptionEnabled("使用饰品 1") and Trinket1:IsUsableInventory() then
            local Option1, Option2 = GetOptionValue("使用饰品 1"), GetSecondOptionValue("使用饰品 1")
            if
            Option1 == "无条件使用" or (Option1 == "血量" and Trinket1Units >= GetOptionValue("使用种族技能和饰品的单位数量")) or
            (Option1 == "蓝量" and Player:PowerPercentage() < GetSecondOptionValue("使用饰品 1"))
            then
                Trinket1:UseInventory()
            end
        end
        if IsOptionEnabled("使用饰品 2") and Trinket2:IsUsableInventory() then
            local Option1, Option2 = GetOptionValue("使用饰品 2"), GetSecondOptionValue("使用饰品 2")
            if
            Option1 == "无条件使用" or (Option1 == "血量" and Trinket2Units >= GetOptionValue("使用种族技能和饰品的单位数量")) or
            (Option1 == "蓝量" and Player:PowerPercentage() < GetSecondOptionValue("使用饰品 2"))
            then
                Trinket2:UseInventory()
            end
        end
        if
        Ascendance:Exists() and IsOptionEnabled("升腾") and AscendanceCount >= GetOptionValue("升腾") and
        Player:CanCast(Ascendance)
        then
            Player:Cast(Ascendance)
            return
        end
        if
        AncestralGuidance:Exists() and IsOptionEnabled("先祖指引") and AncestralGuidanceCount >= GetOptionValue("先祖指引") and
        Player:CanCast(AncestralGuidance)
        then
            Player:Cast(AncestralGuidance)
            return
        end
    end
    if Player:IsInCombat() or GetOptionValue("脱离战斗后暂停治疗") == "启用" then
        if CurrentBadDebuffs ~= nil then
            Player:DispelHandler(PurifySpirit, "驱散", DispelUnit, CurrentBadDebuffs.Dispel, "正常")
        end
        if
        Wellspring:Exists() and IsOptionEnabled("奔涌之流") and WellspringCount >= GetOptionValue("奔涌之流") and
        self:SpiritwalkersGraceHandler() and
        Player:CanCast(Wellspring)
        then
            Player:Cast(Wellspring)
            return
        end
        if IsOptionEnabled("紧急治疗") then
            MainTankHealth = MainTank and MainTank:CanCast(HealingWave) and MainTank:SpecialHealthPercentage() or 100
            OffTankHealth = OffTank and OffTank:CanCast(HealingWave) and OffTank:SpecialHealthPercentage() or 100
            BestTankTarget = MainTankHealth < OffTankHealth and MainTank or OffTank
            if BestTankTarget and BestTankTarget:SpecialHealthPercentage() < GetOptionValue("紧急治疗") then
                if UnleashLife:Exists() and BestTankTarget:CanCast(UnleashLife) then
                    Bug("Unleash Life - Tanks Emergency")
                    BestTankTarget:Cast(UnleashLife)
                    return
                end
                if BestTankTarget:CanCast(Riptide) then
                    Bug("Riptide - Tanks Emergency")
                    BestTankTarget:Cast(Riptide)
                    return
                end
                if self:SpiritwalkersGraceHandler() and BestTankTarget:CanCast(HealingSurge) then
                    Bug("Healing Surge - Tanks Emergency")
                    BestTankTarget:Cast(HealingSurge)
                    return
                end
            end
            if Player:SpecialHealthPercentage() < GetSecondOptionValue("紧急治疗") then
                if UnleashLife:Exists() and Player:CanCast(UnleashLife) then
                    Bug("Unleash Life - Tanks Emergency")
                    Player:Cast(UnleashLife)
                    return
                end
                if Player:CanCast(Riptide) then
                    Bug("Riptide - Tanks Emergency")
                    Player:Cast(Riptide)
                    return
                end
                if self:SpiritwalkersGraceHandler() and Player:CanCast(HealingSurge) then
                    Bug("Healing Surge - Tanks Emergency")
                    Player:Cast(HealingSurge)
                    return
                end
            end
        end
        if UnleashLife:Exists() and IsOptionEnabled("生命释放") then
            if
            MainTank and MainTank:SpecialHealthPercentage() < GetOptionValue("生命释放") and
            MainTank:CanCast(UnleashLife)
            then
                MainTank:Cast(UnleashLife)
                return
            end
            if OffTank and OffTank:SpecialHealthPercentage() < GetOptionValue("生命释放") and OffTank:CanCast(UnleashLife) then
                OffTank:Cast(UnleashLife)
                return
            end
            if
            Lowest and Lowest:SpecialHealthPercentage() <= GetSecondOptionValue("生命释放") and
            Lowest:CanCast(UnleashLife)
            then
                Lowest:Cast(UnleashLife)
                return
            end
        end
        if Riptide:Exists() and IsOptionEnabled("激流") then
            if
            MainTank and MainTank:SpecialHealthPercentage() < GetOptionValue("激流") and
            MainTank:BuffRemains(Riptide) < 3 and
            MainTank:CanCast(Riptide)
            then
                MainTank:Cast(Riptide)
                return
            end
            if
            OffTank and OffTank:SpecialHealthPercentage() < GetOptionValue("激流") and
            OffTank:BuffRemains(Riptide) < 3 and
            OffTank:CanCast(Riptide)
            then
                OffTank:Cast(Riptide)
                return
            end
        end
        if
        Player:IsInCombat() and Riptide:Exists() and IsOptionEnabled("激流") and
        (not EchoOfTheElements:Exists() or Riptide:Charges() >= 2 or
        (Riptide:Charges() >= 1 and Riptide:Recharge() < 2)) and
        (Player:BuffRemains(TidalWave) < 3 or Player:BuffCount(TidalWave) < 2)
        then
            local BestUnit, BestUnitHealth = nil, 100
            for i = 1, #HealUnits do
                local ThisUnit, ThisUnitHealth = HealUnits[i], HealUnits[i]:SpecialHealthPercentage()
                if ThisUnitHealth <= BestUnitHealth and ThisUnit:CanCast(Riptide) and ThisUnit:BuffRemains(Riptide) < 3 then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth
                end
            end
            if BestUnit then
                BestUnit:Cast(Riptide)
                return
            end
        end
        if GiftOfTheQueenUnit and self:SpiritwalkersGraceHandler() and Player:CanCast(GiftOfTheQueen) then
            GiftOfTheQueenUnit:Cast(GiftOfTheQueen)
            return
        end
        if
        IsOptionEnabled("治疗链") and ChainHealUnit and self:SpiritwalkersGraceHandler() and
        ChainHealUnit:CanCast(ChainHeal)
        then
            ChainHealUnit:Cast(ChainHeal)
            return
        end
        if HealingSurge:Exists() and IsOptionEnabled("治疗之涌") then
            if
            Lowest and Lowest:SpecialHealthPercentage() < GetOptionValue("治疗之涌") and
            self:SpiritwalkersGraceHandler() and
            Lowest:CanCast(HealingSurge)
            then
                Lowest:Cast(HealingSurge)
                return
            end
        end
        if HealingRainUnit and self:SpiritwalkersGraceHandler() and Player:CanCast(HealingRain) then
            HealingRainUnit:Cast(HealingRain)
            return
        end
        if Riptide:Exists() and IsOptionEnabled("坦克Debuffs") and CurrentBadDebuffs and #CurrentBadDebuffs.Tanks > 0 then
            local BestUnit, BestUnitHealth = nil, 100
            for i = 1, #CurrentBadDebuffs.Tanks do
                local ThisUnit, ThisUnitHealth =                 CurrentBadDebuffs.Tanks[i],
                CurrentBadDebuffs.Tanks[i]:SpecialHealthPercentage()
                if
                ThisUnit:CanCast(Riptide) and not ThisUnit:Buff(Riptide) and
                (BestUnit == nil or ThisUnitHealth < BestUnitHealth)
                then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth
                end
            end
            if BestUnit ~= nil and BestUnitHealth < GetOptionValue("坦克Debuffs") then
                Bug("Riptide on " .. BestUnit:Name() .. " to heal tank debuff")
                BestUnit:Cast(Riptide)
                return
            end
        end
        if Riptide:Exists() and IsOptionEnabled("团队成员Debuffs") and CurrentBadDebuffs and #CurrentBadDebuffs.Debuff > 0 then
            local BestUnit, BestUnitHealth = nil, 100
            for i = 1, #CurrentBadDebuffs.Debuff do
                local ThisUnit, ThisUnitHealth =                 CurrentBadDebuffs.Debuff[i],
                CurrentBadDebuffs.Debuff[i]:SpecialHealthPercentage()
                if
                ThisUnit:CanCast(Riptide) and not ThisUnit:Buff(Riptide) and
                (BestUnit == nil or ThisUnitHealth < BestUnitHealth)
                then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth
                end
            end
            if BestUnit ~= nil and BestUnitHealth < GetOptionValue("团队成员Debuffs") then
                Bug("Riptide on " .. BestUnit:Name() .. " to mitigate debuff")
                BestUnit:Cast(Riptide)
                return
            end
        end
        if IsOptionEnabled("Topping") and CurrentBadDebuffs and #CurrentBadDebuffs.Top > 0 then
            local BestUnit, BestUnitHealth = nil, 100
            for i = 1, #CurrentBadDebuffs.Top do
                local ThisUnit, ThisUnitHealth =                 CurrentBadDebuffs.Top[i],
                CurrentBadDebuffs.Top[i]:SpecialHealthPercentage()
                if ThisUnit:CanCast(HealingSurge) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth
                end
            end
            if BestUnit ~= nil then
                if
                Riptide:Exists() and BestUnitHealth <= GetOptionValue("Topping") and BestUnit:CanCast(Riptide) and
                not BestUnit:Buff(Riptide)
                then
                    Bug("Riptide on " .. BestUnit:Name() .. " to top it")
                    BestUnit:Cast(Riptide)
                    return
                end
                if
                HealingSurge:Exists() and BestUnitHealth <= GetOptionValue("Topping") and
                self:SpiritwalkersGraceHandler() and
                BestUnit:CanCast(HealingSurge)
                then
                    Bug("Healing Surge on " .. BestUnit:Name() .. " to top it")
                    BestUnit:Cast(HealingSurge)
                    return
                end
            end
        end
        if HealingWave:Exists() and IsOptionEnabled("治疗波") then
            if Lowest and Lowest:SpecialHealthPercentage() <= GetOptionValue("治疗波") and Lowest:CanCast(HealingWave) then
                Lowest:Cast(HealingWave)
                return
            end
        end
    end
    if
    GhostWolf:Exists() and IsOptionEnabled("幽魂之狼") and
    (GetOptionValue("幽魂之狼") == "无条件使用" or (GetOptionValue("幽魂之狼") == "在战斗中" and Player:IsInCombat()) or
    (GetOptionValue("幽魂之狼") == "脱离战斗后" and not Player:IsInCombat())) and
    Player:Moving() > GetSecondOptionValue("幽魂之狼") and
    not IsFalling() and
    not Player:Buff(GhostWolf) and
    Player:CanCast(GhostWolf)
    then
        Player:Cast(GhostWolf)
        return
    end
end
function Rotation:OutOfCombat()
    if
    GhostWolf:Exists() and IsOptionEnabled("幽魂之狼") and
    (GetOptionValue("幽魂之狼") == "无条件使用" or GetOptionValue("幽魂之狼") == "脱离战斗后") and
    Player:Moving() > GetSecondOptionValue("幽魂之狼") and
    not IsFalling() and
    not Player:Buff(GhostWolf) and
    Player:CanCast(GhostWolf)
    then
        Player:Cast(GhostWolf)
        return
    end
    if IsOptionEnabled("自动进入战斗") and Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        local EngageSpell = LightningBolt
        if EngageSpell:Exists() and Target:CanCast(EngageSpell) then
            Target:Cast(EngageSpell)
            return
        end
    end
    if IsOptionEnabled("脱离战斗后暂停治疗") then
        self:Combat()
    end
end
SetRotation(265, {})
local Rotation = Rotations[265]
function Rotation:Initialize()
    Healthstone = Item(5512, false, false, true)
    ArcaneTorrent = Spell(28730, false, false, true)
    Berserking = Spell(26297, false, false, true)
    BloodFury = Spell(33702, false, false, true)
    AbsoluteCorruption = Spell(196103)
    Agony = Spell(980, false, true, true)
    BurningRush = Spell(111400)
    CompoundingHorror = Spell(199281)
    ConcordanceOfTheLegionfall = Spell(242586)
    Contagion = Spell(196105)
    Corruption = Spell(172, false, true, true)
    CorruptionDebuff = Spell(146739)
    CreateHealthstone = Spell(6201, false, false, false)
    DarkPact = Spell(108416, false, false, true)
    DeadwindHarvester = Spell(216708)
    DrainLife = Spell(689, true, true, false)
    DrainSoul = Spell(198590, true, true, false)
    EmpoweredLifeTap = Spell(235157)
    EmpoweredLifeTapBuff = Spell(235156)
    GuardianDoomguard = Spell(18540, false, true, true)
    GuardianInfernal = Spell(1122, false, true, true)
    GrimoreOfSacrifice = Spell(108503, false, false, true)
    GrimoreOfSacrificeBuff = Spell(196099)
    GrimoreOfService = Spell(108501, false, false, true)
    GrimoreOfSupremacy = Spell(152107, false, true, true)
    GrimoreOfImp = Spell(111859, false, true, true)
    GrimoreOfVoid = Spell(111895, false, true, true)
    GrimoreOfSuccubus = Spell(111896, false, true, true)
    GrimoreOfFelHunter = Spell(111897, false, true, true)
    Haunt = Spell(48181, true, true, false)
    HealthFunnel = Spell(755, false, false, false)
    LifeTap = Spell(1454, false, false, true)
    MaleficGrasp = Spell(235155)
    ManaTap = Spell(196104, false, false, true)
    MortalCoil = Spell(6789, false, true, true)
    PhantomSingularity = Spell(205179, false, true, true)
    ReapSouls = Spell(216698, false, false, true)
    SeedOfCorruption = Spell(27243, false, true, false)
    ShadowLock = Spell(171138, true, true, true)
    SiphonLife = Spell(63106, false, true, true)
    SoulHarvest = Spell(196098, false, false, true)
    Soulstone = Spell(20707, false, false, false, true)
    SowTheSeeds = Spell(196226)
    SpellLock = Spell(19647, false, true, true)
    SummonDoomguard = Spell(157757, false, false, false)
    SummonFelhunter = Spell(691, false, false, false)
    SummonImp = Spell(688, false, false, false)
    SummonInfernal = Spell(157898, false, false, false)
    SummonSuccubus = Spell(712, false, false, false)
    SummonVoidwalker = Spell(697, false, false, false)
    TormentedSouls = Spell(216695)
    UnendingBreath = Spell(5697, false, false, true)
    UnendingResolve = Spell(104773, false, false, true)
    UnstableAffliction = Spell(30108, false, true, false)
    UnstableAffliction1 = Spell(233490, false, true, false)
    UnstableAffliction2 = Spell(233496, false, true, false)
    UnstableAffliction3 = Spell(233497, false, true, false)
    UnstableAffliction4 = Spell(233498, false, true, false)
    UnstableAffliction5 = Spell(233499, false, true, false)
    WritheInAgony = Spell(196102)
    HoodOfEternalDisdain = Item(132394)
    PowerCordOfLethtendris = Item(132457)
    SephuzsSecret = Item(132452)
    ReapAndSow = Item(144364)
    AddPage("常规")
    AddPage("进攻")
    AddPage("防御")
    AddCommonOptions()
    AddPresetOption("常规", "Caster", nil, false)
    AddSection("常规", "移动", "Yellow")
    AddNewOption(
    "常规",
    "爆燃冲刺",
    222,
    true,
    { 50, 1, 100, 1 },
    { 1.5, 0, 10, 0.1 },
    "Use Burning Rush on player. Burning Rush will be stopped when the Player falls under the Health Threshold (Value 1)." ..
    C.TOOLTIP_VALUE_1 ..
    "Minimum Health of Player in Percent to use Burning Rush." ..
    C.TOOLTIP_VALUE_2 .. "Time, in seconds, to wait when you start moving to use it."
    )
    AddSection("常规", "灵魂石", "Yellow")
    AddNewOption(
    "常规",
    "灵魂石",
    210,
    true,
    nil,
    nil,
    "Enable to automatically resurrect targeted dead player targets in combat."
    )
    AddNewOption(
    "常规",
    "给坦克绑灵魂石",
    220,
    false,
    { 1.2, 0, 3, 0.1 },
    nil,
    "Enable to use the Soulstone to resuscitate a dead tank" .. C.TOOLTIP_VALUE .. "Set the delay before using it."
    )
    AddSection("常规", "恶魔管理", "Yellow")
    AddNewOption(
    "常规",
    "恶魔管理器",
    230,
    true,
    { 3, "末日守卫", "Felhunter", "Imp", "地狱火", "Succubus", "Voidwalker" },
    nil,
    "Enable pet management." .. C.TOOLTIP_VALUE .. "Choose demon to use."
    )
    AddNewOption(
    "常规",
    "生命通道",
    220,
    true,
    { 25, 1, 100, 5 },
    nil,
    "Use Health Funnel to heal our demon." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddPresetOption("进攻")
    AddSection("进攻", "大技能", "Yellow")
    AddPresetOption("Cooldown", "末日守卫")
    AddPresetOption("Cooldown", "统御魔典", 1, { 2, "Felhunter", "Imp", "Succubus", "Voidwalker" }, "Choose demon to use.")
    AddPresetOption("Cooldown", "地狱火")
    AddPresetOption("Cooldown", "强化生命分流", 1)
    AddPresetOption("Cooldown", "诡异魅影", 1, { 1, 1, 20, 1 }, 'Unit Threshhold. This also applies to "Always"')
    AddNewOption(
    "进攻",
    "夺魂",
    223,
    true,
    { 8, 1, 18, 1 },
    { 1, "无条件使用", "大技能用法" },
    "Reap Souls stack Threshold." ..
    C.TOOLTIP_VALUE ..
    "Amount of Tormented Souls stacks needed to use Reap Souls with the conditions." ..
    C.TOOLTIP_VALUE_2 .. "Conditions to use Reap Souls."
    )
    AddPresetOption(
    "Cooldown",
    "灵魂收割",
    1,
    { 2, 1, 5, 1 },
    "Unstable Affliction Threshhold to use Soul Harvest. The minimum amount of running UA to use Soul Harvest."
    )
    AddSection("进攻", "能力", "Yellow")
    AddNewOption("进攻", "魔典：恶魔牺牲", 210, true, nil, nil, "Automatic Grimoire Of Sacrifice usage.")
    AddNewOption(
    "进攻",
    "带增益效果时泄片",
    230,
    true,
    { 1, "任何", "Concordance only" },
    nil,
    "Use the additional Unstable Affliction dump on Trinket or Concordance procs." ..
    C.TOOLTIP_VALUE_1 ..
    "Choose when to dump Unstable Affliction." ..
    C.TOOLTIP_SUBVALUE("任何") ..
    "Dump Shards on any Proc e.g. Concordance or any Trinket Proc." ..
    C.TOOLTIP_SUBVALUE("Concordance only") .. "Dump Shards on only on Concordance Procs"
    )
    AddNewOption(
    "进攻",
    "UA Mode",
    232,
    true,
    { 2, "SimC", "SBR" },
    { 5, 1, 5, 1 },
    "The way Unstable Affliction is used" ..
    C.TOOLTIP_VALUE_1 ..
    C.TOOLTIP_SUBVALUE("SimC") ..
    "Will use UA the Simcraft way." ..
    C.TOOLTIP_SUBVALUE("SBR") ..
    "Will use UA the Soapbox way.." ..
    C.TOOLTIP_VALUE_2 .. "Only for SBR Way.\nMaximum amount of running UAs."
    )
    AddNewOption(
    "进攻",
    "UA Circuit",
    222,
    true,
    { 1, 1, 5, 1 },
    { 5, 1, 10, 1 },
    "The SBR UA Mode." ..
    C.TOOLTIP_VALUE_1 ..
    "Minimum amount of Soul Shards to keep." ..
    C.TOOLTIP_VALUE_2 .. "Minimum amount of Soul Shards to start casting UA."
    )
    AddNewOption(
    "进攻",
    "腐蚀之种 AoE",
    222,
    true,
    { 1, 1, 5, 1 },
    { 5, 1, 10, 1 },
    "Use AoE rotation. Apply Dots to current target and spam Seed of Corruption." ..
    C.TOOLTIP_VALUE_1 ..
    "Minimum amount of Soul Shards to use Seed of Corruption on Target." ..
    C.TOOLTIP_VALUE_2 ..
    "Amount of units needed within 10 yards around our target." ..
    C.TOOLTIP_HINT(
    "If the talent Sow the Seeds is used, Value 2 is internally reduced by 2.\nValue 2: [5] will be handled as [3] in the calculations. This is correct."
    )
    )
    AddNewOption(
    "进攻",
    "痛苦无常",
    122,
    false,
    { 1, 1, 5, 1 },
    { 3, 0, 25, 0.1 },
    "Unstable Affliction Normal priority, following usual rotation triggers." ..
    C.TOOLTIP_VALUE_1 ..
    "Soul Shard Threshold to use Unstable Affliction as Normal priority." ..
    C.TOOLTIP_VALUE_2 ..
    "Minimum health (in million) to apply." ..
    C.TOOLTIP_HINT(
    "If you have a damage increasing Proc or Contagion talent enabled the Soul Shard threshold will be ignored."
    )
    )
    AddSection("进攻", "多目标Dots", "Yellow")
    AddNewOption(
    "进攻",
    "多目标 痛楚",
    222,
    true,
    { 3, 1, 10, 1 },
    { 3, 0, 25, 0.1 },
    "Multi-Dot Agony Cycle." ..
    C.TOOLTIP_VALUE_1 ..
    "Amount of dots to apply." .. C.TOOLTIP_VALUE_2 .. "Minimum health (in million) to apply."
    )
    AddNewOption(
    "进攻",
    "多目标 腐败",
    222,
    true,
    { 3, 1, 10, 1 },
    { 3, 0, 25, 0.1 },
    "Multi-Dot Corruption Cycle." ..
    C.TOOLTIP_VALUE_1 ..
    "Amount of dots to apply." .. C.TOOLTIP_VALUE_2 .. "Minimum health (in million) to apply."
    )
    AddNewOption(
    "进攻",
    "多目标 生命虹吸",
    222,
    false,
    { 3, 1, 10, 1 },
    { 3, 0, 25, 0.1 },
    "Multi-Dot Siphon Life Cycle." ..
    C.TOOLTIP_VALUE_1 ..
    "Amount of dots to apply." .. C.TOOLTIP_VALUE_2 .. "Minimum health (in million) to apply."
    )
    AddNewOption(
    "进攻",
    "传染 痛苦无常",
    222,
    false,
    { 3, 1, 6, 1 },
    { 3, 0, 25, 0.1 },
    "Spread Unstable Affliction with Contagion Talent." ..
    C.TOOLTIP_VALUE_1 ..
    "Amount of dots to apply." .. C.TOOLTIP_VALUE_2 .. "Minimum health (in million) to apply."
    )
    AddPresetOption("防御")
    AddNewOption(
    "防御",
    "制造治疗石",
    210,
    true,
    nil,
    nil,
    "Will create you a new healthstone if you have none in your bags and are out of combat."
    )
    AddSection("防御", "能力", "Yellow")
    AddNewOption(
    "防御",
    "黑暗契约",
    220,
    true,
    { 40, 1, 100, 1 },
    nil,
    "Use Dark Bargain." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddNewOption(
    "防御",
    "死亡缠绕",
    220,
    true,
    { 50, 1, 100, 1 },
    nil,
    "Use Mortal Coil." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddNewOption(
    "防御",
    "不灭决心",
    220,
    true,
    { 40, 1, 100, 1 },
    nil,
    "Use Dark Unending Resolve." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddOutput("痛苦无常:")
    SetOutput("痛苦无常:", "0")
    ISCL = {
        [UnstableAffliction:ID()] = "痛苦无常",
        [UnstableAffliction1:ID()] = "痛苦无常",
        [UnstableAffliction2:ID()] = "痛苦无常",
        [UnstableAffliction3:ID()] = "痛苦无常",
        [UnstableAffliction4:ID()] = "痛苦无常",
        [UnstableAffliction5:ID()] = "痛苦无常",
        [SeedOfCorruption:ID()] = "Seed of Corruption",
        [Haunt:ID()] = "Haunt"
    }
    PetTimer = 0
    self.PreventCorruption = 0
end
function Rotation:Events()
    self.PrevGCD = {}
    EventFrame:RegisterForSelfCombatEvent(
    function(...)
        SpellID = select(12, ...)
        if SpellID == 30108 then
            Rotation.LastCast = "痛苦无常"
        end
        if SpellID == 27243 then
            Rotation.PreventCorruption = GetTime() + SeedOfCorruption:TravelTime() + 0.05
        end
    end,
    "SPELL_CAST_SUCCESS"
    )
    local GCDSpells = {
        [980] = "Agony",
        [111400] = "爆燃冲刺",
        [172] = "Corruption",
        [108416] = "黑暗契约",
        [48018] = "Demonic Circle",
        [198590] = "Drain Soul",
        [5782] = "Fear",
        [108503] = "Grimoire of Sacrifice",
        [111897] = "Grimoire: FelHunter",
        [111859] = "Grimoire: Imp",
        [111896] = "Grimoire: Succubus",
        [111895] = "Grimoire: Voidwalker",
        [48181] = "Haunt",
        [755] = "生命通道",
        [5484] = "Howl of Terror",
        [1454] = "Life Tap",
        [6789] = "死亡缠绕",
        [205179] = "诡异魅影",
        [216698] = "夺魂",
        [27243] = "Seed of Corruption",
        [63106] = "Siphon Life",
        [20707] = "灵魂石",
        [688] = "Summon Imp",
        [697] = "Summon Voidwalker",
        [691] = "Summon Felhunter",
        [712] = "Summon Succubus",
        [157757] = "Summon Doomguard",
        [18540] = "Summon Doomguard",
        [157898] = "Summon Infernal",
        [1122] = "Summon Infernal",
        [30108] = "痛苦无常",
        [688] = "Summon Imp",
        [688] = "Summon Imp",
        [688] = "Summon Imp"
    }
    EventFrame:RegisterForSelfCombatEvent(
    function(...)
        if GetSpecialization() == 1 then
            SpellID = select(12, ...)
            if GCDSpells[SpellID] then
                Rotation.PrevGCD[3] = Rotation.PrevGCD[2]
                Rotation.PrevGCD[2] = Rotation.PrevGCD[1]
                Rotation.PrevGCD[1] = GCDSpells[SpellID]
                Bug("GCD triggered by " .. tostring(GCDSpells[SpellID]) .. ".")
            end
        end
    end,
    "SPELL_CAST_SUCCESS"
    )
end
function Rotation:Pulse()
    if Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
        return
    end
    AgonyTickTime, SiphonLifeTickTime = 2 / (1 + Player:Haste() / 100), 3 / (1 + Player:Haste() / 100)
    CorruptionTickTime, UnstableAfflictionTickTime = AgonyTickTime, AgonyTickTime
    if Target:Exists() and BMPullTime() < 5 then
        self:Opening()
        return
    end
    if GetTime() < Rotation.SpamPrevention then
        return
    end
    Rotation.SpamPrevention = GetTime() + 0.05
    Target = Unit.Target
    local InCombat = Player:IsInCombat()
    if not InCombat then
        self:OutOfCombat()
        return
    end
    if InCombat then
        self:Defensives()
    end
    Target = Player:ReTarget(Corruption, true) or Unit.Target
    if Target:Exists() then
        Rotations:RefreshUnitTables(Rotation.Identifier)
        self:Interrupts()
        if
        IsOptionEnabled("开怪技能") and
        (GetOptionValue("开怪技能") == "无条件使用" or (GetOptionValue("开怪技能") == "打BOSS使用" and Target:IsBoss()) or
        (GetOptionValue("开怪技能") == "CDs Only" and CooldownsAllowed())) and
        not OpenerEnded
        then
            self:Opener()
            return
        elseif CombatTime() > 10 then
            OpenerEnded = true
        end
        self:OffGCDAbilities()
        self:Combat()
    end
end
function Rotation:Opening()
    Player:UsePotions("智力药水", GetSecondOptionValue("抢先使用药水"))
    if
    IsOptionEnabled("抢先施放(需DBM插件)") and
    (GetOptionValue("抢先施放(需DBM插件)") == "无条件使用" or
    (GetOptionValue("抢先施放(需DBM插件)") == "打BOSS使用" and Target:IsBoss()))
    then
        OpenerSpell = UnstableAffliction
        if BMPullTime() < GetSecondOptionValue("抢先施放(需DBM插件)") and Target:CanCast(OpenerSpell) then
            Target:Cast(OpenerSpell)
            return
        end
    end
end
function Rotation:Opener()
    self.ChoosenOpener = nil
    if Player:GlobalCooldown() == 0 then
        if self.ChoosenOpener ~= nil then
            OpenerParser(self.ChoosenOpener)
        else
            Bug("Invalid Talents combination, Opener will not be used.")
            OpenerEnded = true
        end
    end
end
function Rotation:Defensives()
    Player:UseHealingItem()
    if
    MortalCoil:Exists() and IsOptionEnabled("死亡缠绕") and Target:Exists() and
    Player:HealthPercentage() <= GetOptionValue("死亡缠绕") and
    Target:CanCast(MortalCoil)
    then
        Target:Cast(MortalCoil)
    end
    if
    DarkPact:Exists() and IsOptionEnabled("黑暗契约") and Player:HealthPercentage() <= GetOptionValue("黑暗契约") and
    Player:CanCast(DarkPact)
    then
        Player:Cast(DarkPact)
        return
    end
    if
    UnendingResolve:Exists() and IsOptionEnabled("不灭决心") and Player:HealthPercentage() <= GetOptionValue("不灭决心") and
    Player:CanCast(UnendingResolve)
    then
        Player:Cast(UnendingResolve)
        return
    end
end
function Rotation:Interrupts()
    self.PetInterrupt = (SpellLock:PetKnown() and SpellLock) or (ShadowLock:PetKnown() and ShadowLock) or nil
    if self.PetInterrupt then
        Player:UseInterrupt(self.PetInterrupt, ArcaneTorrent, true)
    else
        Player:UseInterrupt(nil, ArcaneTorrent)
    end
end
function Rotation:OffGCDAbilities()
end
function Rotation:DotRefreshUnit(
TheseUnits,
Spell,
Debuff,
RemainingDuration,
OptionName,
AlsoApply,
TTDCheck,
ApplyOnce)
    if IsOptionEnabled(OptionName) then
        local MinHealth = GetSecondOptionValue(OptionName) * 1000000 or 0
        local BestUnit, BestUnitHealth, BestUnitDuration
        local ThisUnit, ThisUnitHealth, ThisUnitDuration
        local DebuffsCount = 0
        for i = 1, #TheseUnits do
            ThisUnit = TheseUnits[i]
            ThisUnitHealth, ThisUnitDuration = ThisUnit:Health(), ThisUnit:DebuffRemains(Debuff)
            DebuffsCount =             ThisUnitDuration ~= 0 and ThisUnitDuration > RemainingDuration and DebuffsCount + 1 or DebuffsCount
            if
            ThisUnit:Exists() and (not ApplyOnce or not ThisUnit:Debuff(Debuff)) and
            (ThisUnit:Debuff(Debuff) or AlsoApply) and
            ThisUnit:IsInCombat() and
            not ThisUnit:IsHardBlacklisted() and
            not ThisUnit:IsCrowdControlled() and
            Player:CanAttack(ThisUnit) and
            Player:IsWithinCastRange(ThisUnit, Spell) and
            (ThisUnitHealth >= MinHealth or ThisUnit:IsDummy()) and
            ThisUnitDuration <= RemainingDuration and
            (ThisUnit:TimeToDie() > RemainingDuration or not TTDCheck) and
            ThisUnit:CanCast(Spell, false, false, false, true)
            then
                BestUnit, BestUnitHealth, BestUnitDuration = ThisUnit, ThisUnitHealth, ThisUnitDuration
            end
        end
        return DebuffsCount < GetOptionValue(OptionName) and BestUnit or nil
    else
        return nil
    end
end
function Rotation:GetContagionUnit()
    if IsOptionEnabled("传染 痛苦无常") then
        local MinHealth = GetSecondOptionValue("传染 痛苦无常") * 1000000 or 0
        local BestUnit, BestUnitHealth, BestUnitDuration
        local ThisUnit, ThisUnitHealth, ThisUnitDuration
        local DebuffsCount = 0
        for i = 1, #Enemies_40y do
            ThisUnit = Enemies_40y[i]
            ThisUnitHealth, ThisUnitAfflictions =             ThisUnit:Health(),
            ThisUnit:UnstableAfflictionCount(UnstableAffliction:CastTime())
            DebuffsCount = ThisUnitAfflictions ~= 0 and DebuffsCount + 1 or DebuffsCount
            if
            ThisUnit:Exists() and ThisUnit:CorruptionRemains() > 3 and ThisUnit:DebuffRemains(Agony) > 3 and
            ThisUnit:UnstableAfflictionCount(UnstableAffliction:CastTime()) == 0 and
            not ThisUnit:IsHardBlacklisted() and
            not ThisUnit:IsCrowdControlled() and
            (ThisUnitHealth >= MinHealth or ThisUnit:IsDummy()) and
            ThisUnit:CanCast(UnstableAffliction, false, false, false, true)
            then
                BestUnit = ThisUnit
            end
        end
        return DebuffsCount < GetOptionValue("传染 痛苦无常") and BestUnit or nil
    else
        return nil
    end
end
function Rotation:PetsManager()
    if IsOptionEnabled("魔典：恶魔牺牲") and GrimoreOfSacrifice:Exists() and not Player:Buff(GrimoreOfSacrificeBuff) then
        if UnitExists("PlayerPet") and Player:CanCast(GrimoreOfSacrifice) then
            if SacrificeRandomDelay then
                if SacrificeRandomDelay < GetTime() then
                    Player:Cast(GrimoreOfSacrifice)
                    PetTimer = GetTime() + 4
                    SacrificeRandomDelay = nil
                    return
                end
            else
                SacrificeRandomDelay = GetTime() + math.random(2, 6)
            end
        end
    end
    if not (GrimoreOfSacrifice:Exists() and Player:Buff(GrimoreOfSacrificeBuff)) then
        if
        not Player:IsMoving() and IsOptionEnabled("恶魔管理器") and (not PlayerPet:Exists() or PlayerPet:IsDeadOrGhost()) and
        Player:SoulShards() >= 1
        then
            local SelectedPet = GetOptionValue("恶魔管理器")
            local SelectedPetSpell =             SelectedPet == "末日守卫" and GrimoreOfSupremacy:Exists() and SummonDoomguard or
            SelectedPet == "Felhunter" and SummonFelhunter:Exists() and SummonFelhunter or
            SelectedPet == "地狱火" and GrimoreOfSupremacy:Exists() and SummonInfernal or
            SelectedPet == "Succubus" and SummonSuccubus:Exists() and SummonSuccubus or
            SelectedPet == "Voidwalker" and SummonVoidwalker:Exists() and SummonVoidwalker or
            SummonImp
            if GetTime() - PetTimer >= 1 and Player:CanCast(SelectedPetSpell) then
                Player:Cast(SelectedPetSpell)
                PetTimer = GetTime() + 2.5
            end
        end
        if
        IsOptionEnabled("生命通道") and PlayerPet:Exists() and not PlayerPet:IsDeadOrGhost() and
        Player:Standing() > 0.25 and
        PlayerPet:HealthPercentage() < GetOptionValue("生命通道") and
        Player:CanCast(HealthFunnel)
        then
            Player:Cast(HealthFunnel)
            return
        end
    end
end
function Rotation:ServicePet()
    if CDOptionEnabled("统御魔典") then
        self.SelectedGrimoire = GetSecondOptionValue("统御魔典")
        self.SelectedGrimoireSpell =         self.SelectedGrimoire == "Felhunter" and GrimoreOfFelHunter or
        self.SelectedGrimoire == "Imp" and GrimoreOfImp or
        self.SelectedGrimoire == "Succubus" and GrimoreOfSuccubus or
        self.SelectedGrimoire == "Voidwalker" and GrimoreOfVoid
        if Target:CanCast(self.SelectedGrimoireSpell) then
            Target:Cast(self.SelectedGrimoireSpell)
            return
        end
    end
end
function Unit:CorruptionRemains()
    return AbsoluteCorruption:Exists() and self:Debuff(CorruptionDebuff) and 20 or
    not AbsoluteCorruption:Exists() and self:DebuffRemains(CorruptionDebuff) or
    0
end
function Unit:UnstableAfflictionCount(DebuffTime)
    self.DebuffTime = DebuffTime ~= nil and DebuffTime or 0
    self.AfflictionsCount = 0
    self.AfflictionsCount =     self:DebuffRemains(UnstableAffliction) > self.DebuffTime and self.AfflictionsCount + 1 or self.AfflictionsCount
    self.AfflictionsCount =     self:DebuffRemains(UnstableAffliction1) > self.DebuffTime and self.AfflictionsCount + 1 or self.AfflictionsCount
    self.AfflictionsCount =     self:DebuffRemains(UnstableAffliction2) > self.DebuffTime and self.AfflictionsCount + 1 or self.AfflictionsCount
    self.AfflictionsCount =     self:DebuffRemains(UnstableAffliction3) > self.DebuffTime and self.AfflictionsCount + 1 or self.AfflictionsCount
    self.AfflictionsCount =     self:DebuffRemains(UnstableAffliction4) > self.DebuffTime and self.AfflictionsCount + 1 or self.AfflictionsCount
    self.AfflictionsCount =     self:DebuffRemains(UnstableAffliction5) > self.DebuffTime and self.AfflictionsCount + 1 or self.AfflictionsCount
    return self.AfflictionsCount
end
function Rotation:UnstableAfflictionsRunning()
    self.AfflictionsCount = 0
    for i = 1, #Enemies_40y do
        ThisUnit = Enemies_40y[i]
        self.AfflictionsCount = self.AfflictionsCount + ThisUnit:UnstableAfflictionCount()
    end
    return self.AfflictionsCount
end
function Rotation:AfflictionsUI(UACount)
    SetOutput("痛苦无常:", tostring(UACount))
end
function Rotation:GetSoCEnemiesOptionValue()
    if IsOptionEnabled("腐蚀之种 AoE") then
        if SowTheSeeds:Exists() then
            if GetSecondOptionValue("腐蚀之种 AoE") - 2 <= 1 then
                return 1
            else
                return GetSecondOptionValue("腐蚀之种 AoE") - 2
            end
        else
            return GetSecondOptionValue("腐蚀之种 AoE")
        end
    else
        return 990
    end
end
function Rotation:ProcDumpShards()
    if IsOptionEnabled("带增益效果时泄片") and Player:SoulShards() >= 1 then
        if GetOptionValue("带增益效果时泄片") == "任何" and Player:HasAnyProc() then
            return true
        elseif
        GetOptionValue("带增益效果时泄片") == "Concordance only" and Player:BuffRemains(ConcordanceOfTheLegionfall) and
        UnstableAffliction:CastTime()
        then
            return true
        end
    end
    return false
end
function Rotation:UnitTables()
    UARuntime = 8 / (1 + UnitSpellHaste("player") / 100)
    GCDmax = Player:GCD()
    Enemies_40y = UseAOE() and Player:EnemiesWithinDistance(40) or {}
    TargetEnemies_10y = Target:Exists() and UseAOE() and Target:EnemiesWithinDistance(10, true) or {}
    SoCEnemiesCount = #TargetEnemies_10y
    SoCEnemiesOption = UseAOE() and self:GetSoCEnemiesOptionValue() or 991
    TargetEnemies_15y = UseAOE() and #Target:EnemiesWithinDistance(15) or 1
    AgonyUnit = self:DotRefreshUnit(Enemies_40y, Agony, Agony, 5.4, "多目标 痛楚", true)
    AgonyUnitGCD = self:DotRefreshUnit(Enemies_40y, Agony, Agony, AgonyTickTime + GCDmax, "多目标 痛楚", true)
    AgonyUnit3 = self:DotRefreshUnit(Enemies_40y, Agony, Agony, 0.3 * 18, "多目标 痛楚", true, true)
    CorruptionUnit =     Unit.DotCycle(Enemies_40y, Corruption, CorruptionDebuff, 14, "多目标 腐败", false, AbsoluteCorruption:Exists())
    CorruptionUnitGCD =     self:DotRefreshUnit(
    Enemies_40y,
    Corruption,
    CorruptionDebuff,
    CorruptionTickTime + GCDmax,
    "多目标 腐败",
    true,
    false,
    AbsoluteCorruption:Exists()
    )
    CorruptionUnit3 =     self:DotRefreshUnit(
    Enemies_40y,
    Corruption,
    CorruptionDebuff,
    14 * 0.3,
    "多目标 腐败",
    true,
    true,
    AbsoluteCorruption:Exists()
    )
    SiphonLifeUnit = self:DotRefreshUnit(Enemies_40y, SiphonLife, SiphonLife, 15, "多目标 生命虹吸", true)
    SiphonLifeUnitGCD =     self:DotRefreshUnit(Enemies_40y, SiphonLife, SiphonLife, SiphonLifeTickTime + GCDmax, "多目标 生命虹吸", true)
    SiphonLifeUnit3 = self:DotRefreshUnit(Enemies_40y, SiphonLife, SiphonLife, 15 * 0.3, "多目标 生命虹吸", true, true)
    ContagionUnit = UseAOE() and Contagion:Exists() and self:GetContagionUnit() or nil
    UARunning = self:UnstableAfflictionsRunning()
    self:AfflictionsUI(UARunning)
end
function Rotation:CombatDuringChannel()
end
function Rotation:Combat()
    if Haunt:Exists() then
        if
        ReapSouls:Exists() and IsOptionEnabled("夺魂") and
        (CooldownsAllowed() or GetSecondOptionValue("夺魂") == "无条件使用") and
        not Player:Buff(DeadwindHarvester) and
        (Player:BuffCount(TormentedSouls) >= 5 or
        Target:TimeToDie() <=
        (Player:Buff(TormentedSouls) and 1 or 0) * (5 + 1.5 * (ReapAndSow:IsEquipped(15) and 1 or 0)))
        then
            Player:Cast(ReapSouls)
        end
        if
        ReapSouls:Exists() and IsOptionEnabled("夺魂") and
        (CooldownsAllowed() or GetSecondOptionValue("夺魂") == "无条件使用") and
        Player:Buff(TormentedSouls) and
        Target:Debuff(Haunt) and
        not Player:Buff(DeadwindHarvester) and
        Player:CanCast(ReapSouls)
        then
            Player:Cast(ReapSouls)
        end
        if
        ReapSouls:Exists() and IsOptionEnabled("夺魂") and
        (CooldownsAllowed() or GetSecondOptionValue("夺魂") == "无条件使用") and
        Player:Buff(TormentedSouls) and
        #Enemies_40y > 1 and
        not Player:Buff(DeadwindHarvester) and
        Player:SoulShards() > 0 and
        SoCEnemiesCount >= SoCEnemiesOption and
        Player:CanCast(ReapSouls)
        then
            Player:Cast(ReapSouls)
        end
        if Agony:Exists() then
            if Target:Exists() and Target:DebuffRemains(Agony) <= AgonyTickTime + GCDmax and Target:CanCast(Agony) then
                Target:Cast(Agony)
                return
            end
            if AgonyUnitGCD and AgonyUnitGCD:Debuff(Agony) and AgonyUnitGCD:CanCast(Agony) then
                AgonyUnitGCD:Cast(Agony)
                return
            end
            if AgonyUnitGCD and AgonyUnitGCD:CanCast(Agony) then
                AgonyUnitGCD:Cast(Agony)
                return
            end
        end
        if GrimoreOfService:Exists() and Target:CorruptionRemains() > 0 and Target:Debuff(Agony) then
            self:ServicePet()
        end
        if
        GuardianDoomguard:Exists() and not GrimoreOfSupremacy:Exists() and CDOptionEnabled("末日守卫") and
        Target:CanCast(GuardianDoomguard)
        then
            Target:Cast(GuardianDoomguard)
            return
        end
        if
        GuardianInfernal:Exists() and not GrimoreOfSupremacy:Exists() and CDOptionEnabled("地狱火") and
        not GrimoreOfSupremacy and
        SoCEnemiesCount >= 3 and
        Target:CanCast(GuardianInfernal)
        then
            Target:Cast(GuardianInfernal)
            return
        end
        if Player:IsWithinCastRange(Target, Corruption) then
            if CDOptionEnabled("进攻性种族技能") then
                if BloodFury:Exists() and Player:CanCast(BloodFury) then
                    Player:Cast(BloodFury)
                end
                if
                Berserking:Exists() and Berserking:Cooldown() <= 0 and self.PrevGCD[1] == "痛苦无常" or
                Player:BuffRemains(SoulHarvest) >= 10 and Player:CanCast(Berserking)
                then
                    Player:Cast(Berserking)
                end
                if ArcaneTorrent:Exists() and Player:SoulShards() < 4 and Player:CanCast(ArcaneTorrent) then
                    Player:Cast(ArcaneTorrent)
                end
            end
        end
        if
        SoulHarvest:Exists() and CDOptionEnabled("灵魂收割") and Player:DebuffRemains(SoulHarvest) <= 8 and
        UARunning >= GetSecondOptionValue("灵魂收割") and
        Player:CanCast(SoulHarvest)
        then
            Player:Cast(SoulHarvest)
        end
        if Player:IsWithinCastRange(Target, Corruption) then
            Player:UseTrinkets()
            Player:UsePotions("智力药水")
        end
        if SiphonLife:Exists() then
            if
            Target:Exists() and Target:DebuffRemains(SiphonLife) <= SiphonLifeTickTime + GCDmax and
            Target:CanCast(SiphonLife)
            then
                Target:Cast(SiphonLife)
                return
            end
            if SiphonLifeUnitGCD and SiphonLifeUnitGCD:CanCast(SiphonLife) then
                SiphonLifeUnitGCD:Cast(SiphonLife)
                return
            end
        end
        if Corruption:Exists() and (SoCEnemiesCount < SoCEnemiesOption) then
            if
            Target:Exists() and Target:CorruptionRemains() <= CorruptionTickTime + GCDmax and
            Target:CanCast(Corruption)
            then
                Target:Cast(Corruption)
                return
            end
            if CorruptionUnitGCD and CorruptionUnitGCD:CanCast(Corruption) then
                CorruptionUnitGCD:Cast(Corruption)
                return
            end
        end
        if
        ReapSouls:Exists() and IsOptionEnabled("夺魂") and
        (CooldownsAllowed() or GetSecondOptionValue("夺魂") == "无条件使用") and
        Player:Buff(TormentedSouls) and
        (Player:BuffRemains(DeadwindHarvester) +
        Player:BuffRemains(TormentedSouls) * (5 + (ReapAndSow:IsEquipped(15) or 0))) >=
        (12 * (5 + 1.5 * (ReapAndSow:IsEquipped(15) or 0))) and
        Player:CanCast(ReapSouls)
        then
            Player:Cast(ReapSouls)
        end
        if
        LifeTap:Exists() and EmpoweredLifeTap:Exists() and CDOptionEnabled("强化生命分流") and
        Player:BuffRemains(EmpoweredLifeTapBuff) <= GCDmax and
        Player:CanCast(LifeTap)
        then
            Player:Cast(LifeTap)
            return
        end
        if
        PhantomSingularity:Exists() and CDOptionEnabled("诡异魅影") and
        TargetEnemies_15y >= GetSecondOptionValue("诡异魅影") and
        Target:CanCast(PhantomSingularity)
        then
            Target:Cast(PhantomSingularity)
            return
        end
        if Haunt:Exists() and Target:CanCast(Haunt) then
            Target:Cast(Haunt)
            return
        end
        if Agony:Exists() then
            if
            Target:DebuffRemains(Agony) < 5.4 and Target:TimeToDie() >= Target:DebuffRemains(Agony) and
            Target:CanCast(Agony)
            then
                Target:Cast(Agony)
                return
            end
            if AgonyUnit and AgonyUnit:DebuffRemains(Agony) and AgonyUnit:CanCast(Agony) then
                AgonyUnit:Cast(Agony)
                return
            end
            if AgonyUnit and AgonyUnit:CanCast(Agony) then
                AgonyUnit:Cast(Agony)
                return
            end
        end
        if
        LifeTap:Exists() and EmpoweredLifeTap:Exists() and CDOptionEnabled("强化生命分流") and
        Player:BuffRemains(EmpoweredLifeTapBuff) <= 20 * 0.3 or
        MaleficGrasp:Exists() and Player:ManaPercentage() < 10 and Player:CanCast(LifeTap)
        then
            Player:Cast(LifeTap)
            return
        end
        if
        SiphonLife:Exists() and Target:DebuffRemains(SiphonLife) <= 4.5 and
        Target:TimeToDie() >= Target:DebuffRemains(SiphonLife) and
        Target:CanCast(SiphonLife)
        then
            Target:Cast(SiphonLife)
            return
        end
        if
        SiphonLife:Exists() and SiphonLifeUnit3 and
        SiphonLifeUnit3:DebuffRemains(Haunt) >= UnstableAfflictionTickTime * 6 and
        SiphonLifeUnit3:CanCast(SiphonLife)
        then
            SiphonLifeUnit3:Cast(SiphonLife)
            return
        end
        if
        SeedOfCorruption:Exists() and IsOptionEnabled("腐蚀之种 AoE") and
        Player:SoulShards() >= GetOptionValue("腐蚀之种 AoE") and
        (SoCEnemiesCount >= SoCEnemiesOption or
        (SoCEnemiesCount >= SoCEnemiesOption and
        Target:CorruptionRemains() <= SeedOfCorruption:CastTime() + SeedOfCorruption:TravelTime())) and
        Target:CanCast(SeedOfCorruption)
        then
            Target:Cast(SeedOfCorruption)
            SeedOfCorruption.LastCastTime = GetTime()
            return
        end
        if Corruption:Exists() and not Target:Debuff(SeedOfCorruption) and self.PreventCorruption < GetTime() then
            if
            Target:CorruptionRemains() <= 4.2 and Target:TimeToDie() >= Target:CorruptionRemains() and
            Target:UnstableAfflictionCount() == 0 and
            Target:CanCast(Corruption)
            then
                Target:Cast(Corruption)
                return
            end
        end
        if
        CorruptionUnit and CorruptionUnit:DebuffRemains(Haunt) >= UnstableAfflictionTickTime * 6 and
        CorruptionUnit:CanCast(Corruption)
        then
            CorruptionUnit:Cast(Corruption)
            return
        end
        if
        UnstableAffliction:Exists() and (not SowTheSeeds:Exists() or SoCEnemiesCount < SoCEnemiesOption) and
        SoCEnemiesCount < SoCEnemiesOption and
        ((Player:SoulShards() >= 4 and not Contagion:Exists()) or Player:SoulShards() >= 5 or
        Target:TimeToDie() < 30) and
        Target:CanCast(UnstableAffliction)
        then
            Target:Cast(UnstableAffliction)
            return
        end
        if
        UnstableAffliction:Exists() and (not SowTheSeeds:Exists() or SoCEnemiesCount < SoCEnemiesOption) and
        Player:SoulShards() >= 4 and
        Contagion:Exists() and
        ContagionUnit and
        not ContagionUnit:Debuff(Haunt) and
        ContagionUnit:CanCast(UnstableAffliction)
        then
            ContagionUnit:Cast(UnstableAffliction)
            return
        end
        if
        UnstableAffliction:Exists() and (not SowTheSeeds:Exists() or SoCEnemiesCount < SoCEnemiesOption) and
        SoCEnemiesCount < SoCEnemiesOption and
        Contagion:Exists() and
        Player:SoulShards() >= 4 and
        UARunning <= 0 and
        Target:CanCast(UnstableAffliction)
        then
            Target:Cast(UnstableAffliction)
            return
        end
        if
        UnstableAffliction:Exists() and (not SowTheSeeds:Exists() or SoCEnemiesCount < SoCEnemiesOption) and
        SoCEnemiesCount < SoCEnemiesOption and
        Target:DebuffRemains(Haunt) >= UnstableAfflictionTickTime * 2 and
        Target:CanCast(UnstableAffliction)
        then
            Target:Cast(UnstableAffliction)
            return
        end
        if
        ReapSouls:Exists() and IsOptionEnabled("夺魂") and
        (CooldownsAllowed() or GetSecondOptionValue("夺魂") == "无条件使用") and
        Player:Buff(TormentedSouls) and
        not Player:Buff(DeadwindHarvester) and
        (UARunning > 1 or (self.PrevGCD[1] == "痛苦无常" and Player:BuffCount(TormentedSouls) > 1)) and
        Player:CanCast(ReapSouls)
        then
            Player:Cast(ReapSouls)
        end
        if
        LifeTap:Exists() and Player:ManaPercentage() <= 10 and Player:HealthPercentage() >= 30 and
        Player:CanCast(LifeTap)
        then
            Player:Cast(LifeTap)
            return
        end
        if DrainSoul:Exists() and Target:CanCast(DrainSoul) then
            if Player:Channeling(DrainSoul) then
                return
            end
            if not Player:IsMoving() and Target:CanCast(DrainSoul) then
                DrainFiller = true
                Target:Cast(DrainSoul)
                return
            end
        end
        if
        LifeTap:Exists() and Player:ManaPercentage() <= 65 and Player:HealthPercentage() >= 30 and
        Player:CanCast(LifeTap)
        then
            Player:Cast(LifeTap)
            return
        end
    elseif MaleficGrasp:Exists() then
        if
        ReapSouls:Exists() and IsOptionEnabled("夺魂") and
        (CooldownsAllowed() or GetSecondOptionValue("夺魂") == "无条件使用") and
        Player:Buff(TormentedSouls) and
        not Player:Buff(DeadwindHarvester) and
        (Player:BuffCount(TormentedSouls) >= 5 or
        Target:TimeToDie() <=
        (Player:Buff(TormentedSouls) and 1 or 0) * (5 + 1.5 * (ReapAndSow:IsEquipped(15) and 1 or 0)))
        then
            Player:Cast(ReapSouls)
        end
        if
        ReapSouls:Exists() and Player:Buff(TormentedSouls) and #Enemies_40y > 1 and
        not Player:Buff(DeadwindHarvester) and
        Player:SoulShards() > 0 and
        ((SowTheSeeds:Exists() and SoCEnemiesCount >= SoCEnemiesOption) or SoCEnemiesCount >= SoCEnemiesOption) and
        Player:CanCast(ReapSouls)
        then
            Player:Cast(ReapSouls)
        end
        if Agony:Exists() then
            if Target:Exists() and Target:DebuffRemains(Agony) <= AgonyTickTime + GCDmax and Target:CanCast(Agony) then
                Target:Cast(Agony)
                return
            end
            if AgonyUnitGCD and AgonyUnitGCD:Debuff(Agony) and AgonyUnitGCD:CanCast(Agony) then
                AgonyUnitGCD:Cast(Agony)
                return
            end
            if AgonyUnitGCD and AgonyUnitGCD:CanCast(Agony) then
                AgonyUnitGCD:Cast(Agony)
                return
            end
        end
        if GrimoreOfService:Exists() and Target:CorruptionRemains() > 0 and Target:Debuff(Agony) then
            self:ServicePet()
        end
        if
        GuardianDoomguard:Exists() and not GrimoreOfSupremacy:Exists() and CDOptionEnabled("末日守卫") and
        Target:CanCast(GuardianDoomguard)
        then
            Target:Cast(GuardianDoomguard)
            return
        end
        if
        GuardianInfernal:Exists() and not GrimoreOfSupremacy:Exists() and CDOptionEnabled("地狱火") and
        not GrimoreOfSupremacy and
        SoCEnemiesCount >= 3 and
        Target:CanCast(GuardianInfernal)
        then
            Target:Cast(GuardianInfernal)
            return
        end
        if Player:IsWithinCastRange(Target, Corruption) and CDOptionEnabled("进攻性种族技能") then
            if
            Berserking:Exists() and Berserking:Cooldown() <= 0 and self.PrevGCD[1] == "痛苦无常" or
            Player:BuffRemains(SoulHarvest) >= 10 and Player:CanCast(Berserking)
            then
                Player:Cast(Berserking)
            end
            if BloodFury:Exists() and Player:CanCast(BloodFury) then
                Player:Cast(BloodFury)
            end
        end
        if
        SoulHarvest:Exists() and CDOptionEnabled("灵魂收割") and Player:BuffRemains(SoulHarvest) <= 8 and
        UARunning >= GetSecondOptionValue("灵魂收割") and
        Player:CanCast(SoulHarvest)
        then
            Player:Cast(SoulHarvest)
        end
        if SiphonLife:Exists() then
            if Target:DebuffRemains(SiphonLife) <= SiphonLifeTickTime + GCDmax and Target:CanCast(SiphonLife) then
                Target:Cast(SiphonLife)
                return
            end
            if SiphonLifeUnitGCD and #Enemies_40y > 1 and UARunning <= 0 then
                SiphonLifeUnitGCD:Cast(SiphonLife)
                return
            end
        end
        if
        Corruption:Exists() and Target:CorruptionRemains() < CorruptionTickTime + GCDmax and
        ((SowTheSeeds:Exists() and SoCEnemiesCount < SoCEnemiesOption) or SoCEnemiesCount < SoCEnemiesOption) and
        Target:CanCast(Corruption)
        then
            Target:Cast(Corruption)
            return
        end
        if
        LifeTap:Exists() and EmpoweredLifeTap:Exists() and CDOptionEnabled("强化生命分流") and
        Player:BuffRemains(EmpoweredLifeTapBuff) <= GCDmax and
        Player:CanCast(LifeTap)
        then
            Player:Cast(LifeTap)
            return
        end
        if
        ReapSouls:Exists() and Player:Buff(TormentedSouls) and
        (Player:BuffRemains(DeadwindHarvester) +
        Player:BuffCount(TormentedSouls) * (5 + (ReapAndSow:IsEquipped(15) or 0))) >=
        (12 * (5 + (ReapAndSow:IsEquipped(15) or 0))) and
        UARunning < 1 and
        Player:CanCast(ReapSouls)
        then
            Player:Cast(ReapSouls)
        end
        if
        PhantomSingularity:Exists() and CDOptionEnabled("诡异魅影") and
        TargetEnemies_15y >= GetSecondOptionValue("诡异魅影") and
        Target:CanCast(PhantomSingularity)
        then
            Target:Cast(PhantomSingularity)
            return
        end
        if Agony:Exists() and AgonyUnit and UARunning <= 0 and AgonyUnit:CanCast(Agony) then
            AgonyUnit:Cast(Agony)
            return
        end
        if
        LifeTap:Exists() and EmpoweredLifeTap:Exists() and CDOptionEnabled("强化生命分流") and
        Player:BuffRemains(EmpoweredLifeTapBuff) <= 20 * 0.3 or
        MaleficGrasp:Exists() and Player:ManaPercentage() < 10 and Player:CanCast(LifeTap)
        then
            Player:Cast(LifeTap)
            return
        end
        if
        SiphonLife:Exists() and SiphonLifeUnit3 and
        SiphonLifeUnit3:DebuffRemains(Haunt) >= UnstableAfflictionTickTime * 6 and
        UARunning <= 0 and
        SiphonLifeUnit3:CanCast(SiphonLife)
        then
            SiphonLifeUnit3:Cast(SiphonLife)
            return
        end
        if
        SeedOfCorruption:Exists() and IsOptionEnabled("腐蚀之种 AoE") and
        Player:SoulShards() >= GetOptionValue("腐蚀之种 AoE") and
        (SoCEnemiesCount >= SoCEnemiesOption or
        (SoCEnemiesCount >= SoCEnemiesOption and
        Target:CorruptionRemains() <= SeedOfCorruption:CastTime() + SeedOfCorruption:TravelTime())) and
        Target:CanCast(SeedOfCorruption)
        then
            Target:Cast(SeedOfCorruption)
            SeedOfCorruption.LastCastTime = GetTime()
            return
        end
        if Corruption:Exists() and UARunning <= 0 then
            if
            Target:Exists() and Target:CorruptionRemains() <= CorruptionTickTime + GCDmax and
            Target:CanCast(Corruption)
            then
                Target:Cast(Corruption)
                return
            end
            if CorruptionUnit3 and CorruptionUnit3:CanCast(Corruption) then
                CorruptionUnit3:Cast(Corruption)
                return
            end
        end
        if GetOptionValue("UA Mode") == "SBR" then
            if (not SowTheSeeds:Exists() or SoCEnemiesCount < SoCEnemiesOption) and SoCEnemiesCount < SoCEnemiesOption then
                if
                Agony:Exists() and Player:SoulShards() >= GetSecondOptionValue("UA Circuit") and
                Target:DebuffRemains(Agony) < UnstableAffliction:CastTime() * 2 + 6.5 and
                Target:CanCast(Agony)
                then
                    Target:Cast(Agony)
                    return
                end
                if
                Corruption:Exists() and Player:SoulShards() >= GetSecondOptionValue("UA Circuit") and
                (Target:CorruptionRemains() < UnstableAffliction:CastTime() + 6.5 or AbsoluteCorruption:Exists()) and
                Target:CanCast(Corruption)
                then
                    Target:Cast(Corruption)
                    return
                end
                if
                UnstableAffliction:Exists() and
                (self:ProcDumpShards() or
                (Player:SoulShards() > GetOptionValue("UA Circuit") and
                (Player:SoulShards() >= GetSecondOptionValue("UA Circuit") or self.PrevGCD[1] == "痛苦无常") and
                UARunning < GetSecondOptionValue("UA Mode") and
                Target:DebuffRemains(Agony) > UnstableAffliction:CastTime() * 2 + 6.5 and
                (Target:CorruptionRemains() > UnstableAffliction:CastTime() + 6.5 or
                AbsoluteCorruption:Exists()) and
                (not SiphonLife:Exists() or
                Target:DebuffRemains(SiphonLife) > UnstableAffliction:CastTime() + 6.5))) and
                Target:CanCast(UnstableAffliction)
                then
                    Target:Cast(UnstableAffliction)
                    Bug("Unstable Affliction - 0")
                    return
                end
            end
        end
        if GetOptionValue("UA Mode") == "SimC" then
            if
            UnstableAffliction:Exists() and (not SowTheSeeds:Exists() or SoCEnemiesCount < SoCEnemiesOption) and
            SoCEnemiesCount < SoCEnemiesOption and
            (Target:TimeToDie() < 30 or
            self.PrevGCD[1] == "痛苦无常" and Player:SoulShards() >= 4 and
            (PowerCordOfLethtendris:IsEquipped(6) or UARunning < 2)) and
            Target:CanCast(UnstableAffliction)
            then
                Target:Cast(UnstableAffliction)
                Bug("Unstable Affliction - 1")
                return
            end
            if
            UnstableAffliction:Exists() and (not SowTheSeeds:Exists() or SoCEnemiesCount < SoCEnemiesOption) and
            SoCEnemiesCount < SoCEnemiesOption and
            (Player:SoulShards() >= 4 or (PowerCordOfLethtendris:IsEquipped(6) and Player:SoulShards() == 5)) and
            Target:CanCast(UnstableAffliction)
            then
                Target:Cast(UnstableAffliction)
                Bug("Unstable Affliction - 2")
                return
            end
            if
            UnstableAffliction:Exists() and not PowerCordOfLethtendris:IsEquipped(6) and self.PrevGCD[3] ~= "痛苦无常" and
            Target:DebuffRemains(Agony) > UnstableAffliction:CastTime() * 2 + 6.5 and
            (Target:CorruptionRemains() > UnstableAffliction:CastTime() + 6.5 or AbsoluteCorruption:Exists()) and
            (not SiphonLife:Exists() or Target:DebuffRemains(SiphonLife) > UnstableAffliction:CastTime() + 6.5) and
            Target:CanCast(UnstableAffliction)
            then
                Target:Cast(UnstableAffliction)
                Bug("Unstable Affliction - 3")
                return
            end
            if
            UnstableAffliction:Exists() and (not SowTheSeeds:Exists() or SoCEnemiesCount < SoCEnemiesOption) and
            SoCEnemiesCount < SoCEnemiesOption and
            PowerCordOfLethtendris:IsEquipped(6) and
            (UARunning == 0 or self.PrevGCD[3] ~= "痛苦无常" and self.PrevGCD[1] ~= "痛苦无常") and
            Target:DebuffRemains(Agony) > UnstableAffliction:CastTime() + 6.5 and
            Target:CanCast(UnstableAffliction)
            then
                Target:Cast(UnstableAffliction)
                Bug("Unstable Affliction - 4")
                return
            end
        end
        if
        ReapSouls:Exists() and IsOptionEnabled("夺魂") and
        (CooldownsAllowed() or GetSecondOptionValue("夺魂") == "无条件使用") and
        Player:Buff(TormentedSouls) and
        not Player:Buff(DeadwindHarvester) and
        (UARunning > 1 or (self.PrevGCD[1] == "痛苦无常" and Player:BuffCount(TormentedSouls) > 1)) and
        Player:CanCast(ReapSouls)
        then
            Player:Cast(ReapSouls)
        end
        if
        LifeTap:Exists() and Player:ManaPercentage() <= 10 and Player:HealthPercentage() >= 30 and
        Player:CanCast(LifeTap)
        then
            Player:Cast(LifeTap)
            return
        end
        if DrainSoul:Exists() and Target:CanCast(DrainSoul) then
            if Player:Channeling(DrainSoul) then
                return
            end
            if not Player:IsMoving() and Target:CanCast(DrainSoul) then
                DrainFiller = true
                Target:Cast(DrainSoul)
                return
            end
        end
        if
        LifeTap:Exists() and Player:ManaPercentage() <= 65 and Player:HealthPercentage() >= 30 and
        Player:CanCast(LifeTap)
        then
            Player:Cast(LifeTap)
            return
        end
    else
        if
        ReapSouls:Exists() and IsOptionEnabled("夺魂") and
        (CooldownsAllowed() or GetSecondOptionValue("夺魂") == "无条件使用") and
        Player:Buff(TormentedSouls) and
        not Player:Buff(DeadwindHarvester) and
        (Player:BuffCount(TormentedSouls) >= 5 or
        Target:TimeToDie() <=
        (Player:Buff(TormentedSouls) and 1 or 0) * (5 + 1.5 * (ReapAndSow:IsEquipped(15) and 1 or 0)))
        then
            Player:Cast(ReapSouls)
        end
        if
        ReapSouls:Exists() and Player:Buff(TormentedSouls) and #Enemies_40y > 1 and
        not Player:Buff(DeadwindHarvester) and
        Player:SoulShards() > 0 and
        ((SowTheSeeds:Exists() and SoCEnemiesCount >= SoCEnemiesOption) or SoCEnemiesCount >= SoCEnemiesOption) and
        Player:CanCast(ReapSouls)
        then
            Player:Cast(ReapSouls)
        end
        if Agony:Exists() then
            if Target:Exists() and Target:DebuffRemains(Agony) <= AgonyTickTime + GCDmax and Target:CanCast(Agony) then
                Target:Cast(Agony)
                return
            end
            if AgonyUnitGCD and AgonyUnitGCD:Debuff(Agony) and AgonyUnitGCD:CanCast(Agony) then
                AgonyUnitGCD:Cast(Agony)
                return
            end
            if AgonyUnitGCD and AgonyUnitGCD:CanCast(Agony) then
                AgonyUnitGCD:Cast(Agony)
                return
            end
        end
        if
        UnstableAffliction:Exists() and (not SowTheSeeds:Exists() or SoCEnemiesCount < SoCEnemiesOption) and
        SoCEnemiesCount < SoCEnemiesOption and
        Player:SoulShards() >= 5 and
        Target:CanCast(UnstableAffliction)
        then
            Target:Cast(UnstableAffliction)
            return
        end
        if GrimoreOfService:Exists() and Target:CorruptionRemains() > 0 and Target:Debuff(Agony) then
            self:ServicePet()
        end
        if
        GuardianDoomguard:Exists() and not GrimoreOfSupremacy:Exists() and CDOptionEnabled("末日守卫") and
        Target:CanCast(GuardianDoomguard)
        then
            Target:Cast(GuardianDoomguard)
            return
        end
        if
        GuardianInfernal:Exists() and not GrimoreOfSupremacy:Exists() and CDOptionEnabled("地狱火") and
        not GrimoreOfSupremacy and
        SoCEnemiesCount >= 3 and
        Target:CanCast(GuardianInfernal)
        then
            Target:Cast(GuardianInfernal)
            return
        end
        if Player:IsWithinCastRange(Target, Corruption) and CDOptionEnabled("进攻性种族技能") then
            if
            Berserking:Exists() and Berserking:Cooldown() <= 0 and self.PrevGCD[1] == "痛苦无常" or
            Player:BuffRemains(SoulHarvest) >= 10 and Player:CanCast(Berserking)
            then
                Player:Cast(Berserking)
            end
            if BloodFury:Exists() and Player:CanCast(BloodFury) then
                Player:Cast(BloodFury)
            end
        end
        if
        SoulHarvest:Exists() and CDOptionEnabled("灵魂收割") and Player:DebuffRemains(SoulHarvest) <= 8 and
        UARunning >= GetSecondOptionValue("灵魂收割") and
        Player:CanCast(SoulHarvest)
        then
            Player:Cast(SoulHarvest)
        end
        if Player:IsWithinCastRange(Target, Corruption) then
            Player:UseTrinkets()
            if not SoulHarvest:Exists() and UARunning > 2 then
                Player:UsePotions("智力药水")
            end
            if SoulHarvest:Exists() and Player:Buff(SoulHarvest) and UARunning > 2 then
                Player:UsePotions("智力药水")
            end
        end
        if SiphonLife:Exists() then
            if
            Target:Exists() and Target:DebuffRemains(SiphonLife) <= SiphonLifeTickTime + GCDmax and
            Target:CanCast(SiphonLife)
            then
                Target:Cast(SiphonLife)
                return
            end
            if SiphonLifeUnitGCD and SiphonLifeUnitGCD:CanCast(SiphonLife) then
                SiphonLifeUnitGCD:Cast(SiphonLife)
                return
            end
        end
        if Corruption:Exists() and SoCEnemiesCount < SoCEnemiesOption then
            if
            Target:Exists() and Target:CorruptionRemains() <= CorruptionTickTime + GCDmax and
            Target:CanCast(Corruption)
            then
                Target:Cast(Corruption)
                return
            end
            if CorruptionUnitGCD and CorruptionUnitGCD:CanCast(Corruption) then
                CorruptionUnitGCD:Cast(Corruption)
                return
            end
        end
        if
        ReapSouls:Exists() and IsOptionEnabled("夺魂") and
        (CooldownsAllowed() or GetSecondOptionValue("夺魂") == "无条件使用") and
        Player:Buff(TormentedSouls) and
        (Player:BuffRemains(DeadwindHarvester) +
        Player:BuffCount(TormentedSouls) * (5 + (ReapAndSow:IsEquipped(15) or 0))) >=
        (12 * (5 + (ReapAndSow:IsEquipped(15) or 0))) and
        Player:CanCast(ReapSouls)
        then
            Player:Cast(ReapSouls)
        end
        if
        LifeTap:Exists() and EmpoweredLifeTap:Exists() and CDOptionEnabled("强化生命分流") and
        Player:BuffRemains(EmpoweredLifeTapBuff) <= GCDmax and
        Player:CanCast(LifeTap)
        then
            Player:Cast(LifeTap)
            return
        end
        if
        PhantomSingularity:Exists() and CDOptionEnabled("诡异魅影") and
        TargetEnemies_15y >= GetSecondOptionValue("诡异魅影") and
        Target:CanCast(PhantomSingularity)
        then
            Target:Cast(PhantomSingularity)
            return
        end
        if Agony:Exists() then
            if
            Target:DebuffRemains(Agony) < 5.4 and Target:TimeToDie() >= Target:DebuffRemains(Agony) and
            Target:CanCast(Agony)
            then
                Target:Cast(Agony)
                return
            end
            if AgonyUnit and AgonyUnit:DebuffRemains(Agony) and AgonyUnit:CanCast(Agony) then
                AgonyUnit:Cast(Agony)
                return
            end
            if AgonyUnit and AgonyUnit:CanCast(Agony) then
                AgonyUnit:Cast(Agony)
                return
            end
        end
        if
        LifeTap:Exists() and EmpoweredLifeTap:Exists() and CDOptionEnabled("强化生命分流") and
        Player:BuffRemains(EmpoweredLifeTapBuff) <= 20 * 0.3 or
        MaleficGrasp:Exists() and Player:ManaPercentage() < 10 and Player:CanCast(LifeTap)
        then
            Player:Cast(LifeTap)
            return
        end
        if
        SiphonLife:Exists() and SiphonLifeUnit3 and
        SiphonLifeUnit3:DebuffRemains(Haunt) >= UnstableAfflictionTickTime * 6 and
        SiphonLifeUnit3:CanCast(SiphonLife)
        then
            SiphonLifeUnit3:Cast(SiphonLife)
            return
        end
        if
        SeedOfCorruption:Exists() and IsOptionEnabled("腐蚀之种 AoE") and
        Player:SoulShards() >= GetOptionValue("腐蚀之种 AoE") and
        (SoCEnemiesCount >= SoCEnemiesOption or
        (SoCEnemiesCount >= SoCEnemiesOption and
        Target:CorruptionRemains() <= SeedOfCorruption:CastTime() + SeedOfCorruption:TravelTime())) and
        Target:CanCast(SeedOfCorruption)
        then
            Target:Cast(SeedOfCorruption)
            SeedOfCorruption.LastCastTime = GetTime()
            return
        end
        if
        CorruptionUnit and CorruptionUnit:DebuffRemains(Haunt) >= UnstableAfflictionTickTime * 6 and
        CorruptionUnit:CanCast(Corruption)
        then
            CorruptionUnit:Cast(Corruption)
            return
        end
        if
        UnstableAffliction:Exists() and #Enemies_40y > 1 and Player:SoulShards() >= 2 and
        (not SowTheSeeds:Exists() or SoCEnemiesCount < SoCEnemiesOption) and
        SoCEnemiesCount < SoCEnemiesOption and
        ContagionUnit and
        ContagionUnit:UnstableAfflictionCount(UnstableAffliction:CastTime()) <= 0 and
        ContagionUnit:CanCast(UnstableAffliction)
        then
            ContagionUnit:Cast(UnstableAffliction)
            return
        end
        if
        UnstableAffliction:Exists() and (#Enemies_40y > 1 or PowerCordOfLethtendris:IsEquipped(6)) and
        (not SowTheSeeds:Exists() or SoCEnemiesCount < SoCEnemiesOption) and
        SoCEnemiesCount < SoCEnemiesOption and
        Contagion:Exists() and
        Target:UnstableAfflictionCount(UnstableAffliction:CastTime()) <= 0 and
        Target:CanCast(UnstableAffliction)
        then
            Target:Cast(UnstableAffliction)
            return
        end
        if
        UnstableAffliction:Exists() and (not SowTheSeeds:Exists() or SoCEnemiesCount < SoCEnemiesOption) and
        SoCEnemiesCount < SoCEnemiesOption and
        (Player:SoulShards() >= 4 or Player:Buff(SoulHarvest) or Player:Buff(DeadwindHarvester) or
        Target:TimeToDie() <= 20 or
        Player:Buff(ConcordanceOfTheLegionfall) or
        self:GetSoCEnemiesOptionValue()) and
        Target:CanCast(UnstableAffliction)
        then
            Target:Cast(UnstableAffliction)
            return
        end
        if
        ReapSouls:Exists() and IsOptionEnabled("夺魂") and
        (CooldownsAllowed() or GetSecondOptionValue("夺魂") == "无条件使用") and
        Player:Buff(TormentedSouls) and
        not Player:Buff(DeadwindHarvester) and
        UARunning > 1 and
        Player:BuffCount(TormentedSouls) > 1 and
        Player:CanCast(ReapSouls)
        then
            Player:Cast(ReapSouls)
        end
        if
        ReapSouls:Exists() and IsOptionEnabled("夺魂") and
        (CooldownsAllowed() or GetSecondOptionValue("夺魂") == "无条件使用") and
        Player:Buff(TormentedSouls) and
        not Player:Buff(DeadwindHarvester) and
        self.PrevGCD[1] == "痛苦无常" and
        Player:BuffCount(TormentedSouls) > 1 and
        Player:CanCast(ReapSouls)
        then
            Player:Cast(ReapSouls)
        end
        if
        LifeTap:Exists() and Player:ManaPercentage() <= 10 and Player:HealthPercentage() >= 30 and
        Player:CanCast(LifeTap)
        then
            Player:Cast(LifeTap)
            return
        end
        if DrainSoul:Exists() and Target:CanCast(DrainSoul) then
            if Player:Channeling(DrainSoul) then
                return
            end
            if not Player:IsMoving() and Target:CanCast(DrainSoul) then
                DrainFiller = true
                Target:Cast(DrainSoul)
                return
            end
        end
        if
        LifeTap:Exists() and Player:ManaPercentage() <= 65 and Player:HealthPercentage() >= 30 and
        Player:CanCast(LifeTap)
        then
            Player:Cast(LifeTap)
            return
        end
    end
end
function Rotation:OutOfCombat()
    SetOutput("痛苦无常:", "0")
    self:PetsManager()
    if
    IsOptionEnabled("制造治疗石") and Player:Standing() > 0.25 and not Healthstone:InStock() and
    CreateHealthstone:TimeSinceCast() >= 4 and
    Player:CanCast(CreateHealthstone)
    then
        CreateHealthstone.LastCastTime = GetTime()
        Player:Cast(CreateHealthstone)
        return
    end
    if
    BurningRush:Exists() and not Player:Buff(BurningRush) and IsOptionEnabled("爆燃冲刺") and
    Player:HealthPercentage() >= GetOptionValue("爆燃冲刺") and
    Player:Moving() > GetSecondOptionValue("爆燃冲刺") and
    Player:CanCast(BurningRush)
    then
        Player:Cast(BurningRush)
        return
    end
    if
    BurningRush:Exists() and Player:Buff(BurningRush) and IsOptionEnabled("爆燃冲刺") and
    (Player:HealthPercentage() < GetOptionValue("爆燃冲刺") or Player:Standing() > 1) and
    Player:CanCast(BurningRush)
    then
        Player:Cast(BurningRush)
        return
    end
    if IsOptionEnabled("自动进入战斗") and Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        local EngageSpell = Agony
        if EngageSpell:Exists() and Target:CanCast(EngageSpell) then
            Target:Cast(EngageSpell)
            return
        end
    end
end
SetRotation(266, {})
local Rotation = Rotations[266]
function Rotation:Initialize()
    Healthstone = Item(5512, false, false, true)
    ArcaneTorrent = Spell(28730, false, false, true)
    Berserking = Spell(26297, false, false, true)
    BloodFury = Spell(33702, false, false, true)
    BurningRush = Spell(111400)
    CallDreadstalkers = Spell(104316, false, true, false)
    ChaosWave = Spell(129346, false, true, true)
    CreateHealthstone = Spell(6201, false, false, false)
    DarkPact = Spell(108416, false, false, true)
    DrainLife = Spell(689, false, true, false)
    Demonbolt = Spell(157695, false, true, false)
    DemonboltInstant = Spell(157695, false, true, true)
    DemonicCalling = Spell(205146)
    DemonicEmpowerment = Spell(193396, false, false, false)
    DemonicSynergy = Spell(171982)
    Demonwrath = Spell(193440, false, false, true)
    Doom = Spell(603, false, true, true)
    Felstorm = Spell(89751, false, true, true)
    GuardianDoomguard = Spell(18540, false, true, true)
    GuardianInfernal = Spell(157898, false, true, true)
    GrimoreOfService = Spell(108501, false, false, true)
    GrimoreOfSupremacy = Spell(152107, false, true, true)
    GrimoreOfSynergy = Spell(171975, false, true, true)
    GrimoreOfImp = Spell(111859, false, true, true)
    GrimoreOfVoid = Spell(111895, false, true, true)
    GrimoreOfSuccubus = Spell(111896, false, true, true)
    GrimoreOfFelHunter = Spell(111897, false, true, true)
    GrimoreOfFelguard = Spell(111898, false, true, true)
    HandOfDoom = Spell(196283)
    HandOfGuldan = Spell(105174, false, true, false)
    HealthFunnel = Spell(755, false, false, false)
    Implosion = Spell(196277, false, true, true)
    LifeTap = Spell(1454, false, false, true)
    MortalCoil = Spell(6789, false, true, true)
    PowerTrip = Spell(196605)
    ShadowBolt = Spell(686, true, true, false)
    ShadowBoltInstant = Spell(686, true, true, true)
    Shadowflame = Spell(205181, false, true, true)
    ShadowLock = Spell(171138, false, true, true)
    ShadowyInspiration = Spell(196269)
    ShadowyInspirationBuff = Spell(196606)
    SindoreiSpite = Spell(208871)
    SoulConduit = Spell(215941)
    SoulHarvest = Spell(196098, false, false, true)
    Soulstone = Spell(20707, false, false, false, true)
    SpellLock = Spell(19647, false, true, true)
    SummonDarkglare = Spell(205180, false, false, true)
    SummonDoomguard = Spell(157757, false, false, false)
    SummonFelguard = Spell(30146, false, false, false)
    SummonFelhunter = Spell(691, false, false, false)
    SummonImp = Spell(688, false, false, false)
    SummonInfernal = Spell(157898, false, false, false)
    SummonSuccubus = Spell(712, false, false, false)
    SummonVoidwalker = Spell(697, false, false, false)
    ThalkielsConsumption = Spell(211714, false, true, true)
    UnendingBreath = Spell(5697, false, false, true)
    UnendingResolve = Spell(104773, false, false, true)
    Wrathstorm = Spell(115831, false, true, true)
    BreathOfThalkiel = Spell(221882)
    SummonersProwess = Spell(211108)
    SwarmsOfTheBlackHarvest = Spell(241252)
    ThalkielsAscendance = Spell(238145)
    ThalkielsLingeringPower = Spell(214935)
    T19P4 = Spell(212007)
    AddPage("常规")
    AddPage("进攻")
    AddPage("防御")
    AddCommonOptions()
    AddPresetOption("常规", "Caster", nil, false)
    AddSection("常规", "移动", "Yellow")
    AddNewOption(
    "常规",
    "爆燃冲刺",
    222,
    true,
    { 50, 1, 100, 1 },
    { 1.5, 0, 10, 0.1 },
    "Use Burning Rush on player. Burning Rush will be stopped when the Player falls under the Health Threshold (Value 1)." ..
    C.TOOLTIP_VALUE_1 ..
    "Minimum Health of Player in Percent to use Burning Rush." ..
    C.TOOLTIP_VALUE_2 .. "Time, in seconds, to wait when you start moving to use it."
    )
    AddSection("常规", "灵魂石", "Yellow")
    AddNewOption(
    "常规",
    "灵魂石",
    210,
    true,
    nil,
    nil,
    "Enable to automatically resurrect targeted dead player targets in combat."
    )
    AddNewOption(
    "常规",
    "给坦克绑灵魂石",
    220,
    false,
    { 1.2, 0, 3, 0.1 },
    nil,
    "Enable to use the Soulstone to resuscitate a dead tank" .. C.TOOLTIP_VALUE .. "Set the delay before using it."
    )
    AddSection("常规", "恶魔管理", "Yellow")
    AddNewOption(
    "常规",
    "恶魔",
    230,
    true,
    { 2, "末日守卫", "Felguard", "Felhunter", "Imp", "地狱火", "Succubus", "Voidwalker" },
    nil,
    "Enable pet management." .. C.TOOLTIP_VALUE .. "Choose demon to use."
    )
    AddNewOption(
    "常规",
    "生命通道",
    220,
    true,
    { 35, 1, 100, 5 },
    nil,
    "Use Health Funnel to heal our demon." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddPresetOption("进攻")
    AddSection("进攻", "大技能", "Yellow")
    AddPresetOption("Cooldown", "末日守卫")
    AddPresetOption("Cooldown", "地狱火")
    AddPresetOption(
    "Cooldown",
    "统御魔典",
    1,
    { 1, "Felguard", "Felhunter", "Imp", "Succubus", "Voidwalker" },
    "Choose demon to use."
    )
    AddPresetOption("Cooldown", "灵魂收割")
    AddSection("进攻", "能力", "Yellow")
    AddNewOption(
    "进攻",
    "内爆",
    230,
    true,
    { 1, "保持", "Agressive" },
    nil,
    "Enable to automatically use Implosion." ..
    C.TOOLTIP_VALUE_1 ..
    "Don't use Implosion when there are more than 4 Imps with different runtime." ..
    C.TOOLTIP_VALUE_2 ..
    "Use Implosion Implosion is useful. Doesn't mind if there are long remaining Imps out."
    )
    AddNewOption(
    "进攻",
    "恶魔之怒",
    232,
    true,
    { 1, "无条件使用", "Not Moving", "移动时" },
    { 3, 1, 12, 1 },
    "Use Demonwrath." ..
    C.TOOLTIP_VALUE_1 ..
    "Choose if you want to use Demonwrath always or only while moving or just for AoE while standing." ..
    C.TOOLTIP_VALUE_2 ..
    "Amount of units that need to be within 8 yards around out target to use Demowrath."
    )
    AddNewOption(
    "进攻",
    "魔刃风暴 | 愤怒风暴",
    232,
    true,
    { 1, "无条件使用", "大技能用法" },
    { 1, 1, 5, 1 },
    "Use Felstorm." ..
    C.TOOLTIP_VALUE_1 ..
    C.TOOLTIP_SUBVALUE("无条件使用", true) ..
    "Will use the ability even if CDs are disabled." ..
    C.TOOLTIP_SUBVALUE("大技能用法") ..
    "Will only use the ability if CDs are enabled." ..
    C.TOOLTIP_VALUE_2 .. "Amount of units that needs to be in range to use."
    )
    AddNewOption(
    "进攻",
    "萨奇尔的消耗",
    220,
    true,
    { 250, 50, 2500, 10 },
    nil,
    "Use Thal'kiel's Consumption." .. C.TOOLTIP_VALUE_1 .. "Amount of damage needed to use."
    )
    AddNewOption(
    "进攻",
    "多重 末日降临",
    222,
    false,
    { 6, 1, 10, 1 },
    { 5, 0, 25, 0.1 },
    "Multi-Dot Doom Cycle." ..
    C.TOOLTIP_VALUE_1 ..
    "Number of dots to apply." ..
    C.TOOLTIP_VALUE_2 ..
    "Minimum health (in million) to apply." ..
    C.TOOLTIP_HINT(
    "Doom on Target will always be applied as long as the Target has more than 12 seconds to live and we do not have the Hand of Doom talent."
    )
    )
    AddPresetOption("防御")
    AddNewOption(
    "防御",
    "制造治疗石",
    210,
    true,
    nil,
    nil,
    "Will create you a new healthstone if you have none in your bags and are out of combat."
    )
    AddSection("防御", "能力", "Yellow")
    AddNewOption(
    "防御",
    "黑暗契约",
    220,
    true,
    { 40, 1, 100, 1 },
    nil,
    "Use Dark Bargain." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddNewOption(
    "防御",
    "吸取生命",
    220,
    true,
    { 20, 1, 75, 1 },
    nil,
    "Use Drain Life." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddNewOption(
    "防御",
    "死亡缠绕",
    220,
    true,
    { 50, 1, 100, 1 },
    nil,
    "Use Mortal Coil." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddNewOption(
    "防御",
    "不灭决心",
    220,
    true,
    { 40, 1, 100, 1 },
    nil,
    "Use Dark Unending Resolve." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddOutput("小鬼 / 恐惧猎犬 / 恶魔:")
    AddOutput("萨奇尔的消耗 伤害量:")
    SetOutput("小鬼 / 恐惧猎犬 / 恶魔:", "0 / 0 / 0")
    SetOutput("萨奇尔的消耗 伤害量:", "0 (0)")
    ISCL = {
        [CallDreadstalkers:ID()] = "Call Dreadstalkers",
        [Demonbolt:ID()] = "Demonbolt",
        [DemonicEmpowerment:ID()] = "Demonic Empowerment",
        [HandOfGuldan:ID()] = "Hand of Gul'dan",
        [ShadowBolt:ID()] = "Shadow Bolt",
        [ThalkielsConsumption:ID()] = "Thal'kiels Consumption"
    }
    DoomTime, PetTimer = 20, 0
end
function Rotation:Events()
    DemonTable = {}
    DemonCount = {}
    LastCast = nil
    ShouldEmpowerDemons = false
    self.PrevGCD = {}
    EventFrame:RegisterForSelfCombatEvent(
    function(...)
        SpellID = select(12, ...)
    end,
    "SPELL_CAST_SUCCESS"
    )
    local GCDSpells = {
        [980] = "Agony",
        [111400] = "爆燃冲刺",
        [104316] = "Call Dreadstalkers",
        [172] = "Corruption",
        [108416] = "黑暗契约",
        [48018] = "Demonic Circle",
        [603] = "Doom",
        [198590] = "Drain Soul",
        [5782] = "Fear",
        [108503] = "Grimoire of Sacrifice",
        [111897] = "Grimoire: FelHunter",
        [111859] = "Grimoire: Imp",
        [111896] = "Grimoire: Succubus",
        [111895] = "Grimoire: Voidwalker",
        [105174] = "Hand of Gul'dan",
        [755] = "生命通道",
        [5484] = "Howl of Terror",
        [1454] = "Life Tap",
        [6789] = "死亡缠绕",
        [205179] = "诡异魅影",
        [216698] = "夺魂",
        [27243] = "Seed of Corruption",
        [63106] = "Siphon Life",
        [20707] = "灵魂石",
        [205180] = "Summon Darkglare",
        [688] = "Summon Imp",
        [697] = "Summon Voidwalker",
        [691] = "Summon Felhunter",
        [712] = "Summon Succubus",
        [157757] = "Summon Doomguard",
        [18540] = "Summon Doomguard",
        [157898] = "Summon Infernal",
        [1122] = "Summon Infernal",
        [30108] = "痛苦无常",
        [688] = "Summon Imp",
        [688] = "Summon Imp",
        [688] = "Summon Imp"
    }
    EventFrame:RegisterForSelfCombatEvent(
    function(...)
        SpellID = select(12, ...)
        DestGUID = select(8, ...)
        SummonTime = GetTime()
        DreadTime = HasT19_4Pc and 16 or 12
        Pointer = false
        if SpellID == 196273 or SpellID == 196274 or SpellID == 104317 or SpellID == 196271 then
            DieTime = SummonTime + 12
            DemonTable[DestGUID] = { "Imp", false, SummonTime, DieTime, SpellID, Pointer, 0 }
        end
        if SpellID == 193331 or SpellID == 193332 then
            DieTime = SummonTime + DreadTime
            DemonTable[DestGUID] = { "Dreadstalker", false, SummonTime, DieTime, SpellID, Pointer, 0 }
        end
        if SpellID == 30146 then
            DieTime = math.huge
            DemonTable[DestGUID] = { "Felguard", false, SummonTime, DieTime, SpellID, Pointer, 0 }
        end
        if SpellID == 205180 then
            DieTime = SummonTime + 12
            DemonTable[DestGUID] = { "Darkglare", false, SummonTime, DieTime, SpellID, Pointer, 0 }
        end
        if SpellID == 60478 or SpellID == 1122 then
            DieTime = SummonTime + 25
            DemonTable[DestGUID] = { "DoomguardInfernal", false, SummonTime, DieTime, SpellID, Pointer, 0 }
        end
        if SpellID == 111859 or SpellID == 111895 or SpellID == 111896 or SpellID == 111897 or SpellID == 111898 then
            DieTime = SummonTime + 25
            DemonTable[DestGUID] = { "Service", false, SummonTime, DieTime, SpellID, Pointer, 0 }
        end
    end,
    "SPELL_SUMMON"
    )
    EventFrame:RegisterForCombatEvent(
    function(...)
        DestGUID = select(8, ...)
        if DemonTable[DestGUID] then
            DemonTable[DestGUID] = nil
        end
    end,
    "UNIT_DIED"
    )
    EventFrame:RegisterForSelfCombatEvent(
    function(...)
        SpellID = select(12, ...)
        if SpellID == 196277 then
            for index, subtable in pairs(DemonTable) do
                if subtable[1] == "Imp" then
                    DemonTable[index] = nil
                end
                DemonCount.Imp = 0
            end
            DemonCount.Imp = 0
            ImpRemainingTime = 99
        end
    end,
    "SPELL_CAST_SUCCESS"
    )
    EventFrame:RegisterForSelfCombatEvent(
    function(...)
        SpellID = select(12, ...)
        if SpellID == 193396 then
            for index, subtable in pairs(DemonTable) do
                DemonTable[index][2] = true
            end
        end
        ShouldEmpowerDemons = false
    end,
    "SPELL_CAST_SUCCESS"
    )
    EventFrame:RegisterForSelfCombatEvent(
    function(...)
        SpellID = select(12, ...)
        if SpellID == 105174 then
            LastCast = "HandOfGuldan"
            ShouldEmpowerDemons = true
        elseif SpellID == 104316 then
            LastCast = "CallDreadstalkers"
        elseif SpellID == 205180 then
            LastCast = "SummonDarkglare"
        elseif SpellID == 196277 then
            LastCast = "内爆"
        else
            LastCast = nil
        end
    end,
    "SPELL_CAST_SUCCESS"
    )
    Rotation.FelstormRefresh = 0
    Rotation.FelstormFrame = CreateFrame("Frame")
    function Rotation.FelstormFunction()
        if
        EngineRunning and GetSpecialization() == 2 and IsOptionEnabled("魔刃风暴 | 愤怒风暴") and
        (CooldownsAllowed() or GetOptionValue("魔刃风暴 | 愤怒风暴") == "无条件使用") and
        PlayerPet:Exists()
        then
            if Rotation.FelstormRefresh < GetTime() then
                Rotation.FelstormEnemies = #PlayerPet:EnemiesWithinDistance(8, true)
                Rotation.FelstormRefresh = GetTime() + 0.25
            end
            if PlayerPet:Exists() and Rotation.FelstormEnemies >= GetSecondOptionValue("魔刃风暴 | 愤怒风暴") then
                if Felstorm:PetKnown() and not Wrathstorm:PetKnown() and Target:PetCanCast(Felstorm) then
                    Target:Cast(Felstorm)
                end
                if Wrathstorm:PetKnown() and not Felstorm:PetKnown() and Target:PetCanCast(Wrathstorm) then
                    Target:Cast(Wrathstorm)
                end
            end
        end
    end
    Rotation.FelstormFrame:SetScript("OnUpdate", Rotation.FelstormFunction)
end
function Rotation:TKCRefresh()
    TKCDamage = 0
    local TKCHealthRatio = 0.08
    local BreathOfThalkielLevel = BreathOfThalkiel:ArtifactRank()
    local SummonersProwessLevel = SummonersProwess:ArtifactRank()
    local ThalkielsLingeringPowerLevel = ThalkielsLingeringPower:ArtifactRank()
    local SwarmsOfTheBlackHarvestLevel = SwarmsOfTheBlackHarvest:ArtifactRank()
    local DemonicEmpowermentRatio = 1 + 0.2 + SummonersProwessLevel * 0.02
    local PlayerHP = Player:MaxHealth()
    local TKCDamage = 0
    TKCMax = TKCMax or 0
    local DemonMultiplier = {
        [196273] = 0.15,
        [196274] = 0.15,
        [104317] = 0.15,
        [196271] = 0.15,
        [193331] = 0.4,
        [193332] = 0.4,
        [205180] = 0.4,
        [60478] = 0.4,
        [1122] = 0.5,
        [111859] = 0.3,
        [111895] = 0.5,
        [111897] = 0.4,
        [111896] = 0.4,
        [111898] = 0.5,
        [30146] = 0
    }
    local function GetDemonHealth(DemonID, IsEmpowered)
        local DemonHealth = DemonMultiplier[DemonID] * PlayerHP
        if IsEmpowered then
            DemonHealth = DemonHealth * DemonicEmpowermentRatio
        end
        return DemonHealth
    end
    for index, subtable in pairs(DemonTable) do
        if subtable[4] - ThalkielsConsumption:CastTime() > GetTime() then
            TKCDamage = TKCDamage + GetDemonHealth(subtable[5], subtable[2])
        end
    end
    if PlayerPet:Exists() then
        TKCDamage = TKCDamage + PlayerPet:MaxHealth()
    end
    TKCDamage = TKCDamage * TKCHealthRatio
    if BreathOfThalkielLevel > 0 then
        TKCDamage = TKCDamage * (1 + BreathOfThalkielLevel * 0.05)
    end
    if ThalkielsLingeringPowerLevel > 0 then
        TKCDamage = TKCDamage * (1 + ThalkielsLingeringPowerLevel * 0.05)
    end
    if SwarmsOfTheBlackHarvestLevel > 0 then
        TKCDamage = TKCDamage * (1 + SwarmsOfTheBlackHarvestLevel * 0.1)
    end
    TKCDamage = TKCDamage * (1 + Player:Versatility() / 100)
    if Player:Buff(DemonicSynergy) then
        TKCDamage = TKCDamage * 1.4
    end
    if Player:Buff(SoulHarvest) then
        TKCDamage = TKCDamage * 1.2
    end
    if Player:Buff(SindoreiSpite) then
        TKCDamage = TKCDamage * 1.3
    end
    if TKCDamage > TKCMax then
        TKCMax = TKCDamage
    end
    SetOutput("萨奇尔的消耗 伤害量:", (math.round(TKCDamage * 0.001, 0) .. "K (" .. math.round(TKCMax * 0.001, 0) .. "K)"))
    return TKCDamage or 0
end
function Rotation:DemonTableRefresh()
    DemonCount.Imp,
    DemonCount.Dreadstalker,
    DemonCount.Felguard,
    DemonCount.Darkglare,
    DemonCount.DoomguardInfernal,
    DemonCount.Service = 0, 0, 0, 0, 0, 0
    NoDemonicEmpowermentImps, DemonicEmpowermentImps = 0, 0
    NoDemonicEmpowermentDreadstalkers, DemonicEmpowermentDreadstalkers = 0, 0
    ImpRemainingTime = ImpRemainingTime or 99
    local DemonwrathUnitsTable = {}
    DemonwrathUnits = 0
    Demons = 0
    if DemonTable ~= nil then
        for index, subtable in pairs(DemonTable) do
            if subtable[4] <= GetTime() then
                if subtable[1] == "Imp" then
                    ImpRemainingTime = 99
                end
                DemonTable[index] = nil
            end
            if subtable[6] == false then
                if
                (Unlocker == "FireHack" or Unlocker == "EWT") and not LastCast == "内爆" and
                subtable[3] + 0.2 <= GetTime() and
                OE(GOWG(index))
                then
                    subtable[6] = GOWG(index)
                    subtable[7] = Unit(subtable[6]):EnemiesWithinDistance(10, true)
                    for k, v in pairs(subtable[7]) do
                        DemonwrathUnitsTable[k] = v
                    end
                elseif not (Unlocker == "FireHack" or Unlocker == "EWT") then
                    subtable[6] = index
                    subtable[7] = Unit(subtable[6]):EnemiesWithinDistance(10, true)
                    for k, v in pairs(subtable[7]) do
                        DemonwrathUnitsTable[k] = v
                    end
                end
            end
            if subtable[1] == "Imp" then
                DemonCount.Imp = DemonCount.Imp + 1
                if subtable[2] == false then
                    NoDemonicEmpowermentImps = NoDemonicEmpowermentImps + 1
                end
                if subtable[2] == true then
                    DemonicEmpowermentImps = DemonicEmpowermentImps + 1
                end
                if
                GetOptionValue("内爆") == "Agressive" or
                DemonCount.Imp <= 4 and subtable[4] - GetTime() < ImpRemainingTime
                then
                    ImpRemainingTime = subtable[4] - GetTime()
                end
                if GetOptionValue("内爆") == "保持" and DemonCount.Imp > 4 and subtable[4] - GetTime() > ImpRemainingTime then
                    ImpRemainingTime = subtable[4] - GetTime()
                end
            end
            if DemonCount.Imp <= 0 or ImpRemainingTime <= 0 then
                ImpRemainingTime = 99
            end
            if subtable[1] == "Dreadstalker" then
                DemonCount.Dreadstalker = DemonCount.Dreadstalker + 1
                if subtable[2] == false then
                    ShouldEmpowerDemons = true
                    NoDemonicEmpowermentDreadstalkers = NoDemonicEmpowermentDreadstalkers + 1
                end
                if subtable[2] == true then
                    DemonicEmpowermentDreadstalkers = DemonicEmpowermentDreadstalkers + 1
                end
            end
            if subtable[1] == "Darkglare" then
                DemonCount.Darkglare = DemonCount.Darkglare + 1
                if subtable[2] == false then
                    ShouldEmpowerDemons = true
                end
            end
            if subtable[1] == "DoomguardInfernal" then
                DemonCount.DoomguardInfernal = DemonCount.DoomguardInfernal + 1
                if subtable[2] == false then
                    ShouldEmpowerDemons = true
                end
            end
            if subtable[1] == "Service" then
                DemonCount.Service = DemonCount.Service + 1
                if subtable[2] == false then
                    ShouldEmpowerDemons = true
                end
            end
        end
        Demons =         DemonCount.Imp + DemonCount.Dreadstalker + DemonCount.Felguard + DemonCount.Darkglare +
        DemonCount.DoomguardInfernal +
        DemonCount.Service
        if PlayerPet:Exists() then
            Demons = Demons + 1
        end
        if PlayerPet:Exists() then
            for k, v in pairs(PlayerPet:EnemiesWithinDistance(10, true)) do
                DemonwrathUnitsTable[k] = v
            end
        end
        DemonwrathUnits = #DemonwrathUnitsTable
    end
    self:TKCRefresh()
    SetOutput(
    "小鬼 / 恐惧猎犬 / 恶魔:",
    DemonCount.Imp ..
    "(" ..
    DemonicEmpowermentImps ..
    ") / " .. DemonCount.Dreadstalker .. "(" .. DemonicEmpowermentDreadstalkers .. ") / " .. Demons
    )
end
function Rotation:Pulse()
    self:DemonTableRefresh()
    if
    (Player:Channeling(Demonwrath) and not Player:IsMoving() and Player:SoulShards() < 4 and ImpRemainingTime >= 3) or
    Player:IsMounted() or
    Player:InVehicle() or
    Player:IsEating() or
    (Player:Channeling(DrainLife) and Player:HealthPercentage() < GetOptionValue("吸取生命") + 15)
    then
        return
    end
    if Target:Exists() and BMPullTime() < 5 then
        self:Opening()
        return
    end
    if GetTime() < Rotation.SpamPrevention then
        return
    end
    Rotation.SpamPrevention = GetTime() + 0.05
    Target = Unit.Target
    local InCombat = Player:IsInCombat()
    if not InCombat then
        self:OutOfCombat()
        return
    end
    if InCombat then
        self:Defensives()
    end
    Target = Player:ReTarget(ShadowBolt, true) or Unit.Target
    if Target:Exists() then
        Rotations:RefreshUnitTables(Rotation.Identifier)
        self:Interrupts()
        if
        IsOptionEnabled("开怪技能") and
        (GetOptionValue("开怪技能") == "无条件使用" or (GetOptionValue("开怪技能") == "打BOSS使用" and Target:IsBoss()) or
        (GetOptionValue("开怪技能") == "CDs Only" and CooldownsAllowed())) and
        not OpenerEnded
        then
            self:Opener()
            return
        elseif CombatTime() > 10 then
            OpenerEnded = true
        end
        self:OffGCDAbilities()
        if Player:GlobalCooldown() == 0 and Player:IsReady() then
            self:Combat()
        end
    end
end
function Rotation:Opening()
    Player:UsePotions("智力药水", GetSecondOptionValue("抢先使用药水"))
    if IsOptionEnabled("抢先施放(需DBM插件)") then
        OpenerSpell = Demonbolt:Exists() and Demonbolt or ShadowBolt
        if BMPullTime() < GetSecondOptionValue("抢先施放(需DBM插件)") and Target:CanCast(OpenerSpell) then
            Target:Cast(OpenerSpell)
            return
        end
        if
        DemonicEmpowerment:Exists() and
        BMPullTime() < GetSecondOptionValue("抢先施放(需DBM插件)") + DemonicEmpowerment:CastTime() and
        DemonicEmpowerment:TimeSinceCast() > 3 and
        Player:CanCast(DemonicEmpowerment)
        then
            DemonicEmpowerment.LastCastTime = GetTime()
            Player:Cast(DemonicEmpowerment)
            return
        end
    end
end
function Rotation:Opener()
    self.ChoosenOpener = nil
    if Player:GlobalCooldown() == 0 then
        if self.ChoosenOpener ~= nil then
            OpenerParser(self.ChoosenOpener)
        else
            Bug("Invalid Talents combination, Opener will not be used.")
            OpenerEnded = true
        end
    end
end
function Rotation:Defensives()
    Player:UseHealingItem()
    if
    MortalCoil:Exists() and IsOptionEnabled("死亡缠绕") and Target:Exists() and Target:CanCast(MortalCoil) and
    Player:HealthPercentage() <= GetOptionValue("死亡缠绕")
    then
        Target:Cast(MortalCoil)
    end
    if
    DarkPact:Exists() and IsOptionEnabled("黑暗契约") and Player:CanCast(DarkPact) and
    Player:HealthPercentage() <= GetOptionValue("黑暗契约")
    then
        Player:Cast(DarkPact)
        return
    end
    if
    UnendingResolve:Exists() and IsOptionEnabled("不灭决心") and Player:CanCast(UnendingResolve) and
    Player:HealthPercentage() <= GetOptionValue("不灭决心")
    then
        Player:Cast(UnendingResolve)
        return
    end
    if DrainLife:Exists() and IsOptionEnabled("吸取生命") then
        if Player:Channeling(DrainLife) and Player:HealthPercentage() > GetOptionValue("吸取生命") + 15 then
            Bug("Stop Chanelling Drain Life as Health threshold was reach.")
            SpellStopCasting()
        end
        if Player:Channeling(DrainLife) then
            return
        end
        if Player:HealthPercentage() < GetOptionValue("吸取生命") and Target:CanCast(DrainLife) then
            Target:Cast(DrainLife)
            return
        end
    end
end
function Rotation:Interrupts()
    local PetInterrupt = (SpellLock:PetKnown() and SpellLock) or (ShadowLock:PetKnown() and ShadowLock) or nil
    if PetInterrupt then
        Player:UseInterrupt(PetInterrupt, ArcaneTorrent, true)
    end
end
function Rotation:OffGCDAbilities()
end
function Rotation:PetsManager()
    if
    not Player:IsMoving() and IsOptionEnabled("恶魔") and (not PlayerPet:Exists() or PlayerPet:IsDeadOrGhost()) and
    Player:SoulShards() >= 1
    then
        local SelectedPet = GetOptionValue("恶魔")
        local SelectedPetSpell =         SelectedPet == "末日守卫" and GrimoreOfSupremacy:Exists() and SummonDoomguard or
        SelectedPet == "Felhunter" and SummonFelhunter:Exists() and SummonFelhunter or
        SelectedPet == "Imp" and SummonImp:Exists() and SummonImp or
        SelectedPet == "地狱火" and GrimoreOfSupremacy:Exists() and SummonInfernal or
        SelectedPet == "Succubus" and SummonSuccubus:Exists() and SummonSuccubus or
        SelectedPet == "Voidwalker" and SummonVoidwalker:Exists() and SummonVoidwalker or
        SummonFelguard
        if GetTime() - PetTimer >= 1 and Player:CanCast(SelectedPetSpell) then
            Player:Cast(SelectedPetSpell)
            PetTimer = GetTime() + 2.5
        end
    end
    if
    IsOptionEnabled("生命通道") and PlayerPet:Exists() and not PlayerPet:IsDeadOrGhost() and Player:Standing() > 0.25 and
    PlayerPet:HealthPercentage() < GetOptionValue("生命通道") and
    Player:CanCast(HealthFunnel)
    then
        Player:Cast(HealthFunnel)
        return
    end
end
function Rotation:ServicePet()
    if CDOptionEnabled("统御魔典") then
        self.SelectedGrimoire = GetSecondOptionValue("统御魔典")
        self.SelectedGrimoireSpell =         self.SelectedGrimoire == "Felguard" and GrimoreOfFelguard or
        self.SelectedGrimoire == "Felhunter" and GrimoreOfFelHunter or
        self.SelectedGrimoire == "Imp" and GrimoreOfImp or
        self.SelectedGrimoire == "Succubus" and GrimoreOfSuccubus or
        self.SelectedGrimoire == "Voidwalker" and GrimoreOfVoid
        if Target:CanCast(self.SelectedGrimoireSpell) then
            Target:Cast(self.SelectedGrimoireSpell)
            return
        end
    end
end
function Rotation:ServicePetCooldown()
    if GrimoreOfImp:Cooldown() > 0 then
        return GrimoreOfImp:Cooldown()
    elseif GrimoreOfVoid:Cooldown() > 0 then
        return GrimoreOfVoid:Cooldown()
    elseif GrimoreOfSuccubus:Cooldown() > 0 then
        return GrimoreOfSuccubus:Cooldown()
    elseif GrimoreOfFelHunter:Cooldown() > 0 then
        return GrimoreOfFelHunter:Cooldown()
    elseif GrimoreOfFelguard:Cooldown() > 0 then
        return GrimoreOfFelguard:Cooldown()
    end
    return 0
end
function Rotation:UnitTables()
    Enemies_40y = UseAOE() and Player:EnemiesWithinDistance(40) or {}
    Enemies_10y = UseAOE() and Target:EnemiesWithinDistance(10, true) or {}
    Enemies_8y = UseAOE() and Target:FilterEnemiesByDistance(Enemies_10y, 8, true) or {}
    NumEnemies = #Enemies_8y
    NumEnemies8 = #Enemies_8y
    NumEnemies10 = #Enemies_10y
    DoomUnit = UseAOE() and Unit.DotCycle(Enemies_40y, Doom, Doom, DoomTime, "多重 末日降临") or nil
end
function Rotation:Combat()
    GCDMax = Player:GCD()
    DoomTime = 20 / (1 + Player:Haste() / 100)
    if IsOptionEnabled("给坦克绑灵魂石") then
        MainTank, MainTankTarget, OffTank, OffTankTarget = Unit.GetMainTanks()
        if MainTank and MainTank:Exists() and not MainTank:IsDeadOrGhost() then
            MainTankResDelay = nil
        end
        if OffTank and OffTank:Exists() and not OffTank:IsDeadOrGhost() then
            OffTankResDelay = nil
        end
        if
        MainTank and MainTank:Exists() and MainTank:IsDeadOrGhost() and MainTank:IsPlayer() and
        MainTank:CanCast(Soulstone)
        then
            if not MainTankResDelay then
                MainTankResDelay = GetTime()
            end
            if GetTime() - MainTankResDelay >= GetOptionValue("给坦克绑灵魂石") then
                MainTankResDelay = nil
                MainTank:Cast(Soulstone)
                return
            end
        elseif
        OffTank and OffTank:Exists() and OffTank:IsDeadOrGhost() and OffTank:IsPlayer() and
        OffTank:CanCast(Soulstone)
        then
            if not OffTankResDelay then
                OffTankResDelay = GetTime()
            end
            if GetTime() - OffTankResDelay >= GetOptionValue("给坦克绑灵魂石") then
                OffTankResDelay = nil
                OffTank:Cast(Soulstone)
                return
            end
        end
    end
    if
    IsOptionEnabled("灵魂石") and Target:Exists() and Target:IsDeadOrGhost() and not Player:IsMoving() and
    Target:IsPlayer() and
    Target:CanCast(Soulstone)
    then
        Target:Cast(Soulstone)
        return
    end
    self:PetsManager()
    if
    BurningRush:Exists() and not Player:Buff(BurningRush) and IsOptionEnabled("爆燃冲刺") and
    Player:HealthPercentage() >= GetOptionValue("爆燃冲刺") and
    Player:Moving() > GetSecondOptionValue("爆燃冲刺") and
    Player:CanCast(BurningRush)
    then
        Player:Cast(BurningRush)
        return
    end
    if
    BurningRush:Exists() and Player:Buff(BurningRush) and IsOptionEnabled("爆燃冲刺") and
    (Player:HealthPercentage() < GetOptionValue("爆燃冲刺") or Player:Standing() > 1) and
    Player:CanCast(BurningRush)
    then
        Player:Cast(BurningRush)
        return
    end
    if Player:CanAttack(Target) then
        if
        Implosion:Exists() and IsOptionEnabled("内爆") and DemonCount.Imp > 0 and
        ImpRemainingTime <= ShadowBolt:CastTime() and
        (Player:Buff(DemonicSynergy) or SoulConduit:Exists() or (not SoulConduit:Exists() and NumEnemies8 > 1) or
        DemonCount.Imp <= 4) and
        Target:CanCast(Implosion)
        then
            Target:Cast(Implosion)
            return
        end
        if
        Implosion:Exists() and IsOptionEnabled("内爆") and self.PrevGCD[1] == "Hand of Gul'dan" and
        ((ImpRemainingTime <= 3 and Player:Buff(DemonicSynergy)) or (ImpRemainingTime <= 4 and NumEnemies8 > 2)) and
        Target:CanCast(Implosion)
        then
            Target:Cast(Implosion)
            return
        end
        if
        Shadowflame:Exists() and Target:DebuffCount(Shadowflame) >= 1 and
        Target:DebuffRemains(Shadowflame) <= ShadowBolt:CastTime() and
        DemonwrathUnits < GetSecondOptionValue("恶魔之怒") and
        Target:CanCast(Shadowflame)
        then
            Target:Cast(Shadowflame)
            return
        end
        if
        Shadowflame:Exists() and Target:DebuffCount(Shadowflame) >= 2 and Shadowflame:Charges() > 0 and
        Target:CanCast(Shadowflame)
        then
            Target:Cast(Shadowflame)
            return
        end
        if Shadowflame:Exists() and Target:DebuffCount(Shadowflame) >= 1 and Target:DebuffCount(Shadowflame) < 3 then
            if ShadowBolt:CastTime() + 1.5 * Shadowflame:TravelTime() >= Target:DebuffRemains(Shadowflame) then
                Bug("Waiting for next Shadowflame Stack")
                return
            end
        end
        if
        CallDreadstalkers:Exists() and
        ((not SummonDarkglare:Exists() or PowerTrip:Exists()) and (NumEnemies8 < 3 or not Implosion:Exists())) and
        not (Player:SoulShards() == 5 and Player:Buff(DemonicCalling)) and
        Target:CanCast(CallDreadstalkers)
        then
            Target:Cast(CallDreadstalkers)
            return
        end
        if
        Doom:Exists() and IsOptionEnabled("多重 末日降临") and DoomUnit and
        (not HandOfDoom:Exists() or (HandOfDoom:Exists() and DoomUnit:DistanceTo(Target) > 8)) and
        DoomUnit:TimeToDie() > 12 and
        (not DoomUnit:Debuff(Doom) or DoomUnit:DebuffRemains(Doom) < 12 and DoomUnit:DistanceTo(Target) > 8) and
        not (ShouldEmpowerDemons or self.PrevGCD[1] == "Hand of Gul'dan") and
        DoomUnit:CanCast(Doom)
        then
            Bug("Doom on " .. DoomUnit:GUID())
            DoomUnit:Cast(Doom)
            return
        end
        if
        Doom:Exists() and not IsOptionEnabled("多重 末日降临") and not HandOfDoom:Exists() and Target:TimeToDie() > 12 and
        not Target:Debuff(Doom) and
        Target:CanCast(Doom)
        then
            Bug("Doom on Target")
            Target:Cast(Doom)
            return
        end
        if
        GrimoreOfService:Exists() and CDOptionEnabled("统御魔典") and not ShouldEmpowerDemons and
        Target:CanCast(GrimoreOfImp)
        then
            self:ServicePet()
        end
        if
        GuardianDoomguard:Exists() and CDOptionEnabled("末日守卫") and not GrimoreOfSupremacy:Exists() and
        NumEnemies10 <= 2 and
        Target:CanCast(GuardianDoomguard)
        then
            Target:Cast(GuardianDoomguard)
            return
        end
        if
        GuardianInfernal:Exists() and CDOptionEnabled("地狱火") and not GrimoreOfSupremacy:Exists() and
        NumEnemies10 > 2 and
        Target:CanCast(GuardianInfernal)
        then
            Target:Cast(GuardianInfernal)
            return
        end
        if
        ShadowBolt:Exists() and Player:Buff(ShadowyInspirationBuff) and Player:SoulShards() < 5 and
        self.PrevGCD[1] ~= "Doom" and
        Target:CanCast(ShadowBolt)
        then
            Target:Cast(ShadowBolt)
            return
        end
        if
        SummonDarkglare:Exists() and
        (self.PrevGCD[1] ~= "Hand of Gul'dan" or self.PrevGCD[1] ~= "Call Dreadstalkers" or PowerTrip:Exists()) and
        Player:CanCast(SummonDarkglare)
        then
            Player:Cast(SummonDarkglare)
            return
        end
        if
        SummonDarkglare:Exists() and CallDreadstalkers:Cooldown() > 5 and Player:SoulShards() < 3 and
        Player:CanCast(SummonDarkglare)
        then
            Player:Cast(SummonDarkglare)
            return
        end
        if
        SummonDarkglare:Exists() and CallDreadstalkers:Cooldown() <= SummonDarkglare:CastTime() and
        (Player:SoulShards() >= 3 or Player:SoulShards() >= 1 and Player:Buff(DemonicCalling)) and
        Target:CanCast(SummonDarkglare)
        then
            Player:Cast(SummonDarkglare)
            return
        end
        if
        CallDreadstalkers:Exists() and SummonDarkglare:Exists() and (NumEnemies8 < 3 or not Implosion:Exists()) and
        (SummonDarkglare:Cooldown() > 2 or self.PrevGCD[1] == "Summon Darkglare" or
        SummonDarkglare:Cooldown() <= CallDreadstalkers:CastTime() and Player:SoulShards() >= 3 or
        SummonDarkglare:Cooldown() <= CallDreadstalkers:CastTime() and Player:SoulShards() >= 1 and
        Player:Buff(DemonicCalling)) and
        Target:CanCast(CallDreadstalkers)
        then
            Target:Cast(CallDreadstalkers)
            return
        end
        if
        HandOfGuldan:Exists() and Player:SoulShards() >= 4 and
        (((not (ShouldEmpowerDemons or self.PrevGCD[1] == "Hand of Gul'dan") and
        (Demons >= 13 and not ShadowyInspiration:Exists() or Demons >= 6 and ShadowyInspiration:Exists())) or
        not ShouldEmpowerDemons or
        Player:SoulShards() == 5) and
        PowerTrip:Exists()) and
        Target:CanCast(HandOfGuldan)
        then
            Target:Cast(HandOfGuldan)
            return
        end
        if
        HandOfGuldan:Exists() and
        (Player:SoulShards() >= 3 and self.PrevGCD[1] == "Call Dreadstalkers" and
        ThalkielsAscendance:ArtifactRank() <= 0) or
        Player:SoulShards() >= 5 or
        (Player:SoulShards() >= 4 and SummonDarkglare:Cooldown() > 2) and Target:CanCast(HandOfGuldan)
        then
            Target:Cast(HandOfGuldan)
            return
        end
        if
        DemonicEmpowerment:Exists() and
        (((PowerTrip:Exists() and (not Implosion:Exists() or DemonwrathUnits <= 1)) or not Implosion:Exists() or
        (Implosion:Exists() and not SoulConduit:Exists() and DemonwrathUnits <= 3)) and
        (ShouldEmpowerDemons or self.PrevGCD[1] == "Hand of Gul'dan")) or
        (self.PrevGCD[1] == "Hand of Gul'dan" and not ShouldEmpowerDemons and ImpRemainingTime <= 0) or
        (self.PrevGCD[1] == "内爆" and ShouldEmpowerDemons) and Player:CanCast(DemonicEmpowerment)
        then
            Player:Cast(DemonicEmpowerment)
            return
        end
        if
        DemonicEmpowerment:Exists() and ShouldEmpowerDemons or
        self.PrevGCD[1] == "HandOfGuldan" and Player:CanCast(DemonicEmpowerment)
        then
            Player:Cast(DemonicEmpowerment)
            return
        end
        if CDOptionEnabled("进攻性种族技能") then
            Player:UseTrinkets()
            if BloodFury:Exists() and Player:CanCast(BloodFury) then
                Player:Cast(BloodFury)
            end
            if Berserking:Exists() and Player:CanCast(Berserking) then
                Player:Cast(Berserking)
            end
        end
        if SoulHarvest:Exists() and CDOptionEnabled("灵魂收割") and Player:CanCast(SoulHarvest) then
            Player:Cast(SoulHarvest)
            return
        end
        if Player:IsWithinCastRange(Target, Corruption) then
            Player:UsePotions("智力药水")
        end
        if Shadowflame:Exists() and Shadowflame:Charges() >= 2 and DemonwrathUnits < 5 and Target:CanCast(Shadowflame) then
            Target:Cast(Shadowflame)
            return
        end
        if
        ThalkielsConsumption:Exists() and IsOptionEnabled("萨奇尔的消耗") and
        GetOptionValue("萨奇尔的消耗") * 1000 < self:TKCRefresh() and
        Target:CanCast(ThalkielsConsumption, true)
        then
            Target:Cast(ThalkielsConsumption)
            return
        end
        if
        LifeTap:Exists() and Player:ManaPercentage() <= 15 or
        (Player:ManaPercentage() <= 65 and
        ((CallDreadstalkers:Cooldown() <= 0.75 and Player:SoulShards() >= 2) or
        ((CallDreadstalkers:Cooldown() < GCDMax * 2) and
        (GuardianDoomguard:Cooldown() <= 0.75 or self:ServicePetCooldown() <= 0.75) and
        Player:SoulShards() >= 3))) and
        Player:CanCast(LifeTap)
        then
            Player:Cast(LifeTap)
            return
        end
        if
        Demonwrath:Exists() and UseAOE() and IsOptionEnabled("恶魔之怒") and
        (GetOptionValue("恶魔之怒") == "无条件使用" or GetOptionValue("恶魔之怒") == "Not Moving") and
        DemonwrathUnits >= GetSecondOptionValue("恶魔之怒") and
        Player:CanCast(Demonwrath, true)
        then
            Player:Cast(Demonwrath)
            return
        end
        if
        Demonwrath:Exists() and UseAOE() and IsOptionEnabled("恶魔之怒") and
        (GetOptionValue("恶魔之怒") == "无条件使用" or GetOptionValue("恶魔之怒") == "移动时") and
        Player:IsMoving() and
        Player:CanCast(Demonwrath, true)
        then
            Player:Cast(Demonwrath)
            return
        end
        if Demonbolt:Exists() and Target:CanCast(Demonbolt) then
            Target:Cast(Demonbolt)
            return
        end
        if ShadowBolt:Exists() and Player:Buff(ShadowyInspirationBuff) and Target:CanCast(ShadowBolt) then
            Target:Cast(ShadowBolt)
            return
        end
        if
        DemonicEmpowerment:Exists() and ThalkielsAscendance:ArtifactRank() >= 1 and PowerTrip:Exists() and
        not Demonbolt:Exists() and
        ShadowyInspiration:Exists() and
        Player:CanCast(DemonicEmpowerment)
        then
            Player:Cast(DemonicEmpowerment)
            return
        end
        if ShadowBolt:Exists() and Target:CanCast(ShadowBolt) then
            Target:Cast(ShadowBolt)
            return
        end
        if
        (Player:ManaPercentage() <= 40 or (Player:IsMoving() and Player:ManaPercentage() <= 70)) and
        Player:CanCast(LifeTap)
        then
            Player:Cast(LifeTap)
            return
        end
        if Doom:Exists() and IsOptionEnabled("多重 末日降临") and Player:Moving() >= GCDMax and DoomUnit then
            Bug("Doom on " .. DoomUnit:GUID())
            DoomUnit:Cast(Doom)
            return
        end
    end
end
function Rotation:OutOfCombat()
    OpeningSequenceEnded = false
    self:PetsManager()
    TKCMax = 0
    self:DemonTableRefresh()
    if
    IsOptionEnabled("制造治疗石") and Player:Standing() > 0.25 and not Healthstone:InStock() and
    CreateHealthstone:TimeSinceCast() >= 4 and
    Player:CanCast(CreateHealthstone)
    then
        CreateHealthstone.LastCastTime = GetTime()
        Player:Cast(CreateHealthstone)
        return
    end
    if
    BurningRush:Exists() and not Player:Buff(BurningRush) and IsOptionEnabled("爆燃冲刺") and
    Player:HealthPercentage() >= GetOptionValue("爆燃冲刺") and
    Player:Moving() > GetSecondOptionValue("爆燃冲刺") and
    Player:CanCast(BurningRush)
    then
        Player:Cast(BurningRush)
        return
    end
    if
    BurningRush:Exists() and Player:Buff(BurningRush) and IsOptionEnabled("爆燃冲刺") and
    (Player:HealthPercentage() < GetOptionValue("爆燃冲刺") or Player:Standing() > 1) and
    Player:CanCast(BurningRush)
    then
        Player:Cast(BurningRush)
        return
    end
    if IsOptionEnabled("自动进入战斗") and Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        local EngageSpell = Demonbolt:Exists() and Demonbolt or ShadowBolt
        if EngageSpell:Exists() and Target:CanCast(EngageSpell) then
            Target:Cast(EngageSpell)
            return
        end
    end
end
SetRotation(267, {})
local Rotation = Rotations[267]
function Rotation:Initialize()
    Healthstone = Item(5512, false, false, true)
    ArcaneTorrent = Spell(28730, false, false, true)
    Berserking = Spell(26297, false, false, true)
    BloodFury = Spell(33702, false, false, true)
    BackDraft = Spell(196406)
    BackDraftBuff = Spell(117828)
    BurningRush = Spell(111400)
    Cataclysm = Spell(152108, false, true, true)
    ChaosBolt = Spell(116858, true, true, false)
    ChannelDemonfire = Spell(196447, true, true, false)
    Conflagrate = Spell(17962, true, true, true)
    ConflagrationOfChaos = Spell(196546)
    CreateHealthstone = Spell(6201, false, false, false)
    DarkPact = Spell(108416, false, false, true)
    DimensionalRift = Spell(196586, false, true, true)
    DrainLife = Spell(234153, true, true, false)
    Eradication = Spell(196412)
    EradicationDebuff = Spell(196414)
    FireAndBrimstone = Spell(169408)
    GuardianDoomguard = Spell(18540, false, true, true)
    GuardianInfernal = Spell(1122, false, true, true)
    GrimoreOfSacrifice = Spell(108503, false, false, true)
    GrimoreOfSacrificeBuff = Spell(196099)
    GrimoreOfService = Spell(108501, false, false, true)
    GrimoreOfSupremacy = Spell(152107, false, true, true)
    GrimoreOfImp = Spell(111859, false, true, true)
    GrimoreOfVoid = Spell(111895, false, true, true)
    GrimoreOfSuccubus = Spell(111896, false, true, true)
    GrimoreOfFelHunter = Spell(111897, false, true, true)
    Havoc = Spell(80240, false, true, true)
    HealthFunnel = Spell(755, false, false, false)
    Immolate = Spell(348, true, true, true)
    ImmolateDebuff = Spell(157736)
    Incinerate = Spell(29722, true, true, true)
    LifeTap = Spell(1454, false, false, true)
    EmpoweredLifeTap = Spell(235157, false, false, true)
    EmpoweredLifeTapBuff = Spell(235156)
    MortalCoil = Spell(6789, false, true, true)
    RainOfFire = Spell(5740, false, true, true)
    RoaringBlaze = Spell(205184)
    Shadowburn = Spell(17877, true, true, true)
    ShadowLock = Spell(171138, true, true, true)
    SoulHarvest = Spell(196098, false, false, true)
    Soulstone = Spell(20707, false, false, false, true)
    SpellLock = Spell(19647, false, true, true)
    SummonDoomguard = Spell(157757, false, false, false)
    SummonFelhunter = Spell(691, false, false, false)
    SummonImp = Spell(688, false, false, false)
    SummonInfernal = Spell(157898, false, false, false)
    SummonSuccubus = Spell(712, false, false, false)
    SummonVoidwalker = Spell(697, false, false, false)
    UnendingBreath = Spell(5697, false, false, true)
    UnendingResolve = Spell(104773, false, false, true)
    WreakHavoc = Spell(196410)
    LordOfFlames = Spell(224103)
    ConcordanceOfTheLegionfall = Spell(242586)
    Odr = Item(132375)
    LessonsOfSpaceTime = Item(144369)
    LessonsOfSpaceTimeBuff = Spell(236174)
    AddPage("常规")
    AddPage("进攻")
    AddPage("防御")
    AddCommonOptions()
    AddPresetOption("常规", "Caster", nil, false)
    AddSection("常规", "移动", "Yellow")
    AddNewOption(
    "常规",
    "爆燃冲刺",
    222,
    true,
    { 50, 1, 100, 1 },
    { 1.5, 0, 10, 0.1 },
    "Use Burning Rush on player. Burning Rush will be stopped when the Player falls under the Health Threshold (Value 1)." ..
    C.TOOLTIP_VALUE_1 ..
    "Minimum Health of Player in Percent to use Burning Rush." ..
    C.TOOLTIP_VALUE_2 .. "Time, in seconds, to wait when you start moving to use it."
    )
    AddSection("常规", "灵魂石", "Yellow")
    AddNewOption(
    "常规",
    "灵魂石",
    210,
    true,
    nil,
    nil,
    "Enable to automatically resurrect targeted dead player targets in combat."
    )
    AddNewOption(
    "常规",
    "给坦克绑灵魂石",
    220,
    false,
    { 1.2, 0, 3, 0.1 },
    nil,
    "Enable to use the Soulstone to resuscitate a dead tank" .. C.TOOLTIP_VALUE .. "Set the delay before using it."
    )
    AddSection("常规", "恶魔管理", "Yellow")
    AddNewOption(
    "常规",
    "恶魔管理器",
    230,
    true,
    { 3, "末日守卫", "Felhunter", "Imp", "地狱火", "Succubus", "Voidwalker" },
    nil,
    "Enable pet management." .. C.TOOLTIP_VALUE .. "Choose demon to use."
    )
    AddNewOption(
    "常规",
    "生命通道",
    220,
    true,
    { 25, 1, 100, 5 },
    nil,
    "Use Health Funnel to heal our demon." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddPresetOption("进攻")
    AddSection("进攻", "大技能", "Yellow")
    AddPresetOption("Cooldown", "末日守卫")
    AddPresetOption("Cooldown", "统御魔典", 1, { 2, "Felhunter", "Imp", "Succubus", "Voidwalker" }, "Choose demon to use.")
    AddPresetOption("Cooldown", "地狱火")
    AddPresetOption("Cooldown", "强化生命分流", 1)
    AddPresetOption("Cooldown", "灵魂收割")
    AddPresetOption("Cooldown", "Dimensional Rift")
    AddSection("进攻", "能力", "Yellow")
    AddNewOption(
    "进攻",
    "混乱之箭",
    120,
    true,
    { 45, 1, 50, 1 },
    nil,
    "Soul Shards Fragments for Chaos Bolt." ..
    C.TOOLTIP_VALUE .. "Use Chaos Bolt with a minimum amount of Soul Shard Fragments."
    )
    AddNewOption(
    "进攻",
    "带增益效果时泄片",
    230,
    true,
    { 1, "任何", "Concordance only" },
    nil,
    "Use the additional Chaos Bolt dump on Trinket or Concordance procs." ..
    C.TOOLTIP_VALUE_1 ..
    "Choose when to dump Chaos Bolts." ..
    C.TOOLTIP_SUBVALUE("任何") ..
    "Dump Shards on any Proc e.g. Concordance or any Trinket Proc." ..
    C.TOOLTIP_SUBVALUE("Concordance only") .. "Dump Shards only on Concordance Procs"
    )
    AddNewOption(
    "进攻",
    "大灾变(高优先级)",
    232,
    true,
    { 2, "目标", "Target Standing", "Centered", "Centered Standing" },
    { 1, 1, 10, 1 },
    "Use Cataclysm." ..
    C.TOOLTIP_VALUE_1 ..
    "Choose preferred mode." ..
    C.TOOLTIP_SUBVALUE("目标") ..
    "Always use on the current target." ..
    C.TOOLTIP_SUBVALUE("Target Standing") ..
    "Always use on the current target. Target must be standing still." ..
    C.TOOLTIP_SUBVALUE("Centered") ..
    "Use centered on a cluster of enemies." ..
    C.TOOLTIP_SUBVALUE("Centered Standing") ..
    "Use centered on a cluster of enemies. Enemies must be standing still." ..
    C.TOOLTIP_VALUE_2 ..
    "Amount of enemies that must be in the spell effect to use."
    )
    AddNewOption(
    "进攻",
    "大灾变",
    232,
    true,
    { 2, "目标", "Target Standing", "Centered", "Centered Standing" },
    { 1, 1, 10, 1 },
    "Use Cataclysm." ..
    C.TOOLTIP_VALUE_1 ..
    "Choose preferred mode." ..
    C.TOOLTIP_SUBVALUE("目标") ..
    "Always use on the current target." ..
    C.TOOLTIP_SUBVALUE("Target Standing") ..
    "Always use on the current target. Target must be standing still." ..
    C.TOOLTIP_SUBVALUE("Centered") ..
    "Use centered on a cluster of enemies." ..
    C.TOOLTIP_SUBVALUE("Centered Standing") ..
    "Use centered on a cluster of enemies. Enemies must be standing still." ..
    C.TOOLTIP_VALUE_2 ..
    "Amount of enemies that must be in the spell effect to use."
    )
    AddNewOption("进攻", "魔典：恶魔牺牲", 210, true, nil, nil, "Automatic Grimoire Of Sacrifice usage.")
    AddNewOption(
    "进攻",
    "浩劫",
    232,
    true,
    { 1, "自动", "焦点" },
    { 3, 0, 25, 0.1 },
    "Use Havoc." ..
    C.TOOLTIP_VALUE_1 ..
    "On which unit should we apply Havoc." ..
    C.TOOLTIP_SUBVALUE("自动") ..
    "Use on the unit with the most health." ..
    C.TOOLTIP_SUBVALUE("焦点") ..
    "Use on the Focus unit or the unit with the most health." ..
    C.TOOLTIP_SUBVALUE("目标") ..
    "Use on the Target." ..
    C.TOOLTIP_VALUE_2 .. "Minimum health (in million) to apply."
    )
    AddNewOption(
    "进攻",
    "火焰之雨",
    232,
    true,
    { 2, "目标", "Target Standing", "Centered", "Centered Standing" },
    { 6, 1, 10, 1 },
    "Use Rain Of Fire." ..
    C.TOOLTIP_VALUE_1 ..
    "Choose preferred mode." ..
    C.TOOLTIP_SUBVALUE("目标") ..
    "Always use on the current target." ..
    C.TOOLTIP_SUBVALUE("Target Standing") ..
    "Always use on the current target. Target must be standing still." ..
    C.TOOLTIP_SUBVALUE("Centered") ..
    "Use centered on a cluster of enemies." ..
    C.TOOLTIP_SUBVALUE("Centered Standing") ..
    "Use centered on a cluster of enemies. Enemies must be standing still." ..
    C.TOOLTIP_VALUE_2 ..
    "Amount of enemies that must be in the spell effect to use."
    )
    AddNewOption("进攻", "暗影灼烧 填充技能", 210, true, nil, nil, "Use Shadowburn as Low Priority while moving.")
    AddNewOption(
    "进攻",
    "暗影灼烧 狙击",
    210,
    true,
    nil,
    nil,
    "Attempt to get Shadowburn on adds that will die in the next 5 seconds to get back Soul Shards."
    )
    AddSection("进攻", "多目标Dots", "Yellow")
    AddNewOption(
    "进攻",
    "多重 献祭",
    222,
    true,
    { 6, 1, 10, 1 },
    { 3, 0, 25, 0.1 },
    "Multi-Dot Immolate Cycle." ..
    C.TOOLTIP_VALUE_1 ..
    "Amount of dots to apply." .. C.TOOLTIP_VALUE_2 .. "Minimum health (in million) to apply."
    )
    AddPresetOption("防御")
    AddNewOption(
    "防御",
    "制造治疗石",
    210,
    true,
    nil,
    nil,
    "Will create you a new healthstone if you have none in your bags and are out of combat."
    )
    AddSection("防御", "能力", "Yellow")
    AddNewOption(
    "防御",
    "黑暗契约",
    220,
    true,
    { 40, 1, 100, 1 },
    nil,
    "Use Dark Bargain." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddNewOption(
    "防御",
    "吸取生命",
    220,
    true,
    { 20, 1, 75, 1 },
    nil,
    "Use Drain Life." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddNewOption(
    "防御",
    "死亡缠绕",
    220,
    true,
    { 50, 1, 100, 1 },
    nil,
    "Use Mortal Coil." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddNewOption(
    "防御",
    "不灭决心",
    220,
    true,
    { 40, 1, 100, 1 },
    nil,
    "Use Dark Unending Resolve." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    ISCL = {[ChaosBolt:ID()] = "混乱之箭", [Immolate:ID()] = "Immolate" }
    PetTimer = 0
end
function Rotation:Events()
    self.HavocTable = {}
    self.HavocRemaining = 0
    self.HavocTime = 0
    EventFrame:RegisterForSelfCombatEvent(
    function(...)
        SpellID = select(12, ...)
        DestGUID = select(8, ...)
        CastTime = GetTime()
        local WreakHavocTalent = Spell(196410)
        HavocFallOffTime = (WreakHavocTalent:Exists() and CastTime + 20) or (CastTime + 8)
        Pointer = false
        Remaining = HavocFallOffTime - GetTime()
        if SpellID == 80240 then
            self.HavocTable[DestGUID] = { CastTime, HavocFallOffTime, Pointer, Remaining }
            self.HavocUnit = DestGUID
            HavocCastTime = (WreakHavocTalent:Exists() and 20 or 8) + GetTime()
            self.HavocRemaining = Remaining
        end
    end,
    "SPELL_AURA_APPLIED",
    "SPELL_AURA_REFRESH"
    )
    EventFrame:RegisterForSelfCombatEvent(
    function(...)
        SpellID = select(12, ...)
        DestGUID = select(8, ...)
        if SpellID == 80240 then
            if self.HavocTable[DestGUID] then
                self.HavocTable[DestGUID] = nil
            end
            self.HavocUnit = nil
            self.HavocRemaining = 0
        end
    end,
    "SPELL_AURA_REMOVED"
    )
    self.BlazeTable = {}
    EventFrame:RegisterForSelfCombatEvent(
    function(...)
        SpellID = select(12, ...)
        DestGUID = select(8, ...)
        CastTime = GetTime()
        Pointer = false
        BlazeLevel = 1
        if SpellID == 17962 then
            if self.BlazeTable[DestGUID] ~= nil then
                self.BlazeTable[DestGUID][3] = self.BlazeTable[DestGUID][3] + 1
            else
                self.BlazeTable[DestGUID] = { CastTime, Pointer, BlazeLevel }
            end
        end
    end,
    "SPELL_CAST_SUCCESS"
    )
    EventFrame:RegisterForSelfCombatEvent(
    function(...)
        SpellID = select(12, ...)
        if SpellID == 157736 then
            DestGUID = select(8, ...)
            CastTime = GetTime()
            Pointer = false
            BlazeLevel = 0
            self.BlazeTable[DestGUID] = { CastTime, Pointer, BlazeLevel }
        end
    end,
    "SPELL_AURA_REFRESH"
    )
    EventFrame:RegisterForSelfCombatEvent(
    function(...)
        SpellID = select(12, ...)
        DestGUID = select(8, ...)
        if SpellID == 157736 then
            if self.BlazeTable[DestGUID] then
                self.BlazeTable[DestGUID] = nil
            end
        end
    end,
    "SPELL_AURA_REMOVED"
    )
    EventFrame:RegisterForCombatEvent(
    function(...)
        DestGUID = select(8, ...)
        if self.HavocTable[DestGUID] then
            self.HavocTable[DestGUID] = nil
        end
        if self.BlazeTable[DestGUID] then
            self.BlazeTable[DestGUID] = nil
        end
    end,
    "UNIT_DIED"
    )
    EventFrame:RegisterForSelfCombatEvent(
    function(...)
        SpellID = select(12, ...)
        if SpellID == 348 then
            LastCast = "Immolate"
        elseif SpellID == 80240 then
            LastCast = "浩劫"
        elseif SpellID == 29722 then
            LastCast = "Incinerate"
        else
            LastCast = nil
        end
    end,
    "SPELL_CAST_SUCCESS"
    )
end
function Rotation:GetBlazeLevel(ThisUnit)
    if ThisUnit then
        if self.BlazeTable[ThisUnit:GUID()] ~= nil then
            return self.BlazeTable[ThisUnit:GUID()][3]
        else
            return 0
        end
    else
        return -1
    end
end
function Rotation:ServicePetCooldown()
    if GrimoreOfImp:Cooldown() > 0 then
        return GrimoreOfImp:Cooldown()
    elseif GrimoreOfVoid:Cooldown() > 0 then
        return GrimoreOfVoid:Cooldown()
    elseif GrimoreOfSuccubus:Cooldown() > 0 then
        return GrimoreOfSuccubus:Cooldown()
    elseif GrimoreOfFelHunter:Cooldown() > 0 then
        return GrimoreOfFelHunter:Cooldown()
    end
    return 0
end
function Rotation:HavocTableRefresh()
    if self.HavocTable ~= nil then
        for index, subtable in pairs(self.HavocTable) do
            if subtable[2] <= GetTime() then
                self.HavocTable[index] = nil
            end
            if subtable[2] ~= nil then
                self.HavocRemaining = subtable[2] - GetTime()
            end
        end
    end
    if self.BlazeTable ~= nil then
        for index, subtable in pairs(self.BlazeTable) do
            if subtable[1] + 25 <= GetTime() then
                self.BlazeTable[index] = nil
            end
            if subtable[2] == false then
                if FireHackEnabled and subtable[1] + 0.2 <= GetTime() and ObjectExists(GetObjectWithGUID(index)) then
                    subtable[2] = GetObjectWithGUID(index)
                elseif not FireHackEnabled then
                    subtable[2] = index
                end
            end
        end
    end
end
function Rotation:ProcDumpShards()
    if IsOptionEnabled("带增益效果时泄片") then
        if GetOptionValue("带增益效果时泄片") == "任何" and Player:HasAnyProc() then
            return true
        elseif
        GetOptionValue("带增益效果时泄片") == "Concordance only" and
        Player:BuffRemains(ConcordanceOfTheLegionfall) >= ChaosBolt:CastTime()
        then
            return true
        end
    end
    return false
end
function Rotation:Pulse()
    self:HavocTableRefresh()
    if
    not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() or
    Player:Channeling(ChannelDemonfire) or
    (Player:Channeling(DrainLife) and Player:HealthPercentage() < GetOptionValue("吸取生命") + 15)
    then
        return
    end
    if Target:Exists() and BMPullTime() < 5 then
        self:Opening()
        return
    end
    if GetTime() < Rotation.SpamPrevention then
        return
    end
    Rotation.SpamPrevention = GetTime() + 0.05
    Target = Unit.Target
    local InCombat = Player:IsInCombat()
    if not InCombat then
        self:OutOfCombat()
        return
    end
    if InCombat then
        self:Defensives()
    end
    Target = Player:ReTarget(Immolate, true) or Unit.Target
    if Target:Exists() then
        Rotations:RefreshUnitTables(Rotation.Identifier)
        self:Interrupts()
        if
        IsOptionEnabled("开怪技能") and
        (GetOptionValue("开怪技能") == "无条件使用" or (GetOptionValue("开怪技能") == "打BOSS使用" and Target:IsBoss()) or
        (GetOptionValue("开怪技能") == "CDs Only" and CooldownsAllowed())) and
        not OpenerEnded
        then
            self:Opener()
            return
        elseif CombatTime() > 10 then
            OpenerEnded = true
        end
        self:OffGCDAbilities()
        if Player:GlobalCooldown() == 0 and Player:IsReady() then
            self:Combat()
        end
    end
end
function Rotation:Opening()
    Player:UsePotions("智力药水", GetSecondOptionValue("抢先使用药水"))
    if
    IsOptionEnabled("抢先施放(需DBM插件)") and
    (GetOptionValue("抢先施放(需DBM插件)") == "无条件使用" or
    (GetOptionValue("抢先施放(需DBM插件)") == "打BOSS使用" and Target:IsBoss()))
    then
        OpenerSpell = Incinerate
        if
        EmpoweredLifeTap:Exists() and not Player:Buff(EmpoweredLifeTapBuff) and
        BMPullTime() < GetSecondOptionValue("抢先施放(需DBM插件)") + Player:GCD() and
        Player:CanCast(LifeTap)
        then
            Player:Cast(LifeTap)
            return
        end
        if BMPullTime() < GetSecondOptionValue("抢先施放(需DBM插件)") and Target:CanCast(OpenerSpell) then
            Target:Cast(OpenerSpell)
            return
        end
    end
end
function Rotation:Opener()
    self.ChoosenOpener = nil
    if Player:GlobalCooldown() == 0 then
        if self.ChoosenOpener ~= nil then
            OpenerParser(self.ChoosenOpener)
        else
            Bug("Invalid Talents combination, Opener will not be used.")
            OpenerEnded = true
        end
    end
end
function Rotation:Defensives()
    Player:UseHealingItem()
    if
    MortalCoil:Exists() and IsOptionEnabled("死亡缠绕") and Target:Exists() and Target:CanCast(MortalCoil) and
    Player:HealthPercentage() <= GetOptionValue("死亡缠绕")
    then
        Target:Cast(MortalCoil)
    end
    if
    DarkPact:Exists() and IsOptionEnabled("黑暗契约") and Player:CanCast(DarkPact) and
    Player:HealthPercentage() <= GetOptionValue("黑暗契约")
    then
        Player:Cast(DarkPact)
        return
    end
    if
    UnendingResolve:Exists() and IsOptionEnabled("不灭决心") and Player:CanCast(UnendingResolve) and
    Player:HealthPercentage() <= GetOptionValue("不灭决心")
    then
        Player:Cast(UnendingResolve)
        return
    end
    if DrainLife:Exists() and IsOptionEnabled("吸取生命") then
        if Player:Channeling(DrainLife) and Player:HealthPercentage() > GetOptionValue("吸取生命") + 15 then
            Bug("Stop Chanelling Drain Life as Health threshold was reach.")
            SpellStopCasting()
        end
        if
        not Player:Channeling(DrainLife) and Player:HealthPercentage() < GetOptionValue("吸取生命") and
        Target:CanCast(DrainLife)
        then
            Target:Cast(DrainLife)
            return
        end
    end
end
function Rotation:Interrupts()
    local PetInterrupt = (SpellLock:PetKnown() and SpellLock) or (ShadowLock:PetKnown() and ShadowLock) or nil
    if PetInterrupt then
        Player:UseInterrupt(PetInterrupt, ArcaneTorrent, true)
    end
end
function Rotation:OffGCDAbilities()
    if
    self.HavocUnit and self.HavocTime > GetTime() and self.HavocUnit:Exists() and
    self.HavocUnit:GUID() == Target:GUID()
    then
        BestUnit, BestUnitHealth, BestTarget = nil, 0, nil
        for i = 1, #Enemies_40y do
            ThisUnit, ThisUnitHealth = Enemies_40y[i], Enemies_40y[i]:Health()
            if not ThisUnit:Debuff(Havoc) and ThisUnitHealth > BestUnitHealth and ThisUnit:CanCast(Incinerate) then
                BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth
            end
        end
        if BestUnit then
            BestTarget = BestUnit
        end
    end
end
function Rotation:HavocHandler2(HavocSpell)
    if IsOptionEnabled("浩劫") then
        if
        not WreakHavoc:Exists() and
        (not Havoc:IsOnCooldown() and HavocSpell or
        WreakHavoc:Exists() and self.HavocUnit and self.HavocRemaining <= ChaosBolt:CastTime()) or
        WreakHavoc:Exists() and not self.HavocUnit
        then
            HavocThreshold = GetSecondOptionValue("浩劫") * 1000000
            if
            GetOptionValue("浩劫") == "焦点" and Focus:Exists() and Focus:Health() >= HavocThreshold and
            Focus:CanCast(Havoc)
            then
                Focus:Cast(Havoc)
                return
            else
                BestUnit, BestUnitHealth, TargetUnitGUID = nil, 0, Target:GUID()
                if ChannelDemonfire:Exists() then
                    for i = 1, #Enemies_40y do
                        ThisUnit, ThisUnitHealth, ThisUnitGUID =                         Enemies_40y[i],
                        Enemies_40y[i]:Health(),
                        Enemies_40y[i]:GUID()
                        if
                        not ThisUnit:Debuff(ImmolateDebuff) and ThisUnit:IsInCombat() and
                        not ThisUnit:IsCrowdControlled() and
                        ThisUnitHealth >= HavocThreshold and
                        ThisUnitHealth > BestUnitHealth and
                        not (ThisUnitGUID == TargetUnitGUID) and
                        ThisUnit:CanCast(Havoc)
                        then
                            BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth
                        end
                    end
                end
                if not ChannelDemonfire:Exists() or not BestUnit then
                    for i = 1, #Enemies_40y do
                        ThisUnit, ThisUnitHealth, ThisUnitGUID =                         Enemies_40y[i],
                        Enemies_40y[i]:Health(),
                        Enemies_40y[i]:GUID()
                        if
                        ThisUnit:IsInCombat() and not ThisUnit:IsCrowdControlled() and
                        ThisUnitHealth >= HavocThreshold and
                        ThisUnitHealth > BestUnitHealth and
                        not (ThisUnitGUID == TargetUnitGUID) and
                        ThisUnit:CanCast(Havoc)
                        then
                            BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth
                        end
                    end
                end
                if BestUnit then
                    BestUnit:Cast(Havoc)
                    return
                end
            end
        end
    end
end
function Rotation:HavocHandler(HavocMode, HavocSpell)
    if
    (HavocMode == "Wreak Havoc" and WreakHavoc:Exists()) or
    (GetOptionValue("Havoc Spell") == "自动" and HavocSpell == "Immolate" and RoaringBlaze:Exists()) or
    (GetOptionValue("Havoc Spell") == "CB" and HavocSpell == "混乱之箭") or
    (GetOptionValue("Havoc Spell") == "自动" and HavocSpell == "混乱之箭" and not RoaringBlaze:Exists())
    then
        if
        Havoc:Exists() and IsOptionEnabled("浩劫") and #Enemies_40y >= 2 and
        not (self.HavocUnit and self.HavocTime > GetTime() and self.HavocUnit:Exists())
        then
            HavocThreshold = GetSecondOptionValue("浩劫") * 1000000
            if
            GetOptionValue("浩劫") == "焦点" and Focus:Exists() and Focus:Health() >= HavocThreshold and
            Focus:CanCast(Havoc)
            then
                self.HavocUnit, self.HavocTime = Focus, WreakHavoc:Exists() and GetTime() + 18 or GetTime() + 8
                Focus:Cast(Havoc)
                return
            else
                BestUnit, BestUnitHealth, TargetUnitGUID = nil, 0, Target:GUID()
                for i = 1, #Enemies_40y do
                    ThisUnit, ThisUnitHealth, ThisUnitGUID =                     Enemies_40y[i],
                    Enemies_40y[i]:Health(),
                    Enemies_40y[i]:GUID()
                    if
                    ThisUnitHealth >= HavocThreshold and ThisUnitHealth > BestUnitHealth and
                    not ThisUnit:IsCrowdControlled() and
                    not (ThisUnitGUID == TargetUnitGUID) and
                    ThisUnit:CanCast(Havoc)
                    then
                        BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth
                    end
                end
                if BestUnit then
                    self.HavocUnit, self.HavocTime =                     BestUnit,
                    WreakHavoc:Exists() and GetTime() + 20 - ChaosBolt:CastTime() or GetTime() + 8
                    BestUnit:Cast(Havoc)
                    return
                end
            end
        end
    end
end
function Rotation:PetsManager()
    if IsOptionEnabled("魔典：恶魔牺牲") and GrimoreOfSacrifice:Exists() and not Player:Buff(GrimoreOfSacrificeBuff) then
        if UnitExists("PlayerPet") and Player:CanCast(GrimoreOfSacrifice) then
            if SacrificeRandomDelay then
                if SacrificeRandomDelay < GetTime() then
                    Player:Cast(GrimoreOfSacrifice)
                    PetTimer = GetTime() + 4
                    SacrificeRandomDelay = nil
                    return
                end
            else
                SacrificeRandomDelay = GetTime() + math.random(2, 6)
            end
        end
    end
    if not (GrimoreOfSacrifice:Exists() and Player:Buff(GrimoreOfSacrificeBuff)) then
        if
        not Player:IsMoving() and IsOptionEnabled("恶魔管理器") and (not PlayerPet:Exists() or PlayerPet:IsDeadOrGhost()) and
        Player:SoulShards() >= 1
        then
            local SelectedPet = GetOptionValue("恶魔管理器")
            local SelectedPetSpell =             SelectedPet == "末日守卫" and GrimoreOfSupremacy:Exists() and SummonDoomguard or
            SelectedPet == "Felhunter" and SummonFelhunter:Exists() and SummonFelhunter or
            SelectedPet == "地狱火" and GrimoreOfSupremacy:Exists() and SummonInfernal or
            SelectedPet == "Succubus" and SummonSuccubus:Exists() and SummonSuccubus or
            SelectedPet == "Voidwalker" and SummonVoidwalker:Exists() and SummonVoidwalker or
            SummonImp
            if GetTime() - PetTimer >= 1 and Player:CanCast(SelectedPetSpell) then
                Player:Cast(SelectedPetSpell)
                PetTimer = GetTime() + 2.5
            end
        end
        if
        IsOptionEnabled("生命通道") and PlayerPet:Exists() and not PlayerPet:IsDeadOrGhost() and
        Player:Standing() > 0.25 and
        PlayerPet:HealthPercentage() < GetOptionValue("生命通道") and
        Player:CanCast(HealthFunnel)
        then
            Player:Cast(HealthFunnel)
            return
        end
    end
end
function Rotation:ServicePet()
    if CDOptionEnabled("统御魔典") then
        self.SelectedGrimoire = GetSecondOptionValue("统御魔典")
        self.SelectedGrimoireSpell =         self.SelectedGrimoire == "Felhunter" and GrimoreOfFelHunter or
        self.SelectedGrimoire == "Imp" and GrimoreOfImp or
        self.SelectedGrimoire == "Succubus" and GrimoreOfSuccubus or
        self.SelectedGrimoire == "Voidwalker" and GrimoreOfVoid
        if Target:CanCast(self.SelectedGrimoireSpell) then
            Target:Cast(self.SelectedGrimoireSpell)
            return
        end
    end
end
function Rotation:UnitTables()
    Enemies_40y = UseAOE() and Player:EnemiesWithinDistance(40) or {}
    TargetEnemies_10y = Target:Exists() and UseAOE() and Target:EnemiesWithinDistance(10, true) or {}
    NumEnemies = #TargetEnemies_10y
    ImmolateUnit = UseAOE() and Unit.DotCycle(Enemies_40y, Immolate, ImmolateDebuff, 18, "多重 献祭") or nil
end
function Rotation:Combat()
    if Player:Casting(ChaosBolt) then
        return
    end
    GCDMax, SoulShards = Player:GCD(), Player:SoulShards()
    if IsOptionEnabled("给坦克绑灵魂石") then
        MainTank, MainTankTarget, OffTank, OffTankTarget = Unit.GetMainTanks()
        if MainTank and MainTank:Exists() and not MainTank:IsDeadOrGhost() then
            MainTankResDelay = nil
        end
        if OffTank and OffTank:Exists() and not OffTank:IsDeadOrGhost() then
            OffTankResDelay = nil
        end
        if
        MainTank and MainTank:Exists() and MainTank:IsDeadOrGhost() and MainTank:IsPlayer() and
        MainTank:CanCast(Soulstone)
        then
            if not MainTankResDelay then
                MainTankResDelay = GetTime()
            end
            if GetTime() - MainTankResDelay >= GetOptionValue("给坦克绑灵魂石") then
                MainTankResDelay = nil
                MainTank:Cast(Soulstone)
                return
            end
        elseif
        OffTank and OffTank:Exists() and OffTank:IsDeadOrGhost() and OffTank:IsPlayer() and
        OffTank:CanCast(Soulstone)
        then
            if not OffTankResDelay then
                OffTankResDelay = GetTime()
            end
            if GetTime() - OffTankResDelay >= GetOptionValue("给坦克绑灵魂石") then
                OffTankResDelay = nil
                OffTank:Cast(Soulstone)
                return
            end
        end
    end
    if
    IsOptionEnabled("灵魂石") and Target:Exists() and Target:IsDeadOrGhost() and not Player:IsMoving() and
    Target:IsPlayer() and
    Target:CanCast(Soulstone)
    then
        Target:Cast(Soulstone)
        return
    end
    self:PetsManager()
    if Player:CanAttack(Target) then
        ImmolateTickTime = 3 / (1 + Player:Haste() / 100)
        if WreakHavoc:Exists() and BestTarget and BestTarget:Exists() and self.HavocTime > GetTime() then
            Target = BestTarget
        end
        if
        BurningRush:Exists() and not Player:Buff(BurningRush) and IsOptionEnabled("爆燃冲刺") and
        Player:HealthPercentage() >= GetOptionValue("爆燃冲刺") and
        Player:Moving() > GetSecondOptionValue("爆燃冲刺") and
        Player:CanCast(BurningRush)
        then
            Player:Cast(BurningRush)
            return
        end
        if
        BurningRush:Exists() and Player:Buff(BurningRush) and IsOptionEnabled("爆燃冲刺") and
        (Player:HealthPercentage() < GetOptionValue("爆燃冲刺") or Player:Standing() > 1) and
        Player:CanCast(BurningRush)
        then
            Player:Cast(BurningRush)
            return
        end
        if Shadowburn:Exists() and IsOptionEnabled("暗影灼烧 狙击") and Player:SoulShards() >= 1 and Player:SoulShards() < 4 then
            for i = 1, #Enemies_40y do
                ThisUnit = Enemies_40y[i]
                if
                not ThisUnit:Debuff(Shadowburn) and ThisUnit:HealthPercentage() < 20 and
                ThisUnit:CanCast(Shadowburn, true, true) and
                (ThisUnit:TimeToDie() < 5 or ThisUnit:IsDummy())
                then
                    Bug("Cancel Cast and Snipe Shadowburn on " .. ThisUnit:Name())
                    SpellStopCasting()
                    ThisUnit:Cast(Shadowburn)
                    return
                end
            end
        end
        if
        Immolate:Exists() and #Enemies_40y == 2 and RoaringBlaze:Exists() and Havoc:Cooldown() <= 0 and ImmolateUnit and
        ImmolateUnit:DebuffRemains(ImmolateDebuff) <= ImmolateUnit:DebuffRemains(Havoc) and
        ImmolateUnit:CanCast(Immolate)
        then
            ImmolateUnit:Cast(Immolate)
            return
        end
        if
        DimensionalRift:Exists() and CDOptionEnabled("Dimensional Rift") and DimensionalRift:Charges() == 3 and
        Target:CanCast(DimensionalRift)
        then
            Target:Cast(DimensionalRift)
            return
        end
        if Cataclysm:Exists() and IsOptionEnabled("大灾变(高优先级)") and Target:CanCast(Cataclysm) then
            if Target:CastGroundSpell(Cataclysm, "大灾变", 8) then
                return
            end
        end
        self:HavocHandler2("自动")
        self:HavocHandler2("CB")
        if
        not WreakHavoc:Exists() and Player:SoulShardsFragments() >= 20 and self.HavocUnit and
        self.HavocRemaining >= ChaosBolt:CastTime() and
        Target:CanCast(ChaosBolt)
        then
            Target:Cast(ChaosBolt)
            return
        end
        if
        Immolate:Exists() and (#Enemies_40y < 5 or not FireAndBrimstone:Exists()) and
        Target:DebuffRemains(ImmolateDebuff) <= ImmolateTickTime and
        Target:CanCast(Immolate)
        then
            Target:Cast(Immolate)
            return
        end
        if
        Immolate:Exists() and IsOptionEnabled("多重 献祭") and ImmolateUnit and
        (#Enemies_40y < 5 or not FireAndBrimstone:Exists()) and
        (not Cataclysm:Exists() or Cataclysm:Cooldown() >= Immolate:CastTime() * #Enemies_40y) and
        #Enemies_40y > 1 and
        ImmolateUnit:DebuffRemains(ImmolateDebuff) <= ImmolateTickTime and
        (not RoaringBlaze:Exists() or
        (self:GetBlazeLevel(ImmolateUnit) == 0 and
        Conflagrate:Charges() < 2 + (select(2, Player:HasTier("T19")) and 1 or 0))) and
        ImmolateUnit:CanCast(Immolate)
        then
            ImmolateUnit:Cast(Immolate)
            return
        end
        if
        Immolate:Exists() and RoaringBlaze:Exists() and Target:DebuffRemains(ImmolateDebuff) <= 18 and
        self:GetBlazeLevel(Target) == 0 and
        Target:TimeToDie() > 10 and
        (Conflagrate:Charges() == 2 + (select(2, Player:HasTier("T19")) and 1 or 0) or
        (Conflagrate:Charges() >= 1 + (select(2, Player:HasTier("T19")) and 1 or 0) and
        Conflagrate:Recharge() < Immolate:CastTime() + GCDMax) or
        Target:TimeToDie() < 24) and
        Target:CanCast(Immolate)
        then
            Target:Cast(Immolate)
            return
        end
        if Player:IsWithinCastRange(Target, Immolate) then
            Player:UsePotions("智力药水")
            Player:UseTrinkets()
            if CDOptionEnabled("进攻性种族技能") then
                if BloodFury:Exists() and Player:CanCast(BloodFury) then
                    Player:Cast(BloodFury)
                end
                if Berserking:Exists() and Player:CanCast(Berserking) then
                    CastSpellByID(26297, "player")
                end
            end
        end
        if
        Shadowburn:Exists() and Player:BuffRemains(ConflagrationOfChaos) <= ChaosBolt:CastTime() and
        Target:CanCast(Shadowburn)
        then
            Target:Cast(Shadowburn)
            return
        end
        if
        Shadowburn:Exists() and
        (Shadowburn:Charges() == 1 + (select(2, Player:HasTier("T19")) and 1 or 0) and
        Shadowburn:Recharge() < ChaosBolt:CastTime() or
        Shadowburn:Charges() == 2 + (select(2, Player:HasTier("T19")) and 1 or 0)) and
        Player:SoulShards() < 5 and
        Target:CanCast(Shadowburn)
        then
            Target:Cast(Shadowburn)
            return
        end
        if
        Conflagrate:Exists() and RoaringBlaze:Exists() and
        (Conflagrate:Charges() == 2 + (select(2, Player:HasTier("T19")) and 1 or 0) or
        (Conflagrate:Charges() >= 1 + (select(2, Player:HasTier("T19")) and 1 or 0) and
        Conflagrate:Recharge() < GCDMax) or
        Target:TimeToDie() < 24) and
        Target:CanCast(Conflagrate)
        then
            Target:Cast(Conflagrate)
            return
        end
        if
        Conflagrate:Exists() and RoaringBlaze:Exists() and self:GetBlazeLevel(Target) >= 0 and
        Target:DebuffRemains(ImmolateDebuff) > 18 * 0.3 and
        (#Enemies_40y == 1 or Player:SoulShards() < 3) and
        Player:SoulShards() < 5 and
        Target:CanCast(Conflagrate)
        then
            Target:Cast(Conflagrate)
            return
        end
        if
        Conflagrate:Exists() and not RoaringBlaze:Exists() and Player:BuffCount(BackDraftBuff) < 3 and
        Player:BuffRemains(ConflagrationOfChaos) <= ChaosBolt:CastTime() and
        Target:CanCast(Conflagrate)
        then
            Target:Cast(Conflagrate)
            return
        end
        if
        Conflagrate:Exists() and not RoaringBlaze:Exists() and Player:BuffCount(BackDraftBuff) < 3 and
        (Conflagrate:Charges() == 1 + (select(2, Player:HasTier("T19")) and 1 or 0) and
        Conflagrate:Recharge() < ChaosBolt:CastTime() or
        Conflagrate:Charges() == 2 + (select(2, Player:HasTier("T19")) and 1 or 0)) and
        Player:SoulShards() < 5 and
        Target:CanCast(Conflagrate)
        then
            Target:Cast(Conflagrate)
            return
        end
        if
        LifeTap:Exists() and EmpoweredLifeTap:Exists() and Player:BuffRemains(EmpoweredLifeTapBuff) <= GCDMax and
        Player:CanCast(LifeTap)
        then
            Player:Cast(LifeTap)
            return
        end
        if
        DimensionalRift:Exists() and CDOptionEnabled("Dimensional Rift") and LessonsOfSpaceTime:IsEquipped(3) and
        not Player:Buff(LessonsOfSpaceTimeBuff) and
        ((not GrimoreOfSupremacy:Exists() and SummonDoomguard:Cooldown() <= 0) or
        (GrimoreOfService:Exists() and self:ServicePetCooldown() <= 0) or
        (SoulHarvest:Exists() and SoulHarvest:Cooldown() <= 0)) and
        Target:CanCast(DimensionalRift)
        then
            Target:Cast(DimensionalRift)
            return
        end
        if GrimoreOfService:Exists() and CDOptionEnabled("统御魔典") and Target:CanCast(GrimoreOfImp) then
            self:ServicePet()
        end
        if
        GuardianInfernal:Exists() and CDOptionEnabled("地狱火") and LordOfFlames:ArtifactRank() > 0 and
        not Player:Buff(LordOfFlames) and
        Target:CanCast(GuardianInfernal)
        then
            Target:Cast(GuardianInfernal)
            return
        end
        if
        GuardianDoomguard:Exists() and not GrimoreOfSupremacy:Exists() and CDOptionEnabled("末日守卫") and
        Target:CanCast(GuardianDoomguard)
        then
            Target:Cast(GuardianDoomguard)
            return
        end
        if
        not GrimoreOfSupremacy:Exists() and GuardianInfernal:Exists() and CDOptionEnabled("地狱火") and
        Target:CanCast(GuardianInfernal)
        then
            Target:Cast(GuardianInfernal)
            return
        end
        if
        GuardianDoomguard:Exists() and CDOptionEnabled("末日守卫") and GrimoreOfSupremacy:Exists() and
        LordOfFlames:ArtifactRank() > 0 and
        Player:Buff(LordOfFlames) and
        Target:CanCast(GuardianDoomguard)
        then
            Target:Cast(GuardianDoomguard)
            return
        end
        if
        SoulHarvest:Exists() and CDOptionEnabled("灵魂收割") and not Player:Buff(SoulHarvest) and
        Player:IsWithinCastRange(Target, Immolate) and
        Player:CanCast(SoulHarvest)
        then
            Player:Cast(SoulHarvest)
            return
        end
        if ChaosBolt:Exists() and self.HavocRemaining > ChaosBolt:CastTime() and Target:CanCast(ChaosBolt) then
            self:HavocHandler2("CB")
            Target:Cast(ChaosBolt)
            return
        end
        if
        ChannelDemonfire:Exists() and Target:DebuffRemains(ImmolateDebuff) > ChannelDemonfire:CastTime() and
        (#Enemies_40y == 1 or self.HavocRemaining < ChaosBolt:CastTime()) and
        Target:CanCast(ChannelDemonfire)
        then
            self:HavocHandler2("CDF")
            Target:Cast(ChannelDemonfire)
            return
        end
        if RainOfFire:Exists() and IsOptionEnabled("火焰之雨") and Player:SoulShards() >= 3 and Target:CanCast(RainOfFire) then
            if Target:CastGroundSpell(RainOfFire, "火焰之雨", 8) then
                return
            end
        end
        if
        RainOfFire:Exists() and IsOptionEnabled("火焰之雨") and WreakHavoc:Exists() and Player:SoulShards() >= 3 and
        Target:CanCast(RainOfFire)
        then
            if Target:CastGroundSpell(RainOfFire, "火焰之雨", 8) then
                return
            end
        end
        if
        DimensionalRift:Exists() and CDOptionEnabled("Dimensional Rift") and
        (not LessonsOfSpaceTime:IsEquipped(3) or DimensionalRift:Charges() > 1 or
        ((not GrimoreOfService:Exists() or DimensionalRift:Recharge() < self:ServicePetCooldown()) and
        (not SoulHarvest:Exists() or DimensionalRift:Recharge() < SoulHarvest:Cooldown()) and
        (not GrimoreOfSupremacy:Exists() or DimensionalRift:Recharge() < SummonDoomguard:Cooldown()))) and
        Target:CanCast(DimensionalRift)
        then
            Target:Cast(DimensionalRift)
            return
        end
        if
        LifeTap:Exists() and EmpoweredLifeTap:Exists() and Player:BuffRemains(EmpoweredLifeTapBuff) <= 20 * 0.3 and
        Player:CanCast(LifeTap)
        then
            Player:Cast(LifeTap)
            return
        end
        if Cataclysm:Exists() and IsOptionEnabled("大灾变") and Target:CanCast(Cataclysm) then
            if Target:CastGroundSpell(Cataclysm, "大灾变", 8) then
                return
            end
        end
        if
        ChaosBolt:Exists() and
        (Havoc:Cooldown() > 12 and Havoc:Cooldown() > 0 or #Enemies_40y == 1 or
        Player:SoulShardsFragments() >= GetOptionValue("混乱之箭")) and
        (Player:SoulShardsFragments() >= GetOptionValue("混乱之箭") or
        Player:BuffRemains(SoulHarvest) > ChaosBolt:CastTime() or
        Player:BuffRemains(ConcordanceOfTheLegionfall) > ChaosBolt:CastTime()) and
        Target:CanCast(ChaosBolt)
        then
            self:HavocHandler2("CB")
            Target:Cast(ChaosBolt)
            return
        end
        if
        ChaosBolt:Exists() and
        (Havoc:Cooldown() > 12 and Havoc:Cooldown() > 0 or #Enemies_40y == 1 or
        Player:SoulShardsFragments() >= GetOptionValue("混乱之箭")) and
        self:ProcDumpShards() and
        Target:CanCast(ChaosBolt)
        then
            self:HavocHandler2("CB")
            Target:Cast(ChaosBolt)
            return
        end
        if Shadowburn:Exists() and Target:CanCast(Shadowburn) then
            Target:Cast(Shadowburn)
            return
        end
        if
        Conflagrate:Exists() and not RoaringBlaze:Exists() and Player:BuffCount(BackDraftBuff) < 3 and
        Target:CanCast(Conflagrate)
        then
            Target:Cast(Conflagrate)
            return
        end
        if
        Immolate:Exists() and (#Enemies_40y < 5 or not FireAndBrimstone:Exists()) and
        (not Cataclysm:Exists() or Cataclysm:Cooldown() >= Immolate:CastTime() * #Enemies_40y) and
        not RoaringBlaze:Exists() and
        Target:DebuffRemains(ImmolateDebuff) <= 18 * 0.3 and
        Target:CanCast(Immolate)
        then
            Target:Cast(Immolate)
            return
        end
        if
        Immolate:Exists() and (#Enemies_40y < 5 or not FireAndBrimstone:Exists()) and
        (not Cataclysm:Exists() or Cataclysm:Cooldown() >= Immolate:CastTime() * #Enemies_40y) and
        not RoaringBlaze:Exists() and
        ImmolateUnit and
        ImmolateUnit:DebuffRemains(ImmolateDebuff) <= 18 * 0.3 and
        ImmolateUnit:CanCast(Immolate)
        then
            ImmolateUnit:Cast(Immolate)
            return
        end
        if Incinerate:Exists() and Target:CanCast(Incinerate) then
            Target:Cast(Incinerate)
            return
        end
        if LifeTap:Exists() and Player:PowerPercentage() < 80 and Player:CanCast(LifeTap) then
            Player:Cast(LifeTap)
            return
        end
        if Shadowburn:Exists() and IsOptionEnabled("暗影灼烧 填充技能") and Player:IsMoving() and Target:CanCast(Shadowburn) then
            Target:Cast(Shadowburn)
            return
        end
    end
end
function Rotation:OutOfCombat()
    self:PetsManager()
    if self.HavocUnit ~= nil then
        self.HavocUnit = nil
        self.HavocRemaining = 0
    end
    if
    IsOptionEnabled("制造治疗石") and Player:Standing() > 0.25 and not Healthstone:InStock() and
    CreateHealthstone:TimeSinceCast() >= 4 and
    Player:CanCast(CreateHealthstone)
    then
        CreateHealthstone.LastCastTime = GetTime()
        Player:Cast(CreateHealthstone)
        return
    end
    if
    BurningRush:Exists() and not Player:Buff(BurningRush) and IsOptionEnabled("爆燃冲刺") and
    Player:HealthPercentage() >= GetOptionValue("爆燃冲刺") and
    Player:Moving() > GetSecondOptionValue("爆燃冲刺") and
    Player:CanCast(BurningRush)
    then
        Player:Cast(BurningRush)
        return
    end
    if
    BurningRush:Exists() and Player:Buff(BurningRush) and IsOptionEnabled("爆燃冲刺") and
    (Player:HealthPercentage() < GetOptionValue("爆燃冲刺") or Player:Standing() > 1) and
    Player:CanCast(BurningRush)
    then
        Player:Cast(BurningRush)
        return
    end
    if IsOptionEnabled("自动进入战斗") and Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        local EngageSpell = Immolate
        if EngageSpell:Exists() and Target:CanCast(EngageSpell) then
            Target:Cast(EngageSpell)
            return
        end
    end
end
SetRotation(71, {})
local Rotation = Rotations[71]
function Rotation:Initialize()
    ArcaneTorrent = Spell(69179, false, false, true)
    Berserking = Spell(26297, false, false, true)
    BloodFury = Spell(20572, false, false, true)
    GiftOfTheNaaru = Spell(59547, false, false, true)
    AngerManagement = Spell(152278)
    Avatar = Spell(107574, false, false, true)
    BattleCry = Spell(1719, false, false, true)
    BerserkerRage = Spell(18499, false, false, true)
    Bladestorm = Spell(227847, false, false, true)
    Charge = Spell(100, true, true, true)
    Cleave = Spell(845, true, false, true)
    CleaveBuff = Spell(188923)
    ColossusSmash = Spell(167105, true, true, true)
    ColossusSmashDebuff = Spell(208086)
    CommandingShout = Spell(97462, false, false, true)
    Dauntless = Spell(202297)
    DeadlyCalm = Spell(227266)
    DefensiveStance = Spell(197690, false, false, true)
    DieByTheSword = Spell(118038, false, false, true)
    Execute = Spell(163201, true, true, true)
    ExecutionersPrecision = Spell(242188)
    FervorOfBattle = Spell(202316)
    FocusedRage = Spell(207982, false, false, true)
    Hamstring = Spell(1715, true, true, true)
    HeroicThrow = Spell(57755, true, true, true)
    InForTheKill = Spell(215550)
    MortalStrike = Spell(12294, true, true, true)
    Overpower = Spell(7384, true, true, true)
    OverpowerBuff = Spell(60503)
    PreciseStrikes = Spell(209492)
    Pummel = Spell(6552, true, true, true)
    Ravager = Spell(152277, false, true, true)
    Rend = Spell(772, true, true, true)
    Slam = Spell(1464, true, true, true)
    ShatteredDefenses = Spell(248625)
    Shockwave = Spell(46968, true, false, true)
    StoneHeart = Spell(225947)
    StormBolt = Spell(107570, true, true, true)
    SweepingStrikes = Spell(202161)
    TitanicMight = Spell(202612)
    VictoryRush = Spell(34428, true, true, true)
    VictoryRushBuff = Spell(32216)
    Warbreaker = Spell(209577, false, false, true)
    Whirlwind = Spell(1680, false, false, true)
    PreciseStrikesTrait = Spell(209492)
    CorruptedBloodOfZakajz = Spell(209566)
    ArchavonsHeavyHands = Item(137060)
    TheGreatStormsEye = Item(151823)
    AddPage("常规")
    AddPage("进攻")
    AddPage("防御")
    AddCommonOptions()
    AddPresetOption("常规", "Melee", nil, false)
    AddPresetOption("进攻")
    AddSection("进攻", "大技能", "Yellow")
    AddPresetOption("Cooldown", "天神下凡")
    AddPresetOption("Cooldown", "战吼", 1, { 0, 0, 10, 0.1 }, "Minimum target health in millions to use Battle Cry.")
    AddPresetOption("Cooldown", "剑刃风暴", 1, { 1, 1, 10, 1 }, "Amount of units that needs to be in range to use.")
    AddNewOption(
    "进攻",
    "剑刃风暴作为填充技能",
    210,
    true,
    nil,
    nil,
    "Use Bladestorm as filler when we are low rage even on single target."
    )
    AddPresetOption("Cooldown", "破坏者", 1, nil, "Amount of units that needs to be in range of the target to use.")
    AddNewOption(
    "进攻",
    "Ravager AOE",
    232,
    true,
    { 2, "目标", "Target Standing", "Centered", "Centered Standing" },
    { 2, 1, 25, 1 },
    "Use Ravager." ..
    C.TOOLTIP_VALUE_1 ..
    "Choose preferred mode." ..
    C.TOOLTIP_SUBVALUE("目标") ..
    "Always use on the current target." ..
    C.TOOLTIP_SUBVALUE("Target Standing") ..
    "Always use on the current target. Target must be standing still." ..
    C.TOOLTIP_SUBVALUE("Centered") ..
    "Use centered on a cluster of enemies." ..
    C.TOOLTIP_SUBVALUE("Centered Standing") ..
    "Use centered on a cluster of enemies. Enemies must be standing still." ..
    C.TOOLTIP_VALUE_2 ..
    "Amount of enemies that must be in the spell effect to use."
    )
    AddSection("进攻", "能力", "Yellow")
    AddNewOption(
    "进攻",
    "斩杀",
    223,
    true,
    { 40, 10, 200, 1 },
    { 2, "只有目标", "任何单位" },
    "Use Execute on low health Targets." ..
    C.TOOLTIP_VALUE_1 ..
    "Minimum amount of rage to use Execute as very high priority in the Cleave rotation while using Sweeping Strikes." ..
    C.TOOLTIP_VALUE_2 ..
    C.TOOLTIP_SUBVALUE("只有目标", true) ..
    "Only use Execute on current Target." ..
    C.TOOLTIP_SUBVALUE("任何单位") .. "Use Execute on any available unit that is in range."
    )
    AddNewOption("进攻", "震荡波", 210, true, nil, nil, "Use Shockwave as very low priority during downtimes.")
    AddNewOption("进攻", "风暴之锤", 210, true, nil, nil, "Use Storm Bolt as very low priority during downtimes.")
    AddNewOption(
    "进攻",
    "灭战者保持巨人打击效果",
    230,
    false,
    { 2, "无条件使用", "大技能用法" },
    nil,
    "Use Warbreaker for Colossus Smash Debuff when Colossus Smash is not available." ..
    C.TOOLTIP_VALUE ..
    C.TOOLTIP_SUBVALUE("无条件使用", true) ..
    "Use the ability even if CDs are disabled." ..
    C.TOOLTIP_SUBVALUE("大技能用法") .. "Only use the ability if CDs are enabled."
    )
    AddNewOption("进攻", "灭战者搭配剑刃风暴", 220, true, { 5, 1, 10, 1 }, nil, "Use Warbreaker Before Bladestorm.")
    AddSection("进攻", "多个目标", "Yellow")
    AddNewOption(
    "进攻",
    "多目标巨人打击",
    222,
    true,
    { 10, 1, 14, 0.1 },
    { 3, 0, 25, 0.1 },
    "Multi Colossus Smash Cycle." ..
    C.TOOLTIP_VALUE_1 ..
    "Minimum time remaining on the current target to allow using Colossus Smash on other units." ..
    C.TOOLTIP_VALUE_2 .. "Minimum health (in million) to apply."
    )
    AddNewOption(
    "进攻",
    "多目标撕裂",
    222,
    true,
    { 3, 1, 10, 1 },
    { 3, 0, 25, 0.1 },
    "Multi Rend Cycle." ..
    C.TOOLTIP_VALUE_1 ..
    "Amount of dots to apply." .. C.TOOLTIP_VALUE_2 .. "Minimum health (in million) to apply."
    )
    AddSection("进攻", "循环", "Yellow")
    AddNewOption("进攻", "顺劈斩", 120, true, { 2, 1, 7, 1 }, nil, "Amount of units needed to use Cleave.")
    AddNewOption("进攻", "AoE", 120, true, { 5, 1, 10, 1 }, nil, "Amount of units needed to use AoE.")
    AddPresetOption("防御")
    AddSection("防御", "能力", "Yellow")
    AddNewOption(
    "防御",
    "剑在人在",
    220,
    true,
    { 30, 1, 100, 1 },
    nil,
    "Use Die By The Sword." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
    AddNewOption(
    "防御",
    "乘胜追击",
    220,
    true,
    { 50, 1, 100, 1 },
    nil,
    "Use Victory Rush." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
end
function Rotation:Events()
end
function Rotation:Pulse()
    if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
        return
    end
    if Target:Exists() and BMPullTime() < 5 then
        self:Opening()
        return
    end
    if GetTime() < Rotation.SpamPrevention then
        return
    end
    Rotation.SpamPrevention = GetTime() + 0.05
    Target = Unit.Target
    local InCombat = Player:IsInCombat()
    if not InCombat then
        self:OutOfCombat()
        return
    end
    if InCombat then
        self:Defensives()
    end
    Target = Player:ReTarget(MortalStrike, false) or Unit.Target
    if Target:Exists() then
        Rotations:RefreshUnitTables(Rotation.Identifier)
        self:Interrupts()
        self:OffGCDAbilities()
        if Player:GlobalCooldown() == 0 then
            self:Combat()
        end
    end
end
function Rotation:Opening()
    Player:UsePotions("力量药水")
    if
    IsOptionEnabled("抢先施放(需DBM插件)") and
    (GetOptionValue("抢先施放(需DBM插件)") == "无条件使用" or
    (GetOptionValue("抢先施放(需DBM插件)") == "打BOSS使用" and Target:IsBoss()))
    then
        if
        Charge:Exists() and BMPullTime() < GetSecondOptionValue("抢先施放(需DBM插件)") and Player:DistanceTo(Target) > 8 and
        Player:DistanceTo(Target) < 25 and
        Target:CanCast(Charge)
        then
            Player:StartAttack()
            Target:Cast(Charge)
            return
        end
    end
end
function Rotation:Defensives()
    Player:UseHealingItem()
    if
    DieByTheSword:Exists() and IsOptionEnabled("剑在人在") and Player:HealthPercentage() <= GetOptionValue("剑在人在") and
    Player:CanCast(DieByTheSword)
    then
        Player:Cast(DieByTheSword)
    end
    if
    GiftOfTheNaaru:Exists() and IsOptionEnabled("纳鲁的赐福") and
    Player:SpecialHealthPercentage() <= GetOptionValue("纳鲁的赐福") and
    Player:CanCast(GiftOfTheNaaru)
    then
        Player:Cast(GiftOfTheNaaru)
        return
    end
end
function Rotation:Interrupts()
    Player:UseInterrupt(Pummel, ArcaneTorrent)
end
function Rotation:OffGCDAbilities()
    self.BossTimeToDie = Target:IsBoss() and Target:TimeToDie() or 100
    self.BattleCryDeadlyCalm = (Player:Buff(BattleCry) and DeadlyCalm:Exists()) or false
    if Target:Exists() and Player:IsWithinCastRange(Target, MortalStrike) and Player:CanAttack(Target) then
        if
        Avatar:Exists() and CDOptionEnabled("天神下凡") and
        ((Player:GlobalCooldown() < 0.25 and (Player:Buff(BattleCry) or BattleCry:Cooldown() < 15)) or
        self.BossTimeToDie <= 20) and
        Player:CanCast(Avatar)
        then
            Player:Cast(Avatar)
            return
        end
        if
        Rotation.Status == "顺劈斩" and FocusedRage:Exists() and
        (Player:Rage() > 100 or (Player:Buff(BattleCry) and DeadlyCalm:Exists())) and
        Player:BuffCount(FocusedRage) < 3 and
        Player:CanCast(FocusedRage)
        then
            Player:Cast(FocusedRage)
            return
        end
        if
        Rotation.Status == "Single" and FocusedRage:Exists() and
        not (Player:Buff(BattleCry) and DeadlyCalm:Exists()) and
        Player:BuffCount(FocusedRage) < 3 and
        ColossusSmash:IsOnCooldown() and
        (Player:Rage() >= 50 or not Target:Debuff(ColossusSmashDebuff) or BattleCry:Cooldown() <= 8 or
        (BattleCry:Cooldown() <= 8 and BattleCry:Cooldown() > 0 and Player:Rage() > 100)) and
        Player:CanCast(FocusedRage)
        then
            Player:Cast(FocusedRage)
            return
        end
    end
end
function Rotation:UnitTables()
    Enemies_8y = UseAOE() and Player:EnemiesWithinDistance(8, true) or {}
    Enemies_5y = UseAOE() and Player:EnemiesWithinDistance(5, true) or {}
    ExecuteUnit = Unit.LightEnemyAvailableForSpellHP(Enemies_5y, Execute, 20)
    TargetEnemies_8y = UseAOE() and Target:EnemiesWithinDistance(8, true) or {}
    Enemies_Cleave = UseAOE() and Player:UnitsInFrontConeAroundUnit(Target, 7, 180) or {}
    RendUnit = Unit.DotCycle(Enemies_5y, Rend, Rend, 8, "多目标撕裂", false, false)
end
function Rotation:BattleCry()
    if
    BattleCry:Exists() and CDOptionEnabled("战吼") and Target:Health() >= GetSecondOptionValue("战吼") * 1000000 and
    Player:CanCast(BattleCry)
    then
        if CDOptionEnabled("进攻性种族技能") then
            if Berserking:Exists() and Player:CanCast(Berserking) then
                Player:Cast(Berserking)
            end
            if BloodFury:Exists() and Player:CanCast(BloodFury) then
                Player:Cast(BloodFury)
            end
        end
        Player:Cast(BattleCry)
        Player:UseTrinkets()
        if FocusedRage:Exists() and self.BattleCryDeadlyCalm and Player:BuffCount(FocusedRage) < 3 then
            Player:Cast(FocusedRage)
        end
    end
end
function Rotation:WarbreakerBladestorm()
    if
    Warbreaker:Exists() and IsOptionEnabled("灭战者搭配剑刃风暴") and #Enemies_8y >= GetOptionValue("灭战者搭配剑刃风暴") and
    Player:CanCast(Warbreaker)
    then
        Player:Cast(Warbreaker)
        return
    end
end
function Rotation:ExecuteHandler()
    if Target:CanCast(Execute) then
        self:BattleCry()
        Target:Cast(Execute)
        return
    end
    if GetSecondOptionValue("斩杀") == "任何单位" then
        if ExecuteUnit and ExecuteUnit:CanCast(Execute, true, true) then
            self:BattleCry()
            ExecuteUnit:Cast(Execute)
            return
        end
    end
end
function Rotation:Combat()
    if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        Player:StartAttack()
        if Player:IsWithinCastRange(Target, MortalStrike) and Player:CanAttack(Target) then
            if
            ((not Avatar:Exists() or Player:Buff(Avatar)) and Player:Buff(BattleCry) and
            Target:Debuff(ColossusSmashDebuff)) or
            (self.BossTimeToDie <= 26)
            then
                Player:UsePotions("力量药水")
            end
            if CDOptionEnabled("进攻性种族技能") then
                if
                ArcaneTorrent:Exists() and not self.BattleCryDeadlyCalm and Player:RageDeficit() > 40 and
                (BattleCry:Cooldown() or not DeadlyCalm:Exists()) and
                Player:CanCast(ArcaneTorrent)
                then
                    Player:Cast(ArcaneTorrent)
                end
            end
        end
        if
        VictoryRush:Exists() and IsOptionEnabled("乘胜追击") and Player:Buff(VictoryRushBuff) and
        Player:HealthPercentage() <= GetOptionValue("乘胜追击") and
        Target:CanCast(VictoryRush)
        then
            Target:Cast(VictoryRush)
            return
        end
        if
        Rend:Exists() and Target:DebuffRemains(Rend) < Player:GCD() and Target:HealthPercentage() >= 20 and
        Target:CanCast(Rend)
        then
            Target:Cast(Rend)
            return
        end
        if
        ColossusSmash:Exists() and Target:DebuffRemains(ColossusSmashDebuff) < Player:GCD() and
        Target:CanCast(ColossusSmash)
        then
            Target:Cast(ColossusSmash)
            return
        end
        if
        Warbreaker:Exists() and CDOptionEnabled("灭战者保持巨人打击效果") and
        (Target:DebuffRemains(ColossusSmashDebuff) < Player:GCD() or
        (TitanicMight:Exists() and not Player:Buff(ShatteredDefenses))) and
        Player:DistanceTo(Target) < 5 and
        Player:CanCast(Warbreaker)
        then
            Player:Cast(Warbreaker)
            return
        end
        if Ravager:Exists() and CDOptionEnabled("破坏者") and Target:CanCast(Ravager) then
            self:WarbreakerBladestorm()
            if Target:CastGroundSpell(Ravager, "Ravager AOE", 8) then
                return
            end
        end
        if #Enemies_8y >= GetOptionValue("顺劈斩") and SweepingStrikes:Exists() then
            Rotation.Status = "顺劈斩"
            if MortalStrike:Exists() and Target:CanCast(MortalStrike) then
                self:BattleCry()
                Target:Cast(MortalStrike)
                return
            end
            if Execute:Exists() and Player:Buff(StoneHeart) and Target:CanCast(Execute) then
                Target:Cast(Execute)
                return
            end
            if ColossusSmash:Exists() and not Player:Buff(ShatteredDefenses) and not ColossusSmash:IsOnCooldown() then
                if
                (not IsOptionEnabled("多目标巨人打击") or
                Target:DebuffRemains(ColossusSmashDebuff) < GetOptionValue("多目标巨人打击")) and
                Target:CanCast(ColossusSmash)
                then
                    Target:Cast(ColossusSmash)
                    return
                elseif IsOptionEnabled("多目标巨人打击") then
                    local ThisUnit, BestUnit, BestUnitHealth
                    for i = 1, #Enemies_5y do
                        ThisUnit = Enemies_5y[i]
                        if
                        not ThisUnit:Debuff(ColossusSmashDebuff) and
                        ThisUnit:Health() > GetSecondOptionValue("多目标巨人打击") * 1000000 and
                        ThisUnit:CanCast(ColossusSmash)
                        then
                            if BestUnit == nil or (ThisUnit:Health() < BestUnitHealth) then
                                BestUnit, BestUnitHealth = ThisUnit, ThisUnit:Health()
                            end
                        end
                    end
                    if BestUnit ~= nil then
                        BestUnit:Cast(ColossusSmash)
                        return
                    end
                end
            end
            if Execute:Exists() and Player:Rage() >= GetOptionValue("斩杀") then
                self:ExecuteHandler()
            end
            if
            Warbreaker:Exists() and CDOptionEnabled("灭战者保持巨人打击效果") and not Player:Buff(ShatteredDefenses) and
            Player:DistanceTo(Target) < 5 and
            Player:CanCast(Warbreaker)
            then
                Player:Cast(Warbreaker)
                return
            end
            if
            Whirlwind:Exists() and FervorOfBattle:Exists() and
            (Target:Debuff(ColossusSmashDebuff) or Player:RageDeficit() < 50) and
            (not FocusedRage:Exists() or self.BattleCryDeadlyCalm or Player:Buff(CleaveBuff)) and
            Player:IsWithinCastRange(Target, MortalStrike) and
            Player:CanCast(Whirlwind)
            then
                Player:Cast(Whirlwind)
                return
            end
            if Rend:Exists() then
                if Target:Exists() and Target:DebuffRemains(Rend) < 2.4 and Target:CanCast(Rend) then
                    Target:Cast(Rend)
                    return
                end
                if RendUnit and RendUnit:CanCast(Rend) then
                    RendUnit:Cast(Rend)
                    return
                end
            end
            if
            Bladestorm:Exists() and not Ravager:Exists() and CDOptionEnabled("剑刃风暴") and
            #Enemies_8y >= GetSecondOptionValue("剑刃风暴") and
            Player:IsWithinCastRange(Target, MortalStrike) and
            Player:CanCast(Bladestorm)
            then
                self:WarbreakerBladestorm()
                Player:Cast(Bladestorm)
                return
            end
            if Cleave:Exists() and #Enemies_Cleave > 1 and Player:Rage() >= 70 and Player:CanCast(Cleave) then
                Player:Cast(Cleave)
                return
            end
            if
            Whirlwind:Exists() and Player:Buff(CleaveBuff) and Player:IsWithinCastRange(Target, MortalStrike) and
            Player:CanCast(Whirlwind)
            then
                Player:Cast(Whirlwind)
                return
            end
            if Shockwave:Exists() and IsOptionEnabled("震荡波") and Player:CanCast(Shockwave) then
                Player:Cast(Shockwave)
                return
            end
            if StormBolt:Exists() and IsOptionEnabled("风暴之锤") and Player:CanCast(StormBolt) then
                Player:Cast(StormBolt)
                return
            end
            return
        end
        if #Enemies_8y >= GetOptionValue("AoE") and not SweepingStrikes:Exists() then
            Rotation.Status = "AoE"
            if MortalStrike:Exists() and Target:CanCast(MortalStrike) then
                self:BattleCry()
                Target:Cast(MortalStrike)
                return
            end
            if Execute:Exists() and Player:Buff(StoneHeart) and Target:CanCast(Execute) then
                Target:Cast(Execute)
                return
            end
            if
            ColossusSmash:Exists() and not Player:Buff(ShatteredDefenses) and not Player:Buff(PreciseStrikes) and
            not ColossusSmash:IsOnCooldown()
            then
                if
                (not IsOptionEnabled("多目标巨人打击") or
                Target:DebuffRemains(ColossusSmashDebuff) < GetOptionValue("多目标巨人打击")) and
                Target:CanCast(ColossusSmash)
                then
                    Target:Cast(ColossusSmash)
                    return
                elseif IsOptionEnabled("多目标巨人打击") then
                    local ThisUnit, BestUnit, BestUnitHealth
                    for i = 1, #Enemies_5y do
                        ThisUnit = Enemies_5y[i]
                        if
                        not ThisUnit:Debuff(ColossusSmashDebuff) and
                        ThisUnit:Health() > GetSecondOptionValue("多目标巨人打击") * 1000000 and
                        ThisUnit:CanCast(ColossusSmash)
                        then
                            if BestUnit == nil or (ThisUnit:Health() < BestUnitHealth) then
                                BestUnit, BestUnitHealth = ThisUnit, ThisUnit:Health()
                            end
                        end
                    end
                    if BestUnit ~= nil then
                        BestUnit:Cast(ColossusSmash)
                        return
                    end
                end
            end
            if
            Warbreaker:Exists() and CDOptionEnabled("灭战者保持巨人打击效果") and not Player:Buff(ShatteredDefenses) and
            Player:IsWithinCastRange(Target, MortalStrike) and
            Player:CanCast(Warbreaker)
            then
                Player:Cast(Warbreaker)
                return
            end
            if
            Whirlwind:Exists() and FervorOfBattle:Exists() and
            (Target:Debuff(ColossusSmashDebuff) or Player:RageDeficit() < 50) and
            (not FocusedRage:Exists() or self.BattleCryDeadlyCalm or Player:Buff(CleaveBuff)) and
            Player:IsWithinCastRange(Target, MortalStrike) and
            Player:CanCast(Whirlwind)
            then
                Player:Cast(Whirlwind)
                return
            end
            if Rend:Exists() then
                if Target:Exists() and Target:DebuffRemains(Rend) < 2.4 and Target:CanCast(Rend) then
                    Target:Cast(Rend)
                    return
                end
                if RendUnit and RendUnit:CanCast(Rend) then
                    RendUnit:Cast(Rend)
                    return
                end
            end
            if
            Bladestorm:Exists() and not Ravager:Exists() and CDOptionEnabled("剑刃风暴") and
            #Enemies_8y >= GetSecondOptionValue("剑刃风暴") and
            Player:IsWithinCastRange(Target, MortalStrike) and
            Player:CanCast(Bladestorm)
            then
                self:WarbreakerBladestorm()
                self:BattleCry()
                Player:Cast(Bladestorm)
                return
            end
            if Cleave:Exists() and #Enemies_Cleave > 1 and not Player:Buff(CleaveBuff) and Player:CanCast(Cleave) then
                Player:Cast(Cleave)
                return
            end
            if Execute:Exists() and Player:Rage() > 90 and Target:CanCast(Execute) then
                self:ExecuteHandler()
            end
            if
            Whirlwind:Exists() and Player:Rage() >= 40 and Player:IsWithinCastRange(Target, MortalStrike) and
            Player:CanCast(Whirlwind)
            then
                Player:Cast(Whirlwind)
                return
            end
            if Shockwave:Exists() and IsOptionEnabled("震荡波") and Player:CanCast(Shockwave) then
                Player:Cast(Shockwave)
                return
            end
            if StormBolt:Exists() and IsOptionEnabled("风暴之锤") and Player:CanCast(StormBolt) then
                Player:Cast(StormBolt)
                return
            end
            return
        end
        Rotation.Status = "Single"
        if Execute:Exists() and Target:HealthPercentage() <= 20 and #Enemies_8y < GetOptionValue("AoE") then
            if
            Bladestorm:Exists() and not Ravager:Exists() and CDOptionEnabled("剑刃风暴") and
            #Enemies_8y >= GetSecondOptionValue("剑刃风暴") and
            Player:IsWithinCastRange(Target, MortalStrike) and
            Player:Buff(BattleCry) and
            (HasT20_4Pc or TheGreatStormsEye:IsEquipped(1)) and
            Player:CanCast(Bladestorm)
            then
                self:WarbreakerBladestorm()
                Player:Cast(Bladestorm)
                return
            end
            if
            ColossusSmash:Exists() and not Player:Buff(ShatteredDefenses) and
            (not Player:Buff(BattleCry) or Player:BuffRemains(BattleCry) < Player:GCD()) and
            Target:CanCast(ColossusSmash)
            then
                Target:Cast(ColossusSmash)
                return
            end
            if
            Warbreaker:Exists() and CDOptionEnabled("灭战者保持巨人打击效果") and
            MortalStrike:Cooldown() <= Player:GlobalCooldown() and
            not Player:Buff(ShatteredDefenses) and
            Target:DebuffCount(ExecutionersPrecision) == 2 and
            Player:IsWithinCastRange(Target, MortalStrike) and
            Player:CanCast(Warbreaker)
            then
                Player:Cast(Warbreaker)
                return
            end
            if
            Rend:Exists() and Target:DebuffRemains(Rend) < 5 and BattleCry:Cooldown() < 2 and
            (Bladestorm:Cooldown() < 2 or not HasT20_4Pc) and
            Target:TimeToDie() > 3 and
            Target:CanCast(Rend)
            then
                Target:Cast(Rend)
                return
            end
            if
            MortalStrike:Exists() and Target:DebuffCount(ExecutionersPrecision) == 2 and
            Player:Buff(ShatteredDefenses) and
            Target:CanCast(MortalStrike)
            then
                self:BattleCry()
                Target:Cast(MortalStrike)
                return
            end
            if Overpower:Exists() and Player:Rage() < 40 and Target:CanCast(Overpower) then
                Target:Cast(Overpower)
                return
            end
            if
            Execute:Exists() and
            (not Player:Buff(ShatteredDefenses) or Player:Rage() >= 40 or
            (Dauntless:Exists() and Player:Rage() >= 36))
            then
                self:ExecuteHandler()
            end
            if
            Bladestorm:Exists() and not Ravager:Exists() and IsOptionEnabled("剑刃风暴作为填充技能") and
            Player:IsWithinCastRange(Target, MortalStrike) and
            Player:CanCast(Bladestorm)
            then
                self:WarbreakerBladestorm()
                Player:Cast(Bladestorm)
                return
            end
            return
        end
        if Target:HealthPercentage() > 20 then
            if Execute:Exists() and Player:Buff(StoneHeart) and Target:CanCast(Execute) then
                Target:Cast(Execute)
                return
            end
            if
            ColossusSmash:Exists() and not Player:Buff(ShatteredDefenses) and
            (not Player:Buff(BattleCry) or
            (Player:Buff(BattleCry) and Player:BuffRemains(BattleCry) > Player:GCD()) or
            (CorruptedBloodOfZakajz:ArtifactEnabled() and Player:BuffRemains(BattleCry) >= Player:GCD())) and
            Target:CanCast(ColossusSmash)
            then
                Target:Cast(ColossusSmash)
                return
            end
            if
            Bladestorm:Exists() and not Ravager:Exists() and CDOptionEnabled("剑刃风暴") and
            #Enemies_8y >= GetSecondOptionValue("剑刃风暴") and
            Player:IsWithinCastRange(Target, MortalStrike) and
            Player:Buff(BattleCry) and
            (HasT20_4Pc or TheGreatStormsEye:IsEquipped(1)) and
            Player:CanCast(Bladestorm)
            then
                self:WarbreakerBladestorm()
                Player:Cast(Bladestorm)
                return
            end
            if Overpower:Exists() and Player:Buff(OverpowerBuff) and Target:CanCast(Overpower) then
                Target:Cast(Overpower)
                return
            end
            if
            MortalStrike:Exists() and (Player:Buff(ShatteredDefenses) or not Target:Debuff(ExecutionersPrecision)) and
            Target:CanCast(MortalStrike)
            then
                self:BattleCry()
                Target:Cast(MortalStrike)
                return
            end
            if Rend:Exists() then
                if
                Target:Exists() and Target:DebuffRemains(Rend) < 2.4 and Target:TimeToDie() > 3 and
                Target:CanCast(Rend)
                then
                    Target:Cast(Rend)
                    return
                end
                if RendUnit and RendUnit:TimeToDie() > 3 and RendUnit:CanCast(Rend) then
                    RendUnit:Cast(Rend)
                    return
                end
            end
            if
            Cleave:Exists() and #Enemies_Cleave > 1 and
            ((Player:Rage() < 30 and not Dauntless:Exists()) or (Player:Rage() < 24 and Dauntless:Exists())) and
            not Player:Buff(CleaveBuff) and
            Player:CanCast(Cleave)
            then
                Player:Cast(Cleave)
                return
            end
            if #Enemies_8y >= 2 or FervorOfBattle:Exists() then
                if
                Whirlwind:Exists() and (Player:Rage() >= 45 or Player:Buff(BattleCry)) and
                Player:IsWithinCastRange(Target, MortalStrike) and
                Player:CanCast(Whirlwind)
                then
                    Player:Cast(Whirlwind)
                    return
                end
            else
                if
                Slam:Exists() and (Player:Rage() >= 36 or Player:Buff(BattleCry)) and
                (Player:Rage() >= 52 or not Ravager:Exists() or not Rend:Exists()) and
                Target:CanCast(Slam)
                then
                    Target:Cast(Slam)
                    return
                end
            end
            if
            Bladestorm:Exists() and not Ravager:Exists() and IsOptionEnabled("剑刃风暴作为填充技能") and
            Player:IsWithinCastRange(Target, MortalStrike) and
            Player:CanCast(Bladestorm)
            then
                self:WarbreakerBladestorm()
                Player:Cast(Bladestorm)
                return
            end
            return
        end
    end
end
function Rotation:OutOfCombat()
    if
    Charge:Exists() and IsOptionEnabled("自动进入战斗") and Player:DistanceTo(Target) >= 8 and
    Player:DistanceTo(Target) <= 25 and
    Target:CanCast(Charge)
    then
        Target:Cast(Charge)
        return
    end
end
SetRotation(72, {})
local Rotation = Rotations[72]
function Rotation:Initialize()
    ArcaneTorrent = Spell(69179, false, false, true)
    Berserking = Spell(26297, false, false, true)
    BloodFury = Spell(20572, false, false, true)
    GiftOfTheNaaru = Spell(59547, false, false, true)
    Avatar = Spell(107574, false, false, true)
    BattleCry = Spell(1719, false, false, true)
    BerserkerRage = Spell(18499, false, false, true)
    Bladestorm = Spell(46924, false, false, true)
    Bloodbath = Spell(12292, false, false, true)
    Bloodthirst = Spell(23881, true, true, true)
    Charge = Spell(100, true, true, true)
    CommandingShout = Spell(97462, false, false, true)
    DragonRoar = Spell(118000, false, false, true)
    EnragedRegeneration = Spell(184364, false, false, true)
    Execute = Spell(5308, true, true, true)
    HeroicThrow = Spell(57755, true, true, true)
    FuriousSlash = Spell(100130, true, true, true)
    OdynsFury = Spell(205545, false, false, true)
    Pummel = Spell(6552, true, true, true)
    RagingBlow = Spell(85288, true, true, true)
    Rampage = Spell(184367, true, true, true)
    Shockwave = Spell(46968, true, false, true)
    StormBolt = Spell(107570, true, true, true)
    Whirlwind = Spell(190411, false, false, true)
    Carnage = Spell(202922)
    Enrage = Spell(184362)
    Frenzy = Spell(206313)
    FrenzyBuff = Spell(202539)
    FrothingBerserker = Spell(215571)
    FrothingBerserkerBuff = Spell(215572)
    InnerRage = Spell(215573)
    Juggernaut = Spell(201009)
    JuggernautTrait = Spell(200875)
    Massacre = Spell(206316)
    MeatCleaver = Spell(85739)
    Outburst = Spell(206320)
    RecklessAbandon = Spell(202751)
    WreckingBall = Spell(215570)
    SenseDeathBuff = Spell(200979)
    WarMachine = Spell(215556)
    WarMachineBuff = Spell(215562)
    FelCrazedRage = Spell(225141)
    Temptation = Spell(234143)
    DeathRow = Spell(217959)
    OdynsGaze = Spell(215997)
    FujiedasFuryBuff = Spell(207775)
    StoneHeart = Spell(225947)
    NajentussVertebrae = Item(137087)
    ConvergenceOfFates = Item(140806)
    FujiedasFury = Item(137053)
    DraughtOfSouls = Item(140808)
    BurningWish = Item(144259)
    RingOfCollapsingFutures = Item(142173)
    AddPage("常规")
    AddPage("进攻")
    AddPage("防御")
    AddCommonOptions()
    AddPresetOption("常规", "Melee")
    AddPresetOption("进攻")
    AddNewOption(
    "进攻",
    "灵魂之引",
    230,
    true,
    { 1, "打BOSS使用", "无条件使用" },
    nil,
    "Use Draught Of Souls trinket" ..
    C.TOOLTIP_VALUE ..
    C.TOOLTIP_SUBVALUE("打BOSS使用", true) ..
    "Only use Draught Of Souls on Bosses only." ..
    C.TOOLTIP_SUBVALUE("无条件使用") .. "Always use Draught Of Souls."
    )
    AddSection("进攻", "大技能", "Yellow")
    AddPresetOption("Cooldown", "天神下凡")
    AddPresetOption("Cooldown", "战吼")
    AddPresetOption("Cooldown", "剑刃风暴", nil, { 2, 1, 10, 1 }, "Amount of units that needs to be in range to use.")
    AddPresetOption("Cooldown", "浴血奋战")
    AddPresetOption("Cooldown", "巨龙怒吼", nil, { 1, 1, 10, 1 }, "Amount of units that needs to be in range to use.")
    AddPresetOption("Cooldown", "奥丁之怒")
    AddSection("进攻", "能力", "Yellow")
    AddNewOption(
    "进攻",
    "斩杀",
    230,
    true,
    { 2, "只有目标", "任何单位" },
    nil,
    "Use Execute on low health Targets." ..
    C.TOOLTIP_VALUE ..
    C.TOOLTIP_SUBVALUE("只有目标", true) ..
    "Only use Execute on current Target." ..
    C.TOOLTIP_SUBVALUE("任何单位") .. "Use Execute on any available unit that is in range."
    )
    AddNewOption(
    "进攻",
    "震荡波",
    220,
    false,
    { 3, 1, 10, 1 },
    nil,
    "Use Shockwave." .. C.TOOLTIP_VALUE .. "Define number of units needed in front of us to use Shockwave."
    )
    AddSection("进攻", "循环", "Yellow")
    AddNewOption("进攻", "AoE", 120, true, { 4, 1, 10, 1 }, nil, "Amount of units needed to use AoE.")
    AddPresetOption("防御")
    AddSection("防御", "能力", "Yellow")
    AddNewOption(
    "防御",
    "狂怒回复",
    220,
    true,
    { 30, 1, 100, 1 },
    nil,
    "Use Enraged Regeneration." .. C.TOOLTIP_VALUE .. "Health threshold."
    )
end
function Rotation:Events()
end
function Rotation:Pulse()
    if
    not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() or
    Player:Buff(FelCrazedRage)
    then
        return
    end
    if Target:Exists() and BMPullTime() < 5 then
        return self:Opening()
    end
    if GetTime() < Rotation.SpamPrevention then
        return
    end
    Rotation.SpamPrevention = GetTime() + 0.05
    Target = Unit.Target
    local InCombat = Player:IsInCombat()
    if not InCombat then
        return self:OutOfCombat()
    end
    if InCombat then
        self:Defensives()
    end
    Target = Player:ReTarget(Bloodthirst, false) or Unit.Target
    if Target:Exists() then
        Rotations:RefreshUnitTables(Rotation.Identifier)
        self:Interrupts()
        self:OffGCDAbilities()
        if Player:GlobalCooldown() == 0 then
            self:Combat()
        end
    end
end
function Rotation:Opening()
    Player:UsePotions("力量药水")
    if
    IsOptionEnabled("抢先施放(需DBM插件)") and
    (GetOptionValue("抢先施放(需DBM插件)") == "无条件使用" or
    (GetOptionValue("抢先施放(需DBM插件)") == "打BOSS使用" and Target:IsBoss()))
    then
        if
        Charge:Exists() and BMPullTime() < GetSecondOptionValue("抢先施放(需DBM插件)") and Player:DistanceTo(Target) > 8 and
        Player:DistanceTo(Target) < 25 and
        Target:CanCast(Charge)
        then
            Player:StartAttack()
            return Target:Cast(Charge)
        end
    end
end
function Rotation:Defensives()
    Player:UseHealingItem()
    if
    EnragedRegeneration:Exists() and IsOptionEnabled("狂怒回复") and Player:HealthPercentage() <= GetOptionValue("狂怒回复") and
    Player:CanCast(EnragedRegeneration)
    then
        Player:Cast(EnragedRegeneration)
    end
    if
    GiftOfTheNaaru:Exists() and IsOptionEnabled("纳鲁的赐福") and
    Player:SpecialHealthPercentage() <= GetOptionValue("纳鲁的赐福") and
    Player:CanCast(GiftOfTheNaaru)
    then
        return Player:Cast(GiftOfTheNaaru)
    end
end
function Rotation:Interrupts()
    Player:UseInterrupt(Pummel, ArcaneTorrent)
end
function Rotation:OffGCDAbilities()
end
function Rotation:UnitTables()
    Enemies_20y = UseAOE() and Player:EnemiesWithinDistance(20, true) or {}
    Enemies_14y = UseAOE() and Player:EnemiesWithinDistance(14, true) or {}
    Enemies_8y = UseAOE() and Player:EnemiesWithinDistance(8, true) or {}
    Enemies_5y = UseAOE() and Player:EnemiesWithinDistance(5) or {}
    NumEnemies_20y = #Enemies_20y
    NumEnemies_14y = #Enemies_14y
    NumEnemies_8y = #Enemies_8y
    ExecuteHealth = (select(10, _G["GetPvpTalentInfo"](3, 1, 1)) and Player:PVPCombat()) and 25 or 20
    ExecuteUnit = Unit.LightEnemyAvailableForSpellHP(Enemies_5y, Execute, ExecuteHealth)
    WarMachineUnit =     WarMachine:Exists() and Unit.LightEnemyAvailableForSpellHP(Enemies_5y, Execute, ExecuteHealth, false, 5) or nil
    ShockwaveCount = UseAOE() and Shockwave:Exists() and #Player:UnitsInFrontCone(10, 140) or 0
end
function Rotation:ExecuteHandler()
    if Target:CanCast(Execute) then
        return Target:Cast(Execute)
    end
    if GetOptionValue("斩杀") == "任何单位" then
        if ExecuteUnit and ExecuteUnit:CanCast(Execute, true, true) then
            return ExecuteUnit:Cast(Execute)
        end
    end
end
function Rotation:Cooldowns()
    if isPlayer and Player:Buff(Enrage) and BurningWishEnabled and not BurningWish:IsOnCooldown() then
        Target:UseItem(BurningWish)
    end
    if
    Rampage:Exists() and Massacre:Exists() and Player:Buff(Massacre) and Player:BuffRemains(Enrage) < 1 and
    Target:CanCast(Rampage)
    then
        return Target:Cast(Rampage)
    end
    if
    Bloodthirst:Exists() and Target:HealthPercentage() < ExecuteHealth and Player:BuffRemains(Enrage) < 1 and
    Target:CanCast(Bloodthirst)
    then
        return Target:Cast(Bloodthirst)
    end
    local OdynsFuryReady = not OdynsFury:IsOnCooldown()
    OdynsFuryEnabled = OdynsFury:Exists() and CDOptionEnabled("奥丁之怒") or false
    if OdynsFuryEnabled and NumEnemies_14y > 1 and Player:Buff(Enrage) and Player:CanCast(OdynsFury) then
        return Player:Cast(OdynsFury)
    end
    if
    Execute:Exists() and DraughtOfSouls:IsEquipped(13, 14) and DraughtOfSouls:Cooldown() < 1 and
    Player:BuffRemains(Juggernaut) < 3
    then
        self:ExecuteHandler()
    end
    if
    DraughtUsable and NumEnemies_8y < 9 and Player:BuffRemains(Enrage) > 2 and Player:BuffRemains(BattleCry) > 2 and
    not DraughtOfSouls:IsOnCooldown() and
    (Player:BuffRemains(DragonRoar) >= 3 or not DragonRoarEnabled) and
    Player:IsWithinCastRange(Target, Bloodthirst)
    then
        Player:UseItem(DraughtOfSouls)
    end
    WhirlwindUnits = NajentussVertebrae:IsEquipped(6) and 2 or 3
    if
    Whirlwind:Exists() and NumEnemies_8y > WhirlwindUnits and not Player:Buff(MeatCleaver) and
    Player:IsWithinCastRange(Target, Bloodthirst) and
    Player:CanCast(Whirlwind)
    then
        return Player:Cast(Whirlwind)
    end
    if Execute:Exists() then
        self:ExecuteHandler()
    end
    if RagingBlow:Exists() and InnerRage:Exists() and Player:Buff(Enrage) and Target:CanCast(RagingBlow) then
        return Target:Cast(RagingBlow)
    end
    if Rampage:Exists() and (not FrothingBerserker:Exists() or Player:Rage() >= 100) and Target:CanCast(Rampage) then
        return Target:Cast(Rampage)
    end
    if
    BerserkerRage:Exists() and Outburst:Exists() and not Player:Buff(Enrage) and Player:Buff(BattleCry) and
    Player:CanCast(BerserkerRage)
    then
        return Player:Cast(BerserkerRage)
    end
    if Bloodthirst:Exists() and Player:BuffRemains(Enrage) < 1 and not Outburst:Exists() and Target:CanCast(Bloodthirst) then
        return Target:Cast(Bloodthirst)
    end
    if OdynsFuryEnabled and Player:IsWithinCastRange(Target, Bloodthirst) and Player:CanCast(OdynsFury) then
        return Player:Cast(OdynsFury)
    end
    if RagingBlow:Exists() and InnerRage:Exists() and Target:CanCast(RagingBlow) then
        return Target:Cast(RagingBlow)
    end
    if
    Whirlwind:Exists() and Player:Buff(WreckingBall) and Player:Buff(Enrage) and
    Player:IsWithinCastRange(Target, Bloodthirst) and
    UseAOE() and
    Player:CanCast(Whirlwind)
    then
        return Player:Cast(Whirlwind)
    end
    if RagingBlow:Exists() and not InnerRage:Exists() and Target:CanCast(RagingBlow) then
        return Target:Cast(RagingBlow)
    end
    if
    Whirlwind:Exists() and NumEnemies_8y > 1 and not Player:Buff(MeatCleaver) and
    Player:IsWithinCastRange(Target, Bloodthirst) and
    Player:CanCast(Whirlwind)
    then
        return Player:Cast(Whirlwind)
    end
    if Bloodthirst:Exists() and Target:CanCast(Bloodthirst) then
        return Target:Cast(Bloodthirst)
    end
    if FuriousSlash:Exists() and Target:CanCast(FuriousSlash) then
        return Target:Cast(FuriousSlash)
    end
end
function Rotation:AOE()
    if
    Bloodthirst:Exists() and (not Player:Buff(Enrage) or Player:Rage() < 50) and NumEnemies_8y < 4 and
    Target:CanCast(Bloodthirst)
    then
        return Target:Cast(Bloodthirst)
    end
    if
    Bladestorm:Exists() and CDOptionEnabled("剑刃风暴") and Player:BuffRemains(Enrage) > 2 and
    (NumEnemies_8y >= GetSecondOptionValue("剑刃风暴")) and
    Player:IsWithinCastRange(Target, Bloodthirst) and
    Player:CanCast(Bladestorm)
    then
        return Player:Cast(Bladestorm)
    end
    if
    Whirlwind:Exists() and not Player:Buff(MeatCleaver) and Player:IsWithinCastRange(Target, Bloodthirst) and
    Player:CanCast(Whirlwind)
    then
        return Player:Cast(Whirlwind)
    end
    if Execute:Exists() and Player:Buff(Juggernaut) and Player:BuffRemains(Juggernaut) < 1 then
        self:ExecuteHandler()
    end
    if Execute:Exists() and NumEnemies_8y < 6 and Massacre:Exists() and not Player:Buff(Massacre) then
        self:ExecuteHandler()
    end
    if
    Rampage:Exists() and Player:Buff(MeatCleaver) and
    ((not Player:Buff(Enrage) and not FrothingBerserker:Exists()) or Player:Buff(Massacre) or
    Player:Rage() >= 100) and
    Target:CanCast(Rampage)
    then
        return Target:Cast(Rampage)
    end
    if Bloodthirst:Exists() and NumEnemies_8y < 11 and Target:CanCast(Bloodthirst) then
        return Target:Cast(Bloodthirst)
    end
    if Whirlwind:Exists() and Player:IsWithinCastRange(Target, Bloodthirst) and Player:CanCast(Whirlwind) then
        return Player:Cast(Whirlwind)
    end
end
function Rotation:Execute()
    if
    Bloodthirst:Exists() and Player:Buff(FujiedasFuryBuff) and Player:BuffRemains(FujiedasFuryBuff) < 2 and
    Target:CanCast(Bloodthirst)
    then
        return Target:Cast(Bloodthirst)
    end
    if
    Execute:Exists() and
    ((JuggernautTrait:ArtifactEnabled() and (not Player:Buff(Juggernaut) or Player:BuffRemains(Juggernaut) < 3)) or
    Player:Buff(StoneHeart))
    then
        self:ExecuteHandler()
    end
    if FuriousSlash:Exists() and Frenzy:Exists() and Player:BuffRemains(Frenzy) <= 2 and Target:CanCast(FuriousSlash) then
        return Target:Cast(FuriousSlash)
    end
    if Rampage:Exists() and Player:Buff(Massacre) and Player:BuffRemains(Enrage) < 1 and Target:CanCast(Rampage) then
        return Target:Cast(Rampage)
    end
    if Execute:Exists() then
        if Player:Rage() >= 50 then
            self:ExecuteHandler()
        end
        if Player:Buff(SenseDeathBuff) then
            self:ExecuteHandler()
        end
        BattleCryEnabled = BattleCry:Exists() and CDOptionEnabled("战吼")
        if RecklessAbandon:Exists() and BattleCryEnabled and BattleCry:Cooldown() < 5 then
            self:ExecuteHandler()
        end
        if Target:TimeToDie() < 10 then
            self:ExecuteHandler()
        end
    end
    if Bloodthirst:Exists() and Target:CanCast(Bloodthirst) then
        return Target:Cast(Bloodthirst)
    end
    if
    Whirlwind:Exists() and NumEnemies_8y > 2 and Player:Buff(WreckingBall) and Player:Buff(Enrage) and
    Player:IsWithinCastRange(Target, Bloodthirst) and
    Player:CanCast(Whirlwind)
    then
        return Player:Cast(Whirlwind)
    end
    if FuriousSlash:Exists() and HasT19_2Pc and Target:CanCast(FuriousSlash) then
        return Target:Cast(FuriousSlash)
    end
    if RagingBlow:Exists() and Target:CanCast(RagingBlow) then
        return Target:Cast(RagingBlow)
    end
    if FuriousSlash:Exists() and Target:CanCast(FuriousSlash) then
        return Target:Cast(FuriousSlash)
    end
end
function Rotation:SingleTarget()
    if
    Bloodthirst:Exists() and Player:Buff(FujiedasFuryBuff) and Player:BuffRemains(FujiedasFuryBuff) < 2 and
    Target:CanCast(Bloodthirst)
    then
        return Target:Cast(Bloodthirst)
    end
    if
    Execute:Exists() and WarMachine:Exists() and WarMachineUnit and Player:BuffRemains(WarMachineBuff) < 5 and
    WarMachineUnit:CanCast(Execute, true, true)
    then
        return WarMachineUnit:Cast(Execute)
    end
    if Execute:Exists() and Player:Buff(Juggernaut) and Player:BuffRemains(Juggernaut) < 3 then
        self:ExecuteHandler()
    end
    if
    FuriousSlash:Exists() and Frenzy:Exists() and
    (not Player:Buff(FrenzyBuff) or Player:BuffRemains(FrenzyBuff) <= 2) and
    Target:CanCast(FuriousSlash)
    then
        return Target:Cast(FuriousSlash)
    end
    if
    Whirlwind:Exists() and NumEnemies_8y > 2 and Player:Buff(WreckingBall) and
    Player:IsWithinCastRange(Target, Bloodthirst) and
    Player:CanCast(Whirlwind)
    then
        return Player:Cast(Whirlwind)
    end
    if RagingBlow:Exists() and InnerRage:Exists() and Player:Buff(Enrage) and Target:CanCast(RagingBlow) then
        return Target:Cast(RagingBlow)
    end
    if
    Whirlwind:Exists() and NumEnemies_8y > 1 and not Player:Buff(MeatCleaver) and
    Player:IsWithinCastRange(Target, Bloodthirst) and
    Player:CanCast(Whirlwind)
    then
        return Player:Cast(Whirlwind)
    end
    if
    Rampage:Exists() and
    ((not Player:Buff(Enrage) and not FrothingBerserker:Exists()) or Player:Buff(Massacre) or
    Player:Rage() >= 100) and
    Target:CanCast(Rampage)
    then
        return Target:Cast(Rampage)
    end
    if
    Execute:Exists() and Player:Buff(StoneHeart) and
    ((InnerRage:Exists() and RagingBlow:Cooldown() > 1) or Player:Buff(Enrage))
    then
        self:ExecuteHandler()
    end
    if Bloodthirst:Exists() and Target:CanCast(Bloodthirst) then
        return Target:Cast(Bloodthirst)
    end
    if RagingBlow:Exists() and InnerRage:Exists() and Target:CanCast(RagingBlow) then
        return Target:Cast(RagingBlow)
    end
    if
    Whirlwind:Exists() and Player:Buff(WreckingBall) and Player:Buff(Enrage) and
    Player:IsWithinCastRange(Target, Bloodthirst) and
    UseAOE() and
    Player:CanCast(Whirlwind)
    then
        return Player:Cast(Whirlwind)
    end
    if
    Bladestorm:Exists() and CDOptionEnabled("剑刃风暴") and Player:BuffRemains(Enrage) > 2 and
    (NumEnemies_8y >= GetSecondOptionValue("剑刃风暴")) and
    Player:IsWithinCastRange(Target, Bloodthirst) and
    Player:CanCast(Bladestorm)
    then
        return Player:Cast(Bladestorm)
    end
    if RagingBlow:Exists() and not HasT19_2Pc and not InnerRage:Exists() and Target:CanCast(RagingBlow) then
        return Target:Cast(RagingBlow)
    end
    if
    Whirlwind:Exists() and NumEnemies_8y > 2 and Player:IsWithinCastRange(Target, Bloodthirst) and
    Player:CanCast(Whirlwind)
    then
        return Player:Cast(Whirlwind)
    end
    if FuriousSlash:Exists() and Target:CanCast(FuriousSlash) then
        return Target:Cast(FuriousSlash)
    end
end
function Rotation:Combat()
    if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        Player:StartAttack()
        if
        Shockwave:Exists() and IsOptionEnabled("震荡波") and ShockwaveCount >= GetOptionValue("震荡波") and
        Player:CanCast(Shockwave)
        then
            return Player:Cast(Shockwave)
        end
        DragonRoarEnabled =         DragonRoar:Exists() and CDOptionEnabled("巨龙怒吼") and NumEnemies_8y >= GetSecondOptionValue("巨龙怒吼") or false
        BattleCryEnabled = (BattleCry:Exists() and CDOptionEnabled("战吼")) or false
        BloodbathEnabled = (Bloodbath:Exists() and CDOptionEnabled("浴血奋战")) or false
        BattleCryCooldown = BattleCryEnabled and BattleCry:Cooldown() or 60
        AvatarEnabled = Avatar:Exists() and CDOptionEnabled("天神下凡")
        if Player:IsWithinCastRange(Target, Bloodthirst) then
            if
            AvatarEnabled and (Player:BuffRemains(BattleCry) > 5 or BattleCry:Cooldown() < 9) and
            Player:CanCast(Avatar)
            then
                Player:Cast(Avatar)
            end
            if CDOptionEnabled("进攻性种族技能") then
                if
                BloodFury:Exists() and
                ((Player:Rage() < 100 and BattleCryCooldown < Player:GCD()) or Player:Buff(BattleCry)) and
                Player:CanCast(BloodFury)
                then
                    Player:Cast(BloodFury)
                end
                if
                Berserking:Exists() and
                ((Player:Rage() < 100 and BattleCryCooldown < Player:GCD()) or Player:Buff(BattleCry)) and
                Player:CanCast(Berserking)
                then
                    Player:Cast(Berserking)
                end
                if ArcaneTorrent:Exists() and Player:Rage() < Player:RageMax() - 40 and Player:CanCast(ArcaneTorrent) then
                    Player:Cast(ArcaneTorrent)
                end
            end
            Player:UsePotions("力量药水")
            if
            DragonRoarEnabled and
            ((ConvergenceOfFates:IsEquipped(13, 14) and BattleCryCooldown < 2) or
            (not ConvergenceOfFates:IsEquipped(13, 14) and (BattleCryCooldown > 10 or BattleCryCooldown < 2))) and
            Player:DistanceTo(Target) < 8 and
            Player:CanCast(DragonRoar)
            then
                return Player:Cast(DragonRoar)
            end
            if BattleCryEnabled and Player:CanCast(BattleCry) and Player:Rage() < 100 then
                if
                not DragonRoarEnabled and
                (not ConvergenceOfFates:IsEquipped(13, 14) or not BloodbathEnabled or
                not Bloodbath:IsOnCooldown() or
                Bloodbath:Cooldown() >= 10)
                then
                    return Player:Cast(BattleCry)
                end
                if
                Player:Buff(DragonRoar) and
                (Bloodthirst:Cooldown() == 0 or (Player:BuffRemains(Enrage) > Bloodthirst:Cooldown()))
                then
                    return Player:Cast(BattleCry)
                end
            end
            if
            RingOfCollapsingFutures:IsEquipped(11, 12) and
            (GetOptionValue("戒指 | 项链") ~= "禁用" and (CooldownsAllowed() or GetOptionValue("戒指 | 项链") == "无条件使用")) and
            Player:Buff(BattleCry) and
            Player:Buff(Enrage) and
            not Player:Debuff(Temptation) and
            not RingOfCollapsingFutures:IsOnCooldown()
            then
                Target:UseItem(RingOfCollapsingFutures)
            end
            DraughtEquipped = DraughtOfSouls:IsEquipped(13, 14)
            DraughtEnabled =             IsOptionEnabled("灵魂之引") and
            ((DraughtEquipped == 13 and GetOptionValue("饰品: 1 | 2") ~= "禁用" and
            (CooldownsAllowed() or GetOptionValue("饰品: 1 | 2") == "无条件使用")) or
            (DraughtEquipped == 14 and GetSecondOptionValue("饰品: 1 | 2") ~= "禁用" and
            (CooldownsAllowed() or GetSecondOptionValue("饰品: 1 | 2") == "无条件使用")))
            DraughtUsable =             DraughtEnabled and
            (GetOptionValue("灵魂之引") == "无条件使用" or (GetOptionValue("灵魂之引") == "打BOSS使用" and Target:IsBoss()))
            BattleCryBuff = Player:BuffRemains(BattleCry)
            if
            BattleCryBuff > 0 and
            (not DraughtEquipped or
            (DraughtOfSouls:Cooldown() > 1 and
            (BattleCryBuff < 2 or DraughtOfSouls:Cooldown() > Player:BuffRemains(BattleCry) - 2)))
            then
                Player:UseTrinkets()
            end
            isPlayer = Target:IsPlayer()
            BurningWishEquipped = BurningWish:IsEquipped(13, 14)
            BurningWishEnabled =             BurningWishEquipped == 13 and
            (GetOptionValue("饰品: 1 | 2") ~= "禁用" and (CooldownsAllowed() or GetOptionValue("饰品: 1 | 2") == "无条件使用")) or
            (BurningWishEquipped == 14 and GetSecondOptionValue("饰品: 1 | 2") ~= "禁用" and
            (CooldownsAllowed() or GetSecondOptionValue("饰品: 1 | 2") == "无条件使用"))
            if
            BurningWishEnabled and not BurningWish:IsOnCooldown() and
            (Player:Buff(BattleCry) or BattleCry:Cooldown() > 17)
            then
                Target:UseItem(BurningWish)
            end
            if
            BloodbathEnabled and (Player:Buff(DragonRoar) or (not DragonRoarEnabled and Player:Buff(BattleCry))) and
            Player:CanCast(Bloodbath)
            then
                Player:Cast(Bloodbath)
            end
        end
        if Player:Buff(BattleCry) then
            return self:Cooldowns()
        end
        if NumEnemies_8y >= GetOptionValue("AoE") then
            return self:AOE()
        end
        if Target:HealthPercentage() < ExecuteHealth then
            return self:Execute()
        end
        if Target:HealthPercentage() >= ExecuteHealth then
            return self:SingleTarget()
        end
    end
end
function Rotation:OutOfCombat()
    if
    Charge:Exists() and IsOptionEnabled("自动进入战斗") and Player:DistanceTo(Target) >= 8 and
    Player:DistanceTo(Target) <= 25 and
    Target:CanCast(Charge)
    then
        return Target:Cast(Charge)
    end
    if Player:Debuff(OdynsGaze) and not Player:IsCasting() and Player:Standing() > 0.5 and not IsFalling() then
        return RunMacroText("/click ExtraActionButton1")
    end
end
SetRotation(73, {})
local Rotation = Rotations[73]
function Rotation:Initialize()
    ArcaneTorrent = Spell(69179, false, false, true)
    Berserking = Spell(26297, false, false, true)
    BloodFury = Spell(20572, false, false, true)
    GiftOfTheNaaru = Spell(28880, false, false, true)
    Avatar = Spell(107574, false, false, true)
    BattleCry = Spell(1719, false, false, true)
    BerserkerRage = Spell(18499, false, false, true)
    BoomingVoice = Spell(202743)
    CracklingThunder = Spell(203201)
    DeepWounds = Spell(115767)
    DemoralizingShout = Spell(1160, false, false, true)
    Devastate = Spell(20243, true, true, true)
    Devastator = Spell(236279)
    FocusedRage = Spell(204488, false, false, true)
    HeavyRepercussions = Spell(203177)
    HeroicThrow = Spell(57755, true, true, true)
    IgnorePain = Spell(190456, false, false, true)
    ImpendingVictory = Spell(202168, true, true, true)
    Intercept = Spell(198304, true, true, true)
    LastStand = Spell(12975, false, false, true)
    NeltharionsFury = Spell(203524, false, false, true)
    NeverSurrender = Spell(202561)
    Pummel = Spell(6552, true, true, true)
    Ravager = Spell(228920, true, true, true)
    Revenge = Spell(6572, false, false, true)
    RevengeFreeBuff = Spell(5302)
    ShieldBlock = Spell(2565, false, false, true)
    ShieldBlockBuff = Spell(132404)
    ShieldSlam = Spell(23922, true, true, true)
    ShieldWall = Spell(871, false, false, true)
    Shockwave = Spell(46968, true, false, true)
    SpellReflection = Spell(23920, false, false, true)
    StormBolt = Spell(107570, true, true, true)
    Taunt = Spell(355, false, true, true)
    ThunderClap = Spell(6343, false, false, true)
    Vengeance = Spell(202572)
    VengeanceRevenge = Spell(202573)
    VengeanceIgnorePain = Spell(202574)
    Victorious = Spell(32216)
    VictoryRush = Spell(34428, true, true, true)
    HandOfProtection = Spell(1022, false, false, true)
    HandOfProtectionName = GetSpellInfo(1022)
    AddPage("常规")
    AddPage("进攻")
    AddPage("防御")
    AddCommonOptions()
    AddPresetOption("常规", "Melee", nil, false)
    AddPresetOption("TankingFeatures", { "嘲讽", "嘲讽" })
    AddSection("常规", { "辅助", "效用" }, "Yellow")
    AddNewOption(
    "常规",
    { "战斗时自动拦截", "自动拦截在战斗中" },
    220,
    false,
    { 15, 6.5, 22, 0.5 },
    nil,
    { "Distance away from the target to auto use Intercept while in combat.", "远离目标到自动使用在战斗中截取。" }
    )
    AddPresetOption("进攻")
    AddSection("进攻", { "大技能", "酷唐斯" }, "Yellow")
    AddPresetOption("Cooldown", { "天神下凡", "天神下凡" })
    AddPresetOption("Cooldown", { "战吼", "战吼" }, 1)
    AddPresetOption(
    "Cooldown",
    { "狂暴之怒", "狂暴之怒" },
    1,
    { 60, 0, 100, 1 },
    { "Use if you have less than the given amount of rage. (For use with T20)", "如果您的使用量少于给定的愤怒数量。 （用于T20）" }
    )
    AddSection("进攻", { "能力", "能力" }, "Yellow")
    AddNewOption(
    "进攻",
    { "英勇投掷", "英勇投掷" },
    210,
    true,
    nil,
    nil,
    { "Use Heroic Throw while we are out of range.", "当我们超出范围时使用英雄投掷。" }
    )
    AddNewOption(
    "进攻",
    { "奈萨里奥之怒", "奈萨里奥之怒" },
    220,
    true,
    { 2, 1, 10, 1 },
    nil,
    {
        "Use Neltharion's Fury." .. C.TOOLTIP_VALUE .. "Amount of units needed in front of us to use.",
        "使用奈萨里奥之怒。" .. C.TOOLTIP_VALUE .. "在我们面前使用的单位数量。"
    }
    )
    AddNewOption(
    "进攻",
    "破坏者",
    232,
    true,
    { 2, "目标", "Target Standing", "Centered", "Centered Standing" },
    { 2, 1, 25, 1 },
    "Use Ravager." ..
    C.TOOLTIP_VALUE_1 ..
    "Choose preferred mode." ..
    C.TOOLTIP_SUBVALUE("目标") ..
    "Always use on the current target." ..
    C.TOOLTIP_SUBVALUE("Target Standing") ..
    "Always use on the current target. Target must be standing still." ..
    C.TOOLTIP_SUBVALUE("Centered") ..
    "Use centered on a cluster of enemies." ..
    C.TOOLTIP_SUBVALUE("Centered Standing") ..
    "Use centered on a cluster of enemies. Enemies must be standing still." ..
    C.TOOLTIP_VALUE_2 ..
    "Amount of enemies that must be in the spell effect to use."
    )
    AddNewOption(
    "进攻",
    { "震荡波", "震荡波" },
    220,
    true,
    { 2, 1, 10, 1 },
    nil,
    {
        "Use Shockwave." .. C.TOOLTIP_VALUE .. "Amount of units needed in front of us to use.",
        "使用震荡波。" .. C.TOOLTIP_VALUE .. "在我们面前使用的单位数量。"
    }
    )
    AddNewOption("进攻", { "风暴之锤", "风暴之锤" }, 210, true, nil, nil, { "Use Storm Bolt.", "使用风暴之锤。" })
    AddNewOption(
    "进攻",
    "Sync Battle Cry",
    230,
    false,
    { 1, "Avatar or Ravager", "天神下凡", "破坏者" },
    nil,
    "Only use Battle Cry together with the selected spells." .. C.TOOLTIP_VALUE_1 .. "Choose preferred spells."
    )
    AddNewOption(
    "进攻",
    { "雷霆一击", "雷霆一击" },
    220,
    true,
    { 2, 1, 10, 1 },
    nil,
    {
        "Use Thunder Clap." .. C.TOOLTIP_VALUE .. "Amount of units needed within 8 yards around player to use.",
        "使用雷霆一击。" .. C.TOOLTIP_VALUE .. "在球员周围使用8码内所需的单位数量。"
    }
    )
    AddPresetOption("防御")
    AddSection("防御", { "减伤", "减轻" }, "Yellow")
    AddNewOption(
    "防御",
    { "无视痛苦 血量", "无视苦痛健康" },
    220,
    true,
    { 70, 1, 100, 1 },
    nil,
    {
        "Use Ignore Pain below this health percentage, otherwise use rage on Revenge. Only applies if Vengeance is not talented." ..
        C.TOOLTIP_VALUE .. "Health threshold.",
        "使用忽略疼痛低于此健康百分比，否则使用愤怒复仇。 只有复仇才有天赋才适用。" .. C.TOOLTIP_VALUE .. "健康阈值。"
    }
    )
    AddNewOption(
    "防御",
    { "无视痛苦 刷新", "无视苦痛刷新" },
    220,
    true,
    { 3, 1, 10, 0.5 },
    nil,
    {
        "Use Ignore Pain to refresh buff when buff remains under threshold." ..
        C.TOOLTIP_VALUE .. "Seconds of buff remaining.",
        "当光环不到阈值时，使用无视苦痛刷新光环。" .. C.TOOLTIP_VALUE .. "秒魔法增益剩余。"
    }
    )
    AddNewOption(
    "防御",
    { "复仇 怒气", "复仇狂怒" },
    220,
    true,
    { 40, 1, 100, 1 },
    nil,
    {
        "Use Revenge filler above this rage and Ignore Pain Health. Only applies of Vengeance is not talented." ..
        C.TOOLTIP_VALUE .. "Rage threshold.",
        "在这种愤怒之上使用复仇填料，忽略疼痛健康。 只适用复仇不是有才华的。" .. C.TOOLTIP_VALUE .. "愤怒阈值"
    }
    )
    AddNewOption(
    "防御",
    { "高优先级 复仇", "报复高优先" },
    220,
    false,
    { 3, 1, 20, 1 },
    nil,
    {
        "Use Revenge as high priority when the given amount of enemies are in range. NOTE: This can lower your survivability." ..
        C.TOOLTIP_VALUE .. "Amount of enemies to be hit.",
        "当给定的敌人数量在范围内时，使用复仇作为高优先级。 注意：这可以降低你的生存能力。" .. C.TOOLTIP_VALUE .. "要打的敌人的数量"
    }
    )
    AddNewOption(
    "防御",
    { "盾牌格挡充能", "屏蔽块充电" },
    222,
    true,
    { 1.8, 1, 3, 0.1 },
    { 1, 1, 3, 0.1 },
    {
        "Use Shield Block if we have more than the given amount of fractional charges available. If you talented into Heavy Repercussions you should set it to a low amount to get the best use out of it." ..
        C.TOOLTIP_VALUE_1 .. "Without Heavy Repercussions." .. C.TOOLTIP_VALUE_2 .. "With Heavy Repercussions.",
        "如果我们有超过给定的分数电量可用，请使用屏蔽块。 如果你有资格进入重型Repercussions，你应该把它设置得很低，以便最好的使用它。" ..
        C.TOOLTIP_VALUE_1 .. "没有重要的repercussions。" .. C.TOOLTIP_VALUE_2 .. "与重要的repercussions。"
    }
    )
    AddSection("防御", { "大技能", "酷唐斯" }, "Yellow")
    AddNewOption(
    "防御",
    { "挫志怒吼", "挫志怒吼" },
    222,
    true,
    { 1, 1, 10, 1 },
    { 70, 1, 100, 1 },
    {
        "Use Demoralizing Shout." ..
        C.TOOLTIP_VALUE_1 ..
        "Amount of units needed within 15 yards around player to use." ..
        C.TOOLTIP_VALUE_2 .. "Health threshold.",
        "使用挫志怒吼。" .. C.TOOLTIP_VALUE_1 .. "在使用者周围15码内需要的单位数量。" .. C.TOOLTIP_VALUE_2 .. "健康阈值。"
    }
    )
    AddNewOption(
    "防御",
    { "破釜沉舟", "破釜沉舟" },
    220,
    true,
    { 20, 1, 100, 1 },
    nil,
    { "Use Last Stand." .. C.TOOLTIP_VALUE .. "Health threshold.", "使用破釜沉舟。" .. C.TOOLTIP_VALUE .. "健康阈值。" }
    )
    AddNewOption(
    "防御",
    { "盾墙", "盾墙" },
    220,
    true,
    { 30, 1, 100, 1 },
    nil,
    { "Use Shield Wall." .. C.TOOLTIP_VALUE .. "Health threshold.", "使用盾墙。" .. C.TOOLTIP_VALUE .. "健康阈值。" }
    )
    AddSection("防御", { "能力", "能力" }, "Yellow")
    AddNewOption(
    "防御",
    { "乘胜追击, 胜利在望", "胜利, 胜利在望" },
    220,
    true,
    { 80, 1, 100, 1 },
    nil,
    { "Use Victory Rush." .. C.TOOLTIP_VALUE .. "Health threshold.", "使用胜利。" .. C.TOOLTIP_VALUE .. "健康阈值。" }
    )
    AddSection("防御", "强力反击", "Yellow")
    AddNewOption(
    "防御",
    "等待盾牌格挡",
    120,
    true,
    { 1.5, 0, 5, 0.1 },
    nil,
    "Wait to use Shield Block when the cooldown of Shield Slam is below the given value." ..
    C.TOOLTIP_VALUE_1 ..
    "Amount of seconds multiplied by your global cooldown. (Global cooldown is reduced by haste)"
    )
    AddNewOption(
    "防御",
    "等待盾牌猛击",
    120,
    true,
    { 1, 0, 5, 0.1 },
    nil,
    "Wait to use Shield Slam when the cooldown of Shield Block is below the given value." ..
    C.TOOLTIP_VALUE_1 ..
    "Amount of seconds multiplied by your global cooldown. (Global cooldown is reduced by haste)"
    )
end
function Rotation:Events()
end
function Rotation:Pulse()
    if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
        return
    end
    if Target:Exists() and BMPullTime() < 5 then
        self:Opening()
        return
    end
    if GetTime() < Rotation.SpamPrevention then
        return
    end
    Rotation.SpamPrevention = GetTime() + 0.05
    Target = Unit.Target
    local InCombat = Player:IsInCombat()
    if not InCombat then
        self:OutOfCombat()
        return
    end
    if InCombat then
        self:Defensives()
    end
    Target = Player:ReTarget(ShieldSlam, false) or Unit.Target
    if Target:Exists() then
        Rotations:RefreshUnitTables(Rotation.Identifier)
        self:Interrupts()
        self:OffGCDAbilities()
        if Player:GlobalCooldown() == 0 then
            self:Combat()
        end
    end
end
function Rotation:Opening()
    Player:UsePotions(GetSecondOptionValue("使用药水"))
    if
    IsOptionEnabled("抢先施放(需DBM插件)") and
    (GetOptionValue("抢先施放(需DBM插件)") == "无条件使用" or
    (GetOptionValue("抢先施放(需DBM插件)") == "打BOSS使用" and Target:IsBoss()))
    then
        if
        Intercept:Exists() and BMPullTime() < GetSecondOptionValue("抢先施放(需DBM插件)") and Player:DistanceTo(Target) > 8 and
        Player:DistanceTo(Target) < 25 and
        Target:CanCast(Intercept)
        then
            Player:StartAttack()
            Target:Cast(Intercept)
            return
        end
    end
end
function Rotation:Defensives()
    Player:UseHealingItem()
    if Player:IsWithinCastRange(Target, Devastate) then
        if
        LastStand:Exists() and IsOptionEnabled("破釜沉舟") and Player:HealthPercentage() <= GetOptionValue("破釜沉舟") and
        Player:CanCast(LastStand)
        then
            Player:Cast(LastStand)
            return
        end
        if
        ShieldWall:Exists() and IsOptionEnabled("盾墙") and Player:HealthPercentage() <= GetOptionValue("盾墙") and
        Player:CanCast(ShieldWall)
        then
            Player:Cast(ShieldWall)
            return
        end
    end
    if
    GiftOfTheNaaru:Exists() and IsOptionEnabled("纳鲁的赐福") and Player:HealthPercentage() <= GetOptionValue("纳鲁的赐福") and
    Player:CanCast(GiftOfTheNaaru)
    then
        Player:Cast(GiftOfTheNaaru)
        return
    end
    if IsOptionEnabled("乘胜追击, 胜利在望") and Player:HealthPercentage() <= GetOptionValue("乘胜追击, 胜利在望") then
        if not ImpendingVictory:Exists() and Player:Buff(Victorious) and Target:CanCast(VictoryRush) then
            Target:Cast(VictoryRush)
            return
        elseif ImpendingVictory:Exists() and Target:CanCast(ImpendingVictory) then
            Target:Cast(ImpendingVictory)
            return
        end
    end
end
function Rotation:Interrupts()
    Player:UseInterrupt(Pummel, ArcaneTorrent)
end
function Rotation:OffGCDAbilities()
    if IsOptionEnabled("自动取消保护之手") and Player:BuffRemainsAny(HandOfProtection) <= 10 - GetOptionValue("自动取消保护之手") then
        RunMacroText("/cancelaura " .. HandOfProtectionName)
    end
    if Taunt:Exists() and Player:TauntManager(Taunt, "嘲讽", Target, TauntEnemies, nil) then
        return
    end
    if
    IgnorePain:Exists() and
    ((Player:Rage() >= 60 and
    (not IsOptionEnabled("无视痛苦 血量") or Player:HealthPercentage() <= GetOptionValue("无视痛苦 血量"))) or
    (Player:Buff(VengeanceIgnorePain) and Player:Rage() >= 39) or
    (Vengeance:Exists() and not Player:Buff(VengeanceIgnorePain) and not Player:Buff(VengeanceRevenge) and
    Player:Rage() < 30 and
    not Player:Buff(RevengeFreeBuff))) and
    Player:CanCast(IgnorePain)
    then
        Player:Cast(IgnorePain)
        return
    end
    if
    IgnorePain:Exists() and IsOptionEnabled("无视痛苦 刷新") and Player:Buff(IgnorePain) and
    Player:BuffRemains(IgnorePain) <= GetOptionValue("无视痛苦 刷新") and
    Player:CanCast(IgnorePain)
    then
        Bug("Refresh Ignore Pain. Buff left: " .. Player:BuffRemains(IgnorePain))
        Player:Cast(IgnorePain)
        return
    end
end
function Rotation:UnitTables()
    Enemies_15y = Player:EnemiesWithinDistance(15, true)
    Enemies_8y = Player:EnemiesWithinDistance(8, true)
    ThunderclapUnits = CracklingThunder:Exists() and Player:EnemiesWithinDistance(12, true) or Enemies_8y
    ShockwaveUnits = #Player:UnitsInFrontCone(10, 140) or 0
    RevengeUnits = #Player:UnitsInFrontCone(6, 125) or 0
    NumEnemies = #Enemies_8y
    TauntEnemies = Player:EnemiesWithinDistance(30, false)
end
function Rotation:Combat()
    if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
        Player:StartAttack()
        if
        IsOptionEnabled("战斗时自动拦截") and Target:CanCast(Intercept) and Player:DistanceTo(Target) >= 8 and
        Player:DistanceTo(Target) <= GetOptionValue("战斗时自动拦截") and
        Player:IsFacing(Target)
        then
            Intercept.LastCastTime = GetTime()
            Target:Cast(Intercept)
            return
        end
        if Player:IsWithinCastRange(Target, Devastate) then
            Player:UsePotions(GetSecondOptionValue("使用药水"))
            if
            DemoralizingShout:Exists() and IsOptionEnabled("挫志怒吼") and #Enemies_15y >= GetOptionValue("挫志怒吼") and
            Player:HealthPercentage() <= GetSecondOptionValue("挫志怒吼") and
            Player:CanCast(DemoralizingShout)
            then
                Player:Cast(DemoralizingShout)
                return
            end
            Player:UseTrinkets()
            if CDOptionEnabled("进攻性种族技能") then
                if BloodFury:Exists() and Player:CanCast(BloodFury) then
                    Player:Cast(BloodFury)
                end
                if Berserking:Exists() and Player:CanCast(Berserking) then
                    Player:Cast(Berserking)
                end
                if ArcaneTorrent:Exists() and Player:CanCast(ArcaneTorrent) and Player:Rage() < Player:RageMax() - 40 then
                    Player:Cast(ArcaneTorrent)
                end
            end
            if Avatar:Exists() and CDOptionEnabled("天神下凡") and Player:CanCast(Avatar) then
                Player:Cast(Avatar)
                return
            end
            if
            BattleCry:Exists() and CDOptionEnabled("战吼") and
            (((not IsOptionEnabled("Sync Battle Cry") or
            (GetOptionValue("Sync Battle Cry") == "Avatar or Ravager" and
            not (Ravager:Exists() or Avatar:Exists())) or
            (GetOptionValue("Sync Battle Cry") == "天神下凡" and not Avatar:Exists()) or
            (GetOptionValue("Sync Battle Cry") == "破坏者" and not Ravager:Exists())) and
            ShieldSlam:Cooldown() < 3) or
            ((GetOptionValue("Sync Battle Cry") == "Avatar or Ravager" and
            (Player:Buff(Avatar) or Ravager:TimeSinceCast() < 2)) or
            (GetOptionValue("Sync Battle Cry") == "天神下凡" and Player:Buff(Avatar)) or
            (GetOptionValue("Sync Battle Cry") == "破坏者" and Ravager:TimeSinceCast() < 2))) and
            Player:CanCast(BattleCry)
            then
                Player:Cast(BattleCry)
                return
            end
            if
            DemoralizingShout:Exists() and BoomingVoice:Exists() and Player:Buff(BattleCry) and
            Player:CanCast(DemoralizingShout)
            then
                Player:Cast(DemoralizingShout)
                return
            end
            if Ravager:Exists() and IsOptionEnabled("破坏者") and CooldownsAllowed() and Target:CanCast(Ravager) then
                if Target:CastGroundSpell(Ravager, "破坏者", 8) then
                    Ravager.LastCastTime = GetTime()
                    return
                end
            end
            if
            BerserkerRage:Exists() and CDOptionEnabled("狂暴之怒") and
            (not HasT20_2Pc or Player:Rage() <= GetSecondOptionValue("狂暴之怒")) and
            Player:CanCast(BerserkerRage)
            then
                Player:Cast(BerserkerRage)
            end
        end
        if Revenge:Exists() and IsOptionEnabled("高优先级 复仇") and RevengeUnits >= GetOptionValue("高优先级 复仇") then
            if
            ((Vengeance:Exists() and Player:Buff(RevengeFreeBuff) and not Player:Buff(VengeanceIgnorePain)) or
            (Player:Buff(VengeanceRevenge) and Player:Rage() >= 59) or
            (Vengeance:Exists() and not Player:Buff(VengeanceIgnorePain) and not Player:Buff(VengeanceRevenge) and
            Player:Rage() >= 69) or
            (not Vengeance:Exists() and Player:Buff(RevengeFreeBuff))) and
            Player:CanCast(Revenge)
            then
                Bug("Revenge High Prio - Enemies: " .. tostring(RevengeUnits))
                Player:Cast(Revenge)
                return
            end
            if
            not Vengeance:Exists() and
            (Player:HealthPercentage() > GetOptionValue("无视痛苦 血量") or not IsOptionEnabled("无视痛苦 血量")) and
            Player:Rage() >= GetOptionValue("复仇 怒气") and
            Player:CanCast(Revenge)
            then
                Bug("Revenge High Prio - Enemies: " .. tostring(RevengeUnits))
                Player:Cast(Revenge)
                return
            end
        end
        if
        NeltharionsFury:Exists() and Player:Standing() > 0.5 and IsOptionEnabled("奈萨里奥之怒") and
        not Player:Buff(ShieldBlockBuff) and
        ShieldBlock:Cooldown() > 3 and
        (ShieldSlam:Cooldown() > 3 or not HeavyRepercussions:Exists()) and
        ShockwaveUnits >= GetOptionValue("奈萨里奥之怒") and
        Player:CanCast(NeltharionsFury)
        then
            Player:Cast(NeltharionsFury)
            return
        end
        if
        ShieldBlock:Exists() and IsOptionEnabled("盾牌格挡充能") and not Player:Buff(NeltharionsFury) and
        ((HeavyRepercussions:Exists() and ShieldBlock:FractionalCharges() >= GetSecondOptionValue("盾牌格挡充能")) or
        ShieldBlock:FractionalCharges() >= GetOptionValue("盾牌格挡充能")) and
        (not Player:Buff(ShieldBlockBuff) and
        (((not ShieldSlam:IsOnCooldown() or ShieldSlam:Cooldown() >= GetOptionValue("等待盾牌猛击") * Player:GCD()) and
        HeavyRepercussions:Exists()) or
        not HeavyRepercussions:Exists())) and
        Player:CanCast(ShieldBlock)
        then
            Player:Cast(ShieldBlock)
            return
        end
        if
        IgnorePain:Exists() and
        ((Player:Rage() >= 60 and not Vengeance:Exists() and
        (not IsOptionEnabled("无视痛苦 血量") or Player:HealthPercentage() <= GetOptionValue("无视痛苦 血量"))) or
        (Player:Buff(VengeanceIgnorePain) and Player:Rage() >= 39) or
        (Vengeance:Exists() and not Player:Buff(VengeanceIgnorePain) and not Player:Buff(VengeanceRevenge) and
        Player:Rage() < 30 and
        not Player:Buff(RevengeFreeBuff))) and
        Player:CanCast(IgnorePain)
        then
            Player:Cast(IgnorePain)
            return
        end
        if
        ShieldSlam:Exists() and
        ((not (ShieldBlock:Cooldown() <= GetOptionValue("等待盾牌格挡") * Player:GCD() and
        not Player:Buff(ShieldBlockBuff)) and
        HeavyRepercussions:Exists()) or
        not IsOptionEnabled("盾牌格挡充能") or
        not HeavyRepercussions:Exists()) and
        Target:CanCast(ShieldSlam)
        then
            Target:Cast(ShieldSlam)
            return
        end
        if
        ThunderClap:Exists() and IsOptionEnabled("雷霆一击") and Intercept:TimeSinceCast() > 2 and
        #ThunderclapUnits >= GetOptionValue("雷霆一击") and
        Player:CanCast(ThunderClap)
        then
            Player:Cast(ThunderClap)
            return
        end
        if
        Revenge:Exists() and Player:IsFacing(Target) and
        ((Vengeance:Exists() and Player:Buff(RevengeFreeBuff) and not Player:Buff(VengeanceIgnorePain)) or
        (Player:Buff(VengeanceRevenge) and Player:Rage() >= 59) or
        (Vengeance:Exists() and not Player:Buff(VengeanceIgnorePain) and not Player:Buff(VengeanceRevenge) and
        Player:Rage() >= 69) or
        (not Vengeance:Exists() and Player:Buff(RevengeFreeBuff))) and
        Player:CanCast(Revenge)
        then
            Player:Cast(Revenge)
            return
        end
        if
        Shockwave:Exists() and IsOptionEnabled("震荡波") and ShockwaveUnits >= GetOptionValue("震荡波") and
        Player:CanCast(Shockwave)
        then
            Player:Cast(Shockwave)
            return
        end
        if StormBolt:Exists() and IsOptionEnabled("风暴之锤") and Target:CanCast(StormBolt) then
            Target:Cast(StormBolt)
            return
        end
        if
        Revenge:Exists() and Player:IsFacing(Target) and not Vengeance:Exists() and
        (Player:HealthPercentage() > GetOptionValue("无视痛苦 血量") or not IsOptionEnabled("无视痛苦 血量")) and
        Player:Rage() >= GetOptionValue("复仇 怒气") and
        Player:CanCast(Revenge)
        then
            Player:Cast(Revenge)
            return
        end
        if Devastate:Exists() and not Devastator:Exists() and Target:CanCast(Devastate) then
            Target:Cast(Devastate)
            return
        end
        if
        HeroicThrow:Exists() and IsOptionEnabled("英勇投掷") and not Player:IsWithinCastRange(Target, Devastate) and
        Target:CanCast(HeroicThrow)
        then
            Target:Cast(HeroicThrow)
            return
        end
    end
end
function Rotation:OutOfCombat()
    if
    Intercept:Exists() and IsOptionEnabled("自动进入战斗") and Player:DistanceTo(Target) >= 8 and
    Player:DistanceTo(Target) <= 25 and
    Target:CanCast(Intercept)
    then
        Target:Cast(Intercept)
        return
    end
end